---
title: 动态规划问题
catalog: true
date: 2023-03-25 00:27:34
subtitle:
header-img:
tags:
categories:
published: false
---

# [动态规划] 动态规划问题
> 本文将过一遍所遇见的所有动态规划解决的问题并给出代码
>

## 斐波那契数
> 力扣题目链接[https://leetcode.cn/problems/fibonacci-number/]
>

### 解题流程
1. 问题分析
   斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列。
   
   该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： F(0) = 0，F(1) = 1 F(n) = F(n - 1) + F(n - 2)，其中 n > 1 问题需求是给n ，请计算 F(n) 的值。

   显然 i 的值包含整个定义域，求解的F(i) 也就是整个解集，需要遍历整个结果集来找对应 i 的解，可以使用 DP 来求解。
   

2. DP 解题流程
   
   * **确定dp数组以及下标的含义**
  
        dp[i]的定义为：第i个数的斐波那契数值是dp[i]

   * **确定递推公式**

        确定得到每一个dp[i]的公式，或者说遍历整个结果集合的方式
    
        在本题目当中，直接给出的是斐波那契数列
   状态转移方程 dp[i] = dp[i - 1] + dp[i - 2];

   * **dp数组如何初始化**
  
        > 本质上就是**寻找边界值，什么时候开始、什么时候结束**，在所有需要遍历的操作当中都需要考虑这个问题

        一般的斐波那契数列已经给出初始边界值：
        ```go
        dp[0] := 0
        dp[1] := 1
        ```
   
   * **确定遍历顺序**

        从递归公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，dp[i]是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序一定是从前到后遍历的

   * **举例推导dp数组**

        按照这个递推公式dp[i] = dp[i - 1] + dp[i - 2]，我们来推导一下，当N为10的时候，dp数组应该是如下的数列：
   
        0 1 1 2 3 5 8 13 21 34 55
   
        如果代码写出来，发现结果不对，就把dp数组打印出来看看和我们推导的数列是不是一致的。



### 代码实现

使用一个数组保存所有遍历的结果，通过索引i直接找到 f[i]对应的值：
```golang
func fib(n int) int {
    var ans []int
    ans = append(ans,0)
    ans = append(ans,1)

    for i := 2 ; i <= n ; i++ {
        temp := ans[i-1] + ans[i-2]
        ans = append(ans,temp)
    }
    return ans[n]
}
```
* 时间复杂度：O(n)
* 空间复杂度：O(n)

但是可以观察到保留的 f 数组其实只用到了一个变量f[i], 并且最后需要的结果是一个固定值 n，也就是说结果是确定位置的，那么是可以只保留计算获得 f[n] 相关的值就可以：f[n-1] 和 f[n-2]，这样的保留过程对于其他的 i 值来说也完全一样，除了 n=0 和 n=1 两个时候的值，那么就需要单独对这两个值来做处理

只保留的pre和now,也可以改成 tmp[i-1] 和 tmp[i-2]也就是改成一个长度为2的一维数组--滚动数组，该数组存储有效信息并跟随遍历的阶段移动

```golang
func fib(n int) int {
    pre := 0
    now := 1

    for i:= 2 ; i <= n ; i++{
        tmp := now
        now = now + pre
        pre = tmp
    }
    if n == 0 {
        now = 0
    }
    return now
}
```

---

## 编辑距离
> 力扣题目链接: (https://leetcode.cn/problems/edit-distance/)

### 解题流程
1. 问题分析
   将word1变成word2，共有三类型的操作：增加、删除、替换；同时计算操作数最小的情况。

   **是否使用动态规划**
   一个最直白的想法就是我先把word1里面每一个字母都删除，进行len(word1)次操作；然后再加上word2里面的每一个字母，进行len(word2)次操作，当然这样的操作是次数最多的，是完全没有考虑到两个字符之间的关联性，当在字符串里面有相同的字母时候，就可以不操作跳过，再对后面的字符进行操作。

   这样不断地替换中间的操作流程就是一个全遍历的过程，需要找寻几乎所有的排列组合且存在着 **最小值的优化目标 --> 适合动态规划**   


   **为什么感觉问题解决会复杂？**

   会发现增删都会改变字母的对应位置，而替换不改变位置，一些不同位置的字母可以通过增删变成对应相同位置的字母，也就是说三个操作之间相互关联。

   同样的问题思考时候，word1变成word2其实也等价于word2变成word1,解题的流程是完全对称的。

   结合以上因素，可以说一个dp状态就有了三种类型的迁移计算，那么我们需要设置一个dp[][][]的三维数组来分别表示三类状态迁移嘛？并不需要，因为替换可以等效为先减少一个字母，然后再增加一个字母只是代价增加为1而不是2，所以可以使用一个二维数组来表示：也就是dp[i][j]；其中i方向可以表示为减少word1 字母的操作，j方向标识增加word2字母的操作，i和j 同时增长表示替换操作：即先减少word1字母，然后增加word2字母。

   还可以看到的是，依据上面的思考流程，i/j应当是和word1/2当中的单词位置相关联的；而麻烦的地方就集中在这个地方的理解上 <font color='red'>dp[i][j] 表示的是将word1前i-1个字符变成word2前j-1个字符最少的操作数</font>，dp[i][j]并不代表一个字符串或者说一个字符串形式，但是到dp[i][j]的路径可以唯一对应一个字符串

   同时当我们使用上述的二位矩阵来计算时会发现，实质上我们也计算了将 word2 变成 word1的最小操作数



2. DP 解题流程
   * **确定dp数组以及下标的含义**
   dp[i][j] 表示的是将word1前i-1个字符变成word2前j-1个字符最少的操作数

   这里有两个需要强调的点：
   * dp[i] 对应的字母是 word[i-1], 而 dp[0] 对应的是空字符
   这样来规定矩阵的计算形式更有利于计算
   * 矩阵中元素对应着操作数，到达操作数的路径对应字符串

   * **确定递推公式**
   > 也就是确认矩阵元素的迁移计算方向并计算操作数

   如果word1[i - 1] == word2[j - 1]，也就意味着对应位置的字母是相同的，那么增删或者删增同一个字母是没有必要，在矩阵元素迁移中，表示向右下移动一格遍历一个字母，但是不用操作两字符串，dp[i][j]操作数不用增加。

   如果word1[i - 1] != word2[j - 1]，那么接下来在矩阵当中移动，在i方向就意味着对word1[i-1]字母进行减操作，在j方向就意味着对word2[j-1]字母进行加操作

   ```
    if (word1[i - 1] == word2[j - 1])
        不操作
    if (word1[i - 1] != word2[j - 1])
        dp[i][j] = min (增,删,换)
   ```

   * **dp数组如何初始化**
   考虑到空字符串的计算，也就是说对另一方不做操作的情况：
    * d[i][0] 表示只减少word1的字母
    * d[0][j] 表示只增加word2的字母
    * d[0][0] 表示空字母


   * **确定遍历顺序**
   将word1变成word2，也就是意味着需要遍历每一个word1字母和每一个word2字母
   ```
    dp[i][j] = dp[i - 1][j - 1]  // i-1,j-1位置两个字符串的字母相同，不用操作，所以在状态迁移时候不用增加dp操作数

    //i-1,j-1位置两个字符串的字母不相同，需要对i-1，j-1位置上的字母做操作
    dp[i][j] = dp[i - 1][j - 1] + 1 //替换
    dp[i][j] = dp[i][j - 1] + 1 // 增加
    dp[i][j] = dp[i - 1][j] + 1 // 减少
   ```


   * **举例推导dp数组**



### 代码实现

---
## 两个字符串的删除操作
> 题目链接：(https://leetcode.cn/problems/delete-operation-for-two-strings/)
### 解题流程
1. 问题分析
   
2. DP 解题流程
   * **确定dp数组以及下标的含义**
   * **确定递推公式**
   * **dp数组如何初始化**
   * **确定遍历顺序**
   * **举例推导dp数组**
### 代码实现


---
## 最长公共子序列
> 题目链接：(https://leetcode.cn/problems/longest-common-subsequence/)
### 解题流程
1. 问题分析
   
2. DP 解题流程
   * **确定dp数组以及下标的含义**
   * **确定递推公式**
   * **dp数组如何初始化**
   * **确定遍历顺序**
   * **举例推导dp数组**
### 代码实现

---
## 打家劫舍
### 解题流程
1. 问题分析
2. DP 解题流程
   * **确定dp数组以及下标的含义**
   * **确定递推公式**
   * **dp数组如何初始化**
   * **确定遍历顺序**
   * **举例推导dp数组**
### 代码实现

---
## 斐波那契数
### 解题流程
1. 问题分析
2. DP 解题流程
   * **确定dp数组以及下标的含义**
   * **确定递推公式**
   * **dp数组如何初始化**
   * **确定遍历顺序**
   * **举例推导dp数组**
### 代码实现