{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"themes/butterfly/source/css/index.styl","path":"css/index.styl","modified":1,"renderable":1},{"_id":"themes/butterfly/source/css/var.styl","path":"css/var.styl","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/404.jpg","path":"img/404.jpg","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/favicon.png","path":"img/favicon.png","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":1,"renderable":1},{"_id":"source/LICENSE","path":"LICENSE","modified":1,"renderable":0},{"_id":"source/img/avatar/2077_mobile.png","path":"img/avatar/2077_mobile.png","modified":1,"renderable":0},{"_id":"source/img/backgroud/moon.png","path":"img/backgroud/moon.png","modified":1,"renderable":0},{"_id":"source/img/backgroud/wallhaven-j3m8y5_1920x1080.png","path":"img/backgroud/wallhaven-j3m8y5_1920x1080.png","modified":1,"renderable":0},{"_id":"source/img/backgroud/worriar.png","path":"img/backgroud/worriar.png","modified":1,"renderable":0},{"_id":"source/img/cover/2077_city.png","path":"img/cover/2077_city.png","modified":1,"renderable":0},{"_id":"source/img/cover/dom_tree1.jpg","path":"img/cover/dom_tree1.jpg","modified":1,"renderable":0},{"_id":"source/img/cover/hope1.jpg","path":"img/cover/hope1.jpg","modified":1,"renderable":0},{"_id":"source/img/cover/sky.png","path":"img/cover/sky.png","modified":1,"renderable":0},{"_id":"source/img/cover/sky2.png","path":"img/cover/sky2.png","modified":1,"renderable":0},{"_id":"source/img/cover/sky3.png","path":"img/cover/sky3.png","modified":1,"renderable":0},{"_id":"source/img/cover/sky4.png","path":"img/cover/sky4.png","modified":1,"renderable":0},{"_id":"source/img/cover/street1.jpg","path":"img/cover/street1.jpg","modified":1,"renderable":0},{"_id":"source/img/cover/sun-flower1.jpg","path":"img/cover/sun-flower1.jpg","modified":1,"renderable":0},{"_id":"source/img/logo/mesh.png","path":"img/logo/mesh.png","modified":1,"renderable":0},{"_id":"source/img/signature/signature-removebg.png","path":"img/signature/signature-removebg.png","modified":1,"renderable":0}],"Cache":[{"_id":"themes/butterfly/LICENSE","hash":"1128f8f91104ba9ef98d37eea6523a888dcfa5de","modified":1682170033220},{"_id":"themes/butterfly/README.md","hash":"52967a864c244af4db8c63902586cb617ee5b8aa","modified":1682170033220},{"_id":"themes/butterfly/README_CN.md","hash":"e19021371184361261ddef1d98eb308d78922714","modified":1682170033224},{"_id":"themes/butterfly/_config.yml","hash":"79b66f0d703e362ce24b791055aaa9f0cd5cb44b","modified":1682170169564},{"_id":"themes/butterfly/package.json","hash":"79b3dde82bc6d983dc383d2810e96fb697d4fba1","modified":1682170033220},{"_id":"themes/butterfly/plugins.yml","hash":"c7a060713f72ec8b4a45244b3aa8d51d772f5ce8","modified":1682170033220},{"_id":"themes/butterfly/languages/default.yml","hash":"4025c0ba440eb24705dd0293ca9ca84efb3105cc","modified":1682170033336},{"_id":"themes/butterfly/languages/en.yml","hash":"4e9cdb7a3570929bcf082de7a4eac49140dddc73","modified":1682170033348},{"_id":"themes/butterfly/languages/zh-CN.yml","hash":"7dd849c3ba34986c57c764d9e36150b4bfffd2e9","modified":1682170033348},{"_id":"themes/butterfly/languages/zh-TW.yml","hash":"ee01e068f12dc33adfae5733824ea1255deb5ca6","modified":1682170033348},{"_id":"themes/butterfly/layout/archive.pug","hash":"a0c034c2d319320a54046805e80b58dc48b7e233","modified":1682170033348},{"_id":"themes/butterfly/layout/category.pug","hash":"710708cfdb436bc875602abf096c919ccdf544db","modified":1682170033348},{"_id":"themes/butterfly/layout/index.pug","hash":"e1c3146834c16e6077406180858add0a8183875a","modified":1682170033348},{"_id":"themes/butterfly/layout/page.pug","hash":"baf469784aef227e4cc840550888554588e87a13","modified":1682170033352},{"_id":"themes/butterfly/layout/post.pug","hash":"fc9f45252d78fcd15e4a82bfd144401cba5b169a","modified":1682170033352},{"_id":"themes/butterfly/layout/tag.pug","hash":"0440f42569df2676273c026a92384fa7729bc4e9","modified":1682170033352},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/bug_report.yml","hash":"fc468a93a64c7a3e408fbac921c9f5a5a8f32027","modified":1682170033624},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/config.yml","hash":"7dfe7189ffeaebb6db13842237f8e124649bea3d","modified":1682170033588},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/feature_request.yml","hash":"996640605ed1e8e35182f0fd9a60a88783b24b03","modified":1682170033588},{"_id":"themes/butterfly/.github/workflows/publish.yml","hash":"05857c2f265246d8de00e31037f2720709540c09","modified":1682170033624},{"_id":"themes/butterfly/.github/workflows/stale.yml","hash":"ac62b989b5550c756e1986fcc68f243170705383","modified":1682170033624},{"_id":"themes/butterfly/layout/includes/404.pug","hash":"cb49f737aca272ccfeb62880bd651eccee72a129","modified":1682170033624},{"_id":"themes/butterfly/layout/includes/additional-js.pug","hash":"aca0ec7ef69b21d1f242c62fed389468a0f0e1a2","modified":1682170033624},{"_id":"themes/butterfly/layout/includes/footer.pug","hash":"02390a5b6ae1f57497b22ba2e6be9f13cfb7acac","modified":1682170033624},{"_id":"themes/butterfly/layout/includes/head.pug","hash":"dd9fde431add984330e3178e06a8d74705e7340e","modified":1682170033624},{"_id":"themes/butterfly/layout/includes/layout.pug","hash":"7fa9ae4b70b87fc97e992dde5944681f92b59bea","modified":1682170033624},{"_id":"themes/butterfly/layout/includes/pagination.pug","hash":"4c85de4dea4dca4e5088097a79bd6d7009cbf8ef","modified":1682170033624},{"_id":"themes/butterfly/layout/includes/rightside.pug","hash":"83a1f2d31792206d432e8e2041e284d88327c02e","modified":1682170033624},{"_id":"themes/butterfly/layout/includes/sidebar.pug","hash":"8d39473ed112d113674a0f689f63fae06c72abd2","modified":1682170033652},{"_id":"themes/butterfly/scripts/events/404.js","hash":"83cd7f73225ccad123afbd526ce1834eb1eb6a6d","modified":1682170033652},{"_id":"themes/butterfly/scripts/events/cdn.js","hash":"21fb5aabe043486d095c4c8cce361ed85ba88a26","modified":1682170033652},{"_id":"themes/butterfly/scripts/events/comment.js","hash":"5351e0bc09e6b5b3f6d30f333a2520626a28ca3a","modified":1682170033652},{"_id":"themes/butterfly/scripts/events/init.js","hash":"3ace1139182d3d367149db138990891427f3356e","modified":1682170033652},{"_id":"themes/butterfly/scripts/events/stylus.js","hash":"9819f0996234fbd80d6c50a9e526c56ebf22588d","modified":1682170033652},{"_id":"themes/butterfly/scripts/events/welcome.js","hash":"8ad9911b755cba13dde2cc055c3f857a6b0dd20e","modified":1682170033652},{"_id":"themes/butterfly/scripts/filters/post_lazyload.js","hash":"932df912976261929f809b7dbd4eb473e7787345","modified":1682170033652},{"_id":"themes/butterfly/scripts/filters/random_cover.js","hash":"8d25f47434deae870bbffd07efe528a40363ab4d","modified":1682170033652},{"_id":"themes/butterfly/scripts/helpers/aside_archives.js","hash":"2ec66513d5322f185d2071acc052978ba9415a8e","modified":1682170033652},{"_id":"themes/butterfly/scripts/helpers/aside_categories.js","hash":"e00efdb5d02bc5c6eb4159e498af69fa61a7dbb9","modified":1682170033656},{"_id":"themes/butterfly/scripts/helpers/findArchiveLength.js","hash":"9ea86bd7a3c3fca3324f70b1cd4d9e42f9efb08d","modified":1682170033676},{"_id":"themes/butterfly/scripts/helpers/inject_head_js.js","hash":"4238e06ff448ff2ee717cd4c874f37f04d35da06","modified":1682170033676},{"_id":"themes/butterfly/scripts/helpers/page.js","hash":"ce5d5a3d07b0d76ac5e96e5f9e5783f4b601b6be","modified":1682170033676},{"_id":"themes/butterfly/scripts/helpers/related_post.js","hash":"4677be4175da6800c0b3b8c1614e593f73df8831","modified":1682170033676},{"_id":"themes/butterfly/scripts/tag/button.js","hash":"91d954f6e9fe6e571eb8ec9f8996294b2dc3688e","modified":1682170033676},{"_id":"themes/butterfly/scripts/tag/flink.js","hash":"ab62919fa567b95fbe14889517abda649991b1ee","modified":1682170033676},{"_id":"themes/butterfly/scripts/tag/gallery.js","hash":"950b3dbac0b21717458a8d1769cbfc454d0eff54","modified":1682170033676},{"_id":"themes/butterfly/scripts/tag/hide.js","hash":"396c3ab1bcf1c7693ad7e506eadd13016c6769b6","modified":1682170033676},{"_id":"themes/butterfly/scripts/tag/inlineImg.js","hash":"a43ee2c7871bdd93cb6beb804429e404570f7929","modified":1682170033676},{"_id":"themes/butterfly/scripts/tag/label.js","hash":"03b2afef41d02bd1045c89578a02402c28356006","modified":1682170033700},{"_id":"themes/butterfly/scripts/tag/mermaid.js","hash":"531808a290b8bdd66bac2faab211ada8e9646a37","modified":1682170033700},{"_id":"themes/butterfly/scripts/tag/note.js","hash":"d51812b43924f1bbf413c67499510dd125022005","modified":1682170033700},{"_id":"themes/butterfly/scripts/tag/score.js","hash":"ea679dfe12d0e2290113b4a9d00663ce7a5ee5ad","modified":1682170033700},{"_id":"themes/butterfly/scripts/tag/tabs.js","hash":"6c6e415623d0fd39da016d9e353bb4f5cca444f5","modified":1682170033700},{"_id":"themes/butterfly/scripts/tag/timeline.js","hash":"300eb779588bf35a1b687d9f829d866074b707e3","modified":1682170033700},{"_id":"themes/butterfly/source/css/index.styl","hash":"861998e4ac67a59529a8245a9130d68f826c9c12","modified":1682170033700},{"_id":"themes/butterfly/source/css/var.styl","hash":"30abbb8eed880d51f61f336064d93abd709e0115","modified":1682170033700},{"_id":"themes/butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1682170033704},{"_id":"themes/butterfly/source/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1682170033700},{"_id":"themes/butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1682170033704},{"_id":"themes/butterfly/source/js/main.js","hash":"05c825962e365af62096d3f1b4d7c9ee1b5fc2f5","modified":1682170033704},{"_id":"themes/butterfly/source/js/tw_cn.js","hash":"76d0c5c172cae44b34b0bd3125fd068b2c3cbd4a","modified":1682170033708},{"_id":"themes/butterfly/source/js/utils.js","hash":"2e74fe8ae5ac20067668a18df5985459faf419f9","modified":1682170033708},{"_id":"themes/butterfly/layout/includes/head/Open_Graph.pug","hash":"8aa8d799aedbfd811195b84a451bc4b6e2647c12","modified":1682170033928},{"_id":"themes/butterfly/layout/includes/head/analytics.pug","hash":"67e1c3b48e4ca7ee0b2c76d3ca7476b9883cf105","modified":1682170033928},{"_id":"themes/butterfly/layout/includes/head/config.pug","hash":"021ccdca211cce0438a378ada37897a8ffcb9574","modified":1682170033928},{"_id":"themes/butterfly/layout/includes/head/config_site.pug","hash":"7df90c8e432e33716517ab918b0a125bc284041b","modified":1682170033928},{"_id":"themes/butterfly/layout/includes/head/google_adsense.pug","hash":"95a37e92b39c44bcbea4be7e29ddb3921c5b8220","modified":1682170033928},{"_id":"themes/butterfly/layout/includes/head/noscript.pug","hash":"d16ad2ee0ff5751fd7f8a5ce1b83935518674977","modified":1682170033928},{"_id":"themes/butterfly/layout/includes/head/preconnect.pug","hash":"a03b3ddc06e7aa9fd07eea0d5f97c8d5addd2315","modified":1682170033928},{"_id":"themes/butterfly/layout/includes/head/pwa.pug","hash":"3d492cfe645d37c94d30512e0b230b0a09913148","modified":1682170033928},{"_id":"themes/butterfly/layout/includes/head/site_verification.pug","hash":"e2e8d681f183f00ce5ee239c42d2e36b3744daad","modified":1682170033968},{"_id":"themes/butterfly/layout/includes/header/index.pug","hash":"0c1551ef80bbece550fe520d91e21f083cbc14fe","modified":1682170033968},{"_id":"themes/butterfly/layout/includes/header/menu_item.pug","hash":"31346a210f4f9912c5b29f51d8f659913492f388","modified":1682170033968},{"_id":"themes/butterfly/layout/includes/header/nav.pug","hash":"f61659aa457d1a2d1baa3a13157996cfac4d6609","modified":1682170033968},{"_id":"themes/butterfly/layout/includes/header/post-info.pug","hash":"9698f22751778dde063cbfbd01c59ca4462ccd85","modified":1682170033968},{"_id":"themes/butterfly/layout/includes/header/social.pug","hash":"5de9a82032cdad1db3b868b797460921cd775fc2","modified":1682170033968},{"_id":"themes/butterfly/layout/includes/loading/fullpage-loading.pug","hash":"68cda524337dfe2e1467318a4a6c124b4c3845a7","modified":1682170033968},{"_id":"themes/butterfly/layout/includes/loading/index.pug","hash":"131f344d68b4c241d6e03849b243ee792fcd3cea","modified":1682170033968},{"_id":"themes/butterfly/layout/includes/loading/pace.pug","hash":"6ab4e301c92586505d6cddce1b3ad23b7c79010d","modified":1682170033968},{"_id":"themes/butterfly/layout/includes/mixins/article-sort.pug","hash":"90554c2ca5ba946f4c02e1bc5fe2859cef1b1594","modified":1682170033988},{"_id":"themes/butterfly/layout/includes/mixins/post-ui.pug","hash":"294df7a74cf36af3a7030274d8b745979c1c8c70","modified":1682170033988},{"_id":"themes/butterfly/layout/includes/page/categories.pug","hash":"5276a8d2835e05bd535fedc9f593a0ce8c3e8437","modified":1682170033968},{"_id":"themes/butterfly/layout/includes/page/default-page.pug","hash":"12c65c174d26a41821df9bad26cdf1087ec5b0ca","modified":1682170033968},{"_id":"themes/butterfly/layout/includes/page/flink.pug","hash":"a59bcfbb609a099c1bf5be40b7a94e7e2b06fc4a","modified":1682170033988},{"_id":"themes/butterfly/layout/includes/page/tags.pug","hash":"9621991359e22b14049346f1cf87bdedc94edf5a","modified":1682170033988},{"_id":"themes/butterfly/layout/includes/post/post-copyright.pug","hash":"ebecba46a5f4efe1c98a386df06c56e26fbd07b9","modified":1682170033988},{"_id":"themes/butterfly/layout/includes/post/reward.pug","hash":"864869c43fe5b5bb6f4ac6b13dd4bfb16ea47550","modified":1682170033988},{"_id":"themes/butterfly/layout/includes/third-party/aplayer.pug","hash":"c7cfade2b160380432c47eef4cd62273b6508c58","modified":1682170033988},{"_id":"themes/butterfly/layout/includes/third-party/effect.pug","hash":"6528e86656906117a1af6b90e0349c2c4651d5e1","modified":1682170033988},{"_id":"themes/butterfly/layout/includes/third-party/pangu.pug","hash":"0f024e36b8116118233e10118714bde304e01e12","modified":1682170033988},{"_id":"themes/butterfly/layout/includes/third-party/pjax.pug","hash":"fc0b09068009edd4026d90a669608cbe211aeecf","modified":1682170033992},{"_id":"themes/butterfly/layout/includes/third-party/prismjs.pug","hash":"ffb9ea15a2b54423cd4cd441e2d061b8233e9b58","modified":1682170033992},{"_id":"themes/butterfly/layout/includes/third-party/subtitle.pug","hash":"35223531f8e086d57caec2d17d45ddbcb39deb74","modified":1682170034008},{"_id":"themes/butterfly/layout/includes/widget/card_ad.pug","hash":"60dc48a7b5d89c2a49123c3fc5893ab9c57dd225","modified":1682170033996},{"_id":"themes/butterfly/layout/includes/widget/card_announcement.pug","hash":"ae392459ad401a083ca51ee0b27526b3c1e1faed","modified":1682170034008},{"_id":"themes/butterfly/layout/includes/widget/card_archives.pug","hash":"86897010fe71503e239887fd8f6a4f5851737be9","modified":1682170034008},{"_id":"themes/butterfly/layout/includes/widget/card_author.pug","hash":"e37468e63db2a0ac09b65d21b7de3e62425bb455","modified":1682170034008},{"_id":"themes/butterfly/layout/includes/widget/card_bottom_self.pug","hash":"13dc8ce922e2e2332fe6ad5856ebb5dbf9ea4444","modified":1682170034008},{"_id":"themes/butterfly/layout/includes/widget/card_categories.pug","hash":"d1a416d0a8a7916d0b1a41d73adc66f8c811e493","modified":1682170034008},{"_id":"themes/butterfly/layout/includes/widget/card_newest_comment.pug","hash":"6d93564a8bd13cb9b52ee5e178db3bcbf18b1bc6","modified":1682170034008},{"_id":"themes/butterfly/layout/includes/widget/card_post_toc.pug","hash":"3057a2f6f051355e35d3b205121af8735100eacf","modified":1682170034008},{"_id":"themes/butterfly/layout/includes/widget/card_recent_post.pug","hash":"e5aac7b28ed4123d75797263c64e74ac547945bc","modified":1682170034008},{"_id":"themes/butterfly/layout/includes/widget/card_tags.pug","hash":"eceb4420a64c720f0d2741e89d6229bbb3d87353","modified":1682170034008},{"_id":"themes/butterfly/layout/includes/widget/card_top_self.pug","hash":"ae67c6d4130a6c075058a9c1faea1648bcc6f83e","modified":1682170034008},{"_id":"themes/butterfly/layout/includes/widget/card_webinfo.pug","hash":"35ce167c5a275211bfc1fa3d49adfde5b404d98f","modified":1682170034024},{"_id":"themes/butterfly/layout/includes/widget/index.pug","hash":"010e3d548ababca2280c4fc4168d9a4a1ee4f536","modified":1682170034012},{"_id":"themes/butterfly/source/css/_global/function.styl","hash":"7fdfbe8f97b41588bbd5c6f27e7e85a881b28954","modified":1682170034024},{"_id":"themes/butterfly/source/css/_global/index.styl","hash":"4f5636c326f794417296bdb6bcfd6a8b207d69d8","modified":1682170034024},{"_id":"themes/butterfly/source/css/_highlight/highlight.styl","hash":"2f95e99b8351fbecd9037a1bbdc3fee9d6ea8a77","modified":1682170034024},{"_id":"themes/butterfly/source/css/_highlight/theme.styl","hash":"bcd384c8b2aa0390c9eb69ac1abbfd1240ce1da4","modified":1682170034024},{"_id":"themes/butterfly/source/css/_layout/aside.styl","hash":"57adf29a3e36e4ea84384e36c034eb294dffb208","modified":1682170034024},{"_id":"themes/butterfly/source/css/_layout/chat.styl","hash":"f9a5d3f1fc5ed0ed2ee4c1eaa58ed650d11ddebd","modified":1682170034024},{"_id":"themes/butterfly/source/css/_layout/comments.styl","hash":"c61dccca690d486c3d9c29cf028d87b777385141","modified":1682170034028},{"_id":"themes/butterfly/source/css/_layout/footer.styl","hash":"83553445fbc92cad4ad220fbd87b4c3db958c32a","modified":1682170034028},{"_id":"themes/butterfly/source/css/_layout/head.styl","hash":"45d71dbb2a61e30989851ba29bb8be7094574d14","modified":1682170034040},{"_id":"themes/butterfly/source/css/_layout/loading.styl","hash":"ac2aeee9926f75b2a0098efe1c114126987430f2","modified":1682170034040},{"_id":"themes/butterfly/source/css/_layout/pagination.styl","hash":"fb9f78bfbb79579f1d752cb73fb6d25c8418e0fd","modified":1682170034040},{"_id":"themes/butterfly/source/css/_layout/post.styl","hash":"e24046fad288a13897195038cb7a63d1014cd7b8","modified":1682170034040},{"_id":"themes/butterfly/source/css/_layout/relatedposts.styl","hash":"d53de408cb27a2e704aba7f7402b7caebe0410d8","modified":1682170034040},{"_id":"themes/butterfly/source/css/_layout/reward.styl","hash":"c5cfed620708807a48076b5ee59b0ba84e29aa80","modified":1682170034040},{"_id":"themes/butterfly/source/css/_layout/rightside.styl","hash":"bbc884d6b2158a833b77a1bbc07248e17874b22e","modified":1682170034040},{"_id":"themes/butterfly/source/css/_layout/sidebar.styl","hash":"631ca35a38bc4ac052e9caf47508ff1f99842fc7","modified":1682170034064},{"_id":"themes/butterfly/source/css/_layout/third-party.styl","hash":"ca39e634668ed4fbb43267ec4782c2b55c44e698","modified":1682170034064},{"_id":"themes/butterfly/source/css/_mode/darkmode.styl","hash":"7ff0c456fae2717ddbbb9f8fae2734d449a5448b","modified":1682170034072},{"_id":"themes/butterfly/source/css/_mode/readmode.styl","hash":"ffea9e7c1543edcf080381e7b99828954c2f2cef","modified":1682170034072},{"_id":"themes/butterfly/source/css/_page/404.styl","hash":"50dbb9e6d98c71ffe16741b8c1b0c1b9771efd2b","modified":1682170034072},{"_id":"themes/butterfly/source/css/_page/archives.styl","hash":"c9e98027f2dd730ce389c2047f62ebb748955fcf","modified":1682170034072},{"_id":"themes/butterfly/source/css/_page/categories.styl","hash":"f01ee74948cedb44e53cd3bb1ef36b7d2778ede7","modified":1682170034072},{"_id":"themes/butterfly/source/css/_page/common.styl","hash":"e4b9d6164e97b30c84e1218c7543c60f6b29edcc","modified":1682170034072},{"_id":"themes/butterfly/source/css/_page/flink.styl","hash":"98d755b686ee833e9da10afaa40c4ec2bd66c19a","modified":1682170034072},{"_id":"themes/butterfly/source/css/_page/homepage.styl","hash":"bb470da1d2ba292cae0a30a252f82f37c4130d2d","modified":1682170034088},{"_id":"themes/butterfly/source/css/_page/tags.styl","hash":"580feb7e8b0822a1be48ac380f8c5c53b1523321","modified":1682170034088},{"_id":"themes/butterfly/source/css/_search/algolia.styl","hash":"649a054e73278b6724bd4dd9b94724791ec5c928","modified":1682170034088},{"_id":"themes/butterfly/source/css/_search/index.styl","hash":"678e56ad2e46b630364540fc6a881d6801192dcd","modified":1682170034088},{"_id":"themes/butterfly/source/css/_search/local-search.styl","hash":"a86e4e9198b225b4b73a7a45f04b86cbbed0d231","modified":1682170034088},{"_id":"themes/butterfly/source/css/_tags/button.styl","hash":"45f0c32bdea117540f6b14ebac6450d7142bd710","modified":1682170034088},{"_id":"themes/butterfly/source/css/_tags/gallery.styl","hash":"81ad85acf0e0fe7f9ee23c16a700e7154574d5dd","modified":1682170034088},{"_id":"themes/butterfly/source/css/_tags/hexo.styl","hash":"d76c38adf1d9c1279ef4241835667789f5b736e0","modified":1682170034088},{"_id":"themes/butterfly/source/css/_tags/hide.styl","hash":"ce489ca2e249e2a3cf71584e20d84bdb022e3475","modified":1682170034088},{"_id":"themes/butterfly/source/css/_tags/inlineImg.styl","hash":"df9d405c33a9a68946b530410f64096bcb72560c","modified":1682170034088},{"_id":"themes/butterfly/source/css/_tags/label.styl","hash":"66c59e193d794cdb02cca7bd1dc4aea5a19d7e84","modified":1682170034088},{"_id":"themes/butterfly/source/css/_tags/note.styl","hash":"85ae91c83691ea4511f4277da1194a185251cc78","modified":1682170034088},{"_id":"themes/butterfly/source/css/_tags/tabs.styl","hash":"bf9568444dd54e39dc59b461323dcd38942f27d9","modified":1682170034092},{"_id":"themes/butterfly/source/css/_tags/timeline.styl","hash":"f071156d439556e7463ed4bc61ceee87170d5d08","modified":1682170034092},{"_id":"themes/butterfly/source/css/_third-party/normalize.min.css","hash":"2c18a1c9604af475b4749def8f1959df88d8b276","modified":1682170034092},{"_id":"themes/butterfly/source/js/search/algolia.js","hash":"fd86281d4f0f99ce173e49c1a0df3507fe268d37","modified":1682170034092},{"_id":"themes/butterfly/source/js/search/local-search.js","hash":"8a0547ecb33ad2939450152adf54fca58e22a424","modified":1682170034092},{"_id":"themes/butterfly/layout/includes/third-party/abcjs/abcjs.pug","hash":"ed6906b7c6aa7046bbad95dfdda9211997be7099","modified":1682170034216},{"_id":"themes/butterfly/layout/includes/third-party/abcjs/index.pug","hash":"cabb3a06f8ef297a1ea3d91ced8abeaa0831aa14","modified":1682170034216},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/artalk.pug","hash":"99d9b17668260b242749c16851d9ec1024d31899","modified":1682170034216},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/disqus.pug","hash":"d85c3737b5c9548553a78b757a7698df126a52cf","modified":1682170034216},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/fb.pug","hash":"0344477a2cf38698318ead2681c63ac12f01586e","modified":1682170034240},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/index.pug","hash":"b2d274db84ef22fbd6d5ea8f4404821898934209","modified":1682170034216},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/remark42.pug","hash":"001e8be47854b891efe04013c240c38fed4185eb","modified":1682170034240},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/twikoo.pug","hash":"58406a7a3bf45815769f652bf3ef81e57dcd07eb","modified":1682170034240},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/valine.pug","hash":"39427e107230a10790972349c9dd4c4f31d55eb7","modified":1682170034240},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/waline.pug","hash":"55acc455ca8e13211e3906cf78e487cc92accee5","modified":1682170034240},{"_id":"themes/butterfly/layout/includes/third-party/chat/chatra.pug","hash":"481cd5053bafb1a19f623554a27d3aa077ea59c3","modified":1682170034240},{"_id":"themes/butterfly/layout/includes/third-party/chat/crisp.pug","hash":"76634112c64023177260d1317ae39cef2a68e35f","modified":1682170034240},{"_id":"themes/butterfly/layout/includes/third-party/chat/daovoice.pug","hash":"cfe63e7d26a6665df6aa32ca90868ad48e05ec04","modified":1682170034240},{"_id":"themes/butterfly/layout/includes/third-party/chat/index.pug","hash":"618e1b7f9204049b07beb9e1363c844a78a9ace3","modified":1682170034240},{"_id":"themes/butterfly/layout/includes/third-party/chat/messenger.pug","hash":"3ce0461534b786cb71d9141dff35fa5cb70e22b9","modified":1682170034240},{"_id":"themes/butterfly/layout/includes/third-party/chat/tidio.pug","hash":"24a926756c2300b9c561aaab6bd3a71fdd16e16d","modified":1682170034240},{"_id":"themes/butterfly/layout/includes/third-party/comments/artalk.pug","hash":"95738f110598f999d627234e78ff9e9decac1b9b","modified":1682170034260},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqus.pug","hash":"8ec24c1939895ac0db2b2e8700bc9307b4ceb53c","modified":1682170034260},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"3ba842bf4801b2f115c2cfe5657f35a732ce589f","modified":1682170034260},{"_id":"themes/butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"a833715eec2171ff05664d6d5752a57c954192ce","modified":1682170034260},{"_id":"themes/butterfly/layout/includes/third-party/comments/giscus.pug","hash":"9c16ff9cdc444ebf47eed33ea35b8366459a18f0","modified":1682170034260},{"_id":"themes/butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"1c3a87393cb49915940c2dd206356c2a16549767","modified":1682170034260},{"_id":"themes/butterfly/layout/includes/third-party/comments/index.pug","hash":"351fe25fbf02635b1f9e86e5e244c7d61f69baa7","modified":1682170034260},{"_id":"themes/butterfly/layout/includes/third-party/comments/js.pug","hash":"00ed91c52939b9675b316137f854d13684c895a6","modified":1682170034260},{"_id":"themes/butterfly/layout/includes/third-party/comments/livere.pug","hash":"52ea8aa26b84d3ad38ae28cdf0f163e9ca8dced7","modified":1682170034260},{"_id":"themes/butterfly/layout/includes/third-party/comments/remark42.pug","hash":"e9bdf80d6796afc04eb809dbbe780d97f22c7fcd","modified":1682170034260},{"_id":"themes/butterfly/layout/includes/third-party/comments/twikoo.pug","hash":"e18fbd88d8942e53e771f29b26209ab735c5c567","modified":1682170034264},{"_id":"themes/butterfly/layout/includes/third-party/comments/utterances.pug","hash":"a737046e730eb7264606ba0536218964044492f9","modified":1682170034264},{"_id":"themes/butterfly/layout/includes/third-party/comments/valine.pug","hash":"e55b9c0f8ced231f47eb88bd7f4ec99f29c5c29d","modified":1682170034264},{"_id":"themes/butterfly/layout/includes/third-party/comments/waline.pug","hash":"26ba1fc99117993087b1c6e02daa2626627d8eb1","modified":1682170034288},{"_id":"themes/butterfly/layout/includes/third-party/math/index.pug","hash":"b8ae5fd7d74e1edcef21f5004fc96147e064d219","modified":1682170034264},{"_id":"themes/butterfly/layout/includes/third-party/math/katex.pug","hash":"dfcbd9881be569ea420eff1a6b00e4f4dbe2138e","modified":1682170034264},{"_id":"themes/butterfly/layout/includes/third-party/math/mathjax.pug","hash":"0ea633b11b357afa50c200290d19c32467d58a1d","modified":1682170034288},{"_id":"themes/butterfly/layout/includes/third-party/math/mermaid.pug","hash":"8e33aca36a4d3ae9e041ba05ced8eff56ae38f77","modified":1682170034288},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/artalk.pug","hash":"e6ebbe137dd86b6d8750a6843e350fcd16030981","modified":1682170034288},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"04b2a5882e789a988e41d45abe606f0617b08e38","modified":1682170034288},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"e846ddfe4a63b15d1416f6055f5756af5e3da7c6","modified":1682170034288},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"4ec0642f2d5444acfab570a6f8c7868e7ff43fde","modified":1682170034308},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/remark42.pug","hash":"ab167c00da4506f591b96f0591bf5bd214a26d4b","modified":1682170034288},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"233907dd7f5b5f33412701d2ccffbc0bbae8707b","modified":1682170034288},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/valine.pug","hash":"d19e1c2c0a50f0e4547d71a17b9be88e8152f17c","modified":1682170034308},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/waline.pug","hash":"441d87067d87d9996b53b25c05b8e620bd94b027","modified":1682170034308},{"_id":"themes/butterfly/layout/includes/third-party/search/algolia.pug","hash":"9c3c109a12d2b6916e8b4965cca12f521510ead9","modified":1682170034308},{"_id":"themes/butterfly/layout/includes/third-party/search/docsearch.pug","hash":"1c3e101445c5571ba998ce293d3984319df1b3b0","modified":1682170034308},{"_id":"themes/butterfly/layout/includes/third-party/search/index.pug","hash":"a99a41334387ee9a46c6f8e8212331a29a10d159","modified":1682170034308},{"_id":"themes/butterfly/layout/includes/third-party/search/local-search.pug","hash":"5ebd5e8d39c9f77f5b2d983f6cd6802ccaf98746","modified":1682170034308},{"_id":"themes/butterfly/layout/includes/third-party/share/add-this.pug","hash":"2980f1889226ca981aa23b8eb1853fde26dcf89a","modified":1682170034308},{"_id":"themes/butterfly/layout/includes/third-party/share/addtoany.pug","hash":"85c92f8a7e44d7cd1c86f089a05be438535e5362","modified":1682170034308},{"_id":"themes/butterfly/layout/includes/third-party/share/index.pug","hash":"4c4a9c15215ae8ac5eadb0e086b278f76db9ee92","modified":1682170034308},{"_id":"themes/butterfly/layout/includes/third-party/share/share-js.pug","hash":"c7dd2b2ae9b23aa0a60fffd7df9e9f76ef52033e","modified":1682170034308},{"_id":"themes/butterfly/source/css/_highlight/highlight/diff.styl","hash":"cf1fae641c927621a4df1be5ca4a853b9b526e23","modified":1682170034308},{"_id":"themes/butterfly/source/css/_highlight/highlight/index.styl","hash":"18804c58239d95798fa86d0597f32d7f7dd30051","modified":1682170034312},{"_id":"themes/butterfly/source/css/_highlight/prismjs/diff.styl","hash":"5972c61f5125068cbe0af279a0c93a54847fdc3b","modified":1682170034312},{"_id":"themes/butterfly/source/css/_highlight/prismjs/index.styl","hash":"5dc2e0bcae9a54bfb9bdcc82d02ae5a3cf1ca97d","modified":1682170034312},{"_id":"themes/butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"8970cc1916c982b64a1478792b2822d1d31e276d","modified":1682170034312},{"_id":"source/404.md","hash":"8fde9c71bb4fb2b5fdfce3973912c76127b7d337","modified":1682169841808},{"_id":"source/LICENSE","hash":"7df059597099bb7dcf25d2a9aedfaf4465f72d8d","modified":1682169841808},{"_id":"source/about/index.md","hash":"4f97d7e47bebf04d8fdb81baeb5226f814f72512","modified":1682169841868},{"_id":"source/archives/index.md","hash":"d4b838f32fd09f696e8956017724c4bbc83aeb67","modified":1682169841868},{"_id":"source/categories/index.md","hash":"47b49f2344165155757a914e0a0adce870b31c3d","modified":1682169841868},{"_id":"source/link/index.md","hash":"ee9380a6a315c42ac37ffba213fce9637329df79","modified":1682169841868},{"_id":"source/tags/index.md","hash":"ef8633bd29bfd6d9dcb07b108e5428496aa8d06a","modified":1682169841868},{"_id":"source/img/logo/mesh.png","hash":"f3f2952c8ce9746d53a5a6b8be035a5da68cf37c","modified":1682169841980},{"_id":"source/_posts/Algorithm/Alg_Acm/acm_info.md","hash":"dbce8eece11ff014b07a21524b670c73c4ec9a1b","modified":1683464765057},{"_id":"source/_posts/Book/如何成为不完美主义者/从微习惯到不完美主义.md","hash":"fe0807bcb67ca21789e8cc63e7182b89668e7bbe","modified":1684219273375},{"_id":"source/_posts/Book/如何成为不完美主义者/完美主义的根源.md","hash":"2bc5179f02f22a2061002af2de86e243ea033458","modified":1685267180341},{"_id":"source/_posts/Book/读书笔记-深入理解Linux网络/读书笔记-深入理解Linux网络.md","hash":"79ac247b50225af593daf1b6bf5d27e05be8b7b9","modified":1684217878045},{"_id":"source/_posts/Common/dyx/April.md","hash":"a834782928dcf957b6c7ae61f23c1c18a48b0805","modified":1685267166834},{"_id":"source/_posts/Common/zjx/test.md","hash":"d093fe9e3a539f7d10ba249c12909fb7c1347f02","modified":1682319989504},{"_id":"source/_posts/EdgeMesh/2023-ospp-fighting/2023-ospp-fighting.md","hash":"be20566c4d8556babe7e232471d18bbea1b49093","modified":1682388417348},{"_id":"source/_posts/EdgeMesh/2023-ospp-fighting/CNI-Basic.md","hash":"e7daf50aa659db0992d82fd35b08090f6876a9a7","modified":1685267067696},{"_id":"source/_posts/EdgeMesh/2023-ospp-fighting/CNI-CreateCNI.md","hash":"0098e8bc3cbd76eeac33d09126c81c3a19edc94d","modified":1685267850035},{"_id":"source/_posts/EdgeMesh/2023-ospp-fighting/CNI-LinuxNetwork.md","hash":"7d7c49211d4b564cf61441ab7197938a463076f4","modified":1685267092227},{"_id":"source/_posts/EdgeMesh/2023-ospp-fighting/CNI-PodandContainer.md","hash":"406ca0282864ab190624d0f9c598c0ed868f350d","modified":1685171950228},{"_id":"source/_posts/EdgeMesh/2023-ospp-fighting/CNI-ReaseachofCni.md","hash":"7665e91ecd4530eb82e6af9e107b65e5a67fd670","modified":1685267154174},{"_id":"source/_posts/EdgeMesh/2023-ospp-fighting/Iptable-Basic.md","hash":"91a01800f806d8636d36212e49618efba90fb625","modified":1685154379152},{"_id":"source/_posts/EdgeMesh/2023-ospp-fighting/cilium-L2-Service.md","hash":"dc575afb756f4d42661c4005867fb492e0c68765","modified":1685154742419},{"_id":"source/_posts/Go/Go-Pratical-knowledge/Go-Pratical-knowledge.md","hash":"9b61c9987ac8ceb06d6939b94c14807452482c6d","modified":1682169842216},{"_id":"source/_posts/Go/Go-basic-knowledge/Go-basic-knowledge.md","hash":"a3a6ff34b53126e194e5c88314b9db1145693ca7","modified":1682388533765},{"_id":"source/_posts/Go/Go-basic-knowledge/Go-basic-typeUsage.md","hash":"04f193a42a1c142bb1a59343eb8e83c5bad6b0b7","modified":1682941779429},{"_id":"source/_posts/Go/Go-basic-knowledge/Go-basic-usage.md","hash":"9c7c2a1e64b475db3a825430a367b8a53fcf9370","modified":1683299377855},{"_id":"source/_posts/Go/Go-enhanced-knowledge/Go 系统知识汇总.md","hash":"07e6967858055b14d69b3a641a50ed14b3f6945a","modified":1683079163972},{"_id":"source/_posts/Go/Go-enhanced-knowledge/Go-Goroutine.md","hash":"e20d1decf27cdc77c92c8a4fd3194413b67bc1ca","modified":1682169842216},{"_id":"source/_posts/Go/Go-enhanced-knowledge/Go-enhanced-knowledge.md","hash":"4f3f8c5d44fd6a8de7bb8a67b97648d90b44af26","modified":1682337490979},{"_id":"source/_posts/Go/Golang-Common-Knowledege/Golang-Common-Knowledege.md","hash":"c02300d93b673798c579a709d1db31b3be9ee4e5","modified":1682169842216},{"_id":"source/_posts/Kubernetes/Kubernetes-网络插件（CNI）性能测试/Kubernetes-网络插件（CNI）性能测试.md","hash":"448dd4023b523e436130a824cf2b658e56cbb6e1","modified":1682169842236},{"_id":"source/_posts/P2P/cpolar/cpolar 使用.md","hash":"89533ed4859ca5692e3604b7eda929a8c2aa654a","modified":1682259400107},{"_id":"source/_posts/RPC/【RPC】Golang-实现简单-RPC/【RPC】Golang-实现简单-RPC.md","hash":"d115a64a8d5b85d97d49a2901936d9e61f6140b8","modified":1682337517635},{"_id":"source/_posts/Algorithm/Alg_Basic/Golang-基础算法/Golang-算法课程--算法.md","hash":"467de38267443de615e6e190c9df68ee14664a1b","modified":1682169842176},{"_id":"source/_posts/Algorithm/script/ACM-模式输入输出总结/ACM-模式输入输出总结.md","hash":"6b7e4e39f1c5b4f77ba690a6e876e52bb8777862","modified":1683079034323},{"_id":"source/_posts/Algorithm/Alg_Basic/Golang-数据结构/Golang-算法课程--数据结构.md","hash":"c550497f202591679f135b046835c3272d8acd79","modified":1683079024911},{"_id":"source/_posts/Algorithm/script/Golang-非算法题目/Golang-非算法题目.md","hash":"c48ae5b4303cd21e9bc69902747e217adca80608","modified":1682169842176},{"_id":"source/_posts/Algorithm/script/[动态规划] 动态规划入门/[动态规划] 动态规划入门.md","hash":"7b34eeae7bb8703790a73f58ee224d6531643749","modified":1682169842176},{"_id":"source/_posts/Algorithm/script/[动态规划] 动态规划问题/ [动态规划] 动态规划问题.md","hash":"38eaec5adb44e08c3df979418a3dfa3c09f48d17","modified":1682169842164},{"_id":"source/_posts/Algorithm/script/leetcode/leet code 简单题目突破.md","hash":"c866471bdaef5a82422d0b8e12e7b0ffa346df9c","modified":1683367966082},{"_id":"source/_posts/Algorithm/script/算法代码通用模板思考/算法代码通用模板思考.md","hash":"d12b86c661711a0545157cacb18d1915223ad6ee","modified":1682169842176},{"_id":"source/_posts/Algorithm/script/算法课程-南开苏明老师/算法简要汇总.md","hash":"2f75e1b596fc62e84a4666a43b02d6bbe3fe87a0","modified":1683079074330},{"_id":"source/_posts/Go/script/Golang-moudle/Golang-moudle.md","hash":"c68a175d9912fd71de4f60d5942ab80f4a8d9083","modified":1682169842216},{"_id":"source/_posts/Go/script/Golang-moudle/strconv.md","hash":"644c301ecae6468c4d24bbfbff320478753b9a15","modified":1682169842216},{"_id":"source/_posts/Go/script/Golang-使用链表/Golang-使用链表.md","hash":"dd2b5b4275436b273e703c1cea60c4bcfec32cf9","modified":1682169842236},{"_id":"source/_posts/Go/script/Golang-协程底层原理解析/Golang-协程底层原理解析.md","hash":"1b6f22f7eb25f00de9de78bc4e8a0789d10649b2","modified":1682169842216},{"_id":"source/_posts/Algorithm/Alg_Basic/Golang-基础算法/Golang- DP/Golang-DP.md","hash":"3e087b3c0373b769565f3831c9367a988ad48bd2","modified":1685267460103},{"_id":"source/_posts/Algorithm/Alg_Basic/Golang-基础算法/Golang-双指针/Golang-双指针.md","hash":"1b5461ee160453e98da541f88f4ccdad41887b9a","modified":1682930704326},{"_id":"source/_posts/Algorithm/Alg_Basic/Golang-数据结构/linklist/Golang-数据结构-链表.md","hash":"69e024c041385fe24ded163bfe43ff5cf0987e9e","modified":1682780623665},{"_id":"source/_posts/Go/Go-basic-knowledge/assets/image-20230228103213-yqcw1ma.png","hash":"79a82a008606e56af46964de04f1fde698b81ecb","modified":1677551533000},{"_id":"source/_posts/Go/Go-basic-knowledge/assets/image-20230228154553-m65t587.png","hash":"455ed99e4b52e8d48b173f1e2c41cddebf9db4e1","modified":1677570353000},{"_id":"source/_posts/Algorithm/Alg_Basic/Golang-数据结构/linklist/img/linklist_double.jpg","hash":"fbdd6b00399cec765f53ff1a56a89695ac075a2d","modified":1682741027163},{"_id":"source/img/backgroud/worriar.png","hash":"b64eb20fbca3fd872e418fe8d99bb4231476ca43","modified":1682169841972},{"_id":"source/img/cover/hope1.jpg","hash":"554232c097773b2f3ae0bee9fc5c517ae827c248","modified":1685268075931},{"_id":"source/img/cover/sun-flower1.jpg","hash":"b9f776c7e84f57e2d3f956edadf469bd8edab0d8","modified":1685268075671},{"_id":"source/_posts/Algorithm/script/leetcode/leet_simple_70.png","hash":"13d6a66ae5a72b91279c7de2eda96d1be189bcfa","modified":1683340921454},{"_id":"source/_posts/Algorithm/script/算法代码通用模板思考/tree_stack1.jpg","hash":"1a1eb04409eb03631a2f6acaefebdd6272ed937c","modified":1682169842180},{"_id":"source/_posts/Algorithm/script/算法代码通用模板思考/tree_stack2.jpg","hash":"f8207862e2abfdc69db0bbe1b2fda701f879e387","modified":1682169842204},{"_id":"source/img/cover/dom_tree1.jpg","hash":"626525a8b0b8691c8e23756c487eac2c4183b6a4","modified":1685268075819},{"_id":"source/img/cover/street1.jpg","hash":"c92abcee5e1a566c0a52847274b608a5a5bc5a1e","modified":1685268075423},{"_id":"source/img/backgroud/moon.png","hash":"aaa1e772e8c105173f3f3ef7bbe210ef402b363e","modified":1682169842248},{"_id":"source/img/cover/sky.png","hash":"732f7801ca8c489716e2d6e6defaacc5f44b05c8","modified":1682389805000},{"_id":"source/img/cover/sky4.png","hash":"ab593b64c65e4deced6e8b9ddc854e0b9c33cdb8","modified":1682389805000},{"_id":"source/img/cover/sky2.png","hash":"144bdb0ace686a0f24411278553e0bc18f154269","modified":1682389805000},{"_id":"source/img/signature/signature-removebg.png","hash":"ba5103eca83d60fd0682ad746442c48998b1c66f","modified":1682169842376},{"_id":"source/img/cover/sky3.png","hash":"fe63172ccea921aa764849ecff4d9997082be3f3","modified":1682389805000},{"_id":"source/img/avatar/2077_mobile.png","hash":"f5bba8aa0fd7a52106544451810c4da4a9c7b2c1","modified":1682169842308},{"_id":"source/img/backgroud/wallhaven-j3m8y5_1920x1080.png","hash":"f00c06b6d4b9249048ba275b082908bcd9afcbd7","modified":1682169842404},{"_id":"source/img/cover/2077_city.png","hash":"34b8054002690965e2cc7a7422491ca65cef023c","modified":1682169842412},{"_id":"public/atom.xml","hash":"9dbd9ee1ec0ca33de2770331770741e8e745ce04","modified":1685268218880},{"_id":"public/sitemap.xml","hash":"e84fa9fd69828729cfdb4b0db2389dbc82a5f5fe","modified":1685268218880},{"_id":"public/sitemap.txt","hash":"60e4c8058fcdd185e661e19c00bafa21fee7d25f","modified":1685268218880},{"_id":"public/404.html","hash":"8785d679133084e9178b56a20effae430179f14a","modified":1685268218880},{"_id":"public/about/index.html","hash":"a5176610adce6101ce336972eb59cb4c80c2cea6","modified":1685268218880},{"_id":"public/archives/index.html","hash":"ccdcdbe26fe371b65cea60d92110490a7a41cf66","modified":1685268218880},{"_id":"public/categories/index.html","hash":"01e622b58982de3567548245ef962fc85174ea0e","modified":1685268218880},{"_id":"public/link/index.html","hash":"8e06f2c43955888555a943802825b6e0095604f9","modified":1685268218880},{"_id":"public/tags/index.html","hash":"07441e43121348337414170167208ead73c46310","modified":1685268218880},{"_id":"public/2023/05/25/EdgeMesh/2023-ospp-fighting/CNI-CreateCNI/index.html","hash":"99b1a67f675871f80081cbbe4439136f0edfbecc","modified":1685268218880},{"_id":"public/2023/05/15/Book/如何成为不完美主义者/完美主义的根源/index.html","hash":"0183024b076fd29a9781ffc8388be0909a64069a","modified":1685268218880},{"_id":"public/2023/05/04/Go/Go-basic-knowledge/Go-basic-usage/index.html","hash":"84de557b615272a33a534bef32c52fc22f8de64c","modified":1685268218880},{"_id":"public/2023/04/18/EdgeMesh/2023-ospp-fighting/2023-ospp-fighting/index.html","hash":"9c9d25367e7b12fa3b7d2a7a3779e364965b3580","modified":1685268218880},{"_id":"public/2023/04/18/EdgeMesh/2023-ospp-fighting/CNI-Basic/index.html","hash":"a6dd5176d2344b90393570a2172577607da37c55","modified":1685268218880},{"_id":"public/2023/04/18/EdgeMesh/2023-ospp-fighting/CNI-LinuxNetwork/index.html","hash":"a9b18801fafc56cccb3a4470c99567eed4c55f62","modified":1685268218880},{"_id":"public/2023/04/18/EdgeMesh/2023-ospp-fighting/CNI-ReaseachofCni/index.html","hash":"cfd3866329602b1b7101e5d00f31eacdfeace326","modified":1685268218880},{"_id":"public/2023/04/04/Algorithm/script/leetcode/leet code 简单题目突破/index.html","hash":"015ccfd7fc797d48b681a03647d0576be4670202","modified":1685268218880},{"_id":"public/2023/04/01/Algorithm/Alg_Acm/acm_info/index.html","hash":"6be95e19c4495c1cd8c61da284e8a5962abf1d7b","modified":1685268218880},{"_id":"public/2023/04/01/Book/如何成为不完美主义者/从微习惯到不完美主义/index.html","hash":"04daed10438c0910c5490f07fda9c1c47fca8cc3","modified":1685268218880},{"_id":"public/2023/04/01/Algorithm/Alg_Basic/Golang-数据结构/Golang-算法课程--数据结构/index.html","hash":"92ba6b18aa714cecd56ef66aae9116aac1723a46","modified":1685268218880},{"_id":"public/2023/04/01/Algorithm/Alg_Basic/Golang-基础算法/Golang-双指针/Golang-双指针/index.html","hash":"f69152c405bd8b3b0948f8825841e6d59252a7a8","modified":1685268218880},{"_id":"public/2023/04/01/Algorithm/Alg_Basic/Golang-数据结构/linklist/Golang-数据结构-链表/index.html","hash":"2a460266ab0d4f931d1c7d90fc4b0a9e760f9c24","modified":1685268218880},{"_id":"public/2023/04/01/Go/Go-enhanced-knowledge/Go 系统知识汇总/index.html","hash":"39d1110d998004e09d6112937665b5fc6ebbe509","modified":1685268218880},{"_id":"public/2023/02/09/Go/Go-basic-knowledge/Go-basic-typeUsage/index.html","hash":"de3bb9d11b2b12a790f5d4aca278d57d043e3170","modified":1685268218880},{"_id":"public/2023/02/09/Go/Go-basic-knowledge/Go-basic-knowledge/index.html","hash":"6d09e57faf54713130f095e4ddcfb1a4f8bc9cb8","modified":1685268218880},{"_id":"public/archives/page/2/index.html","hash":"fcf85d7907aa585822431ab14f985b07934305b1","modified":1685268218880},{"_id":"public/archives/2023/index.html","hash":"65e5e8a985fa5e4fb9592200ddbbd1e6f2d22c72","modified":1685268218880},{"_id":"public/archives/2023/page/2/index.html","hash":"3a66389bff97ec75a1b1a41988f0a4eabdd329c0","modified":1685268218880},{"_id":"public/archives/2023/02/index.html","hash":"1ea87c1dbc307f61136f655042937487ad9cc9e2","modified":1685268218880},{"_id":"public/archives/2023/04/index.html","hash":"76e761ca13ed206f412ffd1cd0fb2bb6e72bda45","modified":1685268218880},{"_id":"public/archives/2023/04/page/2/index.html","hash":"b2d02a7a2f8e3b7915d4af5d1a0f329b26934d3e","modified":1685268218880},{"_id":"public/archives/2023/05/index.html","hash":"a203bf603734563f3c8657bfb14919594713fd73","modified":1685268218880},{"_id":"public/categories/acm/index.html","hash":"e030ebe2617f7bf05b38d7e532ac50e95e3141e8","modified":1685268218880},{"_id":"public/categories/book/index.html","hash":"1cdec92d0ecbd074bc768d7184bf8c672048e888","modified":1685268218880},{"_id":"public/categories/ospp/index.html","hash":"00f9363f014e71e04f88d4e9354eddcf2ec6661a","modified":1685268218880},{"_id":"public/categories/CNI/index.html","hash":"dabe20b853423dfe2ee99d8f017b96c97480e6d5","modified":1685268218880},{"_id":"public/categories/Linux-Container/index.html","hash":"bbb8a2d474904199889f5721d8fc3456be566c8c","modified":1685268218880},{"_id":"public/categories/Linux/index.html","hash":"d8ffe21328232e00a78ee558561e848561a3a766","modified":1685268218880},{"_id":"public/categories/Basic/index.html","hash":"e659b469e7a2c077e9fe064d5218828803efe9b7","modified":1685268218880},{"_id":"public/categories/enhanced/index.html","hash":"93943aab2a4829ab8ab5a2ebc5bd5e7e22a594ed","modified":1685268218880},{"_id":"public/categories/算法，Golang/index.html","hash":"9bd4545c397aaa818d0b2ebfb063e3f4ec58da60","modified":1685268218880},{"_id":"public/categories/算法/index.html","hash":"97f266031f3efa68492e388d8dbed44c0b286735","modified":1685268218880},{"_id":"public/index.html","hash":"7e21b2371d3b7c584a9827cd35390ed411b9397c","modified":1685268218880},{"_id":"public/page/2/index.html","hash":"6a748ce122d38ba6efbe71ae5a8793de44de7278","modified":1685268218880},{"_id":"public/tags/working-acm/index.html","hash":"af630eb33a73aafad132f331dcaf7bfb0c2f1331","modified":1685268218880},{"_id":"public/tags/book/index.html","hash":"357009314cc383ed01294a20762f1e7caa3e5bd3","modified":1685268218880},{"_id":"public/tags/ospp-edgemesh/index.html","hash":"b0b5b4f2dfe3c8a726283200e6821fc57b1bcb86","modified":1685268218880},{"_id":"public/tags/ospp-CNI-Linux-Spec/index.html","hash":"62873fd6f3fbaa45dc4d74313a456cc040b50fa4","modified":1685268218880},{"_id":"public/tags/ospp-Linux-Network/index.html","hash":"43c88ca5c8de4887346a233d446843fa55b9e541","modified":1685268218880},{"_id":"public/tags/working-算法/index.html","hash":"d7d2d0df82e87ee1b7c40fa05af55e6a6722d287","modified":1685268218880},{"_id":"public/tags/双指针-算法/index.html","hash":"035ed328dc42608e921ad396947e1f9419d3fa2a","modified":1685268218880},{"_id":"public/tags/链表-算法-数据结构/index.html","hash":"a582815a488f7e06256fe1712c1ec9f8a415cf2b","modified":1685268218880},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1685268218880},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1685268218880},{"_id":"public/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1685268218880},{"_id":"public/LICENSE","hash":"7df059597099bb7dcf25d2a9aedfaf4465f72d8d","modified":1685268218880},{"_id":"public/img/logo/mesh.png","hash":"f3f2952c8ce9746d53a5a6b8be035a5da68cf37c","modified":1685268218880},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1685268218880},{"_id":"public/js/utils.js","hash":"2e74fe8ae5ac20067668a18df5985459faf419f9","modified":1685268218880},{"_id":"public/js/search/local-search.js","hash":"8a0547ecb33ad2939450152adf54fca58e22a424","modified":1685268218880},{"_id":"public/js/search/algolia.js","hash":"fd86281d4f0f99ce173e49c1a0df3507fe268d37","modified":1685268218880},{"_id":"public/css/index.css","hash":"030f6a3e0090a50aae5eac103d7176eb811f6469","modified":1685268218880},{"_id":"public/js/main.js","hash":"05c825962e365af62096d3f1b4d7c9ee1b5fc2f5","modified":1685268218880},{"_id":"public/js/tw_cn.js","hash":"76d0c5c172cae44b34b0bd3125fd068b2c3cbd4a","modified":1685268218880},{"_id":"public/img/backgroud/worriar.png","hash":"b64eb20fbca3fd872e418fe8d99bb4231476ca43","modified":1685268218880},{"_id":"public/img/cover/hope1.jpg","hash":"554232c097773b2f3ae0bee9fc5c517ae827c248","modified":1685268218880},{"_id":"public/img/cover/sun-flower1.jpg","hash":"b9f776c7e84f57e2d3f956edadf469bd8edab0d8","modified":1685268218880},{"_id":"public/img/cover/dom_tree1.jpg","hash":"626525a8b0b8691c8e23756c487eac2c4183b6a4","modified":1685268218880},{"_id":"public/img/cover/street1.jpg","hash":"c92abcee5e1a566c0a52847274b608a5a5bc5a1e","modified":1685268218880},{"_id":"public/img/backgroud/moon.png","hash":"aaa1e772e8c105173f3f3ef7bbe210ef402b363e","modified":1685268218880},{"_id":"public/img/cover/sky.png","hash":"732f7801ca8c489716e2d6e6defaacc5f44b05c8","modified":1685268218880},{"_id":"public/img/cover/sky4.png","hash":"ab593b64c65e4deced6e8b9ddc854e0b9c33cdb8","modified":1685268218880},{"_id":"public/img/cover/sky2.png","hash":"144bdb0ace686a0f24411278553e0bc18f154269","modified":1685268218880},{"_id":"public/img/signature/signature-removebg.png","hash":"ba5103eca83d60fd0682ad746442c48998b1c66f","modified":1685268218880},{"_id":"public/img/cover/sky3.png","hash":"fe63172ccea921aa764849ecff4d9997082be3f3","modified":1685268218880},{"_id":"public/img/avatar/2077_mobile.png","hash":"f5bba8aa0fd7a52106544451810c4da4a9c7b2c1","modified":1685268218880},{"_id":"public/img/backgroud/wallhaven-j3m8y5_1920x1080.png","hash":"f00c06b6d4b9249048ba275b082908bcd9afcbd7","modified":1685268218880},{"_id":"public/img/cover/2077_city.png","hash":"34b8054002690965e2cc7a7422491ca65cef023c","modified":1685268218880}],"Category":[{"name":"acm","_id":"cli796r0a0004byjx89p9fxqv"},{"name":"book","_id":"cli796r0g000cbyjx80b76h5x"},{"name":"Common","_id":"cli796r0n000obyjx37cfazu8"},{"name":"ospp","_id":"cli796r0p000vbyjx9x6lg2y7"},{"name":"CNI","_id":"cli796r0r0012byjxerrad7r6"},{"name":"Linux, Container","_id":"cli796r0t0019byjx8lho0bew"},{"name":"Linux","_id":"cli796r0x001kbyjxczbobr9y"},{"name":"Basic","_id":"cli796r0z001qbyjxbkcu83h6"},{"name":"enhanced","_id":"cli796r140024byjx3tun937y"},{"name":"Golang","_id":"cli796r16002cbyjx43yf5l3s"},{"name":"p2p","_id":"cli796r18002jbyjx608ja0a6"},{"name":"算法，Golang","_id":"cli796r1a002qbyjxdqhx9fzg"},{"name":"算法","_id":"cli796r1d0030byjxdzos7zyi"},{"name":"算法[Algrithm]","_id":"cli796r1f003bbyjx9nzzad9x"},{"name":"index","_id":"cli796r1f003ebyjx6qxt5n6r"}],"Data":[],"Page":[{"layout":"404","description":"I'm sorry there is nothing that you want , but you can enjoy the scenery here ...","header-img":"img/backgroud/worriar.png","_content":"","source":"404.md","raw":"---\nlayout: 404\ndescription: \"I'm sorry there is nothing that you want , but you can enjoy the scenery here ...\"\nheader-img: \"img/backgroud/worriar.png\"\n---\n","date":"2023-04-22T13:24:01.808Z","updated":"2023-04-22T13:24:01.808Z","path":"404.html","title":"","comments":1,"_id":"cli796r020000byjxceiw18i9","content":"","site":{"data":{}},"cover":"/img/cover/sky4.png","cover_type":"img","excerpt":"","more":""},{"title":"about","header-img":"img/backgroud/wallhaven-j3m8y5_1920x1080.png","date":"2023-04-21T19:27:39.000Z","description":null,"_content":"","source":"about/index.md","raw":"---\ntitle: about\nheader-img: img/backgroud/wallhaven-j3m8y5_1920x1080.png\ndate: 2023-04-22 03:27:39\ndescription:\n---\n","updated":"2023-04-22T13:24:01.868Z","path":"about/index.html","comments":1,"layout":"page","_id":"cli796r080002byjx1syr6dul","content":"","site":{"data":{}},"cover":"/img/cover/sky2.png","cover_type":"img","excerpt":"","more":""},{"title":"archives","header-img":"img/backgroud/wallhaven-j3m8y5_1920x1080.png","date":"2023-04-21T19:27:26.000Z","description":null,"_content":"","source":"archives/index.md","raw":"---\ntitle: archives\nheader-img: img/backgroud/wallhaven-j3m8y5_1920x1080.png\ndate: 2023-04-22 03:27:26\ndescription:\n---\n","updated":"2023-04-22T13:24:01.868Z","path":"archives/index.html","comments":1,"layout":"page","_id":"cli796r0c0006byjx15o854de","content":"","site":{"data":{}},"cover":"/img/cover/sky4.png","cover_type":"img","excerpt":"","more":""},{"title":"categories","header-img":"img/backgroud/wallhaven-j3m8y5_1920x1080.png","date":"2023-04-21T19:28:17.000Z","description":null,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\nheader-img: img/backgroud/wallhaven-j3m8y5_1920x1080.png\ndate: 2023-04-22 03:28:17\ndescription:\n---\n","updated":"2023-04-22T13:24:01.868Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cli796r0e0008byjxfywfbrfz","content":"","site":{"data":{}},"cover":"/img/cover/2077_city.png","cover_type":"img","excerpt":"","more":""},{"title":"link","header-img":"img/backgroud/wallhaven-j3m8y5_1920x1080.png","date":"2023-04-21T19:27:02.000Z","description":null,"_content":"","source":"link/index.md","raw":"---\ntitle: link\nheader-img: img/backgroud/wallhaven-j3m8y5_1920x1080.png\ndate: 2023-04-22 03:27:02\ndescription:\n---\n","updated":"2023-04-22T13:24:01.868Z","path":"link/index.html","comments":1,"layout":"page","_id":"cli796r0f000abyjxhn53c8xx","content":"","site":{"data":{}},"cover":"/img/cover/2077_city.png","cover_type":"img","excerpt":"","more":""},{"title":"tags","header-img":"img/backgroud/wallhaven-j3m8y5_1920x1080.png","date":"2023-04-21T19:29:17.000Z","description":null,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\nheader-img: img/backgroud/wallhaven-j3m8y5_1920x1080.png\ndate: 2023-04-22 03:29:17\ndescription:\n---\n","updated":"2023-04-22T13:24:01.868Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cli796r0h000fbyjx1nuu0x24","content":"","site":{"data":{}},"cover":"/img/cover/sky3.png","cover_type":"img","excerpt":"","more":""}],"Post":[{"title":"acm info","catalog":true,"date":"2023-04-01T16:46:21.000Z","subtitle":null,"header-img":null,"_content":"\n## acm 刷题常用网站\n\n[Problemset - Codeforces](https://codeforces.com/problemset)\n\n[程序设计（复试）自由练题 - 计蒜客 (jisuanke.com)](https://www.jisuanke.com/problems)\n\n[题目列表 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/list)\n\n\n\n## acm 刷题的正确方式（个人用）\n\n","source":"_posts/Algorithm/Alg_Acm/acm_info.md","raw":"---\ntitle: acm info\ncatalog: true\ndate: 2023-04-02 00:46:21\nsubtitle:\nheader-img:\ntags: working, acm\ncategories: acm\n---\n\n## acm 刷题常用网站\n\n[Problemset - Codeforces](https://codeforces.com/problemset)\n\n[程序设计（复试）自由练题 - 计蒜客 (jisuanke.com)](https://www.jisuanke.com/problems)\n\n[题目列表 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/list)\n\n\n\n## acm 刷题的正确方式（个人用）\n\n","slug":"Algorithm/Alg_Acm/acm_info","published":1,"updated":"2023-05-07T13:06:05.057Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli796r050001byjx17g59n94","content":"<h2 id=\"acm-刷题常用网站\"><a href=\"#acm-刷题常用网站\" class=\"headerlink\" title=\"acm 刷题常用网站\"></a>acm 刷题常用网站</h2><p><a href=\"https://codeforces.com/problemset\">Problemset - Codeforces</a></p>\n<p><a href=\"https://www.jisuanke.com/problems\">程序设计（复试）自由练题 - 计蒜客 (jisuanke.com)</a></p>\n<p><a href=\"https://www.luogu.com.cn/problem/list\">题目列表 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>\n<h2 id=\"acm-刷题的正确方式（个人用）\"><a href=\"#acm-刷题的正确方式（个人用）\" class=\"headerlink\" title=\"acm 刷题的正确方式（个人用）\"></a>acm 刷题的正确方式（个人用）</h2>","site":{"data":{}},"cover":"/img/cover/2077_city.png","cover_type":"img","excerpt":"","more":"<h2 id=\"acm-刷题常用网站\"><a href=\"#acm-刷题常用网站\" class=\"headerlink\" title=\"acm 刷题常用网站\"></a>acm 刷题常用网站</h2><p><a href=\"https://codeforces.com/problemset\">Problemset - Codeforces</a></p>\n<p><a href=\"https://www.jisuanke.com/problems\">程序设计（复试）自由练题 - 计蒜客 (jisuanke.com)</a></p>\n<p><a href=\"https://www.luogu.com.cn/problem/list\">题目列表 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>\n<h2 id=\"acm-刷题的正确方式（个人用）\"><a href=\"#acm-刷题的正确方式（个人用）\" class=\"headerlink\" title=\"acm 刷题的正确方式（个人用）\"></a>acm 刷题的正确方式（个人用）</h2>"},{"title":"从微习惯到不完美主义","catalog":true,"date":"2023-04-01T16:46:21.000Z","_content":"\n> 近期反省结论 --> 过于追求过程和结果的完美程度，成效并不符合预期，因此针对这个问题进行修正。\n>\n> 本系列主要摘录书中语句加自己的感悟，贯彻“不完美主义”\n\n\n## 序\n\n>当购买花束时路过健身房，想要去健身提升自己，但却考虑到自己的装束并不适合运动，也不适合一整套的锻炼，于是放弃。\n\n心里的完美主义看到的是去做一件事不充分的条件，没有满足条件于是不做；但不完美主义看到的是一个健身的机会，不必完全做到到可以就做一部分。\n\n阻力是不一样的，过程也是不一样的，尽管这样零散的不完美无法达到最优和最高效，但是从0到1，排除阻力，往往是面对拖延和困难最重要的一步。\n\n\n\n>采纳建议、付诸实践是个人成长中最困难的部分，我们许下的愿望很多的，但真正实现的却很少。\n\n贬低和责备，是必要的，它适用于抑制过高过盛的气焰，能够摆脱浮躁不稳的心态；但却不适合在关键时候和细碎时候使用，开始与尝试，需要的是勇气和信心，越是等待条件越是怀疑自己，越是容易昏头、容易退缩。\n\n\n\n## 什么是完美主义\n\n\n\n​\t追求完美并没有错，完美主义的贯彻，严于律己，推动和逼迫自己，才能够不松懈，所以完美主义作为主旋律是没有错的；可是并不是所有的事情都必须彻底贯彻完美主义，我们是否可以做到整体上的完美主义，局部的不完美主义呢？\n\n​\t就像是我在写这篇博客一样，总想着需要将所读到的数据中好的句子、深入的感悟、句子所在位置、相关引用、句子语法甚至是表述语气，逐字逐句层层琢磨，非得让他毫无遗漏；但这样，光是读一页纸就耗费了许多的精力，如果书籍内容涉及专业领域，代码实验和环境问题又是一笔账，忙来忙去，总感觉做了非常多的事情，但收效并不高。\n\n​\t以往我总想着是不是读书不重要呢，总应该先做重要且紧急的事情。但即便是换了重要的事情，也容易推动缓慢，到头来一些不紧急的事情也变得紧急起来，相对不重要的事情也变得重要起来。\n\n​\t允许完成一件事的不完美，允许改进和成长的空间，允许犯错和失误的自己。现在即便没有设想的那般毫无缺漏，但只要下一步、下一秒有所成长，有所进步就足够了。\n\n​\t计算成长的方式不该是满10进1，而应该是大于即是满足。\n\n> 如果想要批判完美主义，可以从以下五方面入手：\n>\n> * 过高期待\n> * 纠结不放\n> * 行动顾虑\n\n> 如果你追求完美，将永远无法感到满足\n>\n> ​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t—— 列夫.托尔斯泰\n\n### 三种完美主义标准\n\n> 完美主义标准一般有三种：情景、品质与数量\n\n> 完美情景：如果过于追求情景的完美，当事人就会丧失很多情境下行动的机会。\n\n​\t设想当中的环境，理想当中的条件，预想之内的行动，去无法获得计划之下的结果，高估了自己？还是小看了任务，事情并不是那么单纯。\n\n> 资源，时段： 有些人也会应为缺少某些东西而拒绝行动。你是否只愿意身着运动服饰在健身房运动？事实上，你并不需要追求条件上的完美，唯一需要的健身器械就是你自己的身体。\n\n​\t工具、条件、准备，或者用我的理解：就是寻找解决一道题目最优的工具和方式；这种对于暴力解法或者是朴实思路的歧视，同时也是对于巧妙方法的高看。\n\n​\t或许有着更加高效的方式和条件方法，但这些方法并不是必要的条件，一味的执着最优，往往连保底都没有。尤其是对于初次、陌生、不熟悉的事物，放下身段，沉下心态，用最不完美的方式开始，也不至于空手而归。\n\n> 对数量追求完美，指的是那种只要数量达不到预期就无法心满意足的状态。\n\n> 一些目标并非无法完成，而他们之所以会导致完美主义的弊端，是因为这种目标似乎暗示了不如预期的进步就是不够好的。\n\n> 这样的目标就像是撑杆跳：只要不跳过就算失败，只要跳过了就是成功。你跳到多高并不重要，你能不能跳过成了唯一的标准。这种将目标做两极化处理的观点本应鼓励我们朝着目标的方向努力，甚至超越目标，事实上却成了非常低级的策略。\n\n> 完美主义者无法接受微小的价值或进步；他们只看重宏大、顺利、完美的成功。\n\n成败分明的宏大目标比比皆是，但值得肯定的微小进步却不被记录，如果说高楼大厦着实耀眼，但他又何尝不是一砖一瓦累积起来的呢？\n\n​\t虽说书中这里将不完美主义和完美主义对立了起来（或者说译文的表述如此），但完美主义的成败标准也是不可缺少的。人总有松懈的时候，心态膨胀、心性浮躁、情感飘忽，如果没有一个标准或者是结果来导向的话，终难成大事。所以我想，时常的鞭策和逼迫，离开自己的舒适区，以完美主义要求并没有问题；但是自我衡量、决策思考时候，不该是两极化的完美主义，而应该柔软下来，认知到每一个细小的进步，或许这一次还不行，但只要还有机会，我就会努力迈进。\n\n\n\n*耗时45分钟*","source":"_posts/Book/如何成为不完美主义者/从微习惯到不完美主义.md","raw":"---\ntitle: 从微习惯到不完美主义\ncatalog: true\ndate: 2023-04-02 00:46:21\ntags: book\ncategories: book\n---\n\n> 近期反省结论 --> 过于追求过程和结果的完美程度，成效并不符合预期，因此针对这个问题进行修正。\n>\n> 本系列主要摘录书中语句加自己的感悟，贯彻“不完美主义”\n\n\n## 序\n\n>当购买花束时路过健身房，想要去健身提升自己，但却考虑到自己的装束并不适合运动，也不适合一整套的锻炼，于是放弃。\n\n心里的完美主义看到的是去做一件事不充分的条件，没有满足条件于是不做；但不完美主义看到的是一个健身的机会，不必完全做到到可以就做一部分。\n\n阻力是不一样的，过程也是不一样的，尽管这样零散的不完美无法达到最优和最高效，但是从0到1，排除阻力，往往是面对拖延和困难最重要的一步。\n\n\n\n>采纳建议、付诸实践是个人成长中最困难的部分，我们许下的愿望很多的，但真正实现的却很少。\n\n贬低和责备，是必要的，它适用于抑制过高过盛的气焰，能够摆脱浮躁不稳的心态；但却不适合在关键时候和细碎时候使用，开始与尝试，需要的是勇气和信心，越是等待条件越是怀疑自己，越是容易昏头、容易退缩。\n\n\n\n## 什么是完美主义\n\n\n\n​\t追求完美并没有错，完美主义的贯彻，严于律己，推动和逼迫自己，才能够不松懈，所以完美主义作为主旋律是没有错的；可是并不是所有的事情都必须彻底贯彻完美主义，我们是否可以做到整体上的完美主义，局部的不完美主义呢？\n\n​\t就像是我在写这篇博客一样，总想着需要将所读到的数据中好的句子、深入的感悟、句子所在位置、相关引用、句子语法甚至是表述语气，逐字逐句层层琢磨，非得让他毫无遗漏；但这样，光是读一页纸就耗费了许多的精力，如果书籍内容涉及专业领域，代码实验和环境问题又是一笔账，忙来忙去，总感觉做了非常多的事情，但收效并不高。\n\n​\t以往我总想着是不是读书不重要呢，总应该先做重要且紧急的事情。但即便是换了重要的事情，也容易推动缓慢，到头来一些不紧急的事情也变得紧急起来，相对不重要的事情也变得重要起来。\n\n​\t允许完成一件事的不完美，允许改进和成长的空间，允许犯错和失误的自己。现在即便没有设想的那般毫无缺漏，但只要下一步、下一秒有所成长，有所进步就足够了。\n\n​\t计算成长的方式不该是满10进1，而应该是大于即是满足。\n\n> 如果想要批判完美主义，可以从以下五方面入手：\n>\n> * 过高期待\n> * 纠结不放\n> * 行动顾虑\n\n> 如果你追求完美，将永远无法感到满足\n>\n> ​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t—— 列夫.托尔斯泰\n\n### 三种完美主义标准\n\n> 完美主义标准一般有三种：情景、品质与数量\n\n> 完美情景：如果过于追求情景的完美，当事人就会丧失很多情境下行动的机会。\n\n​\t设想当中的环境，理想当中的条件，预想之内的行动，去无法获得计划之下的结果，高估了自己？还是小看了任务，事情并不是那么单纯。\n\n> 资源，时段： 有些人也会应为缺少某些东西而拒绝行动。你是否只愿意身着运动服饰在健身房运动？事实上，你并不需要追求条件上的完美，唯一需要的健身器械就是你自己的身体。\n\n​\t工具、条件、准备，或者用我的理解：就是寻找解决一道题目最优的工具和方式；这种对于暴力解法或者是朴实思路的歧视，同时也是对于巧妙方法的高看。\n\n​\t或许有着更加高效的方式和条件方法，但这些方法并不是必要的条件，一味的执着最优，往往连保底都没有。尤其是对于初次、陌生、不熟悉的事物，放下身段，沉下心态，用最不完美的方式开始，也不至于空手而归。\n\n> 对数量追求完美，指的是那种只要数量达不到预期就无法心满意足的状态。\n\n> 一些目标并非无法完成，而他们之所以会导致完美主义的弊端，是因为这种目标似乎暗示了不如预期的进步就是不够好的。\n\n> 这样的目标就像是撑杆跳：只要不跳过就算失败，只要跳过了就是成功。你跳到多高并不重要，你能不能跳过成了唯一的标准。这种将目标做两极化处理的观点本应鼓励我们朝着目标的方向努力，甚至超越目标，事实上却成了非常低级的策略。\n\n> 完美主义者无法接受微小的价值或进步；他们只看重宏大、顺利、完美的成功。\n\n成败分明的宏大目标比比皆是，但值得肯定的微小进步却不被记录，如果说高楼大厦着实耀眼，但他又何尝不是一砖一瓦累积起来的呢？\n\n​\t虽说书中这里将不完美主义和完美主义对立了起来（或者说译文的表述如此），但完美主义的成败标准也是不可缺少的。人总有松懈的时候，心态膨胀、心性浮躁、情感飘忽，如果没有一个标准或者是结果来导向的话，终难成大事。所以我想，时常的鞭策和逼迫，离开自己的舒适区，以完美主义要求并没有问题；但是自我衡量、决策思考时候，不该是两极化的完美主义，而应该柔软下来，认知到每一个细小的进步，或许这一次还不行，但只要还有机会，我就会努力迈进。\n\n\n\n*耗时45分钟*","slug":"Book/如何成为不完美主义者/从微习惯到不完美主义","published":1,"updated":"2023-05-16T06:41:13.375Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli796r090003byjxfvbj3zy1","content":"<blockquote>\n<p>近期反省结论 –&gt; 过于追求过程和结果的完美程度，成效并不符合预期，因此针对这个问题进行修正。</p>\n<p>本系列主要摘录书中语句加自己的感悟，贯彻“不完美主义”</p>\n</blockquote>\n<h2 id=\"序\"><a href=\"#序\" class=\"headerlink\" title=\"序\"></a>序</h2><blockquote>\n<p>当购买花束时路过健身房，想要去健身提升自己，但却考虑到自己的装束并不适合运动，也不适合一整套的锻炼，于是放弃。</p>\n</blockquote>\n<p>心里的完美主义看到的是去做一件事不充分的条件，没有满足条件于是不做；但不完美主义看到的是一个健身的机会，不必完全做到到可以就做一部分。</p>\n<p>阻力是不一样的，过程也是不一样的，尽管这样零散的不完美无法达到最优和最高效，但是从0到1，排除阻力，往往是面对拖延和困难最重要的一步。</p>\n<blockquote>\n<p>采纳建议、付诸实践是个人成长中最困难的部分，我们许下的愿望很多的，但真正实现的却很少。</p>\n</blockquote>\n<p>贬低和责备，是必要的，它适用于抑制过高过盛的气焰，能够摆脱浮躁不稳的心态；但却不适合在关键时候和细碎时候使用，开始与尝试，需要的是勇气和信心，越是等待条件越是怀疑自己，越是容易昏头、容易退缩。</p>\n<h2 id=\"什么是完美主义\"><a href=\"#什么是完美主义\" class=\"headerlink\" title=\"什么是完美主义\"></a>什么是完美主义</h2><p>​    追求完美并没有错，完美主义的贯彻，严于律己，推动和逼迫自己，才能够不松懈，所以完美主义作为主旋律是没有错的；可是并不是所有的事情都必须彻底贯彻完美主义，我们是否可以做到整体上的完美主义，局部的不完美主义呢？</p>\n<p>​    就像是我在写这篇博客一样，总想着需要将所读到的数据中好的句子、深入的感悟、句子所在位置、相关引用、句子语法甚至是表述语气，逐字逐句层层琢磨，非得让他毫无遗漏；但这样，光是读一页纸就耗费了许多的精力，如果书籍内容涉及专业领域，代码实验和环境问题又是一笔账，忙来忙去，总感觉做了非常多的事情，但收效并不高。</p>\n<p>​    以往我总想着是不是读书不重要呢，总应该先做重要且紧急的事情。但即便是换了重要的事情，也容易推动缓慢，到头来一些不紧急的事情也变得紧急起来，相对不重要的事情也变得重要起来。</p>\n<p>​    允许完成一件事的不完美，允许改进和成长的空间，允许犯错和失误的自己。现在即便没有设想的那般毫无缺漏，但只要下一步、下一秒有所成长，有所进步就足够了。</p>\n<p>​    计算成长的方式不该是满10进1，而应该是大于即是满足。</p>\n<blockquote>\n<p>如果想要批判完美主义，可以从以下五方面入手：</p>\n<ul>\n<li>过高期待</li>\n<li>纠结不放</li>\n<li>行动顾虑</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>如果你追求完美，将永远无法感到满足</p>\n<p>​                                                            —— 列夫.托尔斯泰</p>\n</blockquote>\n<h3 id=\"三种完美主义标准\"><a href=\"#三种完美主义标准\" class=\"headerlink\" title=\"三种完美主义标准\"></a>三种完美主义标准</h3><blockquote>\n<p>完美主义标准一般有三种：情景、品质与数量</p>\n</blockquote>\n<blockquote>\n<p>完美情景：如果过于追求情景的完美，当事人就会丧失很多情境下行动的机会。</p>\n</blockquote>\n<p>​    设想当中的环境，理想当中的条件，预想之内的行动，去无法获得计划之下的结果，高估了自己？还是小看了任务，事情并不是那么单纯。</p>\n<blockquote>\n<p>资源，时段： 有些人也会应为缺少某些东西而拒绝行动。你是否只愿意身着运动服饰在健身房运动？事实上，你并不需要追求条件上的完美，唯一需要的健身器械就是你自己的身体。</p>\n</blockquote>\n<p>​    工具、条件、准备，或者用我的理解：就是寻找解决一道题目最优的工具和方式；这种对于暴力解法或者是朴实思路的歧视，同时也是对于巧妙方法的高看。</p>\n<p>​    或许有着更加高效的方式和条件方法，但这些方法并不是必要的条件，一味的执着最优，往往连保底都没有。尤其是对于初次、陌生、不熟悉的事物，放下身段，沉下心态，用最不完美的方式开始，也不至于空手而归。</p>\n<blockquote>\n<p>对数量追求完美，指的是那种只要数量达不到预期就无法心满意足的状态。</p>\n</blockquote>\n<blockquote>\n<p>一些目标并非无法完成，而他们之所以会导致完美主义的弊端，是因为这种目标似乎暗示了不如预期的进步就是不够好的。</p>\n</blockquote>\n<blockquote>\n<p>这样的目标就像是撑杆跳：只要不跳过就算失败，只要跳过了就是成功。你跳到多高并不重要，你能不能跳过成了唯一的标准。这种将目标做两极化处理的观点本应鼓励我们朝着目标的方向努力，甚至超越目标，事实上却成了非常低级的策略。</p>\n</blockquote>\n<blockquote>\n<p>完美主义者无法接受微小的价值或进步；他们只看重宏大、顺利、完美的成功。</p>\n</blockquote>\n<p>成败分明的宏大目标比比皆是，但值得肯定的微小进步却不被记录，如果说高楼大厦着实耀眼，但他又何尝不是一砖一瓦累积起来的呢？</p>\n<p>​    虽说书中这里将不完美主义和完美主义对立了起来（或者说译文的表述如此），但完美主义的成败标准也是不可缺少的。人总有松懈的时候，心态膨胀、心性浮躁、情感飘忽，如果没有一个标准或者是结果来导向的话，终难成大事。所以我想，时常的鞭策和逼迫，离开自己的舒适区，以完美主义要求并没有问题；但是自我衡量、决策思考时候，不该是两极化的完美主义，而应该柔软下来，认知到每一个细小的进步，或许这一次还不行，但只要还有机会，我就会努力迈进。</p>\n<p><em>耗时45分钟</em></p>\n","site":{"data":{}},"cover":"/img/cover/sky3.png","cover_type":"img","excerpt":"","more":"<blockquote>\n<p>近期反省结论 –&gt; 过于追求过程和结果的完美程度，成效并不符合预期，因此针对这个问题进行修正。</p>\n<p>本系列主要摘录书中语句加自己的感悟，贯彻“不完美主义”</p>\n</blockquote>\n<h2 id=\"序\"><a href=\"#序\" class=\"headerlink\" title=\"序\"></a>序</h2><blockquote>\n<p>当购买花束时路过健身房，想要去健身提升自己，但却考虑到自己的装束并不适合运动，也不适合一整套的锻炼，于是放弃。</p>\n</blockquote>\n<p>心里的完美主义看到的是去做一件事不充分的条件，没有满足条件于是不做；但不完美主义看到的是一个健身的机会，不必完全做到到可以就做一部分。</p>\n<p>阻力是不一样的，过程也是不一样的，尽管这样零散的不完美无法达到最优和最高效，但是从0到1，排除阻力，往往是面对拖延和困难最重要的一步。</p>\n<blockquote>\n<p>采纳建议、付诸实践是个人成长中最困难的部分，我们许下的愿望很多的，但真正实现的却很少。</p>\n</blockquote>\n<p>贬低和责备，是必要的，它适用于抑制过高过盛的气焰，能够摆脱浮躁不稳的心态；但却不适合在关键时候和细碎时候使用，开始与尝试，需要的是勇气和信心，越是等待条件越是怀疑自己，越是容易昏头、容易退缩。</p>\n<h2 id=\"什么是完美主义\"><a href=\"#什么是完美主义\" class=\"headerlink\" title=\"什么是完美主义\"></a>什么是完美主义</h2><p>​    追求完美并没有错，完美主义的贯彻，严于律己，推动和逼迫自己，才能够不松懈，所以完美主义作为主旋律是没有错的；可是并不是所有的事情都必须彻底贯彻完美主义，我们是否可以做到整体上的完美主义，局部的不完美主义呢？</p>\n<p>​    就像是我在写这篇博客一样，总想着需要将所读到的数据中好的句子、深入的感悟、句子所在位置、相关引用、句子语法甚至是表述语气，逐字逐句层层琢磨，非得让他毫无遗漏；但这样，光是读一页纸就耗费了许多的精力，如果书籍内容涉及专业领域，代码实验和环境问题又是一笔账，忙来忙去，总感觉做了非常多的事情，但收效并不高。</p>\n<p>​    以往我总想着是不是读书不重要呢，总应该先做重要且紧急的事情。但即便是换了重要的事情，也容易推动缓慢，到头来一些不紧急的事情也变得紧急起来，相对不重要的事情也变得重要起来。</p>\n<p>​    允许完成一件事的不完美，允许改进和成长的空间，允许犯错和失误的自己。现在即便没有设想的那般毫无缺漏，但只要下一步、下一秒有所成长，有所进步就足够了。</p>\n<p>​    计算成长的方式不该是满10进1，而应该是大于即是满足。</p>\n<blockquote>\n<p>如果想要批判完美主义，可以从以下五方面入手：</p>\n<ul>\n<li>过高期待</li>\n<li>纠结不放</li>\n<li>行动顾虑</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>如果你追求完美，将永远无法感到满足</p>\n<p>​                                                            —— 列夫.托尔斯泰</p>\n</blockquote>\n<h3 id=\"三种完美主义标准\"><a href=\"#三种完美主义标准\" class=\"headerlink\" title=\"三种完美主义标准\"></a>三种完美主义标准</h3><blockquote>\n<p>完美主义标准一般有三种：情景、品质与数量</p>\n</blockquote>\n<blockquote>\n<p>完美情景：如果过于追求情景的完美，当事人就会丧失很多情境下行动的机会。</p>\n</blockquote>\n<p>​    设想当中的环境，理想当中的条件，预想之内的行动，去无法获得计划之下的结果，高估了自己？还是小看了任务，事情并不是那么单纯。</p>\n<blockquote>\n<p>资源，时段： 有些人也会应为缺少某些东西而拒绝行动。你是否只愿意身着运动服饰在健身房运动？事实上，你并不需要追求条件上的完美，唯一需要的健身器械就是你自己的身体。</p>\n</blockquote>\n<p>​    工具、条件、准备，或者用我的理解：就是寻找解决一道题目最优的工具和方式；这种对于暴力解法或者是朴实思路的歧视，同时也是对于巧妙方法的高看。</p>\n<p>​    或许有着更加高效的方式和条件方法，但这些方法并不是必要的条件，一味的执着最优，往往连保底都没有。尤其是对于初次、陌生、不熟悉的事物，放下身段，沉下心态，用最不完美的方式开始，也不至于空手而归。</p>\n<blockquote>\n<p>对数量追求完美，指的是那种只要数量达不到预期就无法心满意足的状态。</p>\n</blockquote>\n<blockquote>\n<p>一些目标并非无法完成，而他们之所以会导致完美主义的弊端，是因为这种目标似乎暗示了不如预期的进步就是不够好的。</p>\n</blockquote>\n<blockquote>\n<p>这样的目标就像是撑杆跳：只要不跳过就算失败，只要跳过了就是成功。你跳到多高并不重要，你能不能跳过成了唯一的标准。这种将目标做两极化处理的观点本应鼓励我们朝着目标的方向努力，甚至超越目标，事实上却成了非常低级的策略。</p>\n</blockquote>\n<blockquote>\n<p>完美主义者无法接受微小的价值或进步；他们只看重宏大、顺利、完美的成功。</p>\n</blockquote>\n<p>成败分明的宏大目标比比皆是，但值得肯定的微小进步却不被记录，如果说高楼大厦着实耀眼，但他又何尝不是一砖一瓦累积起来的呢？</p>\n<p>​    虽说书中这里将不完美主义和完美主义对立了起来（或者说译文的表述如此），但完美主义的成败标准也是不可缺少的。人总有松懈的时候，心态膨胀、心性浮躁、情感飘忽，如果没有一个标准或者是结果来导向的话，终难成大事。所以我想，时常的鞭策和逼迫，离开自己的舒适区，以完美主义要求并没有问题；但是自我衡量、决策思考时候，不该是两极化的完美主义，而应该柔软下来，认知到每一个细小的进步，或许这一次还不行，但只要还有机会，我就会努力迈进。</p>\n<p><em>耗时45分钟</em></p>\n"},{"title":"完美主义的根源","date":"2023-05-15T15:40:37.000Z","catalog":true,"_content":"\n\n\n## 完美主义的根源\n\n缺乏安全感\n\n自卑情结（inferiority complex）\n\n> 自卑心理和缺乏安全感一样，会令你对自己的缺陷高度敏感。你会一直小心翼翼，认为这样就会避免犯错。这或许能够给你一些虚假的安全感，但是，要想获得真正地获得安全感，你需要了解并接受真正的自己。\n>\n> 如果你能够接受自己，包括自己的缺点，即使遭遇最为严厉的批评，你也有力量捍卫自己。\n\n书中虽然详述了自卑情结的祸害，却没有更多地分析产生自卑情结的原因。\n\n导致自卑情结和缺乏安全感的原因有很多，依照我的看法，外界因素占比较多。不稳定的家庭环境，不充足的教育背景，不契合的生活族群，诸多种种都会导致个人的自卑。\n\n从家庭环境来说，最主要的原因并不是物质条件的匮乏或者充裕，而是父母价值观的熏陶，这部分的自卑来源于自我定位和认知上的**焦虑**。作为评价自我最重要的一环，价值观的塑造时时刻刻都在影响着个人的发展。从中国近代直至现今的家庭环境来说，往往总是物质条件充裕的家庭更愿意指导孩子去追求实现自我和精神发展上的条件，衡量成功与否在于是否做出了什么；相较之下贫苦的家庭则更可能面临着教育经历较差的父母，受限于物理条件的制约，他们更加追捧于财富和权力。如此这些自认为失败的人生经历和教训，以一种代代相传的方式侵染着其子孙，成功与否就看是否出名了，是否有钱了，是否能把其他人踩在脚下了。当然，也并非所有的家庭都是这样，物质条件充裕但仍旧贪婪追求垄断的氏族，物质条件匮乏却见识长远的中低产家庭，以上的情况就存在换位。\n\n但不论如何，有着较强自卑心理的孩子，其父母所灌输的价值观和自我衡量的方式必定是更加偏向于物质层面和外界条件的。诚然，这样的价值观更加符合资本发展积累和自然优胜劣汰的逻辑，可能会在一定程度上有着较高的竞争力，但在我看来，这样的追求并没有把人作为人来对待。父母是否想过，为什么想要一个孩子，为什么要抚养他长大，为什么期望着他成长之后的人生呢？\n\n从教育背景来说，核心在于所遇到的导师教育的态度和方式之上。首先要明确的是，教育背景不论好坏学校，只看主导老师的能力强弱。985、211、双一流但是老师却不知道如何教人，也不明白自己所处位置的重要性；职高甚至是周边的朋友，如师如父，指点迷津；换句话说，教育背景的高低在于老师，选择好的学校和学历更多地是增加遇到好老师的概率，当然社会用工环境和舆论将这个概念泛化，认为好的高校就必定有好的教育，这个想法是错误的。\n\n师者，我认为需因材施教，需适时施教，需以德为教。自卑心理的产生很大程度上来源自老师的批评和否定，当然这并不是说批评和否定是错误的，但老师不做任何的理解和认知，不去了解学生的努力和困惑，只以结果的好坏和成果的多少来说，这样包工头子似的培育方式就是将错误的完美主义强加于学生身上，久而久之，学生自然产生厌恶，自然害怕失误，自然讨厌学习，因为自己有困惑但无法解决，寻求老师换来的只是一顿批判。学生不是工人，不是下属，不是劳力，师生之间本不该存在雇佣关系和支配关系；犯错是被允许的、疑惑是被允许的、无知也应该是被允许的。如果从小学到高中，再到大学，这样的否定不绝于耳，那这个学生的教育背景就是极其糟糕的。\n\n","source":"_posts/Book/如何成为不完美主义者/完美主义的根源.md","raw":"---\ntitle: 完美主义的根源\ndate: 2023-05-15 23:40:37\ncatalog: true\ntags: book\ncategories: book\n---\n\n\n\n## 完美主义的根源\n\n缺乏安全感\n\n自卑情结（inferiority complex）\n\n> 自卑心理和缺乏安全感一样，会令你对自己的缺陷高度敏感。你会一直小心翼翼，认为这样就会避免犯错。这或许能够给你一些虚假的安全感，但是，要想获得真正地获得安全感，你需要了解并接受真正的自己。\n>\n> 如果你能够接受自己，包括自己的缺点，即使遭遇最为严厉的批评，你也有力量捍卫自己。\n\n书中虽然详述了自卑情结的祸害，却没有更多地分析产生自卑情结的原因。\n\n导致自卑情结和缺乏安全感的原因有很多，依照我的看法，外界因素占比较多。不稳定的家庭环境，不充足的教育背景，不契合的生活族群，诸多种种都会导致个人的自卑。\n\n从家庭环境来说，最主要的原因并不是物质条件的匮乏或者充裕，而是父母价值观的熏陶，这部分的自卑来源于自我定位和认知上的**焦虑**。作为评价自我最重要的一环，价值观的塑造时时刻刻都在影响着个人的发展。从中国近代直至现今的家庭环境来说，往往总是物质条件充裕的家庭更愿意指导孩子去追求实现自我和精神发展上的条件，衡量成功与否在于是否做出了什么；相较之下贫苦的家庭则更可能面临着教育经历较差的父母，受限于物理条件的制约，他们更加追捧于财富和权力。如此这些自认为失败的人生经历和教训，以一种代代相传的方式侵染着其子孙，成功与否就看是否出名了，是否有钱了，是否能把其他人踩在脚下了。当然，也并非所有的家庭都是这样，物质条件充裕但仍旧贪婪追求垄断的氏族，物质条件匮乏却见识长远的中低产家庭，以上的情况就存在换位。\n\n但不论如何，有着较强自卑心理的孩子，其父母所灌输的价值观和自我衡量的方式必定是更加偏向于物质层面和外界条件的。诚然，这样的价值观更加符合资本发展积累和自然优胜劣汰的逻辑，可能会在一定程度上有着较高的竞争力，但在我看来，这样的追求并没有把人作为人来对待。父母是否想过，为什么想要一个孩子，为什么要抚养他长大，为什么期望着他成长之后的人生呢？\n\n从教育背景来说，核心在于所遇到的导师教育的态度和方式之上。首先要明确的是，教育背景不论好坏学校，只看主导老师的能力强弱。985、211、双一流但是老师却不知道如何教人，也不明白自己所处位置的重要性；职高甚至是周边的朋友，如师如父，指点迷津；换句话说，教育背景的高低在于老师，选择好的学校和学历更多地是增加遇到好老师的概率，当然社会用工环境和舆论将这个概念泛化，认为好的高校就必定有好的教育，这个想法是错误的。\n\n师者，我认为需因材施教，需适时施教，需以德为教。自卑心理的产生很大程度上来源自老师的批评和否定，当然这并不是说批评和否定是错误的，但老师不做任何的理解和认知，不去了解学生的努力和困惑，只以结果的好坏和成果的多少来说，这样包工头子似的培育方式就是将错误的完美主义强加于学生身上，久而久之，学生自然产生厌恶，自然害怕失误，自然讨厌学习，因为自己有困惑但无法解决，寻求老师换来的只是一顿批判。学生不是工人，不是下属，不是劳力，师生之间本不该存在雇佣关系和支配关系；犯错是被允许的、疑惑是被允许的、无知也应该是被允许的。如果从小学到高中，再到大学，这样的否定不绝于耳，那这个学生的教育背景就是极其糟糕的。\n\n","slug":"Book/如何成为不完美主义者/完美主义的根源","published":1,"updated":"2023-05-28T09:46:20.341Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli796r0d0007byjx72tcf7vi","content":"<h2 id=\"完美主义的根源\"><a href=\"#完美主义的根源\" class=\"headerlink\" title=\"完美主义的根源\"></a>完美主义的根源</h2><p>缺乏安全感</p>\n<p>自卑情结（inferiority complex）</p>\n<blockquote>\n<p>自卑心理和缺乏安全感一样，会令你对自己的缺陷高度敏感。你会一直小心翼翼，认为这样就会避免犯错。这或许能够给你一些虚假的安全感，但是，要想获得真正地获得安全感，你需要了解并接受真正的自己。</p>\n<p>如果你能够接受自己，包括自己的缺点，即使遭遇最为严厉的批评，你也有力量捍卫自己。</p>\n</blockquote>\n<p>书中虽然详述了自卑情结的祸害，却没有更多地分析产生自卑情结的原因。</p>\n<p>导致自卑情结和缺乏安全感的原因有很多，依照我的看法，外界因素占比较多。不稳定的家庭环境，不充足的教育背景，不契合的生活族群，诸多种种都会导致个人的自卑。</p>\n<p>从家庭环境来说，最主要的原因并不是物质条件的匮乏或者充裕，而是父母价值观的熏陶，这部分的自卑来源于自我定位和认知上的<strong>焦虑</strong>。作为评价自我最重要的一环，价值观的塑造时时刻刻都在影响着个人的发展。从中国近代直至现今的家庭环境来说，往往总是物质条件充裕的家庭更愿意指导孩子去追求实现自我和精神发展上的条件，衡量成功与否在于是否做出了什么；相较之下贫苦的家庭则更可能面临着教育经历较差的父母，受限于物理条件的制约，他们更加追捧于财富和权力。如此这些自认为失败的人生经历和教训，以一种代代相传的方式侵染着其子孙，成功与否就看是否出名了，是否有钱了，是否能把其他人踩在脚下了。当然，也并非所有的家庭都是这样，物质条件充裕但仍旧贪婪追求垄断的氏族，物质条件匮乏却见识长远的中低产家庭，以上的情况就存在换位。</p>\n<p>但不论如何，有着较强自卑心理的孩子，其父母所灌输的价值观和自我衡量的方式必定是更加偏向于物质层面和外界条件的。诚然，这样的价值观更加符合资本发展积累和自然优胜劣汰的逻辑，可能会在一定程度上有着较高的竞争力，但在我看来，这样的追求并没有把人作为人来对待。父母是否想过，为什么想要一个孩子，为什么要抚养他长大，为什么期望着他成长之后的人生呢？</p>\n<p>从教育背景来说，核心在于所遇到的导师教育的态度和方式之上。首先要明确的是，教育背景不论好坏学校，只看主导老师的能力强弱。985、211、双一流但是老师却不知道如何教人，也不明白自己所处位置的重要性；职高甚至是周边的朋友，如师如父，指点迷津；换句话说，教育背景的高低在于老师，选择好的学校和学历更多地是增加遇到好老师的概率，当然社会用工环境和舆论将这个概念泛化，认为好的高校就必定有好的教育，这个想法是错误的。</p>\n<p>师者，我认为需因材施教，需适时施教，需以德为教。自卑心理的产生很大程度上来源自老师的批评和否定，当然这并不是说批评和否定是错误的，但老师不做任何的理解和认知，不去了解学生的努力和困惑，只以结果的好坏和成果的多少来说，这样包工头子似的培育方式就是将错误的完美主义强加于学生身上，久而久之，学生自然产生厌恶，自然害怕失误，自然讨厌学习，因为自己有困惑但无法解决，寻求老师换来的只是一顿批判。学生不是工人，不是下属，不是劳力，师生之间本不该存在雇佣关系和支配关系；犯错是被允许的、疑惑是被允许的、无知也应该是被允许的。如果从小学到高中，再到大学，这样的否定不绝于耳，那这个学生的教育背景就是极其糟糕的。</p>\n","site":{"data":{}},"cover":"/img/cover/elderring.png","cover_type":"img","excerpt":"","more":"<h2 id=\"完美主义的根源\"><a href=\"#完美主义的根源\" class=\"headerlink\" title=\"完美主义的根源\"></a>完美主义的根源</h2><p>缺乏安全感</p>\n<p>自卑情结（inferiority complex）</p>\n<blockquote>\n<p>自卑心理和缺乏安全感一样，会令你对自己的缺陷高度敏感。你会一直小心翼翼，认为这样就会避免犯错。这或许能够给你一些虚假的安全感，但是，要想获得真正地获得安全感，你需要了解并接受真正的自己。</p>\n<p>如果你能够接受自己，包括自己的缺点，即使遭遇最为严厉的批评，你也有力量捍卫自己。</p>\n</blockquote>\n<p>书中虽然详述了自卑情结的祸害，却没有更多地分析产生自卑情结的原因。</p>\n<p>导致自卑情结和缺乏安全感的原因有很多，依照我的看法，外界因素占比较多。不稳定的家庭环境，不充足的教育背景，不契合的生活族群，诸多种种都会导致个人的自卑。</p>\n<p>从家庭环境来说，最主要的原因并不是物质条件的匮乏或者充裕，而是父母价值观的熏陶，这部分的自卑来源于自我定位和认知上的<strong>焦虑</strong>。作为评价自我最重要的一环，价值观的塑造时时刻刻都在影响着个人的发展。从中国近代直至现今的家庭环境来说，往往总是物质条件充裕的家庭更愿意指导孩子去追求实现自我和精神发展上的条件，衡量成功与否在于是否做出了什么；相较之下贫苦的家庭则更可能面临着教育经历较差的父母，受限于物理条件的制约，他们更加追捧于财富和权力。如此这些自认为失败的人生经历和教训，以一种代代相传的方式侵染着其子孙，成功与否就看是否出名了，是否有钱了，是否能把其他人踩在脚下了。当然，也并非所有的家庭都是这样，物质条件充裕但仍旧贪婪追求垄断的氏族，物质条件匮乏却见识长远的中低产家庭，以上的情况就存在换位。</p>\n<p>但不论如何，有着较强自卑心理的孩子，其父母所灌输的价值观和自我衡量的方式必定是更加偏向于物质层面和外界条件的。诚然，这样的价值观更加符合资本发展积累和自然优胜劣汰的逻辑，可能会在一定程度上有着较高的竞争力，但在我看来，这样的追求并没有把人作为人来对待。父母是否想过，为什么想要一个孩子，为什么要抚养他长大，为什么期望着他成长之后的人生呢？</p>\n<p>从教育背景来说，核心在于所遇到的导师教育的态度和方式之上。首先要明确的是，教育背景不论好坏学校，只看主导老师的能力强弱。985、211、双一流但是老师却不知道如何教人，也不明白自己所处位置的重要性；职高甚至是周边的朋友，如师如父，指点迷津；换句话说，教育背景的高低在于老师，选择好的学校和学历更多地是增加遇到好老师的概率，当然社会用工环境和舆论将这个概念泛化，认为好的高校就必定有好的教育，这个想法是错误的。</p>\n<p>师者，我认为需因材施教，需适时施教，需以德为教。自卑心理的产生很大程度上来源自老师的批评和否定，当然这并不是说批评和否定是错误的，但老师不做任何的理解和认知，不去了解学生的努力和困惑，只以结果的好坏和成果的多少来说，这样包工头子似的培育方式就是将错误的完美主义强加于学生身上，久而久之，学生自然产生厌恶，自然害怕失误，自然讨厌学习，因为自己有困惑但无法解决，寻求老师换来的只是一顿批判。学生不是工人，不是下属，不是劳力，师生之间本不该存在雇佣关系和支配关系；犯错是被允许的、疑惑是被允许的、无知也应该是被允许的。如果从小学到高中，再到大学，这样的否定不绝于耳，那这个学生的教育背景就是极其糟糕的。</p>\n"},{"title":"读书笔记--深入理解Linux网络","catalog":true,"date":"2023-04-02T17:47:41.000Z","subtitle":null,"header-img":null,"published":0,"_content":"","source":"_posts/Book/读书笔记-深入理解Linux网络/读书笔记-深入理解Linux网络.md","raw":"---\ntitle: 读书笔记--深入理解Linux网络\ncatalog: true\ndate: 2023-04-03 01:47:41\nsubtitle:\nheader-img:\ntags:\ncategories:\npublished: false\n---\n","slug":"Book/读书笔记-深入理解Linux网络/读书笔记-深入理解Linux网络","updated":"2023-05-16T06:17:58.045Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli796r0e0009byjxhxko5c52","content":"","site":{"data":{}},"cover":"/img/cover/elderring.png","cover_type":"img","excerpt":"","more":""},{"title":"Searching List","catalog":true,"date":"2023-03-01T16:46:21.000Z","subtitle":null,"header-img":null,"published":0,"_content":"\n# Github \n\n[Git - git-remote Documentation (git-scm.com)](https://git-scm.com/docs/git-remote)\n\n### 添加github 远程仓库\n\n```shell\ngit remote add origin <REMOTE_URL>\n```\n\n[About remote repositories - GitHub Docs](https://docs.github.com/en/get-started/getting-started-with-git/about-remote-repositories)\n\n### 同步远程仓库内容：\n\n```shell\n//在本地新建一个temp分支，并将远程origin仓库的master分支代码下载到本地\ngit fetch origin master:temp\n//比较本地仓库与下载的temp分支\ngit diff temp\n//合并temp分支到本地的master分支对比区别之后，如果觉得没有问题，可以使用如下命令进行代码合并\ngit merge temp\n```\n\n### 强制覆盖远程仓库\n\n```shell\n// 查看本地仓库配置\ngit config --local --list\n \n// 如果有本地与远程关联，保留(多仓库关联)/不保留，看实际需要\n// 此处我选择不保留，即单仓库关联\ngit remote remove origin\n \n// 添加本地仓库与远程仓库关联\ngit remote add origin XXX.git\n \n// 强制推送到远程仓库，且覆盖远程代码库\ngit push -f --set-upstream origin master:master\n```\n\n> [如何将本地的项目一键同步到GitHub - 尹鹏宇的博客 | Yean's Blog (wdblink.github.io)](https://wdblink.github.io/2019/03/24/如何将本地的项目一键同步到GitHub/#:~:text=在github中新建一个repository，复制仓库地址： 同步本地仓库到远程仓库 执行命令： %2F%2F新建一个repository时会出现下面的代码，直接复制即可 %24,git remote add origin https%3A%2F%2Fgithub.com%2FCongliYin%2FCSS.git)\n>\n> [git 本地与远程仓库同步操作 - 简书 (jianshu.com)](https://www.jianshu.com/p/b37ff443de15)\n\n### 在一台电脑上创建两个github账号\n\n#### 1. 生成新的ssh-key\n\n保存的时候，输入一个新的文件名，如：id_rsa_second\n\n```\nssh-keygen -t rsa -C \"your_email@example.com\"    # Creates a new ssh key, using the provided email as a label    # Generating public/private rsa key pair.    # Enter file in which to save the key (/Users/you/.ssh/id_rsa_second): [Press enter] \n```\n\n#### 2. 添加到ssh-agent（每次重启之后都需要调用这句）\n\n```\n    $ssh-add ~/.ssh/id_rsa_second \n```\n\n#### 3. 添加ssh key到github\n\n见[配置ssh-key](https://help.github.com/articles/generating-ssh-keys)。\n\n#### 4. 配置多个ssh-key\n\n修改`~/.ssh/config`文件，如下：\n\n```\n    #default github    Host github.com      HostName github.com      IdentityFile ~/.ssh/id_rsa     Host github_second      HostName github.com      IdentityFile ~/.ssh/id_rsa_second \n```\n\n#### 5. 使用别名pull/push代码\n\n如：\n\n```\n    git clone git@github_second:username/reponame \n```\n\n#### 6. 为每个账号对应的项目配置email/name\n\n```\n    1.取消global    git config --global --unset user.name    git config --global --unset user.email     2.设置每个项目repo的自己的user.email    git config  user.email \"xxxx@xx.com\"    git config  user.name \"xxxx\" \n```\n\n这样，以后每次在相应的repo下提交更改，都会自动匹配相应的ssh-key了。\n\n### 查看本地 git 配置\n\nconfig 配置有system级别 global（用户级别） 和local（当前仓库）三个 设置先从system-》global-》local  底层配置会覆盖顶层配置 分别使用--system/global/local 可以定位到配置文件\n\n```shell\n# 查看系统config\ngit config --system --list\n# 查看当前用户（global）配置\ngit config --global  --list\n# 查看当前仓库配置信息\ngit config -- local    --list\n\n```\n\n### rebase\n\n[图解 Git 基本命令 merge 和 rebase - Michael翔 - 博客园 (cnblogs.com)](https://www.cnblogs.com/michael-xiang/p/13179837.html)\n\n[关于 Git 变基 - GitHub 文档](https://docs.github.com/zh/get-started/using-git/about-git-rebase)\n\n\n\n\n\n```shell\ngit branch -m main master\ngit fetch origin\ngit branch -u origin/master master\ngit remote set-head origin -a\n```\n\n## 缩短 ubuntu 文件目录的长度\n\n```shell\n\n```","source":"_posts/Common/dyx/April.md","raw":"---\ntitle: Searching List\ncatalog: true\ndate: 2023-03-02 00:46:21\nsubtitle:\nheader-img:\ntags: Searching List， April\ncategories: Common\npublished: false\n---\n\n# Github \n\n[Git - git-remote Documentation (git-scm.com)](https://git-scm.com/docs/git-remote)\n\n### 添加github 远程仓库\n\n```shell\ngit remote add origin <REMOTE_URL>\n```\n\n[About remote repositories - GitHub Docs](https://docs.github.com/en/get-started/getting-started-with-git/about-remote-repositories)\n\n### 同步远程仓库内容：\n\n```shell\n//在本地新建一个temp分支，并将远程origin仓库的master分支代码下载到本地\ngit fetch origin master:temp\n//比较本地仓库与下载的temp分支\ngit diff temp\n//合并temp分支到本地的master分支对比区别之后，如果觉得没有问题，可以使用如下命令进行代码合并\ngit merge temp\n```\n\n### 强制覆盖远程仓库\n\n```shell\n// 查看本地仓库配置\ngit config --local --list\n \n// 如果有本地与远程关联，保留(多仓库关联)/不保留，看实际需要\n// 此处我选择不保留，即单仓库关联\ngit remote remove origin\n \n// 添加本地仓库与远程仓库关联\ngit remote add origin XXX.git\n \n// 强制推送到远程仓库，且覆盖远程代码库\ngit push -f --set-upstream origin master:master\n```\n\n> [如何将本地的项目一键同步到GitHub - 尹鹏宇的博客 | Yean's Blog (wdblink.github.io)](https://wdblink.github.io/2019/03/24/如何将本地的项目一键同步到GitHub/#:~:text=在github中新建一个repository，复制仓库地址： 同步本地仓库到远程仓库 执行命令： %2F%2F新建一个repository时会出现下面的代码，直接复制即可 %24,git remote add origin https%3A%2F%2Fgithub.com%2FCongliYin%2FCSS.git)\n>\n> [git 本地与远程仓库同步操作 - 简书 (jianshu.com)](https://www.jianshu.com/p/b37ff443de15)\n\n### 在一台电脑上创建两个github账号\n\n#### 1. 生成新的ssh-key\n\n保存的时候，输入一个新的文件名，如：id_rsa_second\n\n```\nssh-keygen -t rsa -C \"your_email@example.com\"    # Creates a new ssh key, using the provided email as a label    # Generating public/private rsa key pair.    # Enter file in which to save the key (/Users/you/.ssh/id_rsa_second): [Press enter] \n```\n\n#### 2. 添加到ssh-agent（每次重启之后都需要调用这句）\n\n```\n    $ssh-add ~/.ssh/id_rsa_second \n```\n\n#### 3. 添加ssh key到github\n\n见[配置ssh-key](https://help.github.com/articles/generating-ssh-keys)。\n\n#### 4. 配置多个ssh-key\n\n修改`~/.ssh/config`文件，如下：\n\n```\n    #default github    Host github.com      HostName github.com      IdentityFile ~/.ssh/id_rsa     Host github_second      HostName github.com      IdentityFile ~/.ssh/id_rsa_second \n```\n\n#### 5. 使用别名pull/push代码\n\n如：\n\n```\n    git clone git@github_second:username/reponame \n```\n\n#### 6. 为每个账号对应的项目配置email/name\n\n```\n    1.取消global    git config --global --unset user.name    git config --global --unset user.email     2.设置每个项目repo的自己的user.email    git config  user.email \"xxxx@xx.com\"    git config  user.name \"xxxx\" \n```\n\n这样，以后每次在相应的repo下提交更改，都会自动匹配相应的ssh-key了。\n\n### 查看本地 git 配置\n\nconfig 配置有system级别 global（用户级别） 和local（当前仓库）三个 设置先从system-》global-》local  底层配置会覆盖顶层配置 分别使用--system/global/local 可以定位到配置文件\n\n```shell\n# 查看系统config\ngit config --system --list\n# 查看当前用户（global）配置\ngit config --global  --list\n# 查看当前仓库配置信息\ngit config -- local    --list\n\n```\n\n### rebase\n\n[图解 Git 基本命令 merge 和 rebase - Michael翔 - 博客园 (cnblogs.com)](https://www.cnblogs.com/michael-xiang/p/13179837.html)\n\n[关于 Git 变基 - GitHub 文档](https://docs.github.com/zh/get-started/using-git/about-git-rebase)\n\n\n\n\n\n```shell\ngit branch -m main master\ngit fetch origin\ngit branch -u origin/master master\ngit remote set-head origin -a\n```\n\n## 缩短 ubuntu 文件目录的长度\n\n```shell\n\n```","slug":"Common/dyx/April","updated":"2023-05-28T09:46:06.834Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli796r0f000bbyjxew5wgir7","content":"<h1 id=\"Github\"><a href=\"#Github\" class=\"headerlink\" title=\"Github\"></a>Github</h1><p><a href=\"https://git-scm.com/docs/git-remote\">Git - git-remote Documentation (git-scm.com)</a></p>\n<h3 id=\"添加github-远程仓库\"><a href=\"#添加github-远程仓库\" class=\"headerlink\" title=\"添加github 远程仓库\"></a>添加github 远程仓库</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add origin &lt;REMOTE_URL&gt;</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://docs.github.com/en/get-started/getting-started-with-git/about-remote-repositories\">About remote repositories - GitHub Docs</a></p>\n<h3 id=\"同步远程仓库内容：\"><a href=\"#同步远程仓库内容：\" class=\"headerlink\" title=\"同步远程仓库内容：\"></a>同步远程仓库内容：</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//在本地新建一个temp分支，并将远程origin仓库的master分支代码下载到本地</span><br><span class=\"line\">git fetch origin master:temp</span><br><span class=\"line\">//比较本地仓库与下载的temp分支</span><br><span class=\"line\">git diff temp</span><br><span class=\"line\">//合并temp分支到本地的master分支对比区别之后，如果觉得没有问题，可以使用如下命令进行代码合并</span><br><span class=\"line\">git merge temp</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"强制覆盖远程仓库\"><a href=\"#强制覆盖远程仓库\" class=\"headerlink\" title=\"强制覆盖远程仓库\"></a>强制覆盖远程仓库</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 查看本地仓库配置</span><br><span class=\"line\">git config --local --list</span><br><span class=\"line\"> </span><br><span class=\"line\">// 如果有本地与远程关联，保留(多仓库关联)/不保留，看实际需要</span><br><span class=\"line\">// 此处我选择不保留，即单仓库关联</span><br><span class=\"line\">git remote remove origin</span><br><span class=\"line\"> </span><br><span class=\"line\">// 添加本地仓库与远程仓库关联</span><br><span class=\"line\">git remote add origin XXX.git</span><br><span class=\"line\"> </span><br><span class=\"line\">// 强制推送到远程仓库，且覆盖远程代码库</span><br><span class=\"line\">git push -f --set-upstream origin master:master</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>[如何将本地的项目一键同步到GitHub - 尹鹏宇的博客 | Yean’s Blog (wdblink.github.io)](<a href=\"https://wdblink.github.io/2019/03/24/%E5%A6%82%E4%BD%95%E5%B0%86%E6%9C%AC%E5%9C%B0%E7%9A%84%E9%A1%B9%E7%9B%AE%E4%B8%80%E9%94%AE%E5%90%8C%E6%AD%A5%E5%88%B0GitHub/#:~:text=%E5%9C%A8github%E4%B8%AD%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AArepository%EF%BC%8C%E5%A4%8D%E5%88%B6%E4%BB%93%E5%BA%93%E5%9C%B0%E5%9D%80%EF%BC%9A\">https://wdblink.github.io/2019/03/24/如何将本地的项目一键同步到GitHub/#:~:text=在github中新建一个repository，复制仓库地址：</a> 同步本地仓库到远程仓库 执行命令： %2F%2F新建一个repository时会出现下面的代码，直接复制即可 %24,git remote add origin https%3A%2F%2Fgithub.com%2FCongliYin%2FCSS.git)</p>\n<p><a href=\"https://www.jianshu.com/p/b37ff443de15\">git 本地与远程仓库同步操作 - 简书 (jianshu.com)</a></p>\n</blockquote>\n<h3 id=\"在一台电脑上创建两个github账号\"><a href=\"#在一台电脑上创建两个github账号\" class=\"headerlink\" title=\"在一台电脑上创建两个github账号\"></a>在一台电脑上创建两个github账号</h3><h4 id=\"1-生成新的ssh-key\"><a href=\"#1-生成新的ssh-key\" class=\"headerlink\" title=\"1. 生成新的ssh-key\"></a>1. 生成新的ssh-key</h4><p>保存的时候，输入一个新的文件名，如：id_rsa_second</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa -C &quot;your_email@example.com&quot;    # Creates a new ssh key, using the provided email as a label    # Generating public/private rsa key pair.    # Enter file in which to save the key (/Users/you/.ssh/id_rsa_second): [Press enter] </span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-添加到ssh-agent（每次重启之后都需要调用这句）\"><a href=\"#2-添加到ssh-agent（每次重启之后都需要调用这句）\" class=\"headerlink\" title=\"2. 添加到ssh-agent（每次重启之后都需要调用这句）\"></a>2. 添加到ssh-agent（每次重启之后都需要调用这句）</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ssh-add ~/.ssh/id_rsa_second </span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-添加ssh-key到github\"><a href=\"#3-添加ssh-key到github\" class=\"headerlink\" title=\"3. 添加ssh key到github\"></a>3. 添加ssh key到github</h4><p>见<a href=\"https://help.github.com/articles/generating-ssh-keys\">配置ssh-key</a>。</p>\n<h4 id=\"4-配置多个ssh-key\"><a href=\"#4-配置多个ssh-key\" class=\"headerlink\" title=\"4. 配置多个ssh-key\"></a>4. 配置多个ssh-key</h4><p>修改<code>~/.ssh/config</code>文件，如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#default github    Host github.com      HostName github.com      IdentityFile ~/.ssh/id_rsa     Host github_second      HostName github.com      IdentityFile ~/.ssh/id_rsa_second </span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5-使用别名pull-push代码\"><a href=\"#5-使用别名pull-push代码\" class=\"headerlink\" title=\"5. 使用别名pull/push代码\"></a>5. 使用别名pull/push代码</h4><p>如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone git@github_second:username/reponame </span><br></pre></td></tr></table></figure>\n\n<h4 id=\"6-为每个账号对应的项目配置email-name\"><a href=\"#6-为每个账号对应的项目配置email-name\" class=\"headerlink\" title=\"6. 为每个账号对应的项目配置email/name\"></a>6. 为每个账号对应的项目配置email/name</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.取消global    git config --global --unset user.name    git config --global --unset user.email     2.设置每个项目repo的自己的user.email    git config  user.email &quot;xxxx@xx.com&quot;    git config  user.name &quot;xxxx&quot; </span><br></pre></td></tr></table></figure>\n\n<p>这样，以后每次在相应的repo下提交更改，都会自动匹配相应的ssh-key了。</p>\n<h3 id=\"查看本地-git-配置\"><a href=\"#查看本地-git-配置\" class=\"headerlink\" title=\"查看本地 git 配置\"></a>查看本地 git 配置</h3><p>config 配置有system级别 global（用户级别） 和local（当前仓库）三个 设置先从system-》global-》local  底层配置会覆盖顶层配置 分别使用–system/global/local 可以定位到配置文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">查看系统config</span></span><br><span class=\"line\">git config --system --list</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">查看当前用户（global）配置</span></span><br><span class=\"line\">git config --global  --list</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">查看当前仓库配置信息</span></span><br><span class=\"line\">git config -- local    --list</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"rebase\"><a href=\"#rebase\" class=\"headerlink\" title=\"rebase\"></a>rebase</h3><p><a href=\"https://www.cnblogs.com/michael-xiang/p/13179837.html\">图解 Git 基本命令 merge 和 rebase - Michael翔 - 博客园 (cnblogs.com)</a></p>\n<p><a href=\"https://docs.github.com/zh/get-started/using-git/about-git-rebase\">关于 Git 变基 - GitHub 文档</a></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch -m main master</span><br><span class=\"line\">git fetch origin</span><br><span class=\"line\">git branch -u origin/master master</span><br><span class=\"line\">git remote set-head origin -a</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"缩短-ubuntu-文件目录的长度\"><a href=\"#缩短-ubuntu-文件目录的长度\" class=\"headerlink\" title=\"缩短 ubuntu 文件目录的长度\"></a>缩短 ubuntu 文件目录的长度</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>","site":{"data":{}},"cover":"/img/cover/sky.png","cover_type":"img","excerpt":"","more":"<h1 id=\"Github\"><a href=\"#Github\" class=\"headerlink\" title=\"Github\"></a>Github</h1><p><a href=\"https://git-scm.com/docs/git-remote\">Git - git-remote Documentation (git-scm.com)</a></p>\n<h3 id=\"添加github-远程仓库\"><a href=\"#添加github-远程仓库\" class=\"headerlink\" title=\"添加github 远程仓库\"></a>添加github 远程仓库</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add origin &lt;REMOTE_URL&gt;</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://docs.github.com/en/get-started/getting-started-with-git/about-remote-repositories\">About remote repositories - GitHub Docs</a></p>\n<h3 id=\"同步远程仓库内容：\"><a href=\"#同步远程仓库内容：\" class=\"headerlink\" title=\"同步远程仓库内容：\"></a>同步远程仓库内容：</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//在本地新建一个temp分支，并将远程origin仓库的master分支代码下载到本地</span><br><span class=\"line\">git fetch origin master:temp</span><br><span class=\"line\">//比较本地仓库与下载的temp分支</span><br><span class=\"line\">git diff temp</span><br><span class=\"line\">//合并temp分支到本地的master分支对比区别之后，如果觉得没有问题，可以使用如下命令进行代码合并</span><br><span class=\"line\">git merge temp</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"强制覆盖远程仓库\"><a href=\"#强制覆盖远程仓库\" class=\"headerlink\" title=\"强制覆盖远程仓库\"></a>强制覆盖远程仓库</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 查看本地仓库配置</span><br><span class=\"line\">git config --local --list</span><br><span class=\"line\"> </span><br><span class=\"line\">// 如果有本地与远程关联，保留(多仓库关联)/不保留，看实际需要</span><br><span class=\"line\">// 此处我选择不保留，即单仓库关联</span><br><span class=\"line\">git remote remove origin</span><br><span class=\"line\"> </span><br><span class=\"line\">// 添加本地仓库与远程仓库关联</span><br><span class=\"line\">git remote add origin XXX.git</span><br><span class=\"line\"> </span><br><span class=\"line\">// 强制推送到远程仓库，且覆盖远程代码库</span><br><span class=\"line\">git push -f --set-upstream origin master:master</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>[如何将本地的项目一键同步到GitHub - 尹鹏宇的博客 | Yean’s Blog (wdblink.github.io)](<a href=\"https://wdblink.github.io/2019/03/24/%E5%A6%82%E4%BD%95%E5%B0%86%E6%9C%AC%E5%9C%B0%E7%9A%84%E9%A1%B9%E7%9B%AE%E4%B8%80%E9%94%AE%E5%90%8C%E6%AD%A5%E5%88%B0GitHub/#:~:text=%E5%9C%A8github%E4%B8%AD%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AArepository%EF%BC%8C%E5%A4%8D%E5%88%B6%E4%BB%93%E5%BA%93%E5%9C%B0%E5%9D%80%EF%BC%9A\">https://wdblink.github.io/2019/03/24/如何将本地的项目一键同步到GitHub/#:~:text=在github中新建一个repository，复制仓库地址：</a> 同步本地仓库到远程仓库 执行命令： %2F%2F新建一个repository时会出现下面的代码，直接复制即可 %24,git remote add origin https%3A%2F%2Fgithub.com%2FCongliYin%2FCSS.git)</p>\n<p><a href=\"https://www.jianshu.com/p/b37ff443de15\">git 本地与远程仓库同步操作 - 简书 (jianshu.com)</a></p>\n</blockquote>\n<h3 id=\"在一台电脑上创建两个github账号\"><a href=\"#在一台电脑上创建两个github账号\" class=\"headerlink\" title=\"在一台电脑上创建两个github账号\"></a>在一台电脑上创建两个github账号</h3><h4 id=\"1-生成新的ssh-key\"><a href=\"#1-生成新的ssh-key\" class=\"headerlink\" title=\"1. 生成新的ssh-key\"></a>1. 生成新的ssh-key</h4><p>保存的时候，输入一个新的文件名，如：id_rsa_second</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa -C &quot;your_email@example.com&quot;    # Creates a new ssh key, using the provided email as a label    # Generating public/private rsa key pair.    # Enter file in which to save the key (/Users/you/.ssh/id_rsa_second): [Press enter] </span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-添加到ssh-agent（每次重启之后都需要调用这句）\"><a href=\"#2-添加到ssh-agent（每次重启之后都需要调用这句）\" class=\"headerlink\" title=\"2. 添加到ssh-agent（每次重启之后都需要调用这句）\"></a>2. 添加到ssh-agent（每次重启之后都需要调用这句）</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ssh-add ~/.ssh/id_rsa_second </span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-添加ssh-key到github\"><a href=\"#3-添加ssh-key到github\" class=\"headerlink\" title=\"3. 添加ssh key到github\"></a>3. 添加ssh key到github</h4><p>见<a href=\"https://help.github.com/articles/generating-ssh-keys\">配置ssh-key</a>。</p>\n<h4 id=\"4-配置多个ssh-key\"><a href=\"#4-配置多个ssh-key\" class=\"headerlink\" title=\"4. 配置多个ssh-key\"></a>4. 配置多个ssh-key</h4><p>修改<code>~/.ssh/config</code>文件，如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#default github    Host github.com      HostName github.com      IdentityFile ~/.ssh/id_rsa     Host github_second      HostName github.com      IdentityFile ~/.ssh/id_rsa_second </span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5-使用别名pull-push代码\"><a href=\"#5-使用别名pull-push代码\" class=\"headerlink\" title=\"5. 使用别名pull/push代码\"></a>5. 使用别名pull/push代码</h4><p>如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone git@github_second:username/reponame </span><br></pre></td></tr></table></figure>\n\n<h4 id=\"6-为每个账号对应的项目配置email-name\"><a href=\"#6-为每个账号对应的项目配置email-name\" class=\"headerlink\" title=\"6. 为每个账号对应的项目配置email/name\"></a>6. 为每个账号对应的项目配置email/name</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.取消global    git config --global --unset user.name    git config --global --unset user.email     2.设置每个项目repo的自己的user.email    git config  user.email &quot;xxxx@xx.com&quot;    git config  user.name &quot;xxxx&quot; </span><br></pre></td></tr></table></figure>\n\n<p>这样，以后每次在相应的repo下提交更改，都会自动匹配相应的ssh-key了。</p>\n<h3 id=\"查看本地-git-配置\"><a href=\"#查看本地-git-配置\" class=\"headerlink\" title=\"查看本地 git 配置\"></a>查看本地 git 配置</h3><p>config 配置有system级别 global（用户级别） 和local（当前仓库）三个 设置先从system-》global-》local  底层配置会覆盖顶层配置 分别使用–system/global/local 可以定位到配置文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">查看系统config</span></span><br><span class=\"line\">git config --system --list</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">查看当前用户（global）配置</span></span><br><span class=\"line\">git config --global  --list</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">查看当前仓库配置信息</span></span><br><span class=\"line\">git config -- local    --list</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"rebase\"><a href=\"#rebase\" class=\"headerlink\" title=\"rebase\"></a>rebase</h3><p><a href=\"https://www.cnblogs.com/michael-xiang/p/13179837.html\">图解 Git 基本命令 merge 和 rebase - Michael翔 - 博客园 (cnblogs.com)</a></p>\n<p><a href=\"https://docs.github.com/zh/get-started/using-git/about-git-rebase\">关于 Git 变基 - GitHub 文档</a></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch -m main master</span><br><span class=\"line\">git fetch origin</span><br><span class=\"line\">git branch -u origin/master master</span><br><span class=\"line\">git remote set-head origin -a</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"缩短-ubuntu-文件目录的长度\"><a href=\"#缩短-ubuntu-文件目录的长度\" class=\"headerlink\" title=\"缩短 ubuntu 文件目录的长度\"></a>缩短 ubuntu 文件目录的长度</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"zjx-test","date":"2023-04-22T16:28:20.000Z","published":0,"_content":"\n","source":"_posts/Common/zjx/test.md","raw":"---\ntitle: zjx-test\ndate: 2023-04-23 00:28:20\ntags:\npublished: false\n---\n\n","slug":"Common/zjx/test","updated":"2023-04-24T07:06:29.504Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli796r0h000gbyjxaq33fxnc","content":"","site":{"data":{}},"cover":"/img/cover/sky4.png","cover_type":"img","excerpt":"","more":""},{"title":"2023 ospp fighting","catalog":true,"date":"2023-04-18T21:02:23.000Z","subtitle":null,"header-img":null,"_content":"\n\n\n> 本文档用于整理申请 2023 ospp edgeMesh CNI 项目的准备和奋战过程\n\n# 时间线记录\n\n##  1. 项目申请准备阶段\n\n> 努力争取，希望能被选上\n\n### 1.1  调研并整理 CNI 相关内容\n\n> 4/19 - 4/25\n\n\n\n### 1.2 实现一个简单的 CNI\n\n> 4.25 \n","source":"_posts/EdgeMesh/2023-ospp-fighting/2023-ospp-fighting.md","raw":"---\ntitle: 2023 ospp fighting\ncatalog: true\ndate: 2023-04-19 05:02:23\nsubtitle:\nheader-img:\ntags: ospp, edgemesh\ncategories: ospp\n---\n\n\n\n> 本文档用于整理申请 2023 ospp edgeMesh CNI 项目的准备和奋战过程\n\n# 时间线记录\n\n##  1. 项目申请准备阶段\n\n> 努力争取，希望能被选上\n\n### 1.1  调研并整理 CNI 相关内容\n\n> 4/19 - 4/25\n\n\n\n### 1.2 实现一个简单的 CNI\n\n> 4.25 \n","slug":"EdgeMesh/2023-ospp-fighting/2023-ospp-fighting","published":1,"updated":"2023-04-25T02:06:57.348Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli796r0i000hbyjxb4fz1jy3","content":"<blockquote>\n<p>本文档用于整理申请 2023 ospp edgeMesh CNI 项目的准备和奋战过程</p>\n</blockquote>\n<h1 id=\"时间线记录\"><a href=\"#时间线记录\" class=\"headerlink\" title=\"时间线记录\"></a>时间线记录</h1><h2 id=\"1-项目申请准备阶段\"><a href=\"#1-项目申请准备阶段\" class=\"headerlink\" title=\"1. 项目申请准备阶段\"></a>1. 项目申请准备阶段</h2><blockquote>\n<p>努力争取，希望能被选上</p>\n</blockquote>\n<h3 id=\"1-1-调研并整理-CNI-相关内容\"><a href=\"#1-1-调研并整理-CNI-相关内容\" class=\"headerlink\" title=\"1.1  调研并整理 CNI 相关内容\"></a>1.1  调研并整理 CNI 相关内容</h3><blockquote>\n<p>4/19 - 4/25</p>\n</blockquote>\n<h3 id=\"1-2-实现一个简单的-CNI\"><a href=\"#1-2-实现一个简单的-CNI\" class=\"headerlink\" title=\"1.2 实现一个简单的 CNI\"></a>1.2 实现一个简单的 CNI</h3><blockquote>\n<p>4.25 </p>\n</blockquote>\n","site":{"data":{}},"cover":"/img/cover/sky.png","cover_type":"img","excerpt":"","more":"<blockquote>\n<p>本文档用于整理申请 2023 ospp edgeMesh CNI 项目的准备和奋战过程</p>\n</blockquote>\n<h1 id=\"时间线记录\"><a href=\"#时间线记录\" class=\"headerlink\" title=\"时间线记录\"></a>时间线记录</h1><h2 id=\"1-项目申请准备阶段\"><a href=\"#1-项目申请准备阶段\" class=\"headerlink\" title=\"1. 项目申请准备阶段\"></a>1. 项目申请准备阶段</h2><blockquote>\n<p>努力争取，希望能被选上</p>\n</blockquote>\n<h3 id=\"1-1-调研并整理-CNI-相关内容\"><a href=\"#1-1-调研并整理-CNI-相关内容\" class=\"headerlink\" title=\"1.1  调研并整理 CNI 相关内容\"></a>1.1  调研并整理 CNI 相关内容</h3><blockquote>\n<p>4/19 - 4/25</p>\n</blockquote>\n<h3 id=\"1-2-实现一个简单的-CNI\"><a href=\"#1-2-实现一个简单的-CNI\" class=\"headerlink\" title=\"1.2 实现一个简单的 CNI\"></a>1.2 实现一个简单的 CNI</h3><blockquote>\n<p>4.25 </p>\n</blockquote>\n"},{"layout":"source/_posts/edgemesh/2023-ospp-fighting/","title":"Kubernetes 容器网络 — CNI","catalog":true,"date":"2023-04-18T21:02:23.000Z","_content":"\n# CNI 概述\n\n## 什么是 CNI \n\n> CNI的全称是 Container Network Interface，它为**容器提供了一种基于插件结构的标准化网络解决方案**。以往，容器的网络层是和具体的底层网络环境高度相关的，不同的网络服务提供商有不同的实现。**CNI从网络服务里抽象出了一套标准接口**，从而屏蔽了上层网络和底层网络提供商的网络实现之间的差异。并且，通过插件结构，它让容器在网络层的具体实现变得可插拔了，所以非常灵活。\n\n首先 CNI 是一套标准接口，它隶属于[CNCF(Cloud Native Computing Foundation)](https://cncf.io/)，依照这个标准所实现的为 CNI Plugins, 他们彼此独立，也可以组合起来一起使用，由一组用于配置 Linux 容器的网络接口的规范和库组成，同时还包含了一些插件，CNI 仅关心容器创建时的网络分配，和当容器被删除时释放网络资源。\n\n其次 依据 CNI 的[规范](https://github.com/containernetworking/cni/blob/master/SPEC.md)，CNI 具有以下几点特征：\n\n- CNI 需提供网络管理员**定义网络配置的文件格式**\n- CNI 需提供 Container Runtime（CRI） 调用功能的**协议/API**。\n- 当 CNI 被 CRI 调用时，需依据配置文件执行网络配置功能\n- CNI 需预留可调用其他插件的能力\n- CNI 需规范统一返回给CRI 的数据格式\n\n依据这样的特征和要求，可以明确实现一个CNI插件需要包含以下部分：\n\n* 可执行文件\n  * CNI 主进程\n  * IPAM 等\n* 网络配置文件\n\n---\n\n## CNI 的功能\n\nCNI 插件首先得实现一个可以被容器管理系统（CRI），比如rkt、Kubernetes 所调用的可执行文件——cni plugins，这个插件首先需要提供**基础的 Linux 网络联通服务**，比如创建 veth 或者 bridge 并将 veth 对的一端插入容器的 network namespace，一端插入 bridge，使得容器之间可以相互通信。然后**将IP 分配给接口**，并通过调用 **IPAM **插件来设置和管理IP地址，使得集群内的容器IP地址相互不重复，或者是结合其他的插件来实现更加复杂的网络路由管理功能等等。\n\n那么接下来，依据对于这几项功能的要求，来具体看看 CNI 的标准\n\n---\n\n\n\n## CNI 统一的网络配置文件\n\nCNI 为容器网络管理员(操作人员、网络插件、网络编排系统)定义了一种网络配置格式。它包含了供 CRI 和 CNI 插件使用的指令。在插件执行时，这种配置格式由 CRI 解释，并转化为代码数据结构，传递给 CNI 插件。\n\n一般来说配置文件主要是以 JSON 文件为主，且包含以下几个键值：\n\n- `cniVersion`: 指定CNI规范的版本，这样 CRI 和 CNI 才能读懂彼此\n- `Name`: 网络名字，这在一个主机（或其他管理域）的所有网络配置中应该是唯一的。必须以一个字母数字字符开始，后面可以选择由一个或多个字母数字字符、下划线、点（.）或连字符（-）的任何组合。\n- `disableCheck`: 是否禁用检查网络，如果为true,则 `container runtime` 不会调用 Check 方法进行网络检查。\n- `plugin`: cni插件及其配置列表，可以配置多个插件。\n\n接着展开说明一下 plugin 当中的参数，这也与实现 CNI 的功能息息相关，CRI 解析出配置文件当中的这个字段，是必须要一个字不漏地完整交给 CNI 插件来做网络管理\n\n1. 必须配置的键值\n\n   `type` :  指定目前系统目录当中所使用的 CNI 插件，一般是 cni 可执行文件的目录索引\n\n   至少得有一个基础的 cni 插件来完成最基础的 Linux 网络配置的功能\n\n2. 可选键值，由 CRI 依据协议发送的 request 指定\n\n   `capabilities`:  如果 CNI_ARGS 中没有指定此项功能时候来补充的\n\n3. 预留键值，由 CRI 在执行时产生的\n\n   - `runtimeConfig` :  比如 CNI 自己设置的 isGateway == true 就表明告诉插件，作为网关，给bridge指定一个IP地址。这样，连接到bridge的容器就可以拿它当网关来用了。\n   - `args`\n   - 或者是任何以 `cni.dev/`开头的\n\n4. 可选键值,由容器网络管理员添加\n\n   `ipMasq`: 为目标网络配上Outbound Masquerade(地址伪装)，即：由容器内部通过网关向外发送数据包时，对数据包的源IP地址进行修改。\n\n   当我们的容器以宿主机作为网关时，这个参数是必须要设置的。否则，从容器内部发出的数据包就没有办法通过网关路由到其他网段。因为容器内部的IP地址无法被目标网段识别，所以这些数据包最终会被丢弃掉。\n\n   `ipam`: PAM(IP Adderss Management)即IP地址管理，提供了一系列方法用于对IP和路由进行管理。实际上，它对应的是由CNI提供的一组标准IPAM插件，比如像host-local，dhcp，static等。如果要对整个集群的地址做管理，让pod具有单独的ip地址，就需要在这里添加额外的插件\n\n   > 例子1当中：\n   >\n   > - type：指定所用IPAM插件的名称，在例子里，用的是host-local。\n   > - subnet：为目标网络分配网段，包括网络ID和子网掩码，以CIDR形式标记。在例子里为`10.15.10.0/24`，也就是目标网段为`10.15.10.0`，子网掩码为`255.255.255.0`。\n   > - routes：用于指定路由规则，插件会在容器的路由表里生成相应的规则。其中，dst表示希望到达的目标网段，以CIDR形式标记。gw对应网关的IP地址，也就是要到达目标网段所要经过的“next hop(下一跳)”。如果省略gw的话，那么插件会自动帮容器选择默认网关。在例子里，gw选择的是默认网关，而dst为`0.0.0.0/0`则代表“任何网络”，表示数据包将通过默认网关发往任何网络。实际上，这对应的是一条默认路由规则，即：当所有其他路由规则都不匹配时，将选择该路由。\n   > - rangeStart：允许分配的IP地址范围的起始值\n   > - rangeEnd：允许分配的IP地址范围的结束值\n   > - gateway：为网关（也就是将要在宿主机上创建的bridge）指定的IP地址。如果省略的话，那么插件会自动从允许分配的IP地址范围内选择起始值作为网关的IP地址。\n\n配置文件例子如下：\n\n例子1：\n\n```json\n{\n    \"cniVersion\": \"0.4.0\",\n    \"name\": \"lab-br0\",\n    \"type\": \"bridge\",\n    \"bridge\": \"lab-br0\",\n    \"isGateway\": true,\n    \"ipMasq\": true,\n    \"ipam\": {\n        \"type\": \"host-local\",\n        \"subnet\": \"10.15.10.0/24\",\n        \"routes\": [\n            { \"dst\": \"0.0.0.0/0\" }\n        ],\n        \"rangeStart\": \"10.15.10.100\",\n        \"rangeEnd\": \"10.15.10.200\",\n        \"gateway\": \"10.15.10.99\"\n    }\n}\n```\n\n例子2：\n\n```json\n{\n  \"cniVersion\": \"1.0.0\",\n  \"name\": \"dbnet\",\n  \"plugins\": [\n    {\n      \"type\": \"bridge\",\n      // plugin specific parameters\n      \"bridge\": \"cni0\",\n      \"keyA\": [\"some more\", \"plugin specific\", \"configuration\"],\n      \n      \"ipam\": {\n        \"type\": \"host-local\",\n        // ipam specific\n        \"subnet\": \"10.1.0.0/16\",\n        \"gateway\": \"10.1.0.1\",\n        \"routes\": [\n            {\"dst\": \"0.0.0.0/0\"}\n        ]\n      },\n      \"dns\": {\n        \"nameservers\": [ \"10.1.0.1\" ]\n      }\n    },\n    {\n      \"type\": \"tuning\",\n      \"capabilities\": {\n        \"mac\": true\n      },\n      \"sysctl\": {\n        \"net.core.somaxconn\": \"500\"\n      }\n    },\n    {\n        \"type\": \"portmap\",\n        \"capabilities\": {\"portMappings\": true}\n    }\n  ]\n}\n```\n\n---\n\n\n\n## CNI 运行时协议\n\nCNI协议是基于由 CRI 的调用请求来告诉 CNI 该做些什么。\n\n主要的协议参数定义如下：\n\n* CNI_COMMAND：表示所需的操作；ADD、DEL、CHECK、或VERSION。\n* CNI_CONTAINERID：容器ID。告诉CNI插件，将要加入目标网络的容器所对应的network namespace的ID,容器的唯一的标识符，由 CRI 分配。不能是空的。必须以一个字母数字字符开始，后面可以选择一个或多个字母数字字符、下划线（）、点（.）或连字符（-）的任何组合。\n* CNI_NETNS：容器对应的network namespace在宿主机上的文件路径。（例如：/run/netns/[nsname]）。\n* CNI_IFNAME：作为veth pair在容器一端的网络接口,一般是在容器内创建的接口的名称；如果 CNI 插件无法使用这个接口名称，那么就必须返回一个错误。\n* CNI_ARGS：用户在调用时传入的额外参数。用分号分隔的字母数字键值对；例如，\"FOO=BAR;ABC=123\"\n* CNI_PATH: 表示 CNI 插件可执行文件的路径列表。路径由操作系统特定的列表分隔符分隔；例如Linux上的':'和Windows上的'；'。\n\n告诉CNI插件要执行的命令，允许的命令有ADD，DEL，CHECK，VERSION。\n\n对于支持CNI规范的容器系统而言，当容器启动的时候，系统就会自动调用相应的CNI插件，并设置CNI_COMMAND为ADD。相应地，DEL是在容器被销毁时调用的，用于清除在执行ADD阶段分配的网络资源。CHECK用于检查容器网络是否正常。VERSION则用来显示插件的版本。具体的操作如下：\n\n* ADD\n\n  - 将容器添加到网络中，或将新的配置修改应用到已有的集群当中。\n\n  - 一个CNI插件在收到ADD命令后，应该选择\n\n    - 在 CNI_NETNS 的容器内创建由 CNI_IFNAME 定义的接口，\n\n    - 调整容器内 CNI_NETNS 处由CNI_IFNAME定义的接口的配置\n\n      如果CNI插件成功，必须要返回一个处理结果，要么打印出来，要么修改传入的参数。\n\n* DELETE\n\n  * 将容器删除出网络，或将新的配置修改应用到已有的集群当中。\n\n    功能与ADD 相对\n\n* CHECK\n\n  * 查找类型字段中指定的可执行文件，如果没找到返回错误\n  * 当 Plugins （CNI调用的其他的Plugins）返回错误时，将其返回给调用者\n\n---\n\n\n\n## CNI 与插件\n\n为了解决容器网络的各项需求和问题，将所有的功能单独集中在 CNI 单个程序中是不现实的，而且难以兼容不同的上层系统和底层的网络管理，于是一个显然的想法就是将这些功能独立出来，使用插件（Plugins）的形式来执行。\n\n一个常见的例子就是 IP 地址管理，这就是IP地址管理插件（IPAM插件），它必须设置容器和虚拟网络设备的接口 ，IP / 子网，网关和路由，然后将此信息返回给“主”插件（CNI本体）来执行，换句话说 IPAM 做逻辑上的网络地址管理然后告诉本体 CNI 去执行 `ADD`,`DELETE`。 \n\nCNI 本体调用这些插件的形式也是通过路径找到这些插件的可执行文件来实现的，一般这些插件的位置也都一起放置在 `CNI_PATH`之下。同时插件和 CNI 本体都是通过 stdin 接收网络配置，也通过 stdout 输出结果。\n\n如此看来 CNI 的工作流程就是一条链状的调用过程，但调用链中的每一个可执行程序所接收的配置文件信息都是完整的。\n\n---\n\n# CNI 配置文件样例\n\n> 参考[cni/SPEC.md at spec-v1.0.0 · containernetworking/cni (github.com)](https://github.com/containernetworking/cni/blob/spec-v1.0.0/SPEC.md) 的 Appendix: Examples\n\n借助 Github 所给的 SPEC 例子，假设目前 CRI 接收到的 json 文件如下，\n\n```json\n{\n  \"cniVersion\": \"1.0.0\",\n  \"name\": \"dbnet\",\n  \"plugins\": [\n    {\n      \"type\": \"bridge\",\n      // plugin specific parameters\n      \"bridge\": \"cni0\",\n      \"keyA\": [\"some more\", \"plugin specific\", \"configuration\"],\n      \n      \"ipam\": {\n        \"type\": \"host-local\",\n        // ipam specific\n        \"subnet\": \"10.1.0.0/16\",\n        \"gateway\": \"10.1.0.1\",\n        \"routes\": [\n            {\"dst\": \"0.0.0.0/0\"}\n        ]\n      },\n      \"dns\": {\n        \"nameservers\": [ \"10.1.0.1\" ]\n      }\n    },\n    {\n      \"type\": \"tuning\",\n      \"capabilities\": {\n        \"mac\": true\n      },\n      \"sysctl\": {\n        \"net.core.somaxconn\": \"500\"\n      }\n    },\n    {\n        \"type\": \"portmap\",\n        \"capabilities\": {\"portMappings\": true}\n    }\n  ]\n}\n```\n\n### Add example\n\nThe container runtime would perform the following steps for the `add` operation.\n\n1. Call the `bridge` plugin with the following JSON, `CNI_COMMAND=ADD`:\n\n```\n{\n    \"cniVersion\": \"1.0.0\",\n    \"name\": \"dbnet\",\n    \"type\": \"bridge\",\n    \"bridge\": \"cni0\",\n    \"keyA\": [\"some more\", \"plugin specific\", \"configuration\"],\n    \"ipam\": {\n        \"type\": \"host-local\",\n        \"subnet\": \"10.1.0.0/16\",\n        \"gateway\": \"10.1.0.1\"\n    },\n    \"dns\": {\n        \"nameservers\": [ \"10.1.0.1\" ]\n    }\n}\n```\n\nThe bridge plugin, as it delegates IPAM to the `host-local` plugin, would execute the `host-local` binary with the exact same input, `CNI_COMMAND=ADD`.\n\nThe `host-local` plugin returns the following result:\n\n```\n{\n    \"ips\": [\n        {\n          \"address\": \"10.1.0.5/16\",\n          \"gateway\": \"10.1.0.1\"\n        }\n    ],\n    \"routes\": [\n      {\n        \"dst\": \"0.0.0.0/0\"\n      }\n    ],\n    \"dns\": {\n      \"nameservers\": [ \"10.1.0.1\" ]\n    }\n}\n```\n\nThe bridge plugin returns the following result, configuring the interface according to the delegated IPAM configuration:\n\n```\n{\n    \"ips\": [\n        {\n          \"address\": \"10.1.0.5/16\",\n          \"gateway\": \"10.1.0.1\",\n          \"interface\": 2\n        }\n    ],\n    \"routes\": [\n      {\n        \"dst\": \"0.0.0.0/0\"\n      }\n    ],\n    \"interfaces\": [\n        {\n            \"name\": \"cni0\",\n            \"mac\": \"00:11:22:33:44:55\"\n        },\n        {\n            \"name\": \"veth3243\",\n            \"mac\": \"55:44:33:22:11:11\"\n        },\n        {\n            \"name\": \"eth0\",\n            \"mac\": \"99:88:77:66:55:44\",\n            \"sandbox\": \"/var/run/netns/blue\"\n        }\n    ],\n    \"dns\": {\n      \"nameservers\": [ \"10.1.0.1\" ]\n    }\n}\n```\n\n1. Next, call the `tuning` plugin, with `CNI_COMMAND=ADD`. Note that `prevResult` is supplied, along with the `mac` capability argument. The request configuration passed is:\n\n```\n{\n  \"cniVersion\": \"1.0.0\",\n  \"name\": \"dbnet\",\n  \"type\": \"tuning\",\n  \"sysctl\": {\n    \"net.core.somaxconn\": \"500\"\n  },\n  \"runtimeConfig\": {\n    \"mac\": \"00:11:22:33:44:66\"\n  },\n  \"prevResult\": {\n    \"ips\": [\n        {\n          \"address\": \"10.1.0.5/16\",\n          \"gateway\": \"10.1.0.1\",\n          \"interface\": 2\n        }\n    ],\n    \"routes\": [\n      {\n        \"dst\": \"0.0.0.0/0\"\n      }\n    ],\n    \"interfaces\": [\n        {\n            \"name\": \"cni0\",\n            \"mac\": \"00:11:22:33:44:55\"\n        },\n        {\n            \"name\": \"veth3243\",\n            \"mac\": \"55:44:33:22:11:11\"\n        },\n        {\n            \"name\": \"eth0\",\n            \"mac\": \"99:88:77:66:55:44\",\n            \"sandbox\": \"/var/run/netns/blue\"\n        }\n    ],\n    \"dns\": {\n      \"nameservers\": [ \"10.1.0.1\" ]\n    }\n  }\n}\n```\n\nThe plugin returns the following result. Note that the **mac** has changed.\n\n```\n{\n    \"ips\": [\n        {\n          \"address\": \"10.1.0.5/16\",\n          \"gateway\": \"10.1.0.1\",\n          \"interface\": 2\n        }\n    ],\n    \"routes\": [\n      {\n        \"dst\": \"0.0.0.0/0\"\n      }\n    ],\n    \"interfaces\": [\n        {\n            \"name\": \"cni0\",\n            \"mac\": \"00:11:22:33:44:55\"\n        },\n        {\n            \"name\": \"veth3243\",\n            \"mac\": \"55:44:33:22:11:11\"\n        },\n        {\n            \"name\": \"eth0\",\n            \"mac\": \"00:11:22:33:44:66\",\n            \"sandbox\": \"/var/run/netns/blue\"\n        }\n    ],\n    \"dns\": {\n      \"nameservers\": [ \"10.1.0.1\" ]\n    }\n}\n```\n\n1. Finally, call the `portmap` plugin, with `CNI_COMMAND=ADD`. Note that `prevResult` matches that returned by `tuning`:\n\n```\n{\n  \"cniVersion\": \"1.0.0\",\n  \"name\": \"dbnet\",\n  \"type\": \"portmap\",\n  \"runtimeConfig\": {\n    \"portMappings\" : [\n      { \"hostPort\": 8080, \"containerPort\": 80, \"protocol\": \"tcp\" }\n    ]\n  },\n  \"prevResult\": {\n    \"ips\": [\n        {\n          \"address\": \"10.1.0.5/16\",\n          \"gateway\": \"10.1.0.1\",\n          \"interface\": 2\n        }\n    ],\n    \"routes\": [\n      {\n        \"dst\": \"0.0.0.0/0\"\n      }\n    ],\n    \"interfaces\": [\n        {\n            \"name\": \"cni0\",\n            \"mac\": \"00:11:22:33:44:55\"\n        },\n        {\n            \"name\": \"veth3243\",\n            \"mac\": \"55:44:33:22:11:11\"\n        },\n        {\n            \"name\": \"eth0\",\n            \"mac\": \"00:11:22:33:44:66\",\n            \"sandbox\": \"/var/run/netns/blue\"\n        }\n    ],\n    \"dns\": {\n      \"nameservers\": [ \"10.1.0.1\" ]\n    }\n  }\n}\n```\n\nThe `portmap` plugin outputs the exact same result as that returned by `bridge`, as the plugin has not modified anything that would change the result (i.e. it only created iptables rules).\n\n### Check example\n\nGiven the previous *Add*, the container runtime would perform the following steps for the *Check* action:\n\n1. First call the `bridge` plugin with the following request configuration, including the `prevResult` field containing the final JSON response from the *Add* operation, **including the changed mac**. `CNI_COMMAND=CHECK`\n\n```\n{\n  \"cniVersion\": \"1.0.0\",\n  \"name\": \"dbnet\",\n  \"type\": \"bridge\",\n  \"bridge\": \"cni0\",\n  \"keyA\": [\"some more\", \"plugin specific\", \"configuration\"],\n  \"ipam\": {\n    \"type\": \"host-local\",\n    \"subnet\": \"10.1.0.0/16\",\n    \"gateway\": \"10.1.0.1\"\n  },\n  \"dns\": {\n    \"nameservers\": [ \"10.1.0.1\" ]\n  },\n  \"prevResult\": {\n    \"ips\": [\n        {\n          \"address\": \"10.1.0.5/16\",\n          \"gateway\": \"10.1.0.1\",\n          \"interface\": 2\n        }\n    ],\n    \"routes\": [\n      {\n        \"dst\": \"0.0.0.0/0\"\n      }\n    ],\n    \"interfaces\": [\n        {\n            \"name\": \"cni0\",\n            \"mac\": \"00:11:22:33:44:55\"\n        },\n        {\n            \"name\": \"veth3243\",\n            \"mac\": \"55:44:33:22:11:11\"\n        },\n        {\n            \"name\": \"eth0\",\n            \"mac\": \"00:11:22:33:44:66\",\n            \"sandbox\": \"/var/run/netns/blue\"\n        }\n    ],\n    \"dns\": {\n      \"nameservers\": [ \"10.1.0.1\" ]\n    }\n  }\n}\n```\n\nThe `bridge` plugin, as it delegates IPAM, calls `host-local`, `CNI_COMMAND=CHECK`. It returns no error.\n\nAssuming the `bridge` plugin is satisfied, it produces no output on standard out and exits with a 0 return code.\n\n1. Next call the `tuning` plugin with the following request configuration:\n\n```\n{\n  \"cniVersion\": \"1.0.0\",\n  \"name\": \"dbnet\",\n  \"type\": \"tuning\",\n  \"sysctl\": {\n    \"net.core.somaxconn\": \"500\"\n  },\n  \"runtimeConfig\": {\n    \"mac\": \"00:11:22:33:44:66\"\n  },\n  \"prevResult\": {\n    \"ips\": [\n        {\n          \"address\": \"10.1.0.5/16\",\n          \"gateway\": \"10.1.0.1\",\n          \"interface\": 2\n        }\n    ],\n    \"routes\": [\n      {\n        \"dst\": \"0.0.0.0/0\"\n      }\n    ],\n    \"interfaces\": [\n        {\n            \"name\": \"cni0\",\n            \"mac\": \"00:11:22:33:44:55\"\n        },\n        {\n            \"name\": \"veth3243\",\n            \"mac\": \"55:44:33:22:11:11\"\n        },\n        {\n            \"name\": \"eth0\",\n            \"mac\": \"00:11:22:33:44:66\",\n            \"sandbox\": \"/var/run/netns/blue\"\n        }\n    ],\n    \"dns\": {\n      \"nameservers\": [ \"10.1.0.1\" ]\n    }\n  }\n}\n```\n\nLikewise, the `tuning` plugin exits indicating success.\n\n1. Finally, call `portmap` with the following request configuration:\n\n```\n{\n  \"cniVersion\": \"1.0.0\",\n  \"name\": \"dbnet\",\n  \"type\": \"portmap\",\n  \"runtimeConfig\": {\n    \"portMappings\" : [\n      { \"hostPort\": 8080, \"containerPort\": 80, \"protocol\": \"tcp\" }\n    ]\n  },\n  \"prevResult\": {\n    \"ips\": [\n        {\n          \"address\": \"10.1.0.5/16\",\n          \"gateway\": \"10.1.0.1\",\n          \"interface\": 2\n        }\n    ],\n    \"routes\": [\n      {\n        \"dst\": \"0.0.0.0/0\"\n      }\n    ],\n    \"interfaces\": [\n        {\n            \"name\": \"cni0\",\n            \"mac\": \"00:11:22:33:44:55\"\n        },\n        {\n            \"name\": \"veth3243\",\n            \"mac\": \"55:44:33:22:11:11\"\n        },\n        {\n            \"name\": \"eth0\",\n            \"mac\": \"00:11:22:33:44:66\",\n            \"sandbox\": \"/var/run/netns/blue\"\n        }\n    ],\n    \"dns\": {\n      \"nameservers\": [ \"10.1.0.1\" ]\n    }\n  }\n}\n```\n\n### Delete example\n\nGiven the same network configuration JSON list, the container runtime would perform the following steps for the *Delete* action. Note that plugins are executed in reverse order from the *Add* and *Check* actions.\n\n1. First, call `portmap` with the following request configuration, `CNI_COMMAND=DEL`:\n\n```\n{\n  \"cniVersion\": \"1.0.0\",\n  \"name\": \"dbnet\",\n  \"type\": \"portmap\",\n  \"runtimeConfig\": {\n    \"portMappings\" : [\n      { \"hostPort\": 8080, \"containerPort\": 80, \"protocol\": \"tcp\" }\n    ]\n  },\n  \"prevResult\": {\n    \"ips\": [\n        {\n          \"address\": \"10.1.0.5/16\",\n          \"gateway\": \"10.1.0.1\",\n          \"interface\": 2\n        }\n    ],\n    \"routes\": [\n      {\n        \"dst\": \"0.0.0.0/0\"\n      }\n    ],\n    \"interfaces\": [\n        {\n            \"name\": \"cni0\",\n            \"mac\": \"00:11:22:33:44:55\"\n        },\n        {\n            \"name\": \"veth3243\",\n            \"mac\": \"55:44:33:22:11:11\"\n        },\n        {\n            \"name\": \"eth0\",\n            \"mac\": \"00:11:22:33:44:66\",\n            \"sandbox\": \"/var/run/netns/blue\"\n        }\n    ],\n    \"dns\": {\n      \"nameservers\": [ \"10.1.0.1\" ]\n    }\n  }\n}\n```\n\n1. Next, call the `tuning` plugin with the following request configuration, `CNI_COMMAND=DEL`:\n\n```\n{\n  \"cniVersion\": \"1.0.0\",\n  \"name\": \"dbnet\",\n  \"type\": \"tuning\",\n  \"sysctl\": {\n    \"net.core.somaxconn\": \"500\"\n  },\n  \"runtimeConfig\": {\n    \"mac\": \"00:11:22:33:44:66\"\n  },\n  \"prevResult\": {\n    \"ips\": [\n        {\n          \"address\": \"10.1.0.5/16\",\n          \"gateway\": \"10.1.0.1\",\n          \"interface\": 2\n        }\n    ],\n    \"routes\": [\n      {\n        \"dst\": \"0.0.0.0/0\"\n      }\n    ],\n    \"interfaces\": [\n        {\n            \"name\": \"cni0\",\n            \"mac\": \"00:11:22:33:44:55\"\n        },\n        {\n            \"name\": \"veth3243\",\n            \"mac\": \"55:44:33:22:11:11\"\n        },\n        {\n            \"name\": \"eth0\",\n            \"mac\": \"00:11:22:33:44:66\",\n            \"sandbox\": \"/var/run/netns/blue\"\n        }\n    ],\n    \"dns\": {\n      \"nameservers\": [ \"10.1.0.1\" ]\n    }\n  }\n}\n```\n\n1. Finally, call `bridge`:\n\n```\n{\n  \"cniVersion\": \"1.0.0\",\n  \"name\": \"dbnet\",\n  \"type\": \"bridge\",\n  \"bridge\": \"cni0\",\n  \"keyA\": [\"some more\", \"plugin specific\", \"configuration\"],\n  \"ipam\": {\n    \"type\": \"host-local\",\n    \"subnet\": \"10.1.0.0/16\",\n    \"gateway\": \"10.1.0.1\"\n  },\n  \"dns\": {\n    \"nameservers\": [ \"10.1.0.1\" ]\n  },\n  \"prevResult\": {\n    \"ips\": [\n        {\n          \"address\": \"10.1.0.5/16\",\n          \"gateway\": \"10.1.0.1\",\n          \"interface\": 2\n        }\n    ],\n    \"routes\": [\n      {\n        \"dst\": \"0.0.0.0/0\"\n      }\n    ],\n    \"interfaces\": [\n        {\n            \"name\": \"cni0\",\n            \"mac\": \"00:11:22:33:44:55\"\n        },\n        {\n            \"name\": \"veth3243\",\n            \"mac\": \"55:44:33:22:11:11\"\n        },\n        {\n            \"name\": \"eth0\",\n            \"mac\": \"00:11:22:33:44:66\",\n            \"sandbox\": \"/var/run/netns/blue\"\n        }\n    ],\n    \"dns\": {\n      \"nameservers\": [ \"10.1.0.1\" ]\n    }\n  }\n}\n```\n\nThe bridge plugin executes the `host-local` delegated plugin with `CNI_COMMAND=DEL` before returning.\n\n---\n\n\n\n## 相关仓库及文献\n\n[cni/SPEC.md at spec-v1.0.0 · containernetworking/cni (github.com)](https://github.com/containernetworking/cni/blob/spec-v1.0.0/SPEC.md)\n\n[Kubernetes网络之CNI规范解读 | LRF (lengrongfu.github.io)](https://lengrongfu.github.io/2022-05-11-k8s之CNI规范解读/)\n\n[A brief overview of the Container Network Interface (CNI) in Kubernetes | Enable Sysadmin (redhat.com)](https://www.redhat.com/sysadmin/cni-kubernetes)\n\n[Bring your own Container Network Interface (CNI) plugin - Azure Kubernetes Service | Microsoft Learn](https://learn.microsoft.com/en-us/azure/aks/use-byo-cni?tabs=azure-cli)\n\n[Network Plugins | Kubernetes](https://kubernetes.io/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/)\n\n[Kubernetes CNI Explained (tigera.io)](https://www.tigera.io/learn/guides/kubernetes-networking/kubernetes-cni/)\n\n\n","source":"_posts/EdgeMesh/2023-ospp-fighting/CNI-Basic.md","raw":"---\nlayout: source/_posts/edgemesh/2023-ospp-fighting/\ntitle: Kubernetes 容器网络 — CNI \ncatalog: true\ndate: 2023-04-19 05:02:23\ntags: ospp, CNI, Linux, Spec\ncategories: CNI\n---\n\n# CNI 概述\n\n## 什么是 CNI \n\n> CNI的全称是 Container Network Interface，它为**容器提供了一种基于插件结构的标准化网络解决方案**。以往，容器的网络层是和具体的底层网络环境高度相关的，不同的网络服务提供商有不同的实现。**CNI从网络服务里抽象出了一套标准接口**，从而屏蔽了上层网络和底层网络提供商的网络实现之间的差异。并且，通过插件结构，它让容器在网络层的具体实现变得可插拔了，所以非常灵活。\n\n首先 CNI 是一套标准接口，它隶属于[CNCF(Cloud Native Computing Foundation)](https://cncf.io/)，依照这个标准所实现的为 CNI Plugins, 他们彼此独立，也可以组合起来一起使用，由一组用于配置 Linux 容器的网络接口的规范和库组成，同时还包含了一些插件，CNI 仅关心容器创建时的网络分配，和当容器被删除时释放网络资源。\n\n其次 依据 CNI 的[规范](https://github.com/containernetworking/cni/blob/master/SPEC.md)，CNI 具有以下几点特征：\n\n- CNI 需提供网络管理员**定义网络配置的文件格式**\n- CNI 需提供 Container Runtime（CRI） 调用功能的**协议/API**。\n- 当 CNI 被 CRI 调用时，需依据配置文件执行网络配置功能\n- CNI 需预留可调用其他插件的能力\n- CNI 需规范统一返回给CRI 的数据格式\n\n依据这样的特征和要求，可以明确实现一个CNI插件需要包含以下部分：\n\n* 可执行文件\n  * CNI 主进程\n  * IPAM 等\n* 网络配置文件\n\n---\n\n## CNI 的功能\n\nCNI 插件首先得实现一个可以被容器管理系统（CRI），比如rkt、Kubernetes 所调用的可执行文件——cni plugins，这个插件首先需要提供**基础的 Linux 网络联通服务**，比如创建 veth 或者 bridge 并将 veth 对的一端插入容器的 network namespace，一端插入 bridge，使得容器之间可以相互通信。然后**将IP 分配给接口**，并通过调用 **IPAM **插件来设置和管理IP地址，使得集群内的容器IP地址相互不重复，或者是结合其他的插件来实现更加复杂的网络路由管理功能等等。\n\n那么接下来，依据对于这几项功能的要求，来具体看看 CNI 的标准\n\n---\n\n\n\n## CNI 统一的网络配置文件\n\nCNI 为容器网络管理员(操作人员、网络插件、网络编排系统)定义了一种网络配置格式。它包含了供 CRI 和 CNI 插件使用的指令。在插件执行时，这种配置格式由 CRI 解释，并转化为代码数据结构，传递给 CNI 插件。\n\n一般来说配置文件主要是以 JSON 文件为主，且包含以下几个键值：\n\n- `cniVersion`: 指定CNI规范的版本，这样 CRI 和 CNI 才能读懂彼此\n- `Name`: 网络名字，这在一个主机（或其他管理域）的所有网络配置中应该是唯一的。必须以一个字母数字字符开始，后面可以选择由一个或多个字母数字字符、下划线、点（.）或连字符（-）的任何组合。\n- `disableCheck`: 是否禁用检查网络，如果为true,则 `container runtime` 不会调用 Check 方法进行网络检查。\n- `plugin`: cni插件及其配置列表，可以配置多个插件。\n\n接着展开说明一下 plugin 当中的参数，这也与实现 CNI 的功能息息相关，CRI 解析出配置文件当中的这个字段，是必须要一个字不漏地完整交给 CNI 插件来做网络管理\n\n1. 必须配置的键值\n\n   `type` :  指定目前系统目录当中所使用的 CNI 插件，一般是 cni 可执行文件的目录索引\n\n   至少得有一个基础的 cni 插件来完成最基础的 Linux 网络配置的功能\n\n2. 可选键值，由 CRI 依据协议发送的 request 指定\n\n   `capabilities`:  如果 CNI_ARGS 中没有指定此项功能时候来补充的\n\n3. 预留键值，由 CRI 在执行时产生的\n\n   - `runtimeConfig` :  比如 CNI 自己设置的 isGateway == true 就表明告诉插件，作为网关，给bridge指定一个IP地址。这样，连接到bridge的容器就可以拿它当网关来用了。\n   - `args`\n   - 或者是任何以 `cni.dev/`开头的\n\n4. 可选键值,由容器网络管理员添加\n\n   `ipMasq`: 为目标网络配上Outbound Masquerade(地址伪装)，即：由容器内部通过网关向外发送数据包时，对数据包的源IP地址进行修改。\n\n   当我们的容器以宿主机作为网关时，这个参数是必须要设置的。否则，从容器内部发出的数据包就没有办法通过网关路由到其他网段。因为容器内部的IP地址无法被目标网段识别，所以这些数据包最终会被丢弃掉。\n\n   `ipam`: PAM(IP Adderss Management)即IP地址管理，提供了一系列方法用于对IP和路由进行管理。实际上，它对应的是由CNI提供的一组标准IPAM插件，比如像host-local，dhcp，static等。如果要对整个集群的地址做管理，让pod具有单独的ip地址，就需要在这里添加额外的插件\n\n   > 例子1当中：\n   >\n   > - type：指定所用IPAM插件的名称，在例子里，用的是host-local。\n   > - subnet：为目标网络分配网段，包括网络ID和子网掩码，以CIDR形式标记。在例子里为`10.15.10.0/24`，也就是目标网段为`10.15.10.0`，子网掩码为`255.255.255.0`。\n   > - routes：用于指定路由规则，插件会在容器的路由表里生成相应的规则。其中，dst表示希望到达的目标网段，以CIDR形式标记。gw对应网关的IP地址，也就是要到达目标网段所要经过的“next hop(下一跳)”。如果省略gw的话，那么插件会自动帮容器选择默认网关。在例子里，gw选择的是默认网关，而dst为`0.0.0.0/0`则代表“任何网络”，表示数据包将通过默认网关发往任何网络。实际上，这对应的是一条默认路由规则，即：当所有其他路由规则都不匹配时，将选择该路由。\n   > - rangeStart：允许分配的IP地址范围的起始值\n   > - rangeEnd：允许分配的IP地址范围的结束值\n   > - gateway：为网关（也就是将要在宿主机上创建的bridge）指定的IP地址。如果省略的话，那么插件会自动从允许分配的IP地址范围内选择起始值作为网关的IP地址。\n\n配置文件例子如下：\n\n例子1：\n\n```json\n{\n    \"cniVersion\": \"0.4.0\",\n    \"name\": \"lab-br0\",\n    \"type\": \"bridge\",\n    \"bridge\": \"lab-br0\",\n    \"isGateway\": true,\n    \"ipMasq\": true,\n    \"ipam\": {\n        \"type\": \"host-local\",\n        \"subnet\": \"10.15.10.0/24\",\n        \"routes\": [\n            { \"dst\": \"0.0.0.0/0\" }\n        ],\n        \"rangeStart\": \"10.15.10.100\",\n        \"rangeEnd\": \"10.15.10.200\",\n        \"gateway\": \"10.15.10.99\"\n    }\n}\n```\n\n例子2：\n\n```json\n{\n  \"cniVersion\": \"1.0.0\",\n  \"name\": \"dbnet\",\n  \"plugins\": [\n    {\n      \"type\": \"bridge\",\n      // plugin specific parameters\n      \"bridge\": \"cni0\",\n      \"keyA\": [\"some more\", \"plugin specific\", \"configuration\"],\n      \n      \"ipam\": {\n        \"type\": \"host-local\",\n        // ipam specific\n        \"subnet\": \"10.1.0.0/16\",\n        \"gateway\": \"10.1.0.1\",\n        \"routes\": [\n            {\"dst\": \"0.0.0.0/0\"}\n        ]\n      },\n      \"dns\": {\n        \"nameservers\": [ \"10.1.0.1\" ]\n      }\n    },\n    {\n      \"type\": \"tuning\",\n      \"capabilities\": {\n        \"mac\": true\n      },\n      \"sysctl\": {\n        \"net.core.somaxconn\": \"500\"\n      }\n    },\n    {\n        \"type\": \"portmap\",\n        \"capabilities\": {\"portMappings\": true}\n    }\n  ]\n}\n```\n\n---\n\n\n\n## CNI 运行时协议\n\nCNI协议是基于由 CRI 的调用请求来告诉 CNI 该做些什么。\n\n主要的协议参数定义如下：\n\n* CNI_COMMAND：表示所需的操作；ADD、DEL、CHECK、或VERSION。\n* CNI_CONTAINERID：容器ID。告诉CNI插件，将要加入目标网络的容器所对应的network namespace的ID,容器的唯一的标识符，由 CRI 分配。不能是空的。必须以一个字母数字字符开始，后面可以选择一个或多个字母数字字符、下划线（）、点（.）或连字符（-）的任何组合。\n* CNI_NETNS：容器对应的network namespace在宿主机上的文件路径。（例如：/run/netns/[nsname]）。\n* CNI_IFNAME：作为veth pair在容器一端的网络接口,一般是在容器内创建的接口的名称；如果 CNI 插件无法使用这个接口名称，那么就必须返回一个错误。\n* CNI_ARGS：用户在调用时传入的额外参数。用分号分隔的字母数字键值对；例如，\"FOO=BAR;ABC=123\"\n* CNI_PATH: 表示 CNI 插件可执行文件的路径列表。路径由操作系统特定的列表分隔符分隔；例如Linux上的':'和Windows上的'；'。\n\n告诉CNI插件要执行的命令，允许的命令有ADD，DEL，CHECK，VERSION。\n\n对于支持CNI规范的容器系统而言，当容器启动的时候，系统就会自动调用相应的CNI插件，并设置CNI_COMMAND为ADD。相应地，DEL是在容器被销毁时调用的，用于清除在执行ADD阶段分配的网络资源。CHECK用于检查容器网络是否正常。VERSION则用来显示插件的版本。具体的操作如下：\n\n* ADD\n\n  - 将容器添加到网络中，或将新的配置修改应用到已有的集群当中。\n\n  - 一个CNI插件在收到ADD命令后，应该选择\n\n    - 在 CNI_NETNS 的容器内创建由 CNI_IFNAME 定义的接口，\n\n    - 调整容器内 CNI_NETNS 处由CNI_IFNAME定义的接口的配置\n\n      如果CNI插件成功，必须要返回一个处理结果，要么打印出来，要么修改传入的参数。\n\n* DELETE\n\n  * 将容器删除出网络，或将新的配置修改应用到已有的集群当中。\n\n    功能与ADD 相对\n\n* CHECK\n\n  * 查找类型字段中指定的可执行文件，如果没找到返回错误\n  * 当 Plugins （CNI调用的其他的Plugins）返回错误时，将其返回给调用者\n\n---\n\n\n\n## CNI 与插件\n\n为了解决容器网络的各项需求和问题，将所有的功能单独集中在 CNI 单个程序中是不现实的，而且难以兼容不同的上层系统和底层的网络管理，于是一个显然的想法就是将这些功能独立出来，使用插件（Plugins）的形式来执行。\n\n一个常见的例子就是 IP 地址管理，这就是IP地址管理插件（IPAM插件），它必须设置容器和虚拟网络设备的接口 ，IP / 子网，网关和路由，然后将此信息返回给“主”插件（CNI本体）来执行，换句话说 IPAM 做逻辑上的网络地址管理然后告诉本体 CNI 去执行 `ADD`,`DELETE`。 \n\nCNI 本体调用这些插件的形式也是通过路径找到这些插件的可执行文件来实现的，一般这些插件的位置也都一起放置在 `CNI_PATH`之下。同时插件和 CNI 本体都是通过 stdin 接收网络配置，也通过 stdout 输出结果。\n\n如此看来 CNI 的工作流程就是一条链状的调用过程，但调用链中的每一个可执行程序所接收的配置文件信息都是完整的。\n\n---\n\n# CNI 配置文件样例\n\n> 参考[cni/SPEC.md at spec-v1.0.0 · containernetworking/cni (github.com)](https://github.com/containernetworking/cni/blob/spec-v1.0.0/SPEC.md) 的 Appendix: Examples\n\n借助 Github 所给的 SPEC 例子，假设目前 CRI 接收到的 json 文件如下，\n\n```json\n{\n  \"cniVersion\": \"1.0.0\",\n  \"name\": \"dbnet\",\n  \"plugins\": [\n    {\n      \"type\": \"bridge\",\n      // plugin specific parameters\n      \"bridge\": \"cni0\",\n      \"keyA\": [\"some more\", \"plugin specific\", \"configuration\"],\n      \n      \"ipam\": {\n        \"type\": \"host-local\",\n        // ipam specific\n        \"subnet\": \"10.1.0.0/16\",\n        \"gateway\": \"10.1.0.1\",\n        \"routes\": [\n            {\"dst\": \"0.0.0.0/0\"}\n        ]\n      },\n      \"dns\": {\n        \"nameservers\": [ \"10.1.0.1\" ]\n      }\n    },\n    {\n      \"type\": \"tuning\",\n      \"capabilities\": {\n        \"mac\": true\n      },\n      \"sysctl\": {\n        \"net.core.somaxconn\": \"500\"\n      }\n    },\n    {\n        \"type\": \"portmap\",\n        \"capabilities\": {\"portMappings\": true}\n    }\n  ]\n}\n```\n\n### Add example\n\nThe container runtime would perform the following steps for the `add` operation.\n\n1. Call the `bridge` plugin with the following JSON, `CNI_COMMAND=ADD`:\n\n```\n{\n    \"cniVersion\": \"1.0.0\",\n    \"name\": \"dbnet\",\n    \"type\": \"bridge\",\n    \"bridge\": \"cni0\",\n    \"keyA\": [\"some more\", \"plugin specific\", \"configuration\"],\n    \"ipam\": {\n        \"type\": \"host-local\",\n        \"subnet\": \"10.1.0.0/16\",\n        \"gateway\": \"10.1.0.1\"\n    },\n    \"dns\": {\n        \"nameservers\": [ \"10.1.0.1\" ]\n    }\n}\n```\n\nThe bridge plugin, as it delegates IPAM to the `host-local` plugin, would execute the `host-local` binary with the exact same input, `CNI_COMMAND=ADD`.\n\nThe `host-local` plugin returns the following result:\n\n```\n{\n    \"ips\": [\n        {\n          \"address\": \"10.1.0.5/16\",\n          \"gateway\": \"10.1.0.1\"\n        }\n    ],\n    \"routes\": [\n      {\n        \"dst\": \"0.0.0.0/0\"\n      }\n    ],\n    \"dns\": {\n      \"nameservers\": [ \"10.1.0.1\" ]\n    }\n}\n```\n\nThe bridge plugin returns the following result, configuring the interface according to the delegated IPAM configuration:\n\n```\n{\n    \"ips\": [\n        {\n          \"address\": \"10.1.0.5/16\",\n          \"gateway\": \"10.1.0.1\",\n          \"interface\": 2\n        }\n    ],\n    \"routes\": [\n      {\n        \"dst\": \"0.0.0.0/0\"\n      }\n    ],\n    \"interfaces\": [\n        {\n            \"name\": \"cni0\",\n            \"mac\": \"00:11:22:33:44:55\"\n        },\n        {\n            \"name\": \"veth3243\",\n            \"mac\": \"55:44:33:22:11:11\"\n        },\n        {\n            \"name\": \"eth0\",\n            \"mac\": \"99:88:77:66:55:44\",\n            \"sandbox\": \"/var/run/netns/blue\"\n        }\n    ],\n    \"dns\": {\n      \"nameservers\": [ \"10.1.0.1\" ]\n    }\n}\n```\n\n1. Next, call the `tuning` plugin, with `CNI_COMMAND=ADD`. Note that `prevResult` is supplied, along with the `mac` capability argument. The request configuration passed is:\n\n```\n{\n  \"cniVersion\": \"1.0.0\",\n  \"name\": \"dbnet\",\n  \"type\": \"tuning\",\n  \"sysctl\": {\n    \"net.core.somaxconn\": \"500\"\n  },\n  \"runtimeConfig\": {\n    \"mac\": \"00:11:22:33:44:66\"\n  },\n  \"prevResult\": {\n    \"ips\": [\n        {\n          \"address\": \"10.1.0.5/16\",\n          \"gateway\": \"10.1.0.1\",\n          \"interface\": 2\n        }\n    ],\n    \"routes\": [\n      {\n        \"dst\": \"0.0.0.0/0\"\n      }\n    ],\n    \"interfaces\": [\n        {\n            \"name\": \"cni0\",\n            \"mac\": \"00:11:22:33:44:55\"\n        },\n        {\n            \"name\": \"veth3243\",\n            \"mac\": \"55:44:33:22:11:11\"\n        },\n        {\n            \"name\": \"eth0\",\n            \"mac\": \"99:88:77:66:55:44\",\n            \"sandbox\": \"/var/run/netns/blue\"\n        }\n    ],\n    \"dns\": {\n      \"nameservers\": [ \"10.1.0.1\" ]\n    }\n  }\n}\n```\n\nThe plugin returns the following result. Note that the **mac** has changed.\n\n```\n{\n    \"ips\": [\n        {\n          \"address\": \"10.1.0.5/16\",\n          \"gateway\": \"10.1.0.1\",\n          \"interface\": 2\n        }\n    ],\n    \"routes\": [\n      {\n        \"dst\": \"0.0.0.0/0\"\n      }\n    ],\n    \"interfaces\": [\n        {\n            \"name\": \"cni0\",\n            \"mac\": \"00:11:22:33:44:55\"\n        },\n        {\n            \"name\": \"veth3243\",\n            \"mac\": \"55:44:33:22:11:11\"\n        },\n        {\n            \"name\": \"eth0\",\n            \"mac\": \"00:11:22:33:44:66\",\n            \"sandbox\": \"/var/run/netns/blue\"\n        }\n    ],\n    \"dns\": {\n      \"nameservers\": [ \"10.1.0.1\" ]\n    }\n}\n```\n\n1. Finally, call the `portmap` plugin, with `CNI_COMMAND=ADD`. Note that `prevResult` matches that returned by `tuning`:\n\n```\n{\n  \"cniVersion\": \"1.0.0\",\n  \"name\": \"dbnet\",\n  \"type\": \"portmap\",\n  \"runtimeConfig\": {\n    \"portMappings\" : [\n      { \"hostPort\": 8080, \"containerPort\": 80, \"protocol\": \"tcp\" }\n    ]\n  },\n  \"prevResult\": {\n    \"ips\": [\n        {\n          \"address\": \"10.1.0.5/16\",\n          \"gateway\": \"10.1.0.1\",\n          \"interface\": 2\n        }\n    ],\n    \"routes\": [\n      {\n        \"dst\": \"0.0.0.0/0\"\n      }\n    ],\n    \"interfaces\": [\n        {\n            \"name\": \"cni0\",\n            \"mac\": \"00:11:22:33:44:55\"\n        },\n        {\n            \"name\": \"veth3243\",\n            \"mac\": \"55:44:33:22:11:11\"\n        },\n        {\n            \"name\": \"eth0\",\n            \"mac\": \"00:11:22:33:44:66\",\n            \"sandbox\": \"/var/run/netns/blue\"\n        }\n    ],\n    \"dns\": {\n      \"nameservers\": [ \"10.1.0.1\" ]\n    }\n  }\n}\n```\n\nThe `portmap` plugin outputs the exact same result as that returned by `bridge`, as the plugin has not modified anything that would change the result (i.e. it only created iptables rules).\n\n### Check example\n\nGiven the previous *Add*, the container runtime would perform the following steps for the *Check* action:\n\n1. First call the `bridge` plugin with the following request configuration, including the `prevResult` field containing the final JSON response from the *Add* operation, **including the changed mac**. `CNI_COMMAND=CHECK`\n\n```\n{\n  \"cniVersion\": \"1.0.0\",\n  \"name\": \"dbnet\",\n  \"type\": \"bridge\",\n  \"bridge\": \"cni0\",\n  \"keyA\": [\"some more\", \"plugin specific\", \"configuration\"],\n  \"ipam\": {\n    \"type\": \"host-local\",\n    \"subnet\": \"10.1.0.0/16\",\n    \"gateway\": \"10.1.0.1\"\n  },\n  \"dns\": {\n    \"nameservers\": [ \"10.1.0.1\" ]\n  },\n  \"prevResult\": {\n    \"ips\": [\n        {\n          \"address\": \"10.1.0.5/16\",\n          \"gateway\": \"10.1.0.1\",\n          \"interface\": 2\n        }\n    ],\n    \"routes\": [\n      {\n        \"dst\": \"0.0.0.0/0\"\n      }\n    ],\n    \"interfaces\": [\n        {\n            \"name\": \"cni0\",\n            \"mac\": \"00:11:22:33:44:55\"\n        },\n        {\n            \"name\": \"veth3243\",\n            \"mac\": \"55:44:33:22:11:11\"\n        },\n        {\n            \"name\": \"eth0\",\n            \"mac\": \"00:11:22:33:44:66\",\n            \"sandbox\": \"/var/run/netns/blue\"\n        }\n    ],\n    \"dns\": {\n      \"nameservers\": [ \"10.1.0.1\" ]\n    }\n  }\n}\n```\n\nThe `bridge` plugin, as it delegates IPAM, calls `host-local`, `CNI_COMMAND=CHECK`. It returns no error.\n\nAssuming the `bridge` plugin is satisfied, it produces no output on standard out and exits with a 0 return code.\n\n1. Next call the `tuning` plugin with the following request configuration:\n\n```\n{\n  \"cniVersion\": \"1.0.0\",\n  \"name\": \"dbnet\",\n  \"type\": \"tuning\",\n  \"sysctl\": {\n    \"net.core.somaxconn\": \"500\"\n  },\n  \"runtimeConfig\": {\n    \"mac\": \"00:11:22:33:44:66\"\n  },\n  \"prevResult\": {\n    \"ips\": [\n        {\n          \"address\": \"10.1.0.5/16\",\n          \"gateway\": \"10.1.0.1\",\n          \"interface\": 2\n        }\n    ],\n    \"routes\": [\n      {\n        \"dst\": \"0.0.0.0/0\"\n      }\n    ],\n    \"interfaces\": [\n        {\n            \"name\": \"cni0\",\n            \"mac\": \"00:11:22:33:44:55\"\n        },\n        {\n            \"name\": \"veth3243\",\n            \"mac\": \"55:44:33:22:11:11\"\n        },\n        {\n            \"name\": \"eth0\",\n            \"mac\": \"00:11:22:33:44:66\",\n            \"sandbox\": \"/var/run/netns/blue\"\n        }\n    ],\n    \"dns\": {\n      \"nameservers\": [ \"10.1.0.1\" ]\n    }\n  }\n}\n```\n\nLikewise, the `tuning` plugin exits indicating success.\n\n1. Finally, call `portmap` with the following request configuration:\n\n```\n{\n  \"cniVersion\": \"1.0.0\",\n  \"name\": \"dbnet\",\n  \"type\": \"portmap\",\n  \"runtimeConfig\": {\n    \"portMappings\" : [\n      { \"hostPort\": 8080, \"containerPort\": 80, \"protocol\": \"tcp\" }\n    ]\n  },\n  \"prevResult\": {\n    \"ips\": [\n        {\n          \"address\": \"10.1.0.5/16\",\n          \"gateway\": \"10.1.0.1\",\n          \"interface\": 2\n        }\n    ],\n    \"routes\": [\n      {\n        \"dst\": \"0.0.0.0/0\"\n      }\n    ],\n    \"interfaces\": [\n        {\n            \"name\": \"cni0\",\n            \"mac\": \"00:11:22:33:44:55\"\n        },\n        {\n            \"name\": \"veth3243\",\n            \"mac\": \"55:44:33:22:11:11\"\n        },\n        {\n            \"name\": \"eth0\",\n            \"mac\": \"00:11:22:33:44:66\",\n            \"sandbox\": \"/var/run/netns/blue\"\n        }\n    ],\n    \"dns\": {\n      \"nameservers\": [ \"10.1.0.1\" ]\n    }\n  }\n}\n```\n\n### Delete example\n\nGiven the same network configuration JSON list, the container runtime would perform the following steps for the *Delete* action. Note that plugins are executed in reverse order from the *Add* and *Check* actions.\n\n1. First, call `portmap` with the following request configuration, `CNI_COMMAND=DEL`:\n\n```\n{\n  \"cniVersion\": \"1.0.0\",\n  \"name\": \"dbnet\",\n  \"type\": \"portmap\",\n  \"runtimeConfig\": {\n    \"portMappings\" : [\n      { \"hostPort\": 8080, \"containerPort\": 80, \"protocol\": \"tcp\" }\n    ]\n  },\n  \"prevResult\": {\n    \"ips\": [\n        {\n          \"address\": \"10.1.0.5/16\",\n          \"gateway\": \"10.1.0.1\",\n          \"interface\": 2\n        }\n    ],\n    \"routes\": [\n      {\n        \"dst\": \"0.0.0.0/0\"\n      }\n    ],\n    \"interfaces\": [\n        {\n            \"name\": \"cni0\",\n            \"mac\": \"00:11:22:33:44:55\"\n        },\n        {\n            \"name\": \"veth3243\",\n            \"mac\": \"55:44:33:22:11:11\"\n        },\n        {\n            \"name\": \"eth0\",\n            \"mac\": \"00:11:22:33:44:66\",\n            \"sandbox\": \"/var/run/netns/blue\"\n        }\n    ],\n    \"dns\": {\n      \"nameservers\": [ \"10.1.0.1\" ]\n    }\n  }\n}\n```\n\n1. Next, call the `tuning` plugin with the following request configuration, `CNI_COMMAND=DEL`:\n\n```\n{\n  \"cniVersion\": \"1.0.0\",\n  \"name\": \"dbnet\",\n  \"type\": \"tuning\",\n  \"sysctl\": {\n    \"net.core.somaxconn\": \"500\"\n  },\n  \"runtimeConfig\": {\n    \"mac\": \"00:11:22:33:44:66\"\n  },\n  \"prevResult\": {\n    \"ips\": [\n        {\n          \"address\": \"10.1.0.5/16\",\n          \"gateway\": \"10.1.0.1\",\n          \"interface\": 2\n        }\n    ],\n    \"routes\": [\n      {\n        \"dst\": \"0.0.0.0/0\"\n      }\n    ],\n    \"interfaces\": [\n        {\n            \"name\": \"cni0\",\n            \"mac\": \"00:11:22:33:44:55\"\n        },\n        {\n            \"name\": \"veth3243\",\n            \"mac\": \"55:44:33:22:11:11\"\n        },\n        {\n            \"name\": \"eth0\",\n            \"mac\": \"00:11:22:33:44:66\",\n            \"sandbox\": \"/var/run/netns/blue\"\n        }\n    ],\n    \"dns\": {\n      \"nameservers\": [ \"10.1.0.1\" ]\n    }\n  }\n}\n```\n\n1. Finally, call `bridge`:\n\n```\n{\n  \"cniVersion\": \"1.0.0\",\n  \"name\": \"dbnet\",\n  \"type\": \"bridge\",\n  \"bridge\": \"cni0\",\n  \"keyA\": [\"some more\", \"plugin specific\", \"configuration\"],\n  \"ipam\": {\n    \"type\": \"host-local\",\n    \"subnet\": \"10.1.0.0/16\",\n    \"gateway\": \"10.1.0.1\"\n  },\n  \"dns\": {\n    \"nameservers\": [ \"10.1.0.1\" ]\n  },\n  \"prevResult\": {\n    \"ips\": [\n        {\n          \"address\": \"10.1.0.5/16\",\n          \"gateway\": \"10.1.0.1\",\n          \"interface\": 2\n        }\n    ],\n    \"routes\": [\n      {\n        \"dst\": \"0.0.0.0/0\"\n      }\n    ],\n    \"interfaces\": [\n        {\n            \"name\": \"cni0\",\n            \"mac\": \"00:11:22:33:44:55\"\n        },\n        {\n            \"name\": \"veth3243\",\n            \"mac\": \"55:44:33:22:11:11\"\n        },\n        {\n            \"name\": \"eth0\",\n            \"mac\": \"00:11:22:33:44:66\",\n            \"sandbox\": \"/var/run/netns/blue\"\n        }\n    ],\n    \"dns\": {\n      \"nameservers\": [ \"10.1.0.1\" ]\n    }\n  }\n}\n```\n\nThe bridge plugin executes the `host-local` delegated plugin with `CNI_COMMAND=DEL` before returning.\n\n---\n\n\n\n## 相关仓库及文献\n\n[cni/SPEC.md at spec-v1.0.0 · containernetworking/cni (github.com)](https://github.com/containernetworking/cni/blob/spec-v1.0.0/SPEC.md)\n\n[Kubernetes网络之CNI规范解读 | LRF (lengrongfu.github.io)](https://lengrongfu.github.io/2022-05-11-k8s之CNI规范解读/)\n\n[A brief overview of the Container Network Interface (CNI) in Kubernetes | Enable Sysadmin (redhat.com)](https://www.redhat.com/sysadmin/cni-kubernetes)\n\n[Bring your own Container Network Interface (CNI) plugin - Azure Kubernetes Service | Microsoft Learn](https://learn.microsoft.com/en-us/azure/aks/use-byo-cni?tabs=azure-cli)\n\n[Network Plugins | Kubernetes](https://kubernetes.io/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/)\n\n[Kubernetes CNI Explained (tigera.io)](https://www.tigera.io/learn/guides/kubernetes-networking/kubernetes-cni/)\n\n\n","slug":"EdgeMesh/2023-ospp-fighting/CNI-Basic","published":1,"updated":"2023-05-28T09:44:27.696Z","comments":1,"photos":[],"link":"","_id":"cli796r0l000lbyjx63a81eoi","content":"<h1 id=\"CNI-概述\"><a href=\"#CNI-概述\" class=\"headerlink\" title=\"CNI 概述\"></a>CNI 概述</h1><h2 id=\"什么是-CNI\"><a href=\"#什么是-CNI\" class=\"headerlink\" title=\"什么是 CNI\"></a>什么是 CNI</h2><blockquote>\n<p>CNI的全称是 Container Network Interface，它为<strong>容器提供了一种基于插件结构的标准化网络解决方案</strong>。以往，容器的网络层是和具体的底层网络环境高度相关的，不同的网络服务提供商有不同的实现。<strong>CNI从网络服务里抽象出了一套标准接口</strong>，从而屏蔽了上层网络和底层网络提供商的网络实现之间的差异。并且，通过插件结构，它让容器在网络层的具体实现变得可插拔了，所以非常灵活。</p>\n</blockquote>\n<p>首先 CNI 是一套标准接口，它隶属于<a href=\"https://cncf.io/\">CNCF(Cloud Native Computing Foundation)</a>，依照这个标准所实现的为 CNI Plugins, 他们彼此独立，也可以组合起来一起使用，由一组用于配置 Linux 容器的网络接口的规范和库组成，同时还包含了一些插件，CNI 仅关心容器创建时的网络分配，和当容器被删除时释放网络资源。</p>\n<p>其次 依据 CNI 的<a href=\"https://github.com/containernetworking/cni/blob/master/SPEC.md\">规范</a>，CNI 具有以下几点特征：</p>\n<ul>\n<li>CNI 需提供网络管理员<strong>定义网络配置的文件格式</strong></li>\n<li>CNI 需提供 Container Runtime（CRI） 调用功能的<strong>协议/API</strong>。</li>\n<li>当 CNI 被 CRI 调用时，需依据配置文件执行网络配置功能</li>\n<li>CNI 需预留可调用其他插件的能力</li>\n<li>CNI 需规范统一返回给CRI 的数据格式</li>\n</ul>\n<p>依据这样的特征和要求，可以明确实现一个CNI插件需要包含以下部分：</p>\n<ul>\n<li>可执行文件<ul>\n<li>CNI 主进程</li>\n<li>IPAM 等</li>\n</ul>\n</li>\n<li>网络配置文件</li>\n</ul>\n<hr>\n<h2 id=\"CNI-的功能\"><a href=\"#CNI-的功能\" class=\"headerlink\" title=\"CNI 的功能\"></a>CNI 的功能</h2><p>CNI 插件首先得实现一个可以被容器管理系统（CRI），比如rkt、Kubernetes 所调用的可执行文件——cni plugins，这个插件首先需要提供<strong>基础的 Linux 网络联通服务</strong>，比如创建 veth 或者 bridge 并将 veth 对的一端插入容器的 network namespace，一端插入 bridge，使得容器之间可以相互通信。然后<strong>将IP 分配给接口</strong>，并通过调用 **IPAM **插件来设置和管理IP地址，使得集群内的容器IP地址相互不重复，或者是结合其他的插件来实现更加复杂的网络路由管理功能等等。</p>\n<p>那么接下来，依据对于这几项功能的要求，来具体看看 CNI 的标准</p>\n<hr>\n<h2 id=\"CNI-统一的网络配置文件\"><a href=\"#CNI-统一的网络配置文件\" class=\"headerlink\" title=\"CNI 统一的网络配置文件\"></a>CNI 统一的网络配置文件</h2><p>CNI 为容器网络管理员(操作人员、网络插件、网络编排系统)定义了一种网络配置格式。它包含了供 CRI 和 CNI 插件使用的指令。在插件执行时，这种配置格式由 CRI 解释，并转化为代码数据结构，传递给 CNI 插件。</p>\n<p>一般来说配置文件主要是以 JSON 文件为主，且包含以下几个键值：</p>\n<ul>\n<li><code>cniVersion</code>: 指定CNI规范的版本，这样 CRI 和 CNI 才能读懂彼此</li>\n<li><code>Name</code>: 网络名字，这在一个主机（或其他管理域）的所有网络配置中应该是唯一的。必须以一个字母数字字符开始，后面可以选择由一个或多个字母数字字符、下划线、点（.）或连字符（-）的任何组合。</li>\n<li><code>disableCheck</code>: 是否禁用检查网络，如果为true,则 <code>container runtime</code> 不会调用 Check 方法进行网络检查。</li>\n<li><code>plugin</code>: cni插件及其配置列表，可以配置多个插件。</li>\n</ul>\n<p>接着展开说明一下 plugin 当中的参数，这也与实现 CNI 的功能息息相关，CRI 解析出配置文件当中的这个字段，是必须要一个字不漏地完整交给 CNI 插件来做网络管理</p>\n<ol>\n<li><p>必须配置的键值</p>\n<p><code>type</code> :  指定目前系统目录当中所使用的 CNI 插件，一般是 cni 可执行文件的目录索引</p>\n<p>至少得有一个基础的 cni 插件来完成最基础的 Linux 网络配置的功能</p>\n</li>\n<li><p>可选键值，由 CRI 依据协议发送的 request 指定</p>\n<p><code>capabilities</code>:  如果 CNI_ARGS 中没有指定此项功能时候来补充的</p>\n</li>\n<li><p>预留键值，由 CRI 在执行时产生的</p>\n<ul>\n<li><code>runtimeConfig</code> :  比如 CNI 自己设置的 isGateway == true 就表明告诉插件，作为网关，给bridge指定一个IP地址。这样，连接到bridge的容器就可以拿它当网关来用了。</li>\n<li><code>args</code></li>\n<li>或者是任何以 <code>cni.dev/</code>开头的</li>\n</ul>\n</li>\n<li><p>可选键值,由容器网络管理员添加</p>\n<p><code>ipMasq</code>: 为目标网络配上Outbound Masquerade(地址伪装)，即：由容器内部通过网关向外发送数据包时，对数据包的源IP地址进行修改。</p>\n<p>当我们的容器以宿主机作为网关时，这个参数是必须要设置的。否则，从容器内部发出的数据包就没有办法通过网关路由到其他网段。因为容器内部的IP地址无法被目标网段识别，所以这些数据包最终会被丢弃掉。</p>\n<p><code>ipam</code>: PAM(IP Adderss Management)即IP地址管理，提供了一系列方法用于对IP和路由进行管理。实际上，它对应的是由CNI提供的一组标准IPAM插件，比如像host-local，dhcp，static等。如果要对整个集群的地址做管理，让pod具有单独的ip地址，就需要在这里添加额外的插件</p>\n<blockquote>\n<p>例子1当中：</p>\n<ul>\n<li>type：指定所用IPAM插件的名称，在例子里，用的是host-local。</li>\n<li>subnet：为目标网络分配网段，包括网络ID和子网掩码，以CIDR形式标记。在例子里为<code>10.15.10.0/24</code>，也就是目标网段为<code>10.15.10.0</code>，子网掩码为<code>255.255.255.0</code>。</li>\n<li>routes：用于指定路由规则，插件会在容器的路由表里生成相应的规则。其中，dst表示希望到达的目标网段，以CIDR形式标记。gw对应网关的IP地址，也就是要到达目标网段所要经过的“next hop(下一跳)”。如果省略gw的话，那么插件会自动帮容器选择默认网关。在例子里，gw选择的是默认网关，而dst为<code>0.0.0.0/0</code>则代表“任何网络”，表示数据包将通过默认网关发往任何网络。实际上，这对应的是一条默认路由规则，即：当所有其他路由规则都不匹配时，将选择该路由。</li>\n<li>rangeStart：允许分配的IP地址范围的起始值</li>\n<li>rangeEnd：允许分配的IP地址范围的结束值</li>\n<li>gateway：为网关（也就是将要在宿主机上创建的bridge）指定的IP地址。如果省略的话，那么插件会自动从允许分配的IP地址范围内选择起始值作为网关的IP地址。</li>\n</ul>\n</blockquote>\n</li>\n</ol>\n<p>配置文件例子如下：</p>\n<p>例子1：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;cniVersion&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;0.4.0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;lab-br0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;bridge&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;bridge&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;lab-br0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;isGateway&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;ipMasq&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;ipam&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;host-local&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;subnet&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;10.15.10.0/24&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;routes&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">            <span class=\"punctuation\">&#123;</span> <span class=\"attr\">&quot;dst&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;0.0.0.0/0&quot;</span> <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">        <span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;rangeStart&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;10.15.10.100&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;rangeEnd&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;10.15.10.200&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;gateway&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;10.15.10.99&quot;</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>例子2：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;cniVersion&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;1.0.0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;dbnet&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;plugins&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;bridge&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"comment\">// plugin specific parameters</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;bridge&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;cni0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;keyA&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span><span class=\"string\">&quot;some more&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;plugin specific&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;configuration&quot;</span><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"attr\">&quot;ipam&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;host-local&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"comment\">// ipam specific</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;subnet&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;10.1.0.0/16&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;gateway&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;10.1.0.1&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;routes&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">            <span class=\"punctuation\">&#123;</span><span class=\"attr\">&quot;dst&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;0.0.0.0/0&quot;</span><span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">        <span class=\"punctuation\">]</span></span><br><span class=\"line\">      <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;dns&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;nameservers&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span> <span class=\"string\">&quot;10.1.0.1&quot;</span> <span class=\"punctuation\">]</span></span><br><span class=\"line\">      <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;tuning&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;capabilities&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;mac&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span></span><br><span class=\"line\">      <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;sysctl&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;net.core.somaxconn&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;500&quot;</span></span><br><span class=\"line\">      <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;portmap&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;capabilities&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span><span class=\"attr\">&quot;portMappings&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">  <span class=\"punctuation\">]</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"CNI-运行时协议\"><a href=\"#CNI-运行时协议\" class=\"headerlink\" title=\"CNI 运行时协议\"></a>CNI 运行时协议</h2><p>CNI协议是基于由 CRI 的调用请求来告诉 CNI 该做些什么。</p>\n<p>主要的协议参数定义如下：</p>\n<ul>\n<li>CNI_COMMAND：表示所需的操作；ADD、DEL、CHECK、或VERSION。</li>\n<li>CNI_CONTAINERID：容器ID。告诉CNI插件，将要加入目标网络的容器所对应的network namespace的ID,容器的唯一的标识符，由 CRI 分配。不能是空的。必须以一个字母数字字符开始，后面可以选择一个或多个字母数字字符、下划线（）、点（.）或连字符（-）的任何组合。</li>\n<li>CNI_NETNS：容器对应的network namespace在宿主机上的文件路径。（例如：/run/netns/[nsname]）。</li>\n<li>CNI_IFNAME：作为veth pair在容器一端的网络接口,一般是在容器内创建的接口的名称；如果 CNI 插件无法使用这个接口名称，那么就必须返回一个错误。</li>\n<li>CNI_ARGS：用户在调用时传入的额外参数。用分号分隔的字母数字键值对；例如，”FOO=BAR;ABC=123”</li>\n<li>CNI_PATH: 表示 CNI 插件可执行文件的路径列表。路径由操作系统特定的列表分隔符分隔；例如Linux上的’:’和Windows上的’；’。</li>\n</ul>\n<p>告诉CNI插件要执行的命令，允许的命令有ADD，DEL，CHECK，VERSION。</p>\n<p>对于支持CNI规范的容器系统而言，当容器启动的时候，系统就会自动调用相应的CNI插件，并设置CNI_COMMAND为ADD。相应地，DEL是在容器被销毁时调用的，用于清除在执行ADD阶段分配的网络资源。CHECK用于检查容器网络是否正常。VERSION则用来显示插件的版本。具体的操作如下：</p>\n<ul>\n<li><p>ADD</p>\n<ul>\n<li><p>将容器添加到网络中，或将新的配置修改应用到已有的集群当中。</p>\n</li>\n<li><p>一个CNI插件在收到ADD命令后，应该选择</p>\n<ul>\n<li><p>在 CNI_NETNS 的容器内创建由 CNI_IFNAME 定义的接口，</p>\n</li>\n<li><p>调整容器内 CNI_NETNS 处由CNI_IFNAME定义的接口的配置</p>\n<p>如果CNI插件成功，必须要返回一个处理结果，要么打印出来，要么修改传入的参数。</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>DELETE</p>\n<ul>\n<li><p>将容器删除出网络，或将新的配置修改应用到已有的集群当中。</p>\n<p>功能与ADD 相对</p>\n</li>\n</ul>\n</li>\n<li><p>CHECK</p>\n<ul>\n<li>查找类型字段中指定的可执行文件，如果没找到返回错误</li>\n<li>当 Plugins （CNI调用的其他的Plugins）返回错误时，将其返回给调用者</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"CNI-与插件\"><a href=\"#CNI-与插件\" class=\"headerlink\" title=\"CNI 与插件\"></a>CNI 与插件</h2><p>为了解决容器网络的各项需求和问题，将所有的功能单独集中在 CNI 单个程序中是不现实的，而且难以兼容不同的上层系统和底层的网络管理，于是一个显然的想法就是将这些功能独立出来，使用插件（Plugins）的形式来执行。</p>\n<p>一个常见的例子就是 IP 地址管理，这就是IP地址管理插件（IPAM插件），它必须设置容器和虚拟网络设备的接口 ，IP / 子网，网关和路由，然后将此信息返回给“主”插件（CNI本体）来执行，换句话说 IPAM 做逻辑上的网络地址管理然后告诉本体 CNI 去执行 <code>ADD</code>,<code>DELETE</code>。 </p>\n<p>CNI 本体调用这些插件的形式也是通过路径找到这些插件的可执行文件来实现的，一般这些插件的位置也都一起放置在 <code>CNI_PATH</code>之下。同时插件和 CNI 本体都是通过 stdin 接收网络配置，也通过 stdout 输出结果。</p>\n<p>如此看来 CNI 的工作流程就是一条链状的调用过程，但调用链中的每一个可执行程序所接收的配置文件信息都是完整的。</p>\n<hr>\n<h1 id=\"CNI-配置文件样例\"><a href=\"#CNI-配置文件样例\" class=\"headerlink\" title=\"CNI 配置文件样例\"></a>CNI 配置文件样例</h1><blockquote>\n<p>参考<a href=\"https://github.com/containernetworking/cni/blob/spec-v1.0.0/SPEC.md\">cni/SPEC.md at spec-v1.0.0 · containernetworking/cni (github.com)</a> 的 Appendix: Examples</p>\n</blockquote>\n<p>借助 Github 所给的 SPEC 例子，假设目前 CRI 接收到的 json 文件如下，</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;cniVersion&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;1.0.0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;dbnet&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;plugins&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;bridge&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"comment\">// plugin specific parameters</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;bridge&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;cni0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;keyA&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span><span class=\"string\">&quot;some more&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;plugin specific&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;configuration&quot;</span><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"attr\">&quot;ipam&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;host-local&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"comment\">// ipam specific</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;subnet&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;10.1.0.0/16&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;gateway&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;10.1.0.1&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;routes&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">            <span class=\"punctuation\">&#123;</span><span class=\"attr\">&quot;dst&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;0.0.0.0/0&quot;</span><span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">        <span class=\"punctuation\">]</span></span><br><span class=\"line\">      <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;dns&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;nameservers&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span> <span class=\"string\">&quot;10.1.0.1&quot;</span> <span class=\"punctuation\">]</span></span><br><span class=\"line\">      <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;tuning&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;capabilities&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;mac&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span></span><br><span class=\"line\">      <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;sysctl&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;net.core.somaxconn&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;500&quot;</span></span><br><span class=\"line\">      <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;portmap&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;capabilities&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span><span class=\"attr\">&quot;portMappings&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">  <span class=\"punctuation\">]</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Add-example\"><a href=\"#Add-example\" class=\"headerlink\" title=\"Add example\"></a>Add example</h3><p>The container runtime would perform the following steps for the <code>add</code> operation.</p>\n<ol>\n<li>Call the <code>bridge</code> plugin with the following JSON, <code>CNI_COMMAND=ADD</code>:</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;cniVersion&quot;: &quot;1.0.0&quot;,</span><br><span class=\"line\">    &quot;name&quot;: &quot;dbnet&quot;,</span><br><span class=\"line\">    &quot;type&quot;: &quot;bridge&quot;,</span><br><span class=\"line\">    &quot;bridge&quot;: &quot;cni0&quot;,</span><br><span class=\"line\">    &quot;keyA&quot;: [&quot;some more&quot;, &quot;plugin specific&quot;, &quot;configuration&quot;],</span><br><span class=\"line\">    &quot;ipam&quot;: &#123;</span><br><span class=\"line\">        &quot;type&quot;: &quot;host-local&quot;,</span><br><span class=\"line\">        &quot;subnet&quot;: &quot;10.1.0.0/16&quot;,</span><br><span class=\"line\">        &quot;gateway&quot;: &quot;10.1.0.1&quot;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;dns&quot;: &#123;</span><br><span class=\"line\">        &quot;nameservers&quot;: [ &quot;10.1.0.1&quot; ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>The bridge plugin, as it delegates IPAM to the <code>host-local</code> plugin, would execute the <code>host-local</code> binary with the exact same input, <code>CNI_COMMAND=ADD</code>.</p>\n<p>The <code>host-local</code> plugin returns the following result:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;ips&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;address&quot;: &quot;10.1.0.5/16&quot;,</span><br><span class=\"line\">          &quot;gateway&quot;: &quot;10.1.0.1&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;routes&quot;: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;dst&quot;: &quot;0.0.0.0/0&quot;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;dns&quot;: &#123;</span><br><span class=\"line\">      &quot;nameservers&quot;: [ &quot;10.1.0.1&quot; ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>The bridge plugin returns the following result, configuring the interface according to the delegated IPAM configuration:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;ips&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;address&quot;: &quot;10.1.0.5/16&quot;,</span><br><span class=\"line\">          &quot;gateway&quot;: &quot;10.1.0.1&quot;,</span><br><span class=\"line\">          &quot;interface&quot;: 2</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;routes&quot;: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;dst&quot;: &quot;0.0.0.0/0&quot;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;interfaces&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;cni0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;00:11:22:33:44:55&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;veth3243&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;55:44:33:22:11:11&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;eth0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;99:88:77:66:55:44&quot;,</span><br><span class=\"line\">            &quot;sandbox&quot;: &quot;/var/run/netns/blue&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;dns&quot;: &#123;</span><br><span class=\"line\">      &quot;nameservers&quot;: [ &quot;10.1.0.1&quot; ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>Next, call the <code>tuning</code> plugin, with <code>CNI_COMMAND=ADD</code>. Note that <code>prevResult</code> is supplied, along with the <code>mac</code> capability argument. The request configuration passed is:</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;cniVersion&quot;: &quot;1.0.0&quot;,</span><br><span class=\"line\">  &quot;name&quot;: &quot;dbnet&quot;,</span><br><span class=\"line\">  &quot;type&quot;: &quot;tuning&quot;,</span><br><span class=\"line\">  &quot;sysctl&quot;: &#123;</span><br><span class=\"line\">    &quot;net.core.somaxconn&quot;: &quot;500&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;runtimeConfig&quot;: &#123;</span><br><span class=\"line\">    &quot;mac&quot;: &quot;00:11:22:33:44:66&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;prevResult&quot;: &#123;</span><br><span class=\"line\">    &quot;ips&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;address&quot;: &quot;10.1.0.5/16&quot;,</span><br><span class=\"line\">          &quot;gateway&quot;: &quot;10.1.0.1&quot;,</span><br><span class=\"line\">          &quot;interface&quot;: 2</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;routes&quot;: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;dst&quot;: &quot;0.0.0.0/0&quot;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;interfaces&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;cni0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;00:11:22:33:44:55&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;veth3243&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;55:44:33:22:11:11&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;eth0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;99:88:77:66:55:44&quot;,</span><br><span class=\"line\">            &quot;sandbox&quot;: &quot;/var/run/netns/blue&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;dns&quot;: &#123;</span><br><span class=\"line\">      &quot;nameservers&quot;: [ &quot;10.1.0.1&quot; ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>The plugin returns the following result. Note that the <strong>mac</strong> has changed.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;ips&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;address&quot;: &quot;10.1.0.5/16&quot;,</span><br><span class=\"line\">          &quot;gateway&quot;: &quot;10.1.0.1&quot;,</span><br><span class=\"line\">          &quot;interface&quot;: 2</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;routes&quot;: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;dst&quot;: &quot;0.0.0.0/0&quot;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;interfaces&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;cni0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;00:11:22:33:44:55&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;veth3243&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;55:44:33:22:11:11&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;eth0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;00:11:22:33:44:66&quot;,</span><br><span class=\"line\">            &quot;sandbox&quot;: &quot;/var/run/netns/blue&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;dns&quot;: &#123;</span><br><span class=\"line\">      &quot;nameservers&quot;: [ &quot;10.1.0.1&quot; ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>Finally, call the <code>portmap</code> plugin, with <code>CNI_COMMAND=ADD</code>. Note that <code>prevResult</code> matches that returned by <code>tuning</code>:</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;cniVersion&quot;: &quot;1.0.0&quot;,</span><br><span class=\"line\">  &quot;name&quot;: &quot;dbnet&quot;,</span><br><span class=\"line\">  &quot;type&quot;: &quot;portmap&quot;,</span><br><span class=\"line\">  &quot;runtimeConfig&quot;: &#123;</span><br><span class=\"line\">    &quot;portMappings&quot; : [</span><br><span class=\"line\">      &#123; &quot;hostPort&quot;: 8080, &quot;containerPort&quot;: 80, &quot;protocol&quot;: &quot;tcp&quot; &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;prevResult&quot;: &#123;</span><br><span class=\"line\">    &quot;ips&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;address&quot;: &quot;10.1.0.5/16&quot;,</span><br><span class=\"line\">          &quot;gateway&quot;: &quot;10.1.0.1&quot;,</span><br><span class=\"line\">          &quot;interface&quot;: 2</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;routes&quot;: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;dst&quot;: &quot;0.0.0.0/0&quot;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;interfaces&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;cni0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;00:11:22:33:44:55&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;veth3243&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;55:44:33:22:11:11&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;eth0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;00:11:22:33:44:66&quot;,</span><br><span class=\"line\">            &quot;sandbox&quot;: &quot;/var/run/netns/blue&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;dns&quot;: &#123;</span><br><span class=\"line\">      &quot;nameservers&quot;: [ &quot;10.1.0.1&quot; ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>The <code>portmap</code> plugin outputs the exact same result as that returned by <code>bridge</code>, as the plugin has not modified anything that would change the result (i.e. it only created iptables rules).</p>\n<h3 id=\"Check-example\"><a href=\"#Check-example\" class=\"headerlink\" title=\"Check example\"></a>Check example</h3><p>Given the previous <em>Add</em>, the container runtime would perform the following steps for the <em>Check</em> action:</p>\n<ol>\n<li>First call the <code>bridge</code> plugin with the following request configuration, including the <code>prevResult</code> field containing the final JSON response from the <em>Add</em> operation, <strong>including the changed mac</strong>. <code>CNI_COMMAND=CHECK</code></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;cniVersion&quot;: &quot;1.0.0&quot;,</span><br><span class=\"line\">  &quot;name&quot;: &quot;dbnet&quot;,</span><br><span class=\"line\">  &quot;type&quot;: &quot;bridge&quot;,</span><br><span class=\"line\">  &quot;bridge&quot;: &quot;cni0&quot;,</span><br><span class=\"line\">  &quot;keyA&quot;: [&quot;some more&quot;, &quot;plugin specific&quot;, &quot;configuration&quot;],</span><br><span class=\"line\">  &quot;ipam&quot;: &#123;</span><br><span class=\"line\">    &quot;type&quot;: &quot;host-local&quot;,</span><br><span class=\"line\">    &quot;subnet&quot;: &quot;10.1.0.0/16&quot;,</span><br><span class=\"line\">    &quot;gateway&quot;: &quot;10.1.0.1&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;dns&quot;: &#123;</span><br><span class=\"line\">    &quot;nameservers&quot;: [ &quot;10.1.0.1&quot; ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;prevResult&quot;: &#123;</span><br><span class=\"line\">    &quot;ips&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;address&quot;: &quot;10.1.0.5/16&quot;,</span><br><span class=\"line\">          &quot;gateway&quot;: &quot;10.1.0.1&quot;,</span><br><span class=\"line\">          &quot;interface&quot;: 2</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;routes&quot;: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;dst&quot;: &quot;0.0.0.0/0&quot;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;interfaces&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;cni0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;00:11:22:33:44:55&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;veth3243&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;55:44:33:22:11:11&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;eth0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;00:11:22:33:44:66&quot;,</span><br><span class=\"line\">            &quot;sandbox&quot;: &quot;/var/run/netns/blue&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;dns&quot;: &#123;</span><br><span class=\"line\">      &quot;nameservers&quot;: [ &quot;10.1.0.1&quot; ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>The <code>bridge</code> plugin, as it delegates IPAM, calls <code>host-local</code>, <code>CNI_COMMAND=CHECK</code>. It returns no error.</p>\n<p>Assuming the <code>bridge</code> plugin is satisfied, it produces no output on standard out and exits with a 0 return code.</p>\n<ol>\n<li>Next call the <code>tuning</code> plugin with the following request configuration:</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;cniVersion&quot;: &quot;1.0.0&quot;,</span><br><span class=\"line\">  &quot;name&quot;: &quot;dbnet&quot;,</span><br><span class=\"line\">  &quot;type&quot;: &quot;tuning&quot;,</span><br><span class=\"line\">  &quot;sysctl&quot;: &#123;</span><br><span class=\"line\">    &quot;net.core.somaxconn&quot;: &quot;500&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;runtimeConfig&quot;: &#123;</span><br><span class=\"line\">    &quot;mac&quot;: &quot;00:11:22:33:44:66&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;prevResult&quot;: &#123;</span><br><span class=\"line\">    &quot;ips&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;address&quot;: &quot;10.1.0.5/16&quot;,</span><br><span class=\"line\">          &quot;gateway&quot;: &quot;10.1.0.1&quot;,</span><br><span class=\"line\">          &quot;interface&quot;: 2</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;routes&quot;: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;dst&quot;: &quot;0.0.0.0/0&quot;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;interfaces&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;cni0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;00:11:22:33:44:55&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;veth3243&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;55:44:33:22:11:11&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;eth0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;00:11:22:33:44:66&quot;,</span><br><span class=\"line\">            &quot;sandbox&quot;: &quot;/var/run/netns/blue&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;dns&quot;: &#123;</span><br><span class=\"line\">      &quot;nameservers&quot;: [ &quot;10.1.0.1&quot; ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Likewise, the <code>tuning</code> plugin exits indicating success.</p>\n<ol>\n<li>Finally, call <code>portmap</code> with the following request configuration:</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;cniVersion&quot;: &quot;1.0.0&quot;,</span><br><span class=\"line\">  &quot;name&quot;: &quot;dbnet&quot;,</span><br><span class=\"line\">  &quot;type&quot;: &quot;portmap&quot;,</span><br><span class=\"line\">  &quot;runtimeConfig&quot;: &#123;</span><br><span class=\"line\">    &quot;portMappings&quot; : [</span><br><span class=\"line\">      &#123; &quot;hostPort&quot;: 8080, &quot;containerPort&quot;: 80, &quot;protocol&quot;: &quot;tcp&quot; &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;prevResult&quot;: &#123;</span><br><span class=\"line\">    &quot;ips&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;address&quot;: &quot;10.1.0.5/16&quot;,</span><br><span class=\"line\">          &quot;gateway&quot;: &quot;10.1.0.1&quot;,</span><br><span class=\"line\">          &quot;interface&quot;: 2</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;routes&quot;: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;dst&quot;: &quot;0.0.0.0/0&quot;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;interfaces&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;cni0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;00:11:22:33:44:55&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;veth3243&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;55:44:33:22:11:11&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;eth0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;00:11:22:33:44:66&quot;,</span><br><span class=\"line\">            &quot;sandbox&quot;: &quot;/var/run/netns/blue&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;dns&quot;: &#123;</span><br><span class=\"line\">      &quot;nameservers&quot;: [ &quot;10.1.0.1&quot; ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Delete-example\"><a href=\"#Delete-example\" class=\"headerlink\" title=\"Delete example\"></a>Delete example</h3><p>Given the same network configuration JSON list, the container runtime would perform the following steps for the <em>Delete</em> action. Note that plugins are executed in reverse order from the <em>Add</em> and <em>Check</em> actions.</p>\n<ol>\n<li>First, call <code>portmap</code> with the following request configuration, <code>CNI_COMMAND=DEL</code>:</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;cniVersion&quot;: &quot;1.0.0&quot;,</span><br><span class=\"line\">  &quot;name&quot;: &quot;dbnet&quot;,</span><br><span class=\"line\">  &quot;type&quot;: &quot;portmap&quot;,</span><br><span class=\"line\">  &quot;runtimeConfig&quot;: &#123;</span><br><span class=\"line\">    &quot;portMappings&quot; : [</span><br><span class=\"line\">      &#123; &quot;hostPort&quot;: 8080, &quot;containerPort&quot;: 80, &quot;protocol&quot;: &quot;tcp&quot; &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;prevResult&quot;: &#123;</span><br><span class=\"line\">    &quot;ips&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;address&quot;: &quot;10.1.0.5/16&quot;,</span><br><span class=\"line\">          &quot;gateway&quot;: &quot;10.1.0.1&quot;,</span><br><span class=\"line\">          &quot;interface&quot;: 2</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;routes&quot;: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;dst&quot;: &quot;0.0.0.0/0&quot;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;interfaces&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;cni0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;00:11:22:33:44:55&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;veth3243&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;55:44:33:22:11:11&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;eth0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;00:11:22:33:44:66&quot;,</span><br><span class=\"line\">            &quot;sandbox&quot;: &quot;/var/run/netns/blue&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;dns&quot;: &#123;</span><br><span class=\"line\">      &quot;nameservers&quot;: [ &quot;10.1.0.1&quot; ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>Next, call the <code>tuning</code> plugin with the following request configuration, <code>CNI_COMMAND=DEL</code>:</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;cniVersion&quot;: &quot;1.0.0&quot;,</span><br><span class=\"line\">  &quot;name&quot;: &quot;dbnet&quot;,</span><br><span class=\"line\">  &quot;type&quot;: &quot;tuning&quot;,</span><br><span class=\"line\">  &quot;sysctl&quot;: &#123;</span><br><span class=\"line\">    &quot;net.core.somaxconn&quot;: &quot;500&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;runtimeConfig&quot;: &#123;</span><br><span class=\"line\">    &quot;mac&quot;: &quot;00:11:22:33:44:66&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;prevResult&quot;: &#123;</span><br><span class=\"line\">    &quot;ips&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;address&quot;: &quot;10.1.0.5/16&quot;,</span><br><span class=\"line\">          &quot;gateway&quot;: &quot;10.1.0.1&quot;,</span><br><span class=\"line\">          &quot;interface&quot;: 2</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;routes&quot;: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;dst&quot;: &quot;0.0.0.0/0&quot;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;interfaces&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;cni0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;00:11:22:33:44:55&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;veth3243&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;55:44:33:22:11:11&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;eth0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;00:11:22:33:44:66&quot;,</span><br><span class=\"line\">            &quot;sandbox&quot;: &quot;/var/run/netns/blue&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;dns&quot;: &#123;</span><br><span class=\"line\">      &quot;nameservers&quot;: [ &quot;10.1.0.1&quot; ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>Finally, call <code>bridge</code>:</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;cniVersion&quot;: &quot;1.0.0&quot;,</span><br><span class=\"line\">  &quot;name&quot;: &quot;dbnet&quot;,</span><br><span class=\"line\">  &quot;type&quot;: &quot;bridge&quot;,</span><br><span class=\"line\">  &quot;bridge&quot;: &quot;cni0&quot;,</span><br><span class=\"line\">  &quot;keyA&quot;: [&quot;some more&quot;, &quot;plugin specific&quot;, &quot;configuration&quot;],</span><br><span class=\"line\">  &quot;ipam&quot;: &#123;</span><br><span class=\"line\">    &quot;type&quot;: &quot;host-local&quot;,</span><br><span class=\"line\">    &quot;subnet&quot;: &quot;10.1.0.0/16&quot;,</span><br><span class=\"line\">    &quot;gateway&quot;: &quot;10.1.0.1&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;dns&quot;: &#123;</span><br><span class=\"line\">    &quot;nameservers&quot;: [ &quot;10.1.0.1&quot; ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;prevResult&quot;: &#123;</span><br><span class=\"line\">    &quot;ips&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;address&quot;: &quot;10.1.0.5/16&quot;,</span><br><span class=\"line\">          &quot;gateway&quot;: &quot;10.1.0.1&quot;,</span><br><span class=\"line\">          &quot;interface&quot;: 2</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;routes&quot;: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;dst&quot;: &quot;0.0.0.0/0&quot;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;interfaces&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;cni0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;00:11:22:33:44:55&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;veth3243&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;55:44:33:22:11:11&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;eth0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;00:11:22:33:44:66&quot;,</span><br><span class=\"line\">            &quot;sandbox&quot;: &quot;/var/run/netns/blue&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;dns&quot;: &#123;</span><br><span class=\"line\">      &quot;nameservers&quot;: [ &quot;10.1.0.1&quot; ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>The bridge plugin executes the <code>host-local</code> delegated plugin with <code>CNI_COMMAND=DEL</code> before returning.</p>\n<hr>\n<h2 id=\"相关仓库及文献\"><a href=\"#相关仓库及文献\" class=\"headerlink\" title=\"相关仓库及文献\"></a>相关仓库及文献</h2><p><a href=\"https://github.com/containernetworking/cni/blob/spec-v1.0.0/SPEC.md\">cni/SPEC.md at spec-v1.0.0 · containernetworking/cni (github.com)</a></p>\n<p><a href=\"https://lengrongfu.github.io/2022-05-11-k8s%E4%B9%8BCNI%E8%A7%84%E8%8C%83%E8%A7%A3%E8%AF%BB/\">Kubernetes网络之CNI规范解读 | LRF (lengrongfu.github.io)</a></p>\n<p><a href=\"https://www.redhat.com/sysadmin/cni-kubernetes\">A brief overview of the Container Network Interface (CNI) in Kubernetes | Enable Sysadmin (redhat.com)</a></p>\n<p><a href=\"https://learn.microsoft.com/en-us/azure/aks/use-byo-cni?tabs=azure-cli\">Bring your own Container Network Interface (CNI) plugin - Azure Kubernetes Service | Microsoft Learn</a></p>\n<p><a href=\"https://kubernetes.io/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/\">Network Plugins | Kubernetes</a></p>\n<p><a href=\"https://www.tigera.io/learn/guides/kubernetes-networking/kubernetes-cni/\">Kubernetes CNI Explained (tigera.io)</a></p>\n","site":{"data":{}},"cover":"/img/cover/sky2.png","cover_type":"img","excerpt":"","more":"<h1 id=\"CNI-概述\"><a href=\"#CNI-概述\" class=\"headerlink\" title=\"CNI 概述\"></a>CNI 概述</h1><h2 id=\"什么是-CNI\"><a href=\"#什么是-CNI\" class=\"headerlink\" title=\"什么是 CNI\"></a>什么是 CNI</h2><blockquote>\n<p>CNI的全称是 Container Network Interface，它为<strong>容器提供了一种基于插件结构的标准化网络解决方案</strong>。以往，容器的网络层是和具体的底层网络环境高度相关的，不同的网络服务提供商有不同的实现。<strong>CNI从网络服务里抽象出了一套标准接口</strong>，从而屏蔽了上层网络和底层网络提供商的网络实现之间的差异。并且，通过插件结构，它让容器在网络层的具体实现变得可插拔了，所以非常灵活。</p>\n</blockquote>\n<p>首先 CNI 是一套标准接口，它隶属于<a href=\"https://cncf.io/\">CNCF(Cloud Native Computing Foundation)</a>，依照这个标准所实现的为 CNI Plugins, 他们彼此独立，也可以组合起来一起使用，由一组用于配置 Linux 容器的网络接口的规范和库组成，同时还包含了一些插件，CNI 仅关心容器创建时的网络分配，和当容器被删除时释放网络资源。</p>\n<p>其次 依据 CNI 的<a href=\"https://github.com/containernetworking/cni/blob/master/SPEC.md\">规范</a>，CNI 具有以下几点特征：</p>\n<ul>\n<li>CNI 需提供网络管理员<strong>定义网络配置的文件格式</strong></li>\n<li>CNI 需提供 Container Runtime（CRI） 调用功能的<strong>协议/API</strong>。</li>\n<li>当 CNI 被 CRI 调用时，需依据配置文件执行网络配置功能</li>\n<li>CNI 需预留可调用其他插件的能力</li>\n<li>CNI 需规范统一返回给CRI 的数据格式</li>\n</ul>\n<p>依据这样的特征和要求，可以明确实现一个CNI插件需要包含以下部分：</p>\n<ul>\n<li>可执行文件<ul>\n<li>CNI 主进程</li>\n<li>IPAM 等</li>\n</ul>\n</li>\n<li>网络配置文件</li>\n</ul>\n<hr>\n<h2 id=\"CNI-的功能\"><a href=\"#CNI-的功能\" class=\"headerlink\" title=\"CNI 的功能\"></a>CNI 的功能</h2><p>CNI 插件首先得实现一个可以被容器管理系统（CRI），比如rkt、Kubernetes 所调用的可执行文件——cni plugins，这个插件首先需要提供<strong>基础的 Linux 网络联通服务</strong>，比如创建 veth 或者 bridge 并将 veth 对的一端插入容器的 network namespace，一端插入 bridge，使得容器之间可以相互通信。然后<strong>将IP 分配给接口</strong>，并通过调用 **IPAM **插件来设置和管理IP地址，使得集群内的容器IP地址相互不重复，或者是结合其他的插件来实现更加复杂的网络路由管理功能等等。</p>\n<p>那么接下来，依据对于这几项功能的要求，来具体看看 CNI 的标准</p>\n<hr>\n<h2 id=\"CNI-统一的网络配置文件\"><a href=\"#CNI-统一的网络配置文件\" class=\"headerlink\" title=\"CNI 统一的网络配置文件\"></a>CNI 统一的网络配置文件</h2><p>CNI 为容器网络管理员(操作人员、网络插件、网络编排系统)定义了一种网络配置格式。它包含了供 CRI 和 CNI 插件使用的指令。在插件执行时，这种配置格式由 CRI 解释，并转化为代码数据结构，传递给 CNI 插件。</p>\n<p>一般来说配置文件主要是以 JSON 文件为主，且包含以下几个键值：</p>\n<ul>\n<li><code>cniVersion</code>: 指定CNI规范的版本，这样 CRI 和 CNI 才能读懂彼此</li>\n<li><code>Name</code>: 网络名字，这在一个主机（或其他管理域）的所有网络配置中应该是唯一的。必须以一个字母数字字符开始，后面可以选择由一个或多个字母数字字符、下划线、点（.）或连字符（-）的任何组合。</li>\n<li><code>disableCheck</code>: 是否禁用检查网络，如果为true,则 <code>container runtime</code> 不会调用 Check 方法进行网络检查。</li>\n<li><code>plugin</code>: cni插件及其配置列表，可以配置多个插件。</li>\n</ul>\n<p>接着展开说明一下 plugin 当中的参数，这也与实现 CNI 的功能息息相关，CRI 解析出配置文件当中的这个字段，是必须要一个字不漏地完整交给 CNI 插件来做网络管理</p>\n<ol>\n<li><p>必须配置的键值</p>\n<p><code>type</code> :  指定目前系统目录当中所使用的 CNI 插件，一般是 cni 可执行文件的目录索引</p>\n<p>至少得有一个基础的 cni 插件来完成最基础的 Linux 网络配置的功能</p>\n</li>\n<li><p>可选键值，由 CRI 依据协议发送的 request 指定</p>\n<p><code>capabilities</code>:  如果 CNI_ARGS 中没有指定此项功能时候来补充的</p>\n</li>\n<li><p>预留键值，由 CRI 在执行时产生的</p>\n<ul>\n<li><code>runtimeConfig</code> :  比如 CNI 自己设置的 isGateway == true 就表明告诉插件，作为网关，给bridge指定一个IP地址。这样，连接到bridge的容器就可以拿它当网关来用了。</li>\n<li><code>args</code></li>\n<li>或者是任何以 <code>cni.dev/</code>开头的</li>\n</ul>\n</li>\n<li><p>可选键值,由容器网络管理员添加</p>\n<p><code>ipMasq</code>: 为目标网络配上Outbound Masquerade(地址伪装)，即：由容器内部通过网关向外发送数据包时，对数据包的源IP地址进行修改。</p>\n<p>当我们的容器以宿主机作为网关时，这个参数是必须要设置的。否则，从容器内部发出的数据包就没有办法通过网关路由到其他网段。因为容器内部的IP地址无法被目标网段识别，所以这些数据包最终会被丢弃掉。</p>\n<p><code>ipam</code>: PAM(IP Adderss Management)即IP地址管理，提供了一系列方法用于对IP和路由进行管理。实际上，它对应的是由CNI提供的一组标准IPAM插件，比如像host-local，dhcp，static等。如果要对整个集群的地址做管理，让pod具有单独的ip地址，就需要在这里添加额外的插件</p>\n<blockquote>\n<p>例子1当中：</p>\n<ul>\n<li>type：指定所用IPAM插件的名称，在例子里，用的是host-local。</li>\n<li>subnet：为目标网络分配网段，包括网络ID和子网掩码，以CIDR形式标记。在例子里为<code>10.15.10.0/24</code>，也就是目标网段为<code>10.15.10.0</code>，子网掩码为<code>255.255.255.0</code>。</li>\n<li>routes：用于指定路由规则，插件会在容器的路由表里生成相应的规则。其中，dst表示希望到达的目标网段，以CIDR形式标记。gw对应网关的IP地址，也就是要到达目标网段所要经过的“next hop(下一跳)”。如果省略gw的话，那么插件会自动帮容器选择默认网关。在例子里，gw选择的是默认网关，而dst为<code>0.0.0.0/0</code>则代表“任何网络”，表示数据包将通过默认网关发往任何网络。实际上，这对应的是一条默认路由规则，即：当所有其他路由规则都不匹配时，将选择该路由。</li>\n<li>rangeStart：允许分配的IP地址范围的起始值</li>\n<li>rangeEnd：允许分配的IP地址范围的结束值</li>\n<li>gateway：为网关（也就是将要在宿主机上创建的bridge）指定的IP地址。如果省略的话，那么插件会自动从允许分配的IP地址范围内选择起始值作为网关的IP地址。</li>\n</ul>\n</blockquote>\n</li>\n</ol>\n<p>配置文件例子如下：</p>\n<p>例子1：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;cniVersion&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;0.4.0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;lab-br0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;bridge&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;bridge&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;lab-br0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;isGateway&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;ipMasq&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;ipam&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;host-local&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;subnet&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;10.15.10.0/24&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;routes&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">            <span class=\"punctuation\">&#123;</span> <span class=\"attr\">&quot;dst&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;0.0.0.0/0&quot;</span> <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">        <span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;rangeStart&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;10.15.10.100&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;rangeEnd&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;10.15.10.200&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;gateway&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;10.15.10.99&quot;</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>例子2：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;cniVersion&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;1.0.0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;dbnet&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;plugins&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;bridge&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"comment\">// plugin specific parameters</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;bridge&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;cni0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;keyA&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span><span class=\"string\">&quot;some more&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;plugin specific&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;configuration&quot;</span><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"attr\">&quot;ipam&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;host-local&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"comment\">// ipam specific</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;subnet&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;10.1.0.0/16&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;gateway&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;10.1.0.1&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;routes&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">            <span class=\"punctuation\">&#123;</span><span class=\"attr\">&quot;dst&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;0.0.0.0/0&quot;</span><span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">        <span class=\"punctuation\">]</span></span><br><span class=\"line\">      <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;dns&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;nameservers&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span> <span class=\"string\">&quot;10.1.0.1&quot;</span> <span class=\"punctuation\">]</span></span><br><span class=\"line\">      <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;tuning&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;capabilities&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;mac&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span></span><br><span class=\"line\">      <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;sysctl&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;net.core.somaxconn&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;500&quot;</span></span><br><span class=\"line\">      <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;portmap&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;capabilities&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span><span class=\"attr\">&quot;portMappings&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">  <span class=\"punctuation\">]</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"CNI-运行时协议\"><a href=\"#CNI-运行时协议\" class=\"headerlink\" title=\"CNI 运行时协议\"></a>CNI 运行时协议</h2><p>CNI协议是基于由 CRI 的调用请求来告诉 CNI 该做些什么。</p>\n<p>主要的协议参数定义如下：</p>\n<ul>\n<li>CNI_COMMAND：表示所需的操作；ADD、DEL、CHECK、或VERSION。</li>\n<li>CNI_CONTAINERID：容器ID。告诉CNI插件，将要加入目标网络的容器所对应的network namespace的ID,容器的唯一的标识符，由 CRI 分配。不能是空的。必须以一个字母数字字符开始，后面可以选择一个或多个字母数字字符、下划线（）、点（.）或连字符（-）的任何组合。</li>\n<li>CNI_NETNS：容器对应的network namespace在宿主机上的文件路径。（例如：/run/netns/[nsname]）。</li>\n<li>CNI_IFNAME：作为veth pair在容器一端的网络接口,一般是在容器内创建的接口的名称；如果 CNI 插件无法使用这个接口名称，那么就必须返回一个错误。</li>\n<li>CNI_ARGS：用户在调用时传入的额外参数。用分号分隔的字母数字键值对；例如，”FOO=BAR;ABC=123”</li>\n<li>CNI_PATH: 表示 CNI 插件可执行文件的路径列表。路径由操作系统特定的列表分隔符分隔；例如Linux上的’:’和Windows上的’；’。</li>\n</ul>\n<p>告诉CNI插件要执行的命令，允许的命令有ADD，DEL，CHECK，VERSION。</p>\n<p>对于支持CNI规范的容器系统而言，当容器启动的时候，系统就会自动调用相应的CNI插件，并设置CNI_COMMAND为ADD。相应地，DEL是在容器被销毁时调用的，用于清除在执行ADD阶段分配的网络资源。CHECK用于检查容器网络是否正常。VERSION则用来显示插件的版本。具体的操作如下：</p>\n<ul>\n<li><p>ADD</p>\n<ul>\n<li><p>将容器添加到网络中，或将新的配置修改应用到已有的集群当中。</p>\n</li>\n<li><p>一个CNI插件在收到ADD命令后，应该选择</p>\n<ul>\n<li><p>在 CNI_NETNS 的容器内创建由 CNI_IFNAME 定义的接口，</p>\n</li>\n<li><p>调整容器内 CNI_NETNS 处由CNI_IFNAME定义的接口的配置</p>\n<p>如果CNI插件成功，必须要返回一个处理结果，要么打印出来，要么修改传入的参数。</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>DELETE</p>\n<ul>\n<li><p>将容器删除出网络，或将新的配置修改应用到已有的集群当中。</p>\n<p>功能与ADD 相对</p>\n</li>\n</ul>\n</li>\n<li><p>CHECK</p>\n<ul>\n<li>查找类型字段中指定的可执行文件，如果没找到返回错误</li>\n<li>当 Plugins （CNI调用的其他的Plugins）返回错误时，将其返回给调用者</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"CNI-与插件\"><a href=\"#CNI-与插件\" class=\"headerlink\" title=\"CNI 与插件\"></a>CNI 与插件</h2><p>为了解决容器网络的各项需求和问题，将所有的功能单独集中在 CNI 单个程序中是不现实的，而且难以兼容不同的上层系统和底层的网络管理，于是一个显然的想法就是将这些功能独立出来，使用插件（Plugins）的形式来执行。</p>\n<p>一个常见的例子就是 IP 地址管理，这就是IP地址管理插件（IPAM插件），它必须设置容器和虚拟网络设备的接口 ，IP / 子网，网关和路由，然后将此信息返回给“主”插件（CNI本体）来执行，换句话说 IPAM 做逻辑上的网络地址管理然后告诉本体 CNI 去执行 <code>ADD</code>,<code>DELETE</code>。 </p>\n<p>CNI 本体调用这些插件的形式也是通过路径找到这些插件的可执行文件来实现的，一般这些插件的位置也都一起放置在 <code>CNI_PATH</code>之下。同时插件和 CNI 本体都是通过 stdin 接收网络配置，也通过 stdout 输出结果。</p>\n<p>如此看来 CNI 的工作流程就是一条链状的调用过程，但调用链中的每一个可执行程序所接收的配置文件信息都是完整的。</p>\n<hr>\n<h1 id=\"CNI-配置文件样例\"><a href=\"#CNI-配置文件样例\" class=\"headerlink\" title=\"CNI 配置文件样例\"></a>CNI 配置文件样例</h1><blockquote>\n<p>参考<a href=\"https://github.com/containernetworking/cni/blob/spec-v1.0.0/SPEC.md\">cni/SPEC.md at spec-v1.0.0 · containernetworking/cni (github.com)</a> 的 Appendix: Examples</p>\n</blockquote>\n<p>借助 Github 所给的 SPEC 例子，假设目前 CRI 接收到的 json 文件如下，</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;cniVersion&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;1.0.0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;dbnet&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;plugins&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;bridge&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"comment\">// plugin specific parameters</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;bridge&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;cni0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;keyA&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span><span class=\"string\">&quot;some more&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;plugin specific&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;configuration&quot;</span><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"attr\">&quot;ipam&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;host-local&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"comment\">// ipam specific</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;subnet&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;10.1.0.0/16&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;gateway&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;10.1.0.1&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;routes&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">            <span class=\"punctuation\">&#123;</span><span class=\"attr\">&quot;dst&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;0.0.0.0/0&quot;</span><span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">        <span class=\"punctuation\">]</span></span><br><span class=\"line\">      <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;dns&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;nameservers&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span> <span class=\"string\">&quot;10.1.0.1&quot;</span> <span class=\"punctuation\">]</span></span><br><span class=\"line\">      <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;tuning&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;capabilities&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;mac&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span></span><br><span class=\"line\">      <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;sysctl&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;net.core.somaxconn&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;500&quot;</span></span><br><span class=\"line\">      <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;portmap&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;capabilities&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span><span class=\"attr\">&quot;portMappings&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">  <span class=\"punctuation\">]</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Add-example\"><a href=\"#Add-example\" class=\"headerlink\" title=\"Add example\"></a>Add example</h3><p>The container runtime would perform the following steps for the <code>add</code> operation.</p>\n<ol>\n<li>Call the <code>bridge</code> plugin with the following JSON, <code>CNI_COMMAND=ADD</code>:</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;cniVersion&quot;: &quot;1.0.0&quot;,</span><br><span class=\"line\">    &quot;name&quot;: &quot;dbnet&quot;,</span><br><span class=\"line\">    &quot;type&quot;: &quot;bridge&quot;,</span><br><span class=\"line\">    &quot;bridge&quot;: &quot;cni0&quot;,</span><br><span class=\"line\">    &quot;keyA&quot;: [&quot;some more&quot;, &quot;plugin specific&quot;, &quot;configuration&quot;],</span><br><span class=\"line\">    &quot;ipam&quot;: &#123;</span><br><span class=\"line\">        &quot;type&quot;: &quot;host-local&quot;,</span><br><span class=\"line\">        &quot;subnet&quot;: &quot;10.1.0.0/16&quot;,</span><br><span class=\"line\">        &quot;gateway&quot;: &quot;10.1.0.1&quot;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;dns&quot;: &#123;</span><br><span class=\"line\">        &quot;nameservers&quot;: [ &quot;10.1.0.1&quot; ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>The bridge plugin, as it delegates IPAM to the <code>host-local</code> plugin, would execute the <code>host-local</code> binary with the exact same input, <code>CNI_COMMAND=ADD</code>.</p>\n<p>The <code>host-local</code> plugin returns the following result:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;ips&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;address&quot;: &quot;10.1.0.5/16&quot;,</span><br><span class=\"line\">          &quot;gateway&quot;: &quot;10.1.0.1&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;routes&quot;: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;dst&quot;: &quot;0.0.0.0/0&quot;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;dns&quot;: &#123;</span><br><span class=\"line\">      &quot;nameservers&quot;: [ &quot;10.1.0.1&quot; ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>The bridge plugin returns the following result, configuring the interface according to the delegated IPAM configuration:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;ips&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;address&quot;: &quot;10.1.0.5/16&quot;,</span><br><span class=\"line\">          &quot;gateway&quot;: &quot;10.1.0.1&quot;,</span><br><span class=\"line\">          &quot;interface&quot;: 2</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;routes&quot;: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;dst&quot;: &quot;0.0.0.0/0&quot;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;interfaces&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;cni0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;00:11:22:33:44:55&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;veth3243&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;55:44:33:22:11:11&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;eth0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;99:88:77:66:55:44&quot;,</span><br><span class=\"line\">            &quot;sandbox&quot;: &quot;/var/run/netns/blue&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;dns&quot;: &#123;</span><br><span class=\"line\">      &quot;nameservers&quot;: [ &quot;10.1.0.1&quot; ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>Next, call the <code>tuning</code> plugin, with <code>CNI_COMMAND=ADD</code>. Note that <code>prevResult</code> is supplied, along with the <code>mac</code> capability argument. The request configuration passed is:</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;cniVersion&quot;: &quot;1.0.0&quot;,</span><br><span class=\"line\">  &quot;name&quot;: &quot;dbnet&quot;,</span><br><span class=\"line\">  &quot;type&quot;: &quot;tuning&quot;,</span><br><span class=\"line\">  &quot;sysctl&quot;: &#123;</span><br><span class=\"line\">    &quot;net.core.somaxconn&quot;: &quot;500&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;runtimeConfig&quot;: &#123;</span><br><span class=\"line\">    &quot;mac&quot;: &quot;00:11:22:33:44:66&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;prevResult&quot;: &#123;</span><br><span class=\"line\">    &quot;ips&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;address&quot;: &quot;10.1.0.5/16&quot;,</span><br><span class=\"line\">          &quot;gateway&quot;: &quot;10.1.0.1&quot;,</span><br><span class=\"line\">          &quot;interface&quot;: 2</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;routes&quot;: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;dst&quot;: &quot;0.0.0.0/0&quot;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;interfaces&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;cni0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;00:11:22:33:44:55&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;veth3243&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;55:44:33:22:11:11&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;eth0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;99:88:77:66:55:44&quot;,</span><br><span class=\"line\">            &quot;sandbox&quot;: &quot;/var/run/netns/blue&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;dns&quot;: &#123;</span><br><span class=\"line\">      &quot;nameservers&quot;: [ &quot;10.1.0.1&quot; ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>The plugin returns the following result. Note that the <strong>mac</strong> has changed.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;ips&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;address&quot;: &quot;10.1.0.5/16&quot;,</span><br><span class=\"line\">          &quot;gateway&quot;: &quot;10.1.0.1&quot;,</span><br><span class=\"line\">          &quot;interface&quot;: 2</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;routes&quot;: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;dst&quot;: &quot;0.0.0.0/0&quot;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;interfaces&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;cni0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;00:11:22:33:44:55&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;veth3243&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;55:44:33:22:11:11&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;eth0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;00:11:22:33:44:66&quot;,</span><br><span class=\"line\">            &quot;sandbox&quot;: &quot;/var/run/netns/blue&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;dns&quot;: &#123;</span><br><span class=\"line\">      &quot;nameservers&quot;: [ &quot;10.1.0.1&quot; ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>Finally, call the <code>portmap</code> plugin, with <code>CNI_COMMAND=ADD</code>. Note that <code>prevResult</code> matches that returned by <code>tuning</code>:</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;cniVersion&quot;: &quot;1.0.0&quot;,</span><br><span class=\"line\">  &quot;name&quot;: &quot;dbnet&quot;,</span><br><span class=\"line\">  &quot;type&quot;: &quot;portmap&quot;,</span><br><span class=\"line\">  &quot;runtimeConfig&quot;: &#123;</span><br><span class=\"line\">    &quot;portMappings&quot; : [</span><br><span class=\"line\">      &#123; &quot;hostPort&quot;: 8080, &quot;containerPort&quot;: 80, &quot;protocol&quot;: &quot;tcp&quot; &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;prevResult&quot;: &#123;</span><br><span class=\"line\">    &quot;ips&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;address&quot;: &quot;10.1.0.5/16&quot;,</span><br><span class=\"line\">          &quot;gateway&quot;: &quot;10.1.0.1&quot;,</span><br><span class=\"line\">          &quot;interface&quot;: 2</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;routes&quot;: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;dst&quot;: &quot;0.0.0.0/0&quot;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;interfaces&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;cni0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;00:11:22:33:44:55&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;veth3243&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;55:44:33:22:11:11&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;eth0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;00:11:22:33:44:66&quot;,</span><br><span class=\"line\">            &quot;sandbox&quot;: &quot;/var/run/netns/blue&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;dns&quot;: &#123;</span><br><span class=\"line\">      &quot;nameservers&quot;: [ &quot;10.1.0.1&quot; ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>The <code>portmap</code> plugin outputs the exact same result as that returned by <code>bridge</code>, as the plugin has not modified anything that would change the result (i.e. it only created iptables rules).</p>\n<h3 id=\"Check-example\"><a href=\"#Check-example\" class=\"headerlink\" title=\"Check example\"></a>Check example</h3><p>Given the previous <em>Add</em>, the container runtime would perform the following steps for the <em>Check</em> action:</p>\n<ol>\n<li>First call the <code>bridge</code> plugin with the following request configuration, including the <code>prevResult</code> field containing the final JSON response from the <em>Add</em> operation, <strong>including the changed mac</strong>. <code>CNI_COMMAND=CHECK</code></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;cniVersion&quot;: &quot;1.0.0&quot;,</span><br><span class=\"line\">  &quot;name&quot;: &quot;dbnet&quot;,</span><br><span class=\"line\">  &quot;type&quot;: &quot;bridge&quot;,</span><br><span class=\"line\">  &quot;bridge&quot;: &quot;cni0&quot;,</span><br><span class=\"line\">  &quot;keyA&quot;: [&quot;some more&quot;, &quot;plugin specific&quot;, &quot;configuration&quot;],</span><br><span class=\"line\">  &quot;ipam&quot;: &#123;</span><br><span class=\"line\">    &quot;type&quot;: &quot;host-local&quot;,</span><br><span class=\"line\">    &quot;subnet&quot;: &quot;10.1.0.0/16&quot;,</span><br><span class=\"line\">    &quot;gateway&quot;: &quot;10.1.0.1&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;dns&quot;: &#123;</span><br><span class=\"line\">    &quot;nameservers&quot;: [ &quot;10.1.0.1&quot; ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;prevResult&quot;: &#123;</span><br><span class=\"line\">    &quot;ips&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;address&quot;: &quot;10.1.0.5/16&quot;,</span><br><span class=\"line\">          &quot;gateway&quot;: &quot;10.1.0.1&quot;,</span><br><span class=\"line\">          &quot;interface&quot;: 2</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;routes&quot;: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;dst&quot;: &quot;0.0.0.0/0&quot;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;interfaces&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;cni0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;00:11:22:33:44:55&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;veth3243&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;55:44:33:22:11:11&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;eth0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;00:11:22:33:44:66&quot;,</span><br><span class=\"line\">            &quot;sandbox&quot;: &quot;/var/run/netns/blue&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;dns&quot;: &#123;</span><br><span class=\"line\">      &quot;nameservers&quot;: [ &quot;10.1.0.1&quot; ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>The <code>bridge</code> plugin, as it delegates IPAM, calls <code>host-local</code>, <code>CNI_COMMAND=CHECK</code>. It returns no error.</p>\n<p>Assuming the <code>bridge</code> plugin is satisfied, it produces no output on standard out and exits with a 0 return code.</p>\n<ol>\n<li>Next call the <code>tuning</code> plugin with the following request configuration:</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;cniVersion&quot;: &quot;1.0.0&quot;,</span><br><span class=\"line\">  &quot;name&quot;: &quot;dbnet&quot;,</span><br><span class=\"line\">  &quot;type&quot;: &quot;tuning&quot;,</span><br><span class=\"line\">  &quot;sysctl&quot;: &#123;</span><br><span class=\"line\">    &quot;net.core.somaxconn&quot;: &quot;500&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;runtimeConfig&quot;: &#123;</span><br><span class=\"line\">    &quot;mac&quot;: &quot;00:11:22:33:44:66&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;prevResult&quot;: &#123;</span><br><span class=\"line\">    &quot;ips&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;address&quot;: &quot;10.1.0.5/16&quot;,</span><br><span class=\"line\">          &quot;gateway&quot;: &quot;10.1.0.1&quot;,</span><br><span class=\"line\">          &quot;interface&quot;: 2</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;routes&quot;: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;dst&quot;: &quot;0.0.0.0/0&quot;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;interfaces&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;cni0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;00:11:22:33:44:55&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;veth3243&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;55:44:33:22:11:11&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;eth0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;00:11:22:33:44:66&quot;,</span><br><span class=\"line\">            &quot;sandbox&quot;: &quot;/var/run/netns/blue&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;dns&quot;: &#123;</span><br><span class=\"line\">      &quot;nameservers&quot;: [ &quot;10.1.0.1&quot; ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Likewise, the <code>tuning</code> plugin exits indicating success.</p>\n<ol>\n<li>Finally, call <code>portmap</code> with the following request configuration:</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;cniVersion&quot;: &quot;1.0.0&quot;,</span><br><span class=\"line\">  &quot;name&quot;: &quot;dbnet&quot;,</span><br><span class=\"line\">  &quot;type&quot;: &quot;portmap&quot;,</span><br><span class=\"line\">  &quot;runtimeConfig&quot;: &#123;</span><br><span class=\"line\">    &quot;portMappings&quot; : [</span><br><span class=\"line\">      &#123; &quot;hostPort&quot;: 8080, &quot;containerPort&quot;: 80, &quot;protocol&quot;: &quot;tcp&quot; &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;prevResult&quot;: &#123;</span><br><span class=\"line\">    &quot;ips&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;address&quot;: &quot;10.1.0.5/16&quot;,</span><br><span class=\"line\">          &quot;gateway&quot;: &quot;10.1.0.1&quot;,</span><br><span class=\"line\">          &quot;interface&quot;: 2</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;routes&quot;: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;dst&quot;: &quot;0.0.0.0/0&quot;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;interfaces&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;cni0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;00:11:22:33:44:55&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;veth3243&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;55:44:33:22:11:11&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;eth0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;00:11:22:33:44:66&quot;,</span><br><span class=\"line\">            &quot;sandbox&quot;: &quot;/var/run/netns/blue&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;dns&quot;: &#123;</span><br><span class=\"line\">      &quot;nameservers&quot;: [ &quot;10.1.0.1&quot; ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Delete-example\"><a href=\"#Delete-example\" class=\"headerlink\" title=\"Delete example\"></a>Delete example</h3><p>Given the same network configuration JSON list, the container runtime would perform the following steps for the <em>Delete</em> action. Note that plugins are executed in reverse order from the <em>Add</em> and <em>Check</em> actions.</p>\n<ol>\n<li>First, call <code>portmap</code> with the following request configuration, <code>CNI_COMMAND=DEL</code>:</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;cniVersion&quot;: &quot;1.0.0&quot;,</span><br><span class=\"line\">  &quot;name&quot;: &quot;dbnet&quot;,</span><br><span class=\"line\">  &quot;type&quot;: &quot;portmap&quot;,</span><br><span class=\"line\">  &quot;runtimeConfig&quot;: &#123;</span><br><span class=\"line\">    &quot;portMappings&quot; : [</span><br><span class=\"line\">      &#123; &quot;hostPort&quot;: 8080, &quot;containerPort&quot;: 80, &quot;protocol&quot;: &quot;tcp&quot; &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;prevResult&quot;: &#123;</span><br><span class=\"line\">    &quot;ips&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;address&quot;: &quot;10.1.0.5/16&quot;,</span><br><span class=\"line\">          &quot;gateway&quot;: &quot;10.1.0.1&quot;,</span><br><span class=\"line\">          &quot;interface&quot;: 2</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;routes&quot;: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;dst&quot;: &quot;0.0.0.0/0&quot;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;interfaces&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;cni0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;00:11:22:33:44:55&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;veth3243&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;55:44:33:22:11:11&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;eth0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;00:11:22:33:44:66&quot;,</span><br><span class=\"line\">            &quot;sandbox&quot;: &quot;/var/run/netns/blue&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;dns&quot;: &#123;</span><br><span class=\"line\">      &quot;nameservers&quot;: [ &quot;10.1.0.1&quot; ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>Next, call the <code>tuning</code> plugin with the following request configuration, <code>CNI_COMMAND=DEL</code>:</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;cniVersion&quot;: &quot;1.0.0&quot;,</span><br><span class=\"line\">  &quot;name&quot;: &quot;dbnet&quot;,</span><br><span class=\"line\">  &quot;type&quot;: &quot;tuning&quot;,</span><br><span class=\"line\">  &quot;sysctl&quot;: &#123;</span><br><span class=\"line\">    &quot;net.core.somaxconn&quot;: &quot;500&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;runtimeConfig&quot;: &#123;</span><br><span class=\"line\">    &quot;mac&quot;: &quot;00:11:22:33:44:66&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;prevResult&quot;: &#123;</span><br><span class=\"line\">    &quot;ips&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;address&quot;: &quot;10.1.0.5/16&quot;,</span><br><span class=\"line\">          &quot;gateway&quot;: &quot;10.1.0.1&quot;,</span><br><span class=\"line\">          &quot;interface&quot;: 2</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;routes&quot;: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;dst&quot;: &quot;0.0.0.0/0&quot;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;interfaces&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;cni0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;00:11:22:33:44:55&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;veth3243&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;55:44:33:22:11:11&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;eth0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;00:11:22:33:44:66&quot;,</span><br><span class=\"line\">            &quot;sandbox&quot;: &quot;/var/run/netns/blue&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;dns&quot;: &#123;</span><br><span class=\"line\">      &quot;nameservers&quot;: [ &quot;10.1.0.1&quot; ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>Finally, call <code>bridge</code>:</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;cniVersion&quot;: &quot;1.0.0&quot;,</span><br><span class=\"line\">  &quot;name&quot;: &quot;dbnet&quot;,</span><br><span class=\"line\">  &quot;type&quot;: &quot;bridge&quot;,</span><br><span class=\"line\">  &quot;bridge&quot;: &quot;cni0&quot;,</span><br><span class=\"line\">  &quot;keyA&quot;: [&quot;some more&quot;, &quot;plugin specific&quot;, &quot;configuration&quot;],</span><br><span class=\"line\">  &quot;ipam&quot;: &#123;</span><br><span class=\"line\">    &quot;type&quot;: &quot;host-local&quot;,</span><br><span class=\"line\">    &quot;subnet&quot;: &quot;10.1.0.0/16&quot;,</span><br><span class=\"line\">    &quot;gateway&quot;: &quot;10.1.0.1&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;dns&quot;: &#123;</span><br><span class=\"line\">    &quot;nameservers&quot;: [ &quot;10.1.0.1&quot; ]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;prevResult&quot;: &#123;</span><br><span class=\"line\">    &quot;ips&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;address&quot;: &quot;10.1.0.5/16&quot;,</span><br><span class=\"line\">          &quot;gateway&quot;: &quot;10.1.0.1&quot;,</span><br><span class=\"line\">          &quot;interface&quot;: 2</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;routes&quot;: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;dst&quot;: &quot;0.0.0.0/0&quot;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;interfaces&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;cni0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;00:11:22:33:44:55&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;veth3243&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;55:44:33:22:11:11&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;eth0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;00:11:22:33:44:66&quot;,</span><br><span class=\"line\">            &quot;sandbox&quot;: &quot;/var/run/netns/blue&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;dns&quot;: &#123;</span><br><span class=\"line\">      &quot;nameservers&quot;: [ &quot;10.1.0.1&quot; ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>The bridge plugin executes the <code>host-local</code> delegated plugin with <code>CNI_COMMAND=DEL</code> before returning.</p>\n<hr>\n<h2 id=\"相关仓库及文献\"><a href=\"#相关仓库及文献\" class=\"headerlink\" title=\"相关仓库及文献\"></a>相关仓库及文献</h2><p><a href=\"https://github.com/containernetworking/cni/blob/spec-v1.0.0/SPEC.md\">cni/SPEC.md at spec-v1.0.0 · containernetworking/cni (github.com)</a></p>\n<p><a href=\"https://lengrongfu.github.io/2022-05-11-k8s%E4%B9%8BCNI%E8%A7%84%E8%8C%83%E8%A7%A3%E8%AF%BB/\">Kubernetes网络之CNI规范解读 | LRF (lengrongfu.github.io)</a></p>\n<p><a href=\"https://www.redhat.com/sysadmin/cni-kubernetes\">A brief overview of the Container Network Interface (CNI) in Kubernetes | Enable Sysadmin (redhat.com)</a></p>\n<p><a href=\"https://learn.microsoft.com/en-us/azure/aks/use-byo-cni?tabs=azure-cli\">Bring your own Container Network Interface (CNI) plugin - Azure Kubernetes Service | Microsoft Learn</a></p>\n<p><a href=\"https://kubernetes.io/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/\">Network Plugins | Kubernetes</a></p>\n<p><a href=\"https://www.tigera.io/learn/guides/kubernetes-networking/kubernetes-cni/\">Kubernetes CNI Explained (tigera.io)</a></p>\n"},{"layout":"source/_posts/edgemesh/2023-ospp-fighting/","title":"创建简单的 CNI 插件","date":"2023-05-25T23:37:48.000Z","_content":"\n> 使用 Golang 实现一个简易的 CNI \n> 对于 CNI 的功能实现将按照循序渐进的方式来进行\n> 实现目标\n> * 依据 config 文件创建 bridge 对象并分配 ns 对应的 ip 地址\n> * 提供容器网络通信服务\n>\n\n##  设计简易的 CNI 工作逻辑\n由于 cni 提供的服务集中于节点的 L2/L3 层通信，所以基础的 cni 大致功能就是通过读取 config 文件配置在本地 Linux 环境当中给容器分配地址并通过 bridge 等设备建立通信能力。\n\n依据上一篇博客所学习到的 cni 规范，我们可以将 cni 的基础工作逻辑梳理如下：\n1. kubelet 先创建 pause 容器创建对应的网络命名空间；\n2. cri 或者是 cni 主程序根据配置调用具体的 CNI 插件，可以配置成 CNI 插件链来进行链式调用；\n3. 当 CNI 插件被调用时，通过传入配置以及命令行参数来获得网络命名空间、容器的网络设备等必要信息，然后执行 ADD 、 DELETE 或者其他操作；\n4. CNI 插件给 pause 容器配置正确的网络，pod 中其他的容器都是复用 pause 容器的网络；\n\n\n* 当容器准备创建或被终止时，cni 插件被 cri 或者是其他的 cni 插件调用执行功能。\n  * 当创建容器的时候，为容器分配网络资源，包括 IP 地址和网络连接\n  * 当销毁容器的时候，删除为容器分配的所有网络资源\n* cni 插件所获取的信息格式如下: (cri 调用或者是其他 cni 插件)\n  * cni 执行的命令和操作(cni必须要实现的核心可调用功能)\n    * ADD\n    * DELETE\n    * VERSION\n    * CHECK\n  * 容器ID(服务的容器对象ID)\n  * 节点容器所连接网络空间的路径\n  * 容器中需要创建的接口名称\n  * 目前节点内 cni 可执行程序所在路径，一般其他的 cni 插件也在这个路径(一般是`/opt/cni/bin`)\n  * cni 配置文件的路径\n\n而对于节点运行的 cri 调用 cni 服务，需要在路径中设置 cni 可调用的地址。如果是在 Kubernetes 集群当中， cni 以容器的形式来提供服务就需要在其创建了对应的网桥提供服务之后，设置 cni 当中获取服务的地址为该网桥所在网段。\n比如 Docker 当中设置 `vim /usr/lib/systemd/system/docker.service` 中 `--bip=10.244.12.1/24 ` 如下：\n``` shell\n[Service]\nType=notify\n# the default is not to use systemd for cgroups because the delegate issues still\n# exists and systemd currently does not support the cgroup feature set required\n# for containers run by docker\nExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock --bip=10.244.12.1/24 --mtu=1450\nExecReload=/bin/kill -s HUP $MAINPID\nTimeoutStartSec=0\nRestartSec=2\nRestart=always\n```\n\n\n## 代码实现\n\n\n### **Step1 : 创建 cni 主流程**\n\n首先，一个基本的 cni 需要完成在容器创建时候，依据传入参数为其分配网络资源；同时需要在容器终止时候，删除所有分配的资源。\n所以可以先得到一个最基本的 cni 主程序框架如下：\n``` golang\npackage main \n\nimport (\n    \"github.com/containernetworking/cni/pkg/skel\"\n    \"github.com/containernetworking/cni/pkg/version\"\n)\nfunc cmdAdd(args *skel.CmdArgs) error {\n    /**\n    TODO: add code about cmdAdd\n    */\n    // 测试是否 cni 接收到了传入的容器网络配置参数\n    fmt.Printf(\"interfance Name: %s\\n\", args.IfName)\n\t  fmt.Printf(\"Netns path: %s\\n\", args.Netns)\n\t  fmt.Printf(\"The config data: %s\\n\", args.StdinData)\n    return nil\n}\n\nfunc cmdDel(args *skel.CmdArgs) error {\n    /**\n    TODO: add code about cmdDel\n    */\n    return nil\n}\n\nfunc main(){\n    skel.PluginMain(cmdAdd, cmdDel, cmdVersion, cmdCheck)\n}\n\n```\n\n按照所归纳的 cni 逻辑，我们已经实现了一个基础的框架，并且可以接受传入的网络配置参数，但目前还没有执行任何的动作。\n\n传入的参数具体内容定义在 `pkg/skel/skel.go`:\n```golang\n// CmdArgs captures all the arguments passed in to the plugin\n// via both env vars and stdin\ntype CmdArgs struct {\n\tContainerID   string\n\tNetns         string\n\tIfName        string\n\tArgs          string\n\tPath          string\n\tNetnsOverride string\n\tStdinData     []byte\n}\n```\n\n当然 cni 接受参数的目的是去了解该创建怎样的容器网络。但是如何将这些参数传给 cni 呢？ 依据 cni 规范，我们需要从配置文件或者是 cri 传入参数中获取到对应的容器网络需求。顺带一提，在 Kubernetes 网络集群中，kubelet 也并不是直接与 cni 沟通的，所以 cni 本身可以在单节点上创建容器网络以及提供功能，只是说在集群当中可以结合 kubelet 提供 list/watch apiserver 的功能来做局域网内的地址管理和网络连通性，包括 ip capsulating， cidr 等等。\n\n接下来为检验以上的功能逻辑通畅，创建以下 config 文件：\n``` yaml\n{\n\t\"name\": \"mynet\",\n\t\"BridgeName\": \"test\",\n\t\"IP\": \"192.0.2.1/24\"\n}\n```\n那么接下来就可以，模拟 cri 调用 cni 通过 config 文件指定所创建的容器网络配置创建资源，所使用的指令如下：\n``` shell\n\tgo build -o example .\n\techo \"Ready to call the cni program and create resources\"\n\tsudo CNI_COMMAND=ADD CNI_CONTAINERID=ns1 CNI_NETNS=/var/run/netns/ns1 CNI_IFNAME=eth10 CNI_PATH=`pwd` ./example < config\n\techo \"The CNI has been called, see the following results\"\n```\n得到以下输出：\n``` shell\n[root@master knet]# ./run.sh\nReady to call the cni program and create resources\ninterfance Name: eth10\nnetns path: /var/run/netns/ns1\nthe config data: {\n        \"name\": \"mynet\",\n        \"BridgeName\": \"test\",\n        \"IP\": \"192.0.2.1/24\"\n}\nThe CNI has been called, see the following results\n```\n通过这个测试可以明确以上代码可以从命令行当中读取出对应的配置参数，不过仅只是将结果输出而已并没有做更多的操作，当然这并不可能是完整的 cni ，那接下来进一步实现当 cni 获取了这些参数之后该做些什么。\n\n\n### **step2: 实现 cmdAdd 功能**\n\n本文的目的还是在于理清楚 cni 执行的底层逻辑，所以就不深入探究 cni 的多样功能实现，所以以创建一个 Linux 网桥为目标，具体代码逻辑如下：\n\n1. 从配置中读取网桥信息。\n2. 获取我们想要使用的网桥名称。\n3. 如果系统中不存在该网桥，则创建它。\n\n由于 cni 的框架里面将配置内容以[]字节的形式存储在 CmdArgs 对象中，所以我们也应该创建一个结构来解码这些[]字节的数据，数据格式需要兼容规范的各类对象。\n``` golang\n// 简单的网桥结构\ntype SimpleBridge struct {\n\tBridgeName string `json:\"bridgeName\"`\n\tIP         string `json:\"ip\"`\n}\n\n// 在cmdAdd中解析传入的参数内容\nfunc cmdAdd(args *skel.CmdArgs) error {\n\n}\n\n```\n\n当把配置文件中的数据转化为代码当中的数据结构，接下来我们就需要使用这些数据调用内核接口创建对应的内核资源。就但从目前的实现目标创建 Linux 网桥来说，可以通过原始的 os.Exec 创建，不过这样就需要去深入到不同操作系统和内核的功能实现上，为覆盖这部分的复杂性，我们就直接借用开源的调用来实现这部分的功能\n```golang\n/**\n1. 准备好我们想要的 netlink.Bridge 对象。\n2. 创建网桥对象\n3. 设置Linux网桥参数\n*/\nbr := &netlink.Bridge{\n\tLinkAttrs: netlink.LinkAttrs{\n\t\tName: sb.BridgeName,\n\t\tMTU:  1500,\n\t\t// Let kernel use default txqueuelen; leaving it unset\n\t\t// means 0, and a zero-length TX queue messes up FIFO\n\t\t// traffic shapers which use TX queue length as the\n\t\t// default packet limit\n\t\tTxQLen: -1,\n\t},\n}\n\nerr := netlink.LinkAdd(br)\nif err != nil && err != syscall.EEXIST {\n\treturn err\n}\n\nif err := netlink.LinkSetUp(br); err != nil {\n\treturn err\n}\n\n```\n> 当然， cni 的实质原理就是接入 Linux 内核的调用并创建内核资源，所以需要调用借助一些相关的调用，上述代码使用的是 cni 官方整理 `github.com/containernetworking/cni/pkg/skel` 。除此之外，本文还收集了相关的一些 Go 仓库来帮助接下来的项目推进。\n> [netlink](https://github.com/vishvananda/netlink)\n> [go-cni](https://github.com/containerd/go-cni/tree/main)\n> [intel-cni](https://github.com/containerd/go-cni/tree/main)\n> [sr-cni](https://github.com/containerd/go-cni/tree/main)\n\n到这一步，代码就完成了对内核资源的创建和修改，接下来就是将这些将这些资源分配到需求的容器网络上。通过对于 Linux 网络的学习，我们可以想到一个非常简单的方法就是创建 veth 设备并将一端放入容器中，另一端插入到创建的网桥当中，这样网桥所连接的容器就都相当于共享同一个二层设备，划分到同一个子网当中。实际上大部分的 cni 也是同样的操作，不过仅仅设置一个单网桥对于高速网络或者是多功能多层次网络的服务可能稍显不足，这部分的功能会使用 eBPF 来作为补足。\n\n说干就干，我们整理出一下需要继续添加到代码工程当中的逻辑：\n1. 从我们之前创建的Bridge中获取Bridge对象\n2. 获取容器的命名空间\n3. 在容器上创建一个 veth，并将主机端 veth 移至主机 ns。\n4. 将主机端 veth 附加到 linux bridge 上\n\n在这个过程当中有一些地方需要注意：\n* 需要检验已创建的网络资源，避免冲突\n* 获取并处理容器的网络空间\n\n这些问题如果是单独实现一个独立的 cni 插件，那么就不可避免需要考虑环境问题。(1) 怎样与其他的 cni 功能兼容或者是当检验到节点上有使用其他的 cni 插件，需要提醒用户卸载其他的 cni 插件再来安装配置. (2) 清除先前的程序遗留的网络配置参数和内容，保证不出现集群网络的资源冲突。(3) 分配资源的对象参数获取，这里其实指的就是容器网络。\n\n这些麻烦都可以在对内核交互的调用中查询，此外还有其他的需求，也考虑在将来使用 eBPF 来做进一步的开发和补充。\n\n```golang\n// 获取本地的网络设备情况\nl, err := netlink.LinkByName(sb.BridgeName)\nif err != nil {\n    return fmt.Errorf(\"could not lookup %q: %v\", sb.BridgeName, err)\n}\n\n// 比较是否有冲突的问题\nnewBr, ok := l.(*netlink.Bridge)\nif !ok {\n    return fmt.Errorf(\"%q already exists but is not a bridge\", sb.BridgeName)\n}\n```\n而对于容器网络信息的获取，在之前的指令中也涉及到`CNI_CONTAINERID=ns1 CNI_NETNS=/var/run/netns/ns1`,这部分信息可以通过传入的参数获取。\n```golang\nnetns, err := ns.GetNS(args.Netns)\nif err != nil {\n\treturn err\n}\n```\n\n接下来对于每一个 `NetNs`对象（也就是容器对象），我们需要为它创建一个 veth 设备，并将它附加到创建的网桥上。\n``` golang\n// 设置 Handler ,为调用 handler 的容器创建 veth [此时 veth 的一端在容器内，另一端在 hostNS]\nhostIface := &current.Interface{}\n\tvar handler = func(hostNS ns.NetNS) error {\n\t\thostVeth, _, err := ip.SetupVeth(args.IfName, 1500, hostNS)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\thostIface.Name = hostVeth.Name\n\t\treturn nil\n}\n\n// 为每一个容器调用 handler\nif err := netns.Do(handler); err != nil {\n\t\treturn err\n}\n\n// 获取所创建的 Bridge \nhostVeth, err := netlink.LinkByName(hostIface.Name)\n\tif err != nil {\n\t\treturn err\n}\n\n// 将 veth 附加到创建的网桥上\nif err := netlink.LinkSetMaster(hostVeth, newBr); err != nil {\n\t\treturn err\n}\n```\n在上述过程当中，我们通过 `hostIface.Name` 获得主机端 veth 对的接口名称，然后将该链接附加到之前创建的 Linux 网桥上； 接着通过调用 `netlink.LinkByName` 函数从接口名称中获取链接对象, 然后调用 `netlink.LinkSetMaster` 函数将链接连接到网桥上。\n\n> 在操作过程中有一个非常重要的关注点： **确保操作系统不会在命名空间的操作中切换线程**\n> 可以参考 [steps-in-context-switching](https://stackoverflow.com/questions/7439608/steps-in-context-switching) \n> \n> 命名空间操作需要独占访问某些资源，如进程ID（PID）和网络接口。当一个命名空间被创建或销毁时，内核必须确保该命名空间所拥有的资源被正确分配或释放，并且对这些资源的任何操作都是同步的。\n> \n> 如果操作系统在命名空间操作进行时切换线程，可能会导致资源冲突或竞赛条件，这可能导致不可预测的行为或系统不稳定。例如，如果一个线程正在设置一个新的网络命名空间，而另一个线程同时试图使用同一个网络接口，这可能会导致资源争夺和数据损坏。\n> \n> 因此，为了确保命名空间操作的完整性和一致性，操作系统必须以原子方式和互斥方式执行命名空间操作。\n\n所以我们使用以下方式限制,具体的使用手册是：\n[benefits-of-runtime-lockosthread-in-golang](https://stackoverflow.com/questions/25361831/benefits-of-runtime-lockosthread-in-golang)\n[go-pkg-runtime](https://pkg.go.dev/runtime)\n```golang\nfunc init() {\n        // this ensures that main runs only on main thread (thread group leader).\n        // since namespace ops (unshare, setns) are done for a single thread, we\n        // must ensure that the goroutine does not jump from OS thread to thread\n        runtime.LockOSThread()\n}\n```\n\n通过添加上述的代码，我们可以成功给多个 ns 容器提供自己的 veth 设备并接入网桥获取了连通性。然而每个容器依旧是在 L3 不通的，他们并没有唯一可以表示彼此的 IP 地址。 接下来，我们进一步来实验看看如何将 IP 地址分配给各自的容器。\n\nIP 地址管理在集群中往往是结合 IPAM 插件实现相关的功能，通过接入 k8s apiserver 来同步和获取当前集群内的 IP 地址划分情况以及这些 IP 地址所分配到的节点地址。\n这里的节点地址是提供给 k8s 建立集群的内网地址，也就是说如果是跨集群的情况，通过这样的方式 ip capsulated 使用的是节点地址，此时如果节点之间二层不可通的话，那么容器之间通过 PodIP 就无法找到彼此。\n\n不过就本文实现的简易 cni 功能，我们仅通过配置文件来获取容器网络的配置信息，而实现对地址的分配依旧需要借助内核的调用，在此不再重复。但要强调的是，为简单实现，这部分的 IP 支持就仅涉及 IPV4，之后对于 IPV6可能借助 eBPF 实现能够兼容 SRV6 相关特性的 cni， 敬请期待。 \n\n依据上述的逻辑，我们可以得到接下来的代码实现流程：\n1. 依据配置中生成一个IP对象。\n2. 在目标网络命名空间中调用netlink.AddrAdd。\n\n那么接着看看 `netlink`  当中是如何实现他对于地址分配的呢？\n```golang\n// 位于 addr.go\n// Addr represents an IP address from netlink. Netlink ip addresses\n// include a mask, so it stores the address as a net.IPNet.\ntype Addr struct {\n\t*net.IPNet\n\tLabel       string\n\tFlags       int\n\tScope       int\n\tPeer        *net.IPNet\n\tBroadcast   net.IP\n\tPreferedLft int\n\tValidLft    int\n\tLinkIndex   int\n}\n\n// 位于 addr_linux.go\n// AddrAdd will add an IP address to a link device.\n//\n// Equivalent to: `ip addr add $addr dev $link`\n//\n// If `addr` is an IPv4 address and the broadcast address is not given, it\n// will be automatically computed based on the IP mask if /30 or larger.\nfunc AddrAdd(link Link, addr *Addr) error {\n\treturn pkgHandle.AddrAdd(link, addr)\n}\n\n// AddrAdd will add an IP address to a link device.\n//\n// Equivalent to: `ip addr add $addr dev $link`\n//\n// If `addr` is an IPv4 address and the broadcast address is not given, it\n// will be automatically computed based on the IP mask if /30 or larger.\nfunc (h *Handle) AddrAdd(link Link, addr *Addr) error {\n\treq := h.newNetlinkRequest(unix.RTM_NEWADDR, unix.NLM_F_CREATE|unix.NLM_F_EXCL|unix.NLM_F_ACK)\n\treturn h.addrHandle(link, addr, req)\n}\n\n```\n\n我们使用 golang 提供的 `net` 包来生成 `net.IPNet` 类型和它的CIDR形式（IP地址和Mask），然后通过 `net.ParseCIDR` 来解析配置文件中获取的IP字符串并返回一个 `net.IPNet` 的指针。而这几步都需要在创建对应网络资源的时候完成绑定，所以我们需要修改前面的处理程序，在创建 veth 时分配 IP 地址。由于从 `net.ParseCIDR` 得到的 `net.IPNet` 对象是子网而不是真正的 IP 地址，接下来需要依据此子网生成合适的 IP 地址重新分配。\n\n```golang\nvar handler = func(hostNS ns.NetNS) error {\n    hostVeth, containerVeth, err := ip.SetupVeth(args.IfName, 1500, hostNS)\n    if err != nil {\n        return err\n    }\n    hostIface.Name = hostVeth.Name\n    // 在这里创建 IP  地址对象\n    ipv4Addr, ipv4Net, err := net.ParseCIDR(sb.IP)\n    if err != nil {\n        return err\n    }\n\n    link, err := netlink.LinkByName(containerVeth.Name)\n    if err != nil {\n        return err\n    }\n    // 创建 IP 地址\n    ipv4Net.IP = ipv4Addr\n\n    addr := &netlink.Addr{IPNet: ipv4Net, Label: \"\"}\n    if err = netlink.AddrAdd(link, addr); err != nil {\n        return err\n    }\n    return nil\n}\n```\n到这里，一个基础且完整的 `cmdAdd` 就完成了，我们接着来测试他的功能，通过过以下指令来测试功能\n\n```shell\n# 删除先前创建的资源\nsudo ip netns del ns1\nsudo ifconfig test down\nsudo brctl delbr test\n\n# 重新创建 ns1 来模拟容器\nsudo ip netns add ns1\ngo build -o example .\n\n# 执行 cni 来生成地址\necho \"Ready to call the cni to create ip for ns1\"\nsudo CNI_COMMAND=ADD CNI_CONTAINERID=ns1 CNI_NETNS=/var/run/netns/ns1 CNI_IFNAME=eth10 CNI_PATH=`pwd` ./example < config\necho \"The CNI has been called, see the following results\"\necho \"The bridge and the veth has been attatch to\"\nsudo brctl show test\necho \"The interface in the netns\"\nsudo ip netns exec ns1 ifconfig -a\n```\n执行的结果如下：\n``` shell\n[root@master knet]# ./run.sh \nCannot remove namespace file \"/var/run/netns/ns1\": No such file or directory\ntest: ERROR while getting interface flags: No such device\nbridge test doesn't exist; can't delete it\nReady to call the cni to create ip for ns1\n{test 192.0.2.15/24}\nThe CNI has been called, see the following results\nThe bridge and the veth has been attatch to\nbridge name     bridge id               STP enabled     interfaces\ntest            8000.b6e6090625de       no              veth2a9d8a3d\nThe interface in the netns\neth10: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500\n        inet 192.0.2.15  netmask 255.255.255.0  broadcast 192.0.2.255\n        inet6 fe80::477:7aff:fee3:a9b8  prefixlen 64  scopeid 0x20<link>\n        ether 06:77:7a:e3:a9:b8  txqueuelen 0  (Ethernet)\n        RX packets 1  bytes 90 (90.0 B)\n        RX errors 0  dropped 0  overruns 0  frame 0\n        TX packets 1  bytes 90 (90.0 B)\n        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n\nlo: flags=8<LOOPBACK>  mtu 65536\n        loop  txqueuelen 1000  (Local Loopback)\n        RX packets 0  bytes 0 (0.0 B)\n        RX errors 0  dropped 0  overruns 0  frame 0\n        TX packets 0  bytes 0 (0.0 B)\n        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n```\n可以看到IP地址已经设置到了接口eth10上，接着我们使用下面的命令将IP地址设置到linux网桥上，并使用ping命令来检查主机和目标网络命名空间之间的网络连接情况。\n```shell\n[root@master knet]# sudo ifconfig test 192.0.2.1\n[root@master knet]# sudo ip netns exec ns1 ping 192.0.2.1\nPING 192.0.2.1 (192.0.2.1) 56(84) bytes of data.\n64 bytes from 192.0.2.1: icmp_seq=1 ttl=64 time=0.077 ms\n64 bytes from 192.0.2.1: icmp_seq=2 ttl=64 time=0.044 ms\n64 bytes from 192.0.2.1: icmp_seq=3 ttl=64 time=0.053 ms\n64 bytes from 192.0.2.1: icmp_seq=4 ttl=64 time=0.045 ms\n^C\n--- 192.0.2.1 ping statistics ---\n4 packets transmitted, 4 received, 0% packet loss, ti\n```\n\n\n> 主要参考文章：\n> [Container Network Interface](https://www.hwchiu.com/introduce-cni-iii.html)\n> [Create your CNI ](https://morven.life/posts/create-your-own-cni-with-golang/)","source":"_posts/EdgeMesh/2023-ospp-fighting/CNI-CreateCNI.md","raw":"---\nlayout: source/_posts/edgemesh/2023-ospp-fighting/\ntitle: 创建简单的 CNI 插件\ndate: 2023-05-26 07:37:48\ntags:\n---\n\n> 使用 Golang 实现一个简易的 CNI \n> 对于 CNI 的功能实现将按照循序渐进的方式来进行\n> 实现目标\n> * 依据 config 文件创建 bridge 对象并分配 ns 对应的 ip 地址\n> * 提供容器网络通信服务\n>\n\n##  设计简易的 CNI 工作逻辑\n由于 cni 提供的服务集中于节点的 L2/L3 层通信，所以基础的 cni 大致功能就是通过读取 config 文件配置在本地 Linux 环境当中给容器分配地址并通过 bridge 等设备建立通信能力。\n\n依据上一篇博客所学习到的 cni 规范，我们可以将 cni 的基础工作逻辑梳理如下：\n1. kubelet 先创建 pause 容器创建对应的网络命名空间；\n2. cri 或者是 cni 主程序根据配置调用具体的 CNI 插件，可以配置成 CNI 插件链来进行链式调用；\n3. 当 CNI 插件被调用时，通过传入配置以及命令行参数来获得网络命名空间、容器的网络设备等必要信息，然后执行 ADD 、 DELETE 或者其他操作；\n4. CNI 插件给 pause 容器配置正确的网络，pod 中其他的容器都是复用 pause 容器的网络；\n\n\n* 当容器准备创建或被终止时，cni 插件被 cri 或者是其他的 cni 插件调用执行功能。\n  * 当创建容器的时候，为容器分配网络资源，包括 IP 地址和网络连接\n  * 当销毁容器的时候，删除为容器分配的所有网络资源\n* cni 插件所获取的信息格式如下: (cri 调用或者是其他 cni 插件)\n  * cni 执行的命令和操作(cni必须要实现的核心可调用功能)\n    * ADD\n    * DELETE\n    * VERSION\n    * CHECK\n  * 容器ID(服务的容器对象ID)\n  * 节点容器所连接网络空间的路径\n  * 容器中需要创建的接口名称\n  * 目前节点内 cni 可执行程序所在路径，一般其他的 cni 插件也在这个路径(一般是`/opt/cni/bin`)\n  * cni 配置文件的路径\n\n而对于节点运行的 cri 调用 cni 服务，需要在路径中设置 cni 可调用的地址。如果是在 Kubernetes 集群当中， cni 以容器的形式来提供服务就需要在其创建了对应的网桥提供服务之后，设置 cni 当中获取服务的地址为该网桥所在网段。\n比如 Docker 当中设置 `vim /usr/lib/systemd/system/docker.service` 中 `--bip=10.244.12.1/24 ` 如下：\n``` shell\n[Service]\nType=notify\n# the default is not to use systemd for cgroups because the delegate issues still\n# exists and systemd currently does not support the cgroup feature set required\n# for containers run by docker\nExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock --bip=10.244.12.1/24 --mtu=1450\nExecReload=/bin/kill -s HUP $MAINPID\nTimeoutStartSec=0\nRestartSec=2\nRestart=always\n```\n\n\n## 代码实现\n\n\n### **Step1 : 创建 cni 主流程**\n\n首先，一个基本的 cni 需要完成在容器创建时候，依据传入参数为其分配网络资源；同时需要在容器终止时候，删除所有分配的资源。\n所以可以先得到一个最基本的 cni 主程序框架如下：\n``` golang\npackage main \n\nimport (\n    \"github.com/containernetworking/cni/pkg/skel\"\n    \"github.com/containernetworking/cni/pkg/version\"\n)\nfunc cmdAdd(args *skel.CmdArgs) error {\n    /**\n    TODO: add code about cmdAdd\n    */\n    // 测试是否 cni 接收到了传入的容器网络配置参数\n    fmt.Printf(\"interfance Name: %s\\n\", args.IfName)\n\t  fmt.Printf(\"Netns path: %s\\n\", args.Netns)\n\t  fmt.Printf(\"The config data: %s\\n\", args.StdinData)\n    return nil\n}\n\nfunc cmdDel(args *skel.CmdArgs) error {\n    /**\n    TODO: add code about cmdDel\n    */\n    return nil\n}\n\nfunc main(){\n    skel.PluginMain(cmdAdd, cmdDel, cmdVersion, cmdCheck)\n}\n\n```\n\n按照所归纳的 cni 逻辑，我们已经实现了一个基础的框架，并且可以接受传入的网络配置参数，但目前还没有执行任何的动作。\n\n传入的参数具体内容定义在 `pkg/skel/skel.go`:\n```golang\n// CmdArgs captures all the arguments passed in to the plugin\n// via both env vars and stdin\ntype CmdArgs struct {\n\tContainerID   string\n\tNetns         string\n\tIfName        string\n\tArgs          string\n\tPath          string\n\tNetnsOverride string\n\tStdinData     []byte\n}\n```\n\n当然 cni 接受参数的目的是去了解该创建怎样的容器网络。但是如何将这些参数传给 cni 呢？ 依据 cni 规范，我们需要从配置文件或者是 cri 传入参数中获取到对应的容器网络需求。顺带一提，在 Kubernetes 网络集群中，kubelet 也并不是直接与 cni 沟通的，所以 cni 本身可以在单节点上创建容器网络以及提供功能，只是说在集群当中可以结合 kubelet 提供 list/watch apiserver 的功能来做局域网内的地址管理和网络连通性，包括 ip capsulating， cidr 等等。\n\n接下来为检验以上的功能逻辑通畅，创建以下 config 文件：\n``` yaml\n{\n\t\"name\": \"mynet\",\n\t\"BridgeName\": \"test\",\n\t\"IP\": \"192.0.2.1/24\"\n}\n```\n那么接下来就可以，模拟 cri 调用 cni 通过 config 文件指定所创建的容器网络配置创建资源，所使用的指令如下：\n``` shell\n\tgo build -o example .\n\techo \"Ready to call the cni program and create resources\"\n\tsudo CNI_COMMAND=ADD CNI_CONTAINERID=ns1 CNI_NETNS=/var/run/netns/ns1 CNI_IFNAME=eth10 CNI_PATH=`pwd` ./example < config\n\techo \"The CNI has been called, see the following results\"\n```\n得到以下输出：\n``` shell\n[root@master knet]# ./run.sh\nReady to call the cni program and create resources\ninterfance Name: eth10\nnetns path: /var/run/netns/ns1\nthe config data: {\n        \"name\": \"mynet\",\n        \"BridgeName\": \"test\",\n        \"IP\": \"192.0.2.1/24\"\n}\nThe CNI has been called, see the following results\n```\n通过这个测试可以明确以上代码可以从命令行当中读取出对应的配置参数，不过仅只是将结果输出而已并没有做更多的操作，当然这并不可能是完整的 cni ，那接下来进一步实现当 cni 获取了这些参数之后该做些什么。\n\n\n### **step2: 实现 cmdAdd 功能**\n\n本文的目的还是在于理清楚 cni 执行的底层逻辑，所以就不深入探究 cni 的多样功能实现，所以以创建一个 Linux 网桥为目标，具体代码逻辑如下：\n\n1. 从配置中读取网桥信息。\n2. 获取我们想要使用的网桥名称。\n3. 如果系统中不存在该网桥，则创建它。\n\n由于 cni 的框架里面将配置内容以[]字节的形式存储在 CmdArgs 对象中，所以我们也应该创建一个结构来解码这些[]字节的数据，数据格式需要兼容规范的各类对象。\n``` golang\n// 简单的网桥结构\ntype SimpleBridge struct {\n\tBridgeName string `json:\"bridgeName\"`\n\tIP         string `json:\"ip\"`\n}\n\n// 在cmdAdd中解析传入的参数内容\nfunc cmdAdd(args *skel.CmdArgs) error {\n\n}\n\n```\n\n当把配置文件中的数据转化为代码当中的数据结构，接下来我们就需要使用这些数据调用内核接口创建对应的内核资源。就但从目前的实现目标创建 Linux 网桥来说，可以通过原始的 os.Exec 创建，不过这样就需要去深入到不同操作系统和内核的功能实现上，为覆盖这部分的复杂性，我们就直接借用开源的调用来实现这部分的功能\n```golang\n/**\n1. 准备好我们想要的 netlink.Bridge 对象。\n2. 创建网桥对象\n3. 设置Linux网桥参数\n*/\nbr := &netlink.Bridge{\n\tLinkAttrs: netlink.LinkAttrs{\n\t\tName: sb.BridgeName,\n\t\tMTU:  1500,\n\t\t// Let kernel use default txqueuelen; leaving it unset\n\t\t// means 0, and a zero-length TX queue messes up FIFO\n\t\t// traffic shapers which use TX queue length as the\n\t\t// default packet limit\n\t\tTxQLen: -1,\n\t},\n}\n\nerr := netlink.LinkAdd(br)\nif err != nil && err != syscall.EEXIST {\n\treturn err\n}\n\nif err := netlink.LinkSetUp(br); err != nil {\n\treturn err\n}\n\n```\n> 当然， cni 的实质原理就是接入 Linux 内核的调用并创建内核资源，所以需要调用借助一些相关的调用，上述代码使用的是 cni 官方整理 `github.com/containernetworking/cni/pkg/skel` 。除此之外，本文还收集了相关的一些 Go 仓库来帮助接下来的项目推进。\n> [netlink](https://github.com/vishvananda/netlink)\n> [go-cni](https://github.com/containerd/go-cni/tree/main)\n> [intel-cni](https://github.com/containerd/go-cni/tree/main)\n> [sr-cni](https://github.com/containerd/go-cni/tree/main)\n\n到这一步，代码就完成了对内核资源的创建和修改，接下来就是将这些将这些资源分配到需求的容器网络上。通过对于 Linux 网络的学习，我们可以想到一个非常简单的方法就是创建 veth 设备并将一端放入容器中，另一端插入到创建的网桥当中，这样网桥所连接的容器就都相当于共享同一个二层设备，划分到同一个子网当中。实际上大部分的 cni 也是同样的操作，不过仅仅设置一个单网桥对于高速网络或者是多功能多层次网络的服务可能稍显不足，这部分的功能会使用 eBPF 来作为补足。\n\n说干就干，我们整理出一下需要继续添加到代码工程当中的逻辑：\n1. 从我们之前创建的Bridge中获取Bridge对象\n2. 获取容器的命名空间\n3. 在容器上创建一个 veth，并将主机端 veth 移至主机 ns。\n4. 将主机端 veth 附加到 linux bridge 上\n\n在这个过程当中有一些地方需要注意：\n* 需要检验已创建的网络资源，避免冲突\n* 获取并处理容器的网络空间\n\n这些问题如果是单独实现一个独立的 cni 插件，那么就不可避免需要考虑环境问题。(1) 怎样与其他的 cni 功能兼容或者是当检验到节点上有使用其他的 cni 插件，需要提醒用户卸载其他的 cni 插件再来安装配置. (2) 清除先前的程序遗留的网络配置参数和内容，保证不出现集群网络的资源冲突。(3) 分配资源的对象参数获取，这里其实指的就是容器网络。\n\n这些麻烦都可以在对内核交互的调用中查询，此外还有其他的需求，也考虑在将来使用 eBPF 来做进一步的开发和补充。\n\n```golang\n// 获取本地的网络设备情况\nl, err := netlink.LinkByName(sb.BridgeName)\nif err != nil {\n    return fmt.Errorf(\"could not lookup %q: %v\", sb.BridgeName, err)\n}\n\n// 比较是否有冲突的问题\nnewBr, ok := l.(*netlink.Bridge)\nif !ok {\n    return fmt.Errorf(\"%q already exists but is not a bridge\", sb.BridgeName)\n}\n```\n而对于容器网络信息的获取，在之前的指令中也涉及到`CNI_CONTAINERID=ns1 CNI_NETNS=/var/run/netns/ns1`,这部分信息可以通过传入的参数获取。\n```golang\nnetns, err := ns.GetNS(args.Netns)\nif err != nil {\n\treturn err\n}\n```\n\n接下来对于每一个 `NetNs`对象（也就是容器对象），我们需要为它创建一个 veth 设备，并将它附加到创建的网桥上。\n``` golang\n// 设置 Handler ,为调用 handler 的容器创建 veth [此时 veth 的一端在容器内，另一端在 hostNS]\nhostIface := &current.Interface{}\n\tvar handler = func(hostNS ns.NetNS) error {\n\t\thostVeth, _, err := ip.SetupVeth(args.IfName, 1500, hostNS)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\thostIface.Name = hostVeth.Name\n\t\treturn nil\n}\n\n// 为每一个容器调用 handler\nif err := netns.Do(handler); err != nil {\n\t\treturn err\n}\n\n// 获取所创建的 Bridge \nhostVeth, err := netlink.LinkByName(hostIface.Name)\n\tif err != nil {\n\t\treturn err\n}\n\n// 将 veth 附加到创建的网桥上\nif err := netlink.LinkSetMaster(hostVeth, newBr); err != nil {\n\t\treturn err\n}\n```\n在上述过程当中，我们通过 `hostIface.Name` 获得主机端 veth 对的接口名称，然后将该链接附加到之前创建的 Linux 网桥上； 接着通过调用 `netlink.LinkByName` 函数从接口名称中获取链接对象, 然后调用 `netlink.LinkSetMaster` 函数将链接连接到网桥上。\n\n> 在操作过程中有一个非常重要的关注点： **确保操作系统不会在命名空间的操作中切换线程**\n> 可以参考 [steps-in-context-switching](https://stackoverflow.com/questions/7439608/steps-in-context-switching) \n> \n> 命名空间操作需要独占访问某些资源，如进程ID（PID）和网络接口。当一个命名空间被创建或销毁时，内核必须确保该命名空间所拥有的资源被正确分配或释放，并且对这些资源的任何操作都是同步的。\n> \n> 如果操作系统在命名空间操作进行时切换线程，可能会导致资源冲突或竞赛条件，这可能导致不可预测的行为或系统不稳定。例如，如果一个线程正在设置一个新的网络命名空间，而另一个线程同时试图使用同一个网络接口，这可能会导致资源争夺和数据损坏。\n> \n> 因此，为了确保命名空间操作的完整性和一致性，操作系统必须以原子方式和互斥方式执行命名空间操作。\n\n所以我们使用以下方式限制,具体的使用手册是：\n[benefits-of-runtime-lockosthread-in-golang](https://stackoverflow.com/questions/25361831/benefits-of-runtime-lockosthread-in-golang)\n[go-pkg-runtime](https://pkg.go.dev/runtime)\n```golang\nfunc init() {\n        // this ensures that main runs only on main thread (thread group leader).\n        // since namespace ops (unshare, setns) are done for a single thread, we\n        // must ensure that the goroutine does not jump from OS thread to thread\n        runtime.LockOSThread()\n}\n```\n\n通过添加上述的代码，我们可以成功给多个 ns 容器提供自己的 veth 设备并接入网桥获取了连通性。然而每个容器依旧是在 L3 不通的，他们并没有唯一可以表示彼此的 IP 地址。 接下来，我们进一步来实验看看如何将 IP 地址分配给各自的容器。\n\nIP 地址管理在集群中往往是结合 IPAM 插件实现相关的功能，通过接入 k8s apiserver 来同步和获取当前集群内的 IP 地址划分情况以及这些 IP 地址所分配到的节点地址。\n这里的节点地址是提供给 k8s 建立集群的内网地址，也就是说如果是跨集群的情况，通过这样的方式 ip capsulated 使用的是节点地址，此时如果节点之间二层不可通的话，那么容器之间通过 PodIP 就无法找到彼此。\n\n不过就本文实现的简易 cni 功能，我们仅通过配置文件来获取容器网络的配置信息，而实现对地址的分配依旧需要借助内核的调用，在此不再重复。但要强调的是，为简单实现，这部分的 IP 支持就仅涉及 IPV4，之后对于 IPV6可能借助 eBPF 实现能够兼容 SRV6 相关特性的 cni， 敬请期待。 \n\n依据上述的逻辑，我们可以得到接下来的代码实现流程：\n1. 依据配置中生成一个IP对象。\n2. 在目标网络命名空间中调用netlink.AddrAdd。\n\n那么接着看看 `netlink`  当中是如何实现他对于地址分配的呢？\n```golang\n// 位于 addr.go\n// Addr represents an IP address from netlink. Netlink ip addresses\n// include a mask, so it stores the address as a net.IPNet.\ntype Addr struct {\n\t*net.IPNet\n\tLabel       string\n\tFlags       int\n\tScope       int\n\tPeer        *net.IPNet\n\tBroadcast   net.IP\n\tPreferedLft int\n\tValidLft    int\n\tLinkIndex   int\n}\n\n// 位于 addr_linux.go\n// AddrAdd will add an IP address to a link device.\n//\n// Equivalent to: `ip addr add $addr dev $link`\n//\n// If `addr` is an IPv4 address and the broadcast address is not given, it\n// will be automatically computed based on the IP mask if /30 or larger.\nfunc AddrAdd(link Link, addr *Addr) error {\n\treturn pkgHandle.AddrAdd(link, addr)\n}\n\n// AddrAdd will add an IP address to a link device.\n//\n// Equivalent to: `ip addr add $addr dev $link`\n//\n// If `addr` is an IPv4 address and the broadcast address is not given, it\n// will be automatically computed based on the IP mask if /30 or larger.\nfunc (h *Handle) AddrAdd(link Link, addr *Addr) error {\n\treq := h.newNetlinkRequest(unix.RTM_NEWADDR, unix.NLM_F_CREATE|unix.NLM_F_EXCL|unix.NLM_F_ACK)\n\treturn h.addrHandle(link, addr, req)\n}\n\n```\n\n我们使用 golang 提供的 `net` 包来生成 `net.IPNet` 类型和它的CIDR形式（IP地址和Mask），然后通过 `net.ParseCIDR` 来解析配置文件中获取的IP字符串并返回一个 `net.IPNet` 的指针。而这几步都需要在创建对应网络资源的时候完成绑定，所以我们需要修改前面的处理程序，在创建 veth 时分配 IP 地址。由于从 `net.ParseCIDR` 得到的 `net.IPNet` 对象是子网而不是真正的 IP 地址，接下来需要依据此子网生成合适的 IP 地址重新分配。\n\n```golang\nvar handler = func(hostNS ns.NetNS) error {\n    hostVeth, containerVeth, err := ip.SetupVeth(args.IfName, 1500, hostNS)\n    if err != nil {\n        return err\n    }\n    hostIface.Name = hostVeth.Name\n    // 在这里创建 IP  地址对象\n    ipv4Addr, ipv4Net, err := net.ParseCIDR(sb.IP)\n    if err != nil {\n        return err\n    }\n\n    link, err := netlink.LinkByName(containerVeth.Name)\n    if err != nil {\n        return err\n    }\n    // 创建 IP 地址\n    ipv4Net.IP = ipv4Addr\n\n    addr := &netlink.Addr{IPNet: ipv4Net, Label: \"\"}\n    if err = netlink.AddrAdd(link, addr); err != nil {\n        return err\n    }\n    return nil\n}\n```\n到这里，一个基础且完整的 `cmdAdd` 就完成了，我们接着来测试他的功能，通过过以下指令来测试功能\n\n```shell\n# 删除先前创建的资源\nsudo ip netns del ns1\nsudo ifconfig test down\nsudo brctl delbr test\n\n# 重新创建 ns1 来模拟容器\nsudo ip netns add ns1\ngo build -o example .\n\n# 执行 cni 来生成地址\necho \"Ready to call the cni to create ip for ns1\"\nsudo CNI_COMMAND=ADD CNI_CONTAINERID=ns1 CNI_NETNS=/var/run/netns/ns1 CNI_IFNAME=eth10 CNI_PATH=`pwd` ./example < config\necho \"The CNI has been called, see the following results\"\necho \"The bridge and the veth has been attatch to\"\nsudo brctl show test\necho \"The interface in the netns\"\nsudo ip netns exec ns1 ifconfig -a\n```\n执行的结果如下：\n``` shell\n[root@master knet]# ./run.sh \nCannot remove namespace file \"/var/run/netns/ns1\": No such file or directory\ntest: ERROR while getting interface flags: No such device\nbridge test doesn't exist; can't delete it\nReady to call the cni to create ip for ns1\n{test 192.0.2.15/24}\nThe CNI has been called, see the following results\nThe bridge and the veth has been attatch to\nbridge name     bridge id               STP enabled     interfaces\ntest            8000.b6e6090625de       no              veth2a9d8a3d\nThe interface in the netns\neth10: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500\n        inet 192.0.2.15  netmask 255.255.255.0  broadcast 192.0.2.255\n        inet6 fe80::477:7aff:fee3:a9b8  prefixlen 64  scopeid 0x20<link>\n        ether 06:77:7a:e3:a9:b8  txqueuelen 0  (Ethernet)\n        RX packets 1  bytes 90 (90.0 B)\n        RX errors 0  dropped 0  overruns 0  frame 0\n        TX packets 1  bytes 90 (90.0 B)\n        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n\nlo: flags=8<LOOPBACK>  mtu 65536\n        loop  txqueuelen 1000  (Local Loopback)\n        RX packets 0  bytes 0 (0.0 B)\n        RX errors 0  dropped 0  overruns 0  frame 0\n        TX packets 0  bytes 0 (0.0 B)\n        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n```\n可以看到IP地址已经设置到了接口eth10上，接着我们使用下面的命令将IP地址设置到linux网桥上，并使用ping命令来检查主机和目标网络命名空间之间的网络连接情况。\n```shell\n[root@master knet]# sudo ifconfig test 192.0.2.1\n[root@master knet]# sudo ip netns exec ns1 ping 192.0.2.1\nPING 192.0.2.1 (192.0.2.1) 56(84) bytes of data.\n64 bytes from 192.0.2.1: icmp_seq=1 ttl=64 time=0.077 ms\n64 bytes from 192.0.2.1: icmp_seq=2 ttl=64 time=0.044 ms\n64 bytes from 192.0.2.1: icmp_seq=3 ttl=64 time=0.053 ms\n64 bytes from 192.0.2.1: icmp_seq=4 ttl=64 time=0.045 ms\n^C\n--- 192.0.2.1 ping statistics ---\n4 packets transmitted, 4 received, 0% packet loss, ti\n```\n\n\n> 主要参考文章：\n> [Container Network Interface](https://www.hwchiu.com/introduce-cni-iii.html)\n> [Create your CNI ](https://morven.life/posts/create-your-own-cni-with-golang/)","slug":"EdgeMesh/2023-ospp-fighting/CNI-CreateCNI","published":1,"updated":"2023-05-28T09:57:30.035Z","comments":1,"photos":[],"link":"","_id":"cli796r0m000nbyjx5nhhc7c7","content":"<blockquote>\n<p>使用 Golang 实现一个简易的 CNI<br>对于 CNI 的功能实现将按照循序渐进的方式来进行<br>实现目标</p>\n<ul>\n<li>依据 config 文件创建 bridge 对象并分配 ns 对应的 ip 地址</li>\n<li>提供容器网络通信服务</li>\n</ul>\n</blockquote>\n<h2 id=\"设计简易的-CNI-工作逻辑\"><a href=\"#设计简易的-CNI-工作逻辑\" class=\"headerlink\" title=\"设计简易的 CNI 工作逻辑\"></a>设计简易的 CNI 工作逻辑</h2><p>由于 cni 提供的服务集中于节点的 L2/L3 层通信，所以基础的 cni 大致功能就是通过读取 config 文件配置在本地 Linux 环境当中给容器分配地址并通过 bridge 等设备建立通信能力。</p>\n<p>依据上一篇博客所学习到的 cni 规范，我们可以将 cni 的基础工作逻辑梳理如下：</p>\n<ol>\n<li>kubelet 先创建 pause 容器创建对应的网络命名空间；</li>\n<li>cri 或者是 cni 主程序根据配置调用具体的 CNI 插件，可以配置成 CNI 插件链来进行链式调用；</li>\n<li>当 CNI 插件被调用时，通过传入配置以及命令行参数来获得网络命名空间、容器的网络设备等必要信息，然后执行 ADD 、 DELETE 或者其他操作；</li>\n<li>CNI 插件给 pause 容器配置正确的网络，pod 中其他的容器都是复用 pause 容器的网络；</li>\n</ol>\n<ul>\n<li>当容器准备创建或被终止时，cni 插件被 cri 或者是其他的 cni 插件调用执行功能。<ul>\n<li>当创建容器的时候，为容器分配网络资源，包括 IP 地址和网络连接</li>\n<li>当销毁容器的时候，删除为容器分配的所有网络资源</li>\n</ul>\n</li>\n<li>cni 插件所获取的信息格式如下: (cri 调用或者是其他 cni 插件)<ul>\n<li>cni 执行的命令和操作(cni必须要实现的核心可调用功能)<ul>\n<li>ADD</li>\n<li>DELETE</li>\n<li>VERSION</li>\n<li>CHECK</li>\n</ul>\n</li>\n<li>容器ID(服务的容器对象ID)</li>\n<li>节点容器所连接网络空间的路径</li>\n<li>容器中需要创建的接口名称</li>\n<li>目前节点内 cni 可执行程序所在路径，一般其他的 cni 插件也在这个路径(一般是<code>/opt/cni/bin</code>)</li>\n<li>cni 配置文件的路径</li>\n</ul>\n</li>\n</ul>\n<p>而对于节点运行的 cri 调用 cni 服务，需要在路径中设置 cni 可调用的地址。如果是在 Kubernetes 集群当中， cni 以容器的形式来提供服务就需要在其创建了对应的网桥提供服务之后，设置 cni 当中获取服务的地址为该网桥所在网段。<br>比如 Docker 当中设置 <code>vim /usr/lib/systemd/system/docker.service</code> 中 <code>--bip=10.244.12.1/24 </code> 如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Service]</span><br><span class=\"line\">Type=notify</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">the default is not to use systemd <span class=\"keyword\">for</span> cgroups because the delegate issues still</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">exists and systemd currently does not support the cgroup feature <span class=\"built_in\">set</span> required</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\"><span class=\"keyword\">for</span> containers run by docker</span></span><br><span class=\"line\">ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock --bip=10.244.12.1/24 --mtu=1450</span><br><span class=\"line\">ExecReload=/bin/kill -s HUP $MAINPID</span><br><span class=\"line\">TimeoutStartSec=0</span><br><span class=\"line\">RestartSec=2</span><br><span class=\"line\">Restart=always</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><h3 id=\"Step1-创建-cni-主流程\"><a href=\"#Step1-创建-cni-主流程\" class=\"headerlink\" title=\"Step1 : 创建 cni 主流程\"></a><strong>Step1 : 创建 cni 主流程</strong></h3><p>首先，一个基本的 cni 需要完成在容器创建时候，依据传入参数为其分配网络资源；同时需要在容器终止时候，删除所有分配的资源。<br>所以可以先得到一个最基本的 cni 主程序框架如下：</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;github.com/containernetworking/cni/pkg/skel&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;github.com/containernetworking/cni/pkg/version&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">cmdAdd</span><span class=\"params\">(args *skel.CmdArgs)</span></span> <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    <span class=\"doctag\">TODO:</span> add code about cmdAdd</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"comment\">// 测试是否 cni 接收到了传入的容器网络配置参数</span></span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">&quot;interfance Name: %s\\n&quot;</span>, args.IfName)</span><br><span class=\"line\">\t  fmt.Printf(<span class=\"string\">&quot;Netns path: %s\\n&quot;</span>, args.Netns)</span><br><span class=\"line\">\t  fmt.Printf(<span class=\"string\">&quot;The config data: %s\\n&quot;</span>, args.StdinData)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">cmdDel</span><span class=\"params\">(args *skel.CmdArgs)</span></span> <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    <span class=\"doctag\">TODO:</span> add code about cmdDel</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    skel.PluginMain(cmdAdd, cmdDel, cmdVersion, cmdCheck)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>按照所归纳的 cni 逻辑，我们已经实现了一个基础的框架，并且可以接受传入的网络配置参数，但目前还没有执行任何的动作。</p>\n<p>传入的参数具体内容定义在 <code>pkg/skel/skel.go</code>:</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// CmdArgs captures all the arguments passed in to the plugin</span></span><br><span class=\"line\"><span class=\"comment\">// via both env vars and stdin</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> CmdArgs <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tContainerID   <span class=\"type\">string</span></span><br><span class=\"line\">\tNetns         <span class=\"type\">string</span></span><br><span class=\"line\">\tIfName        <span class=\"type\">string</span></span><br><span class=\"line\">\tArgs          <span class=\"type\">string</span></span><br><span class=\"line\">\tPath          <span class=\"type\">string</span></span><br><span class=\"line\">\tNetnsOverride <span class=\"type\">string</span></span><br><span class=\"line\">\tStdinData     []<span class=\"type\">byte</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当然 cni 接受参数的目的是去了解该创建怎样的容器网络。但是如何将这些参数传给 cni 呢？ 依据 cni 规范，我们需要从配置文件或者是 cri 传入参数中获取到对应的容器网络需求。顺带一提，在 Kubernetes 网络集群中，kubelet 也并不是直接与 cni 沟通的，所以 cni 本身可以在单节点上创建容器网络以及提供功能，只是说在集群当中可以结合 kubelet 提供 list/watch apiserver 的功能来做局域网内的地址管理和网络连通性，包括 ip capsulating， cidr 等等。</p>\n<p>接下来为检验以上的功能逻辑通畅，创建以下 config 文件：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"attr\">&quot;name&quot;:</span> <span class=\"string\">&quot;mynet&quot;</span>,</span><br><span class=\"line\">\t<span class=\"attr\">&quot;BridgeName&quot;:</span> <span class=\"string\">&quot;test&quot;</span>,</span><br><span class=\"line\">\t<span class=\"attr\">&quot;IP&quot;:</span> <span class=\"string\">&quot;192.0.2.1/24&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>那么接下来就可以，模拟 cri 调用 cni 通过 config 文件指定所创建的容器网络配置创建资源，所使用的指令如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go build -o example .</span><br><span class=\"line\">echo &quot;Ready to call the cni program and create resources&quot;</span><br><span class=\"line\">sudo CNI_COMMAND=ADD CNI_CONTAINERID=ns1 CNI_NETNS=/var/run/netns/ns1 CNI_IFNAME=eth10 CNI_PATH=`pwd` ./example &lt; config</span><br><span class=\"line\">echo &quot;The CNI has been called, see the following results&quot;</span><br></pre></td></tr></table></figure>\n<p>得到以下输出：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@master knet]# ./run.sh</span><br><span class=\"line\">Ready to call the cni program and create resources</span><br><span class=\"line\">interfance Name: eth10</span><br><span class=\"line\">netns path: /var/run/netns/ns1</span><br><span class=\"line\">the config data: &#123;</span><br><span class=\"line\">        &quot;name&quot;: &quot;mynet&quot;,</span><br><span class=\"line\">        &quot;BridgeName&quot;: &quot;test&quot;,</span><br><span class=\"line\">        &quot;IP&quot;: &quot;192.0.2.1/24&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">The CNI has been called, see the following results</span><br></pre></td></tr></table></figure>\n<p>通过这个测试可以明确以上代码可以从命令行当中读取出对应的配置参数，不过仅只是将结果输出而已并没有做更多的操作，当然这并不可能是完整的 cni ，那接下来进一步实现当 cni 获取了这些参数之后该做些什么。</p>\n<h3 id=\"step2-实现-cmdAdd-功能\"><a href=\"#step2-实现-cmdAdd-功能\" class=\"headerlink\" title=\"step2: 实现 cmdAdd 功能\"></a><strong>step2: 实现 cmdAdd 功能</strong></h3><p>本文的目的还是在于理清楚 cni 执行的底层逻辑，所以就不深入探究 cni 的多样功能实现，所以以创建一个 Linux 网桥为目标，具体代码逻辑如下：</p>\n<ol>\n<li>从配置中读取网桥信息。</li>\n<li>获取我们想要使用的网桥名称。</li>\n<li>如果系统中不存在该网桥，则创建它。</li>\n</ol>\n<p>由于 cni 的框架里面将配置内容以[]字节的形式存储在 CmdArgs 对象中，所以我们也应该创建一个结构来解码这些[]字节的数据，数据格式需要兼容规范的各类对象。</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 简单的网桥结构</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> SimpleBridge <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tBridgeName <span class=\"type\">string</span> <span class=\"string\">`json:&quot;bridgeName&quot;`</span></span><br><span class=\"line\">\tIP         <span class=\"type\">string</span> <span class=\"string\">`json:&quot;ip&quot;`</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在cmdAdd中解析传入的参数内容</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">cmdAdd</span><span class=\"params\">(args *skel.CmdArgs)</span></span> <span class=\"type\">error</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>当把配置文件中的数据转化为代码当中的数据结构，接下来我们就需要使用这些数据调用内核接口创建对应的内核资源。就但从目前的实现目标创建 Linux 网桥来说，可以通过原始的 os.Exec 创建，不过这样就需要去深入到不同操作系统和内核的功能实现上，为覆盖这部分的复杂性，我们就直接借用开源的调用来实现这部分的功能</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">1. 准备好我们想要的 netlink.Bridge 对象。</span></span><br><span class=\"line\"><span class=\"comment\">2. 创建网桥对象</span></span><br><span class=\"line\"><span class=\"comment\">3. 设置Linux网桥参数</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">br := &amp;netlink.Bridge&#123;</span><br><span class=\"line\">\tLinkAttrs: netlink.LinkAttrs&#123;</span><br><span class=\"line\">\t\tName: sb.BridgeName,</span><br><span class=\"line\">\t\tMTU:  <span class=\"number\">1500</span>,</span><br><span class=\"line\">\t\t<span class=\"comment\">// Let kernel use default txqueuelen; leaving it unset</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// means 0, and a zero-length TX queue messes up FIFO</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// traffic shapers which use TX queue length as the</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// default packet limit</span></span><br><span class=\"line\">\t\tTxQLen: <span class=\"number\">-1</span>,</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">err := netlink.LinkAdd(br)</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &amp;&amp; err != syscall.EEXIST &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> err := netlink.LinkSetUp(br); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>当然， cni 的实质原理就是接入 Linux 内核的调用并创建内核资源，所以需要调用借助一些相关的调用，上述代码使用的是 cni 官方整理 <code>github.com/containernetworking/cni/pkg/skel</code> 。除此之外，本文还收集了相关的一些 Go 仓库来帮助接下来的项目推进。<br><a href=\"https://github.com/vishvananda/netlink\">netlink</a><br><a href=\"https://github.com/containerd/go-cni/tree/main\">go-cni</a><br><a href=\"https://github.com/containerd/go-cni/tree/main\">intel-cni</a><br><a href=\"https://github.com/containerd/go-cni/tree/main\">sr-cni</a></p>\n</blockquote>\n<p>到这一步，代码就完成了对内核资源的创建和修改，接下来就是将这些将这些资源分配到需求的容器网络上。通过对于 Linux 网络的学习，我们可以想到一个非常简单的方法就是创建 veth 设备并将一端放入容器中，另一端插入到创建的网桥当中，这样网桥所连接的容器就都相当于共享同一个二层设备，划分到同一个子网当中。实际上大部分的 cni 也是同样的操作，不过仅仅设置一个单网桥对于高速网络或者是多功能多层次网络的服务可能稍显不足，这部分的功能会使用 eBPF 来作为补足。</p>\n<p>说干就干，我们整理出一下需要继续添加到代码工程当中的逻辑：</p>\n<ol>\n<li>从我们之前创建的Bridge中获取Bridge对象</li>\n<li>获取容器的命名空间</li>\n<li>在容器上创建一个 veth，并将主机端 veth 移至主机 ns。</li>\n<li>将主机端 veth 附加到 linux bridge 上</li>\n</ol>\n<p>在这个过程当中有一些地方需要注意：</p>\n<ul>\n<li>需要检验已创建的网络资源，避免冲突</li>\n<li>获取并处理容器的网络空间</li>\n</ul>\n<p>这些问题如果是单独实现一个独立的 cni 插件，那么就不可避免需要考虑环境问题。(1) 怎样与其他的 cni 功能兼容或者是当检验到节点上有使用其他的 cni 插件，需要提醒用户卸载其他的 cni 插件再来安装配置. (2) 清除先前的程序遗留的网络配置参数和内容，保证不出现集群网络的资源冲突。(3) 分配资源的对象参数获取，这里其实指的就是容器网络。</p>\n<p>这些麻烦都可以在对内核交互的调用中查询，此外还有其他的需求，也考虑在将来使用 eBPF 来做进一步的开发和补充。</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取本地的网络设备情况</span></span><br><span class=\"line\">l, err := netlink.LinkByName(sb.BridgeName)</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">&quot;could not lookup %q: %v&quot;</span>, sb.BridgeName, err)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 比较是否有冲突的问题</span></span><br><span class=\"line\">newBr, ok := l.(*netlink.Bridge)</span><br><span class=\"line\"><span class=\"keyword\">if</span> !ok &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">&quot;%q already exists but is not a bridge&quot;</span>, sb.BridgeName)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>而对于容器网络信息的获取，在之前的指令中也涉及到<code>CNI_CONTAINERID=ns1 CNI_NETNS=/var/run/netns/ns1</code>,这部分信息可以通过传入的参数获取。</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">netns, err := ns.GetNS(args.Netns)</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接下来对于每一个 <code>NetNs</code>对象（也就是容器对象），我们需要为它创建一个 veth 设备，并将它附加到创建的网桥上。</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 设置 Handler ,为调用 handler 的容器创建 veth [此时 veth 的一端在容器内，另一端在 hostNS]</span></span><br><span class=\"line\">hostIface := &amp;current.Interface&#123;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> handler = <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(hostNS ns.NetNS)</span></span> <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">\t\thostVeth, _, err := ip.SetupVeth(args.IfName, <span class=\"number\">1500</span>, hostNS)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\thostIface.Name = hostVeth.Name</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 为每一个容器调用 handler</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> err := netns.Do(handler); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取所创建的 Bridge </span></span><br><span class=\"line\">hostVeth, err := netlink.LinkByName(hostIface.Name)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将 veth 附加到创建的网桥上</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> err := netlink.LinkSetMaster(hostVeth, newBr); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上述过程当中，我们通过 <code>hostIface.Name</code> 获得主机端 veth 对的接口名称，然后将该链接附加到之前创建的 Linux 网桥上； 接着通过调用 <code>netlink.LinkByName</code> 函数从接口名称中获取链接对象, 然后调用 <code>netlink.LinkSetMaster</code> 函数将链接连接到网桥上。</p>\n<blockquote>\n<p>在操作过程中有一个非常重要的关注点： <strong>确保操作系统不会在命名空间的操作中切换线程</strong><br>可以参考 <a href=\"https://stackoverflow.com/questions/7439608/steps-in-context-switching\">steps-in-context-switching</a> </p>\n<p>命名空间操作需要独占访问某些资源，如进程ID（PID）和网络接口。当一个命名空间被创建或销毁时，内核必须确保该命名空间所拥有的资源被正确分配或释放，并且对这些资源的任何操作都是同步的。</p>\n<p>如果操作系统在命名空间操作进行时切换线程，可能会导致资源冲突或竞赛条件，这可能导致不可预测的行为或系统不稳定。例如，如果一个线程正在设置一个新的网络命名空间，而另一个线程同时试图使用同一个网络接口，这可能会导致资源争夺和数据损坏。</p>\n<p>因此，为了确保命名空间操作的完整性和一致性，操作系统必须以原子方式和互斥方式执行命名空间操作。</p>\n</blockquote>\n<p>所以我们使用以下方式限制,具体的使用手册是：<br><a href=\"https://stackoverflow.com/questions/25361831/benefits-of-runtime-lockosthread-in-golang\">benefits-of-runtime-lockosthread-in-golang</a><br><a href=\"https://pkg.go.dev/runtime\">go-pkg-runtime</a></p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">init</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// this ensures that main runs only on main thread (thread group leader).</span></span><br><span class=\"line\">        <span class=\"comment\">// since namespace ops (unshare, setns) are done for a single thread, we</span></span><br><span class=\"line\">        <span class=\"comment\">// must ensure that the goroutine does not jump from OS thread to thread</span></span><br><span class=\"line\">        runtime.LockOSThread()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过添加上述的代码，我们可以成功给多个 ns 容器提供自己的 veth 设备并接入网桥获取了连通性。然而每个容器依旧是在 L3 不通的，他们并没有唯一可以表示彼此的 IP 地址。 接下来，我们进一步来实验看看如何将 IP 地址分配给各自的容器。</p>\n<p>IP 地址管理在集群中往往是结合 IPAM 插件实现相关的功能，通过接入 k8s apiserver 来同步和获取当前集群内的 IP 地址划分情况以及这些 IP 地址所分配到的节点地址。<br>这里的节点地址是提供给 k8s 建立集群的内网地址，也就是说如果是跨集群的情况，通过这样的方式 ip capsulated 使用的是节点地址，此时如果节点之间二层不可通的话，那么容器之间通过 PodIP 就无法找到彼此。</p>\n<p>不过就本文实现的简易 cni 功能，我们仅通过配置文件来获取容器网络的配置信息，而实现对地址的分配依旧需要借助内核的调用，在此不再重复。但要强调的是，为简单实现，这部分的 IP 支持就仅涉及 IPV4，之后对于 IPV6可能借助 eBPF 实现能够兼容 SRV6 相关特性的 cni， 敬请期待。 </p>\n<p>依据上述的逻辑，我们可以得到接下来的代码实现流程：</p>\n<ol>\n<li>依据配置中生成一个IP对象。</li>\n<li>在目标网络命名空间中调用netlink.AddrAdd。</li>\n</ol>\n<p>那么接着看看 <code>netlink</code>  当中是如何实现他对于地址分配的呢？</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 位于 addr.go</span></span><br><span class=\"line\"><span class=\"comment\">// Addr represents an IP address from netlink. Netlink ip addresses</span></span><br><span class=\"line\"><span class=\"comment\">// include a mask, so it stores the address as a net.IPNet.</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Addr <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\t*net.IPNet</span><br><span class=\"line\">\tLabel       <span class=\"type\">string</span></span><br><span class=\"line\">\tFlags       <span class=\"type\">int</span></span><br><span class=\"line\">\tScope       <span class=\"type\">int</span></span><br><span class=\"line\">\tPeer        *net.IPNet</span><br><span class=\"line\">\tBroadcast   net.IP</span><br><span class=\"line\">\tPreferedLft <span class=\"type\">int</span></span><br><span class=\"line\">\tValidLft    <span class=\"type\">int</span></span><br><span class=\"line\">\tLinkIndex   <span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 位于 addr_linux.go</span></span><br><span class=\"line\"><span class=\"comment\">// AddrAdd will add an IP address to a link device.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// Equivalent to: `ip addr add $addr dev $link`</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// If `addr` is an IPv4 address and the broadcast address is not given, it</span></span><br><span class=\"line\"><span class=\"comment\">// will be automatically computed based on the IP mask if /30 or larger.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">AddrAdd</span><span class=\"params\">(link Link, addr *Addr)</span></span> <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> pkgHandle.AddrAdd(link, addr)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// AddrAdd will add an IP address to a link device.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// Equivalent to: `ip addr add $addr dev $link`</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// If `addr` is an IPv4 address and the broadcast address is not given, it</span></span><br><span class=\"line\"><span class=\"comment\">// will be automatically computed based on the IP mask if /30 or larger.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h *Handle)</span></span> AddrAdd(link Link, addr *Addr) <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">\treq := h.newNetlinkRequest(unix.RTM_NEWADDR, unix.NLM_F_CREATE|unix.NLM_F_EXCL|unix.NLM_F_ACK)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> h.addrHandle(link, addr, req)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>我们使用 golang 提供的 <code>net</code> 包来生成 <code>net.IPNet</code> 类型和它的CIDR形式（IP地址和Mask），然后通过 <code>net.ParseCIDR</code> 来解析配置文件中获取的IP字符串并返回一个 <code>net.IPNet</code> 的指针。而这几步都需要在创建对应网络资源的时候完成绑定，所以我们需要修改前面的处理程序，在创建 veth 时分配 IP 地址。由于从 <code>net.ParseCIDR</code> 得到的 <code>net.IPNet</code> 对象是子网而不是真正的 IP 地址，接下来需要依据此子网生成合适的 IP 地址重新分配。</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> handler = <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(hostNS ns.NetNS)</span></span> <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">    hostVeth, containerVeth, err := ip.SetupVeth(args.IfName, <span class=\"number\">1500</span>, hostNS)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> err</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    hostIface.Name = hostVeth.Name</span><br><span class=\"line\">    <span class=\"comment\">// 在这里创建 IP  地址对象</span></span><br><span class=\"line\">    ipv4Addr, ipv4Net, err := net.ParseCIDR(sb.IP)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> err</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    link, err := netlink.LinkByName(containerVeth.Name)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> err</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 创建 IP 地址</span></span><br><span class=\"line\">    ipv4Net.IP = ipv4Addr</span><br><span class=\"line\"></span><br><span class=\"line\">    addr := &amp;netlink.Addr&#123;IPNet: ipv4Net, Label: <span class=\"string\">&quot;&quot;</span>&#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err = netlink.AddrAdd(link, addr); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> err</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>到这里，一个基础且完整的 <code>cmdAdd</code> 就完成了，我们接着来测试他的功能，通过过以下指令来测试功能</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">删除先前创建的资源</span></span><br><span class=\"line\">sudo ip netns del ns1</span><br><span class=\"line\">sudo ifconfig test down</span><br><span class=\"line\">sudo brctl delbr test</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">重新创建 ns1 来模拟容器</span></span><br><span class=\"line\">sudo ip netns add ns1</span><br><span class=\"line\">go build -o example .</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">执行 cni 来生成地址</span></span><br><span class=\"line\">echo &quot;Ready to call the cni to create ip for ns1&quot;</span><br><span class=\"line\">sudo CNI_COMMAND=ADD CNI_CONTAINERID=ns1 CNI_NETNS=/var/run/netns/ns1 CNI_IFNAME=eth10 CNI_PATH=`pwd` ./example &lt; config</span><br><span class=\"line\">echo &quot;The CNI has been called, see the following results&quot;</span><br><span class=\"line\">echo &quot;The bridge and the veth has been attatch to&quot;</span><br><span class=\"line\">sudo brctl show test</span><br><span class=\"line\">echo &quot;The interface in the netns&quot;</span><br><span class=\"line\">sudo ip netns exec ns1 ifconfig -a</span><br></pre></td></tr></table></figure>\n<p>执行的结果如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@master knet]# ./run.sh </span><br><span class=\"line\">Cannot remove namespace file &quot;/var/run/netns/ns1&quot;: No such file or directory</span><br><span class=\"line\">test: ERROR while getting interface flags: No such device</span><br><span class=\"line\">bridge test doesn&#x27;t exist; can&#x27;t delete it</span><br><span class=\"line\">Ready to call the cni to create ip for ns1</span><br><span class=\"line\">&#123;test 192.0.2.15/24&#125;</span><br><span class=\"line\">The CNI has been called, see the following results</span><br><span class=\"line\">The bridge and the veth has been attatch to</span><br><span class=\"line\">bridge name     bridge id               STP enabled     interfaces</span><br><span class=\"line\">test            8000.b6e6090625de       no              veth2a9d8a3d</span><br><span class=\"line\">The interface in the netns</span><br><span class=\"line\">eth10: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class=\"line\">        inet 192.0.2.15  netmask 255.255.255.0  broadcast 192.0.2.255</span><br><span class=\"line\">        inet6 fe80::477:7aff:fee3:a9b8  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class=\"line\">        ether 06:77:7a:e3:a9:b8  txqueuelen 0  (Ethernet)</span><br><span class=\"line\">        RX packets 1  bytes 90 (90.0 B)</span><br><span class=\"line\">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class=\"line\">        TX packets 1  bytes 90 (90.0 B)</span><br><span class=\"line\">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class=\"line\"></span><br><span class=\"line\">lo: flags=8&lt;LOOPBACK&gt;  mtu 65536</span><br><span class=\"line\">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class=\"line\">        RX packets 0  bytes 0 (0.0 B)</span><br><span class=\"line\">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class=\"line\">        TX packets 0  bytes 0 (0.0 B)</span><br><span class=\"line\">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure>\n<p>可以看到IP地址已经设置到了接口eth10上，接着我们使用下面的命令将IP地址设置到linux网桥上，并使用ping命令来检查主机和目标网络命名空间之间的网络连接情况。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@master knet]# sudo ifconfig test 192.0.2.1</span><br><span class=\"line\">[root@master knet]# sudo ip netns exec ns1 ping 192.0.2.1</span><br><span class=\"line\">PING 192.0.2.1 (192.0.2.1) 56(84) bytes of data.</span><br><span class=\"line\">64 bytes from 192.0.2.1: icmp_seq=1 ttl=64 time=0.077 ms</span><br><span class=\"line\">64 bytes from 192.0.2.1: icmp_seq=2 ttl=64 time=0.044 ms</span><br><span class=\"line\">64 bytes from 192.0.2.1: icmp_seq=3 ttl=64 time=0.053 ms</span><br><span class=\"line\">64 bytes from 192.0.2.1: icmp_seq=4 ttl=64 time=0.045 ms</span><br><span class=\"line\">^C</span><br><span class=\"line\">--- 192.0.2.1 ping statistics ---</span><br><span class=\"line\">4 packets transmitted, 4 received, 0% packet loss, ti</span><br></pre></td></tr></table></figure>\n\n\n<blockquote>\n<p>主要参考文章：<br><a href=\"https://www.hwchiu.com/introduce-cni-iii.html\">Container Network Interface</a><br><a href=\"https://morven.life/posts/create-your-own-cni-with-golang/\">Create your CNI </a></p>\n</blockquote>\n","site":{"data":{}},"cover":"/img/cover/sky3.png","cover_type":"img","excerpt":"","more":"<blockquote>\n<p>使用 Golang 实现一个简易的 CNI<br>对于 CNI 的功能实现将按照循序渐进的方式来进行<br>实现目标</p>\n<ul>\n<li>依据 config 文件创建 bridge 对象并分配 ns 对应的 ip 地址</li>\n<li>提供容器网络通信服务</li>\n</ul>\n</blockquote>\n<h2 id=\"设计简易的-CNI-工作逻辑\"><a href=\"#设计简易的-CNI-工作逻辑\" class=\"headerlink\" title=\"设计简易的 CNI 工作逻辑\"></a>设计简易的 CNI 工作逻辑</h2><p>由于 cni 提供的服务集中于节点的 L2/L3 层通信，所以基础的 cni 大致功能就是通过读取 config 文件配置在本地 Linux 环境当中给容器分配地址并通过 bridge 等设备建立通信能力。</p>\n<p>依据上一篇博客所学习到的 cni 规范，我们可以将 cni 的基础工作逻辑梳理如下：</p>\n<ol>\n<li>kubelet 先创建 pause 容器创建对应的网络命名空间；</li>\n<li>cri 或者是 cni 主程序根据配置调用具体的 CNI 插件，可以配置成 CNI 插件链来进行链式调用；</li>\n<li>当 CNI 插件被调用时，通过传入配置以及命令行参数来获得网络命名空间、容器的网络设备等必要信息，然后执行 ADD 、 DELETE 或者其他操作；</li>\n<li>CNI 插件给 pause 容器配置正确的网络，pod 中其他的容器都是复用 pause 容器的网络；</li>\n</ol>\n<ul>\n<li>当容器准备创建或被终止时，cni 插件被 cri 或者是其他的 cni 插件调用执行功能。<ul>\n<li>当创建容器的时候，为容器分配网络资源，包括 IP 地址和网络连接</li>\n<li>当销毁容器的时候，删除为容器分配的所有网络资源</li>\n</ul>\n</li>\n<li>cni 插件所获取的信息格式如下: (cri 调用或者是其他 cni 插件)<ul>\n<li>cni 执行的命令和操作(cni必须要实现的核心可调用功能)<ul>\n<li>ADD</li>\n<li>DELETE</li>\n<li>VERSION</li>\n<li>CHECK</li>\n</ul>\n</li>\n<li>容器ID(服务的容器对象ID)</li>\n<li>节点容器所连接网络空间的路径</li>\n<li>容器中需要创建的接口名称</li>\n<li>目前节点内 cni 可执行程序所在路径，一般其他的 cni 插件也在这个路径(一般是<code>/opt/cni/bin</code>)</li>\n<li>cni 配置文件的路径</li>\n</ul>\n</li>\n</ul>\n<p>而对于节点运行的 cri 调用 cni 服务，需要在路径中设置 cni 可调用的地址。如果是在 Kubernetes 集群当中， cni 以容器的形式来提供服务就需要在其创建了对应的网桥提供服务之后，设置 cni 当中获取服务的地址为该网桥所在网段。<br>比如 Docker 当中设置 <code>vim /usr/lib/systemd/system/docker.service</code> 中 <code>--bip=10.244.12.1/24 </code> 如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Service]</span><br><span class=\"line\">Type=notify</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">the default is not to use systemd <span class=\"keyword\">for</span> cgroups because the delegate issues still</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">exists and systemd currently does not support the cgroup feature <span class=\"built_in\">set</span> required</span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\"><span class=\"keyword\">for</span> containers run by docker</span></span><br><span class=\"line\">ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock --bip=10.244.12.1/24 --mtu=1450</span><br><span class=\"line\">ExecReload=/bin/kill -s HUP $MAINPID</span><br><span class=\"line\">TimeoutStartSec=0</span><br><span class=\"line\">RestartSec=2</span><br><span class=\"line\">Restart=always</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><h3 id=\"Step1-创建-cni-主流程\"><a href=\"#Step1-创建-cni-主流程\" class=\"headerlink\" title=\"Step1 : 创建 cni 主流程\"></a><strong>Step1 : 创建 cni 主流程</strong></h3><p>首先，一个基本的 cni 需要完成在容器创建时候，依据传入参数为其分配网络资源；同时需要在容器终止时候，删除所有分配的资源。<br>所以可以先得到一个最基本的 cni 主程序框架如下：</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;github.com/containernetworking/cni/pkg/skel&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;github.com/containernetworking/cni/pkg/version&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">cmdAdd</span><span class=\"params\">(args *skel.CmdArgs)</span></span> <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    <span class=\"doctag\">TODO:</span> add code about cmdAdd</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"comment\">// 测试是否 cni 接收到了传入的容器网络配置参数</span></span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">&quot;interfance Name: %s\\n&quot;</span>, args.IfName)</span><br><span class=\"line\">\t  fmt.Printf(<span class=\"string\">&quot;Netns path: %s\\n&quot;</span>, args.Netns)</span><br><span class=\"line\">\t  fmt.Printf(<span class=\"string\">&quot;The config data: %s\\n&quot;</span>, args.StdinData)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">cmdDel</span><span class=\"params\">(args *skel.CmdArgs)</span></span> <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    <span class=\"doctag\">TODO:</span> add code about cmdDel</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    skel.PluginMain(cmdAdd, cmdDel, cmdVersion, cmdCheck)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>按照所归纳的 cni 逻辑，我们已经实现了一个基础的框架，并且可以接受传入的网络配置参数，但目前还没有执行任何的动作。</p>\n<p>传入的参数具体内容定义在 <code>pkg/skel/skel.go</code>:</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// CmdArgs captures all the arguments passed in to the plugin</span></span><br><span class=\"line\"><span class=\"comment\">// via both env vars and stdin</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> CmdArgs <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tContainerID   <span class=\"type\">string</span></span><br><span class=\"line\">\tNetns         <span class=\"type\">string</span></span><br><span class=\"line\">\tIfName        <span class=\"type\">string</span></span><br><span class=\"line\">\tArgs          <span class=\"type\">string</span></span><br><span class=\"line\">\tPath          <span class=\"type\">string</span></span><br><span class=\"line\">\tNetnsOverride <span class=\"type\">string</span></span><br><span class=\"line\">\tStdinData     []<span class=\"type\">byte</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当然 cni 接受参数的目的是去了解该创建怎样的容器网络。但是如何将这些参数传给 cni 呢？ 依据 cni 规范，我们需要从配置文件或者是 cri 传入参数中获取到对应的容器网络需求。顺带一提，在 Kubernetes 网络集群中，kubelet 也并不是直接与 cni 沟通的，所以 cni 本身可以在单节点上创建容器网络以及提供功能，只是说在集群当中可以结合 kubelet 提供 list/watch apiserver 的功能来做局域网内的地址管理和网络连通性，包括 ip capsulating， cidr 等等。</p>\n<p>接下来为检验以上的功能逻辑通畅，创建以下 config 文件：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"attr\">&quot;name&quot;:</span> <span class=\"string\">&quot;mynet&quot;</span>,</span><br><span class=\"line\">\t<span class=\"attr\">&quot;BridgeName&quot;:</span> <span class=\"string\">&quot;test&quot;</span>,</span><br><span class=\"line\">\t<span class=\"attr\">&quot;IP&quot;:</span> <span class=\"string\">&quot;192.0.2.1/24&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>那么接下来就可以，模拟 cri 调用 cni 通过 config 文件指定所创建的容器网络配置创建资源，所使用的指令如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go build -o example .</span><br><span class=\"line\">echo &quot;Ready to call the cni program and create resources&quot;</span><br><span class=\"line\">sudo CNI_COMMAND=ADD CNI_CONTAINERID=ns1 CNI_NETNS=/var/run/netns/ns1 CNI_IFNAME=eth10 CNI_PATH=`pwd` ./example &lt; config</span><br><span class=\"line\">echo &quot;The CNI has been called, see the following results&quot;</span><br></pre></td></tr></table></figure>\n<p>得到以下输出：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@master knet]# ./run.sh</span><br><span class=\"line\">Ready to call the cni program and create resources</span><br><span class=\"line\">interfance Name: eth10</span><br><span class=\"line\">netns path: /var/run/netns/ns1</span><br><span class=\"line\">the config data: &#123;</span><br><span class=\"line\">        &quot;name&quot;: &quot;mynet&quot;,</span><br><span class=\"line\">        &quot;BridgeName&quot;: &quot;test&quot;,</span><br><span class=\"line\">        &quot;IP&quot;: &quot;192.0.2.1/24&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">The CNI has been called, see the following results</span><br></pre></td></tr></table></figure>\n<p>通过这个测试可以明确以上代码可以从命令行当中读取出对应的配置参数，不过仅只是将结果输出而已并没有做更多的操作，当然这并不可能是完整的 cni ，那接下来进一步实现当 cni 获取了这些参数之后该做些什么。</p>\n<h3 id=\"step2-实现-cmdAdd-功能\"><a href=\"#step2-实现-cmdAdd-功能\" class=\"headerlink\" title=\"step2: 实现 cmdAdd 功能\"></a><strong>step2: 实现 cmdAdd 功能</strong></h3><p>本文的目的还是在于理清楚 cni 执行的底层逻辑，所以就不深入探究 cni 的多样功能实现，所以以创建一个 Linux 网桥为目标，具体代码逻辑如下：</p>\n<ol>\n<li>从配置中读取网桥信息。</li>\n<li>获取我们想要使用的网桥名称。</li>\n<li>如果系统中不存在该网桥，则创建它。</li>\n</ol>\n<p>由于 cni 的框架里面将配置内容以[]字节的形式存储在 CmdArgs 对象中，所以我们也应该创建一个结构来解码这些[]字节的数据，数据格式需要兼容规范的各类对象。</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 简单的网桥结构</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> SimpleBridge <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tBridgeName <span class=\"type\">string</span> <span class=\"string\">`json:&quot;bridgeName&quot;`</span></span><br><span class=\"line\">\tIP         <span class=\"type\">string</span> <span class=\"string\">`json:&quot;ip&quot;`</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在cmdAdd中解析传入的参数内容</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">cmdAdd</span><span class=\"params\">(args *skel.CmdArgs)</span></span> <span class=\"type\">error</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>当把配置文件中的数据转化为代码当中的数据结构，接下来我们就需要使用这些数据调用内核接口创建对应的内核资源。就但从目前的实现目标创建 Linux 网桥来说，可以通过原始的 os.Exec 创建，不过这样就需要去深入到不同操作系统和内核的功能实现上，为覆盖这部分的复杂性，我们就直接借用开源的调用来实现这部分的功能</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">1. 准备好我们想要的 netlink.Bridge 对象。</span></span><br><span class=\"line\"><span class=\"comment\">2. 创建网桥对象</span></span><br><span class=\"line\"><span class=\"comment\">3. 设置Linux网桥参数</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">br := &amp;netlink.Bridge&#123;</span><br><span class=\"line\">\tLinkAttrs: netlink.LinkAttrs&#123;</span><br><span class=\"line\">\t\tName: sb.BridgeName,</span><br><span class=\"line\">\t\tMTU:  <span class=\"number\">1500</span>,</span><br><span class=\"line\">\t\t<span class=\"comment\">// Let kernel use default txqueuelen; leaving it unset</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// means 0, and a zero-length TX queue messes up FIFO</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// traffic shapers which use TX queue length as the</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// default packet limit</span></span><br><span class=\"line\">\t\tTxQLen: <span class=\"number\">-1</span>,</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">err := netlink.LinkAdd(br)</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &amp;&amp; err != syscall.EEXIST &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> err := netlink.LinkSetUp(br); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>当然， cni 的实质原理就是接入 Linux 内核的调用并创建内核资源，所以需要调用借助一些相关的调用，上述代码使用的是 cni 官方整理 <code>github.com/containernetworking/cni/pkg/skel</code> 。除此之外，本文还收集了相关的一些 Go 仓库来帮助接下来的项目推进。<br><a href=\"https://github.com/vishvananda/netlink\">netlink</a><br><a href=\"https://github.com/containerd/go-cni/tree/main\">go-cni</a><br><a href=\"https://github.com/containerd/go-cni/tree/main\">intel-cni</a><br><a href=\"https://github.com/containerd/go-cni/tree/main\">sr-cni</a></p>\n</blockquote>\n<p>到这一步，代码就完成了对内核资源的创建和修改，接下来就是将这些将这些资源分配到需求的容器网络上。通过对于 Linux 网络的学习，我们可以想到一个非常简单的方法就是创建 veth 设备并将一端放入容器中，另一端插入到创建的网桥当中，这样网桥所连接的容器就都相当于共享同一个二层设备，划分到同一个子网当中。实际上大部分的 cni 也是同样的操作，不过仅仅设置一个单网桥对于高速网络或者是多功能多层次网络的服务可能稍显不足，这部分的功能会使用 eBPF 来作为补足。</p>\n<p>说干就干，我们整理出一下需要继续添加到代码工程当中的逻辑：</p>\n<ol>\n<li>从我们之前创建的Bridge中获取Bridge对象</li>\n<li>获取容器的命名空间</li>\n<li>在容器上创建一个 veth，并将主机端 veth 移至主机 ns。</li>\n<li>将主机端 veth 附加到 linux bridge 上</li>\n</ol>\n<p>在这个过程当中有一些地方需要注意：</p>\n<ul>\n<li>需要检验已创建的网络资源，避免冲突</li>\n<li>获取并处理容器的网络空间</li>\n</ul>\n<p>这些问题如果是单独实现一个独立的 cni 插件，那么就不可避免需要考虑环境问题。(1) 怎样与其他的 cni 功能兼容或者是当检验到节点上有使用其他的 cni 插件，需要提醒用户卸载其他的 cni 插件再来安装配置. (2) 清除先前的程序遗留的网络配置参数和内容，保证不出现集群网络的资源冲突。(3) 分配资源的对象参数获取，这里其实指的就是容器网络。</p>\n<p>这些麻烦都可以在对内核交互的调用中查询，此外还有其他的需求，也考虑在将来使用 eBPF 来做进一步的开发和补充。</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取本地的网络设备情况</span></span><br><span class=\"line\">l, err := netlink.LinkByName(sb.BridgeName)</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">&quot;could not lookup %q: %v&quot;</span>, sb.BridgeName, err)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 比较是否有冲突的问题</span></span><br><span class=\"line\">newBr, ok := l.(*netlink.Bridge)</span><br><span class=\"line\"><span class=\"keyword\">if</span> !ok &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">&quot;%q already exists but is not a bridge&quot;</span>, sb.BridgeName)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>而对于容器网络信息的获取，在之前的指令中也涉及到<code>CNI_CONTAINERID=ns1 CNI_NETNS=/var/run/netns/ns1</code>,这部分信息可以通过传入的参数获取。</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">netns, err := ns.GetNS(args.Netns)</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接下来对于每一个 <code>NetNs</code>对象（也就是容器对象），我们需要为它创建一个 veth 设备，并将它附加到创建的网桥上。</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 设置 Handler ,为调用 handler 的容器创建 veth [此时 veth 的一端在容器内，另一端在 hostNS]</span></span><br><span class=\"line\">hostIface := &amp;current.Interface&#123;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> handler = <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(hostNS ns.NetNS)</span></span> <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">\t\thostVeth, _, err := ip.SetupVeth(args.IfName, <span class=\"number\">1500</span>, hostNS)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\thostIface.Name = hostVeth.Name</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 为每一个容器调用 handler</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> err := netns.Do(handler); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取所创建的 Bridge </span></span><br><span class=\"line\">hostVeth, err := netlink.LinkByName(hostIface.Name)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将 veth 附加到创建的网桥上</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> err := netlink.LinkSetMaster(hostVeth, newBr); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上述过程当中，我们通过 <code>hostIface.Name</code> 获得主机端 veth 对的接口名称，然后将该链接附加到之前创建的 Linux 网桥上； 接着通过调用 <code>netlink.LinkByName</code> 函数从接口名称中获取链接对象, 然后调用 <code>netlink.LinkSetMaster</code> 函数将链接连接到网桥上。</p>\n<blockquote>\n<p>在操作过程中有一个非常重要的关注点： <strong>确保操作系统不会在命名空间的操作中切换线程</strong><br>可以参考 <a href=\"https://stackoverflow.com/questions/7439608/steps-in-context-switching\">steps-in-context-switching</a> </p>\n<p>命名空间操作需要独占访问某些资源，如进程ID（PID）和网络接口。当一个命名空间被创建或销毁时，内核必须确保该命名空间所拥有的资源被正确分配或释放，并且对这些资源的任何操作都是同步的。</p>\n<p>如果操作系统在命名空间操作进行时切换线程，可能会导致资源冲突或竞赛条件，这可能导致不可预测的行为或系统不稳定。例如，如果一个线程正在设置一个新的网络命名空间，而另一个线程同时试图使用同一个网络接口，这可能会导致资源争夺和数据损坏。</p>\n<p>因此，为了确保命名空间操作的完整性和一致性，操作系统必须以原子方式和互斥方式执行命名空间操作。</p>\n</blockquote>\n<p>所以我们使用以下方式限制,具体的使用手册是：<br><a href=\"https://stackoverflow.com/questions/25361831/benefits-of-runtime-lockosthread-in-golang\">benefits-of-runtime-lockosthread-in-golang</a><br><a href=\"https://pkg.go.dev/runtime\">go-pkg-runtime</a></p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">init</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// this ensures that main runs only on main thread (thread group leader).</span></span><br><span class=\"line\">        <span class=\"comment\">// since namespace ops (unshare, setns) are done for a single thread, we</span></span><br><span class=\"line\">        <span class=\"comment\">// must ensure that the goroutine does not jump from OS thread to thread</span></span><br><span class=\"line\">        runtime.LockOSThread()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过添加上述的代码，我们可以成功给多个 ns 容器提供自己的 veth 设备并接入网桥获取了连通性。然而每个容器依旧是在 L3 不通的，他们并没有唯一可以表示彼此的 IP 地址。 接下来，我们进一步来实验看看如何将 IP 地址分配给各自的容器。</p>\n<p>IP 地址管理在集群中往往是结合 IPAM 插件实现相关的功能，通过接入 k8s apiserver 来同步和获取当前集群内的 IP 地址划分情况以及这些 IP 地址所分配到的节点地址。<br>这里的节点地址是提供给 k8s 建立集群的内网地址，也就是说如果是跨集群的情况，通过这样的方式 ip capsulated 使用的是节点地址，此时如果节点之间二层不可通的话，那么容器之间通过 PodIP 就无法找到彼此。</p>\n<p>不过就本文实现的简易 cni 功能，我们仅通过配置文件来获取容器网络的配置信息，而实现对地址的分配依旧需要借助内核的调用，在此不再重复。但要强调的是，为简单实现，这部分的 IP 支持就仅涉及 IPV4，之后对于 IPV6可能借助 eBPF 实现能够兼容 SRV6 相关特性的 cni， 敬请期待。 </p>\n<p>依据上述的逻辑，我们可以得到接下来的代码实现流程：</p>\n<ol>\n<li>依据配置中生成一个IP对象。</li>\n<li>在目标网络命名空间中调用netlink.AddrAdd。</li>\n</ol>\n<p>那么接着看看 <code>netlink</code>  当中是如何实现他对于地址分配的呢？</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 位于 addr.go</span></span><br><span class=\"line\"><span class=\"comment\">// Addr represents an IP address from netlink. Netlink ip addresses</span></span><br><span class=\"line\"><span class=\"comment\">// include a mask, so it stores the address as a net.IPNet.</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Addr <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\t*net.IPNet</span><br><span class=\"line\">\tLabel       <span class=\"type\">string</span></span><br><span class=\"line\">\tFlags       <span class=\"type\">int</span></span><br><span class=\"line\">\tScope       <span class=\"type\">int</span></span><br><span class=\"line\">\tPeer        *net.IPNet</span><br><span class=\"line\">\tBroadcast   net.IP</span><br><span class=\"line\">\tPreferedLft <span class=\"type\">int</span></span><br><span class=\"line\">\tValidLft    <span class=\"type\">int</span></span><br><span class=\"line\">\tLinkIndex   <span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 位于 addr_linux.go</span></span><br><span class=\"line\"><span class=\"comment\">// AddrAdd will add an IP address to a link device.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// Equivalent to: `ip addr add $addr dev $link`</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// If `addr` is an IPv4 address and the broadcast address is not given, it</span></span><br><span class=\"line\"><span class=\"comment\">// will be automatically computed based on the IP mask if /30 or larger.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">AddrAdd</span><span class=\"params\">(link Link, addr *Addr)</span></span> <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> pkgHandle.AddrAdd(link, addr)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// AddrAdd will add an IP address to a link device.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// Equivalent to: `ip addr add $addr dev $link`</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// If `addr` is an IPv4 address and the broadcast address is not given, it</span></span><br><span class=\"line\"><span class=\"comment\">// will be automatically computed based on the IP mask if /30 or larger.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h *Handle)</span></span> AddrAdd(link Link, addr *Addr) <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">\treq := h.newNetlinkRequest(unix.RTM_NEWADDR, unix.NLM_F_CREATE|unix.NLM_F_EXCL|unix.NLM_F_ACK)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> h.addrHandle(link, addr, req)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>我们使用 golang 提供的 <code>net</code> 包来生成 <code>net.IPNet</code> 类型和它的CIDR形式（IP地址和Mask），然后通过 <code>net.ParseCIDR</code> 来解析配置文件中获取的IP字符串并返回一个 <code>net.IPNet</code> 的指针。而这几步都需要在创建对应网络资源的时候完成绑定，所以我们需要修改前面的处理程序，在创建 veth 时分配 IP 地址。由于从 <code>net.ParseCIDR</code> 得到的 <code>net.IPNet</code> 对象是子网而不是真正的 IP 地址，接下来需要依据此子网生成合适的 IP 地址重新分配。</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> handler = <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(hostNS ns.NetNS)</span></span> <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">    hostVeth, containerVeth, err := ip.SetupVeth(args.IfName, <span class=\"number\">1500</span>, hostNS)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> err</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    hostIface.Name = hostVeth.Name</span><br><span class=\"line\">    <span class=\"comment\">// 在这里创建 IP  地址对象</span></span><br><span class=\"line\">    ipv4Addr, ipv4Net, err := net.ParseCIDR(sb.IP)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> err</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    link, err := netlink.LinkByName(containerVeth.Name)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> err</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 创建 IP 地址</span></span><br><span class=\"line\">    ipv4Net.IP = ipv4Addr</span><br><span class=\"line\"></span><br><span class=\"line\">    addr := &amp;netlink.Addr&#123;IPNet: ipv4Net, Label: <span class=\"string\">&quot;&quot;</span>&#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err = netlink.AddrAdd(link, addr); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> err</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>到这里，一个基础且完整的 <code>cmdAdd</code> 就完成了，我们接着来测试他的功能，通过过以下指令来测试功能</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">删除先前创建的资源</span></span><br><span class=\"line\">sudo ip netns del ns1</span><br><span class=\"line\">sudo ifconfig test down</span><br><span class=\"line\">sudo brctl delbr test</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">重新创建 ns1 来模拟容器</span></span><br><span class=\"line\">sudo ip netns add ns1</span><br><span class=\"line\">go build -o example .</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">执行 cni 来生成地址</span></span><br><span class=\"line\">echo &quot;Ready to call the cni to create ip for ns1&quot;</span><br><span class=\"line\">sudo CNI_COMMAND=ADD CNI_CONTAINERID=ns1 CNI_NETNS=/var/run/netns/ns1 CNI_IFNAME=eth10 CNI_PATH=`pwd` ./example &lt; config</span><br><span class=\"line\">echo &quot;The CNI has been called, see the following results&quot;</span><br><span class=\"line\">echo &quot;The bridge and the veth has been attatch to&quot;</span><br><span class=\"line\">sudo brctl show test</span><br><span class=\"line\">echo &quot;The interface in the netns&quot;</span><br><span class=\"line\">sudo ip netns exec ns1 ifconfig -a</span><br></pre></td></tr></table></figure>\n<p>执行的结果如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@master knet]# ./run.sh </span><br><span class=\"line\">Cannot remove namespace file &quot;/var/run/netns/ns1&quot;: No such file or directory</span><br><span class=\"line\">test: ERROR while getting interface flags: No such device</span><br><span class=\"line\">bridge test doesn&#x27;t exist; can&#x27;t delete it</span><br><span class=\"line\">Ready to call the cni to create ip for ns1</span><br><span class=\"line\">&#123;test 192.0.2.15/24&#125;</span><br><span class=\"line\">The CNI has been called, see the following results</span><br><span class=\"line\">The bridge and the veth has been attatch to</span><br><span class=\"line\">bridge name     bridge id               STP enabled     interfaces</span><br><span class=\"line\">test            8000.b6e6090625de       no              veth2a9d8a3d</span><br><span class=\"line\">The interface in the netns</span><br><span class=\"line\">eth10: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class=\"line\">        inet 192.0.2.15  netmask 255.255.255.0  broadcast 192.0.2.255</span><br><span class=\"line\">        inet6 fe80::477:7aff:fee3:a9b8  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class=\"line\">        ether 06:77:7a:e3:a9:b8  txqueuelen 0  (Ethernet)</span><br><span class=\"line\">        RX packets 1  bytes 90 (90.0 B)</span><br><span class=\"line\">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class=\"line\">        TX packets 1  bytes 90 (90.0 B)</span><br><span class=\"line\">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class=\"line\"></span><br><span class=\"line\">lo: flags=8&lt;LOOPBACK&gt;  mtu 65536</span><br><span class=\"line\">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class=\"line\">        RX packets 0  bytes 0 (0.0 B)</span><br><span class=\"line\">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class=\"line\">        TX packets 0  bytes 0 (0.0 B)</span><br><span class=\"line\">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure>\n<p>可以看到IP地址已经设置到了接口eth10上，接着我们使用下面的命令将IP地址设置到linux网桥上，并使用ping命令来检查主机和目标网络命名空间之间的网络连接情况。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@master knet]# sudo ifconfig test 192.0.2.1</span><br><span class=\"line\">[root@master knet]# sudo ip netns exec ns1 ping 192.0.2.1</span><br><span class=\"line\">PING 192.0.2.1 (192.0.2.1) 56(84) bytes of data.</span><br><span class=\"line\">64 bytes from 192.0.2.1: icmp_seq=1 ttl=64 time=0.077 ms</span><br><span class=\"line\">64 bytes from 192.0.2.1: icmp_seq=2 ttl=64 time=0.044 ms</span><br><span class=\"line\">64 bytes from 192.0.2.1: icmp_seq=3 ttl=64 time=0.053 ms</span><br><span class=\"line\">64 bytes from 192.0.2.1: icmp_seq=4 ttl=64 time=0.045 ms</span><br><span class=\"line\">^C</span><br><span class=\"line\">--- 192.0.2.1 ping statistics ---</span><br><span class=\"line\">4 packets transmitted, 4 received, 0% packet loss, ti</span><br></pre></td></tr></table></figure>\n\n\n<blockquote>\n<p>主要参考文章：<br><a href=\"https://www.hwchiu.com/introduce-cni-iii.html\">Container Network Interface</a><br><a href=\"https://morven.life/posts/create-your-own-cni-with-golang/\">Create your CNI </a></p>\n</blockquote>\n"},{"layout":"source/_posts/edgemesh/2023-ospp-fighting/","title":"CNI 与  Pod 容器网络—— Linux 网络","catalog":true,"date":"2023-04-18T21:02:23.000Z","_content":"\n\n# CNI 与  Pod 容器网络—— Linux 网络\n\n> Pod 容器在 kubernetes 网络中是怎样获取他的地址的呢? \n>\n> 如何保障 Pod IP 在整个集群当中的唯一性？\n>\n> 容器流量如何在所给的IP之间相互转发？\n\n---\n\n## 从 namespace 开始\n\nnamespace 技术是 Linux 内核提供的一项非常重要的功能，也是容器虚拟化的基础技术，通过构建系统资源的边界，形成一个相对封闭的资源区域，也就是大家认识的容器。Linux 提供的 namespace 包括以下几个方面：\n\n``` bash\n       Linux provides the following namespaces:\n\n       Namespace   Constant          Isolates\n       Cgroup      CLONE_NEWCGROUP   Cgroup root directory\n       IPC         CLONE_NEWIPC      System V IPC, POSIX message queues\n       Network     CLONE_NEWNET      Network devices, stacks, ports, etc.\n       Mount       CLONE_NEWNS       Mount points\n       PID         CLONE_NEWPID      Process IDs\n       User        CLONE_NEWUSER     User and group IDs\n       UTS         CLONE_NEWUTS      Hostname and NIS domain name\n```\n\n其中网络名字空间(network namespace)是网络虚拟化技术的基础，也是本文最为关注的部分；现有的各项容器技术在实现他们各自的网络连接时所依赖的核心，所以要探究 Pod 网络和 CNI 就必须先从 network namespace 入手。\n\n在 Linux 系统当中，每一个 network  namespace  都有他自己的网络设置，包括（routing table）路由表、（network interface）网络设备、（IP address）IP 地址等等，这样隔离的一个典型好处就是在不同的network namespace 之下程序可以绑定到同一个端口并保持各自的网络约束不变。与其他的 namespace 一样, network namspace 也可以调用 clone() API创建一个通用的 namespace, 然后传入 CLONE_NEWNET 参数来创建 network namespace。不过就简单配置来说， 可以使用 **netns** 执行对 networkname space  的各项增删改查。\n\n依据 network namspace 划分出网络区域就像是创建网络通信的对端，但光有隔离出来的对象并不能构成网络；容器还要和外界进行网络联通才能提供服务。与实际网络场景不相同的是，没有物理实体的交换机和路由器，甚至可用的物理网卡也是受限的，那么如何能够在划分隔离出的区域之间提供通信呢？同时如何能够定位这些区域并让数据包能够正确地从一个 netns 中传输到另一个 netns呢？\n\n---\n\n## veth 的创建和连接\n\n首先要清楚 veth-pairs， veth 是虚拟以太网卡（virtual Ethernet）的缩写，veth 设备总是成对出现的，也因此称之为 veth-pair。可以通过` ip link add veth0 type veth peer name veth1` 等指令来创建管理这些虚拟网卡，eg ：[从docker0开始](https://morningspace.github.io/tech/k8s-net-docker0/) ，[Deep dive into Linux Networking and Docker | Medium](https://medium.com/techlog/diving-into-linux-networking-and-docker-bridge-veth-and-iptables-a05eb27b1e72) 等文章就有讲到其作用和类似操作，不再复述。\n\n但关键在于对于系统来说，veth到底是什么呢？是一个文件，进程还是描述符,他是否直接和物理网卡相关？它的工作原理是什么，是怎样来让容器之间相互通信的呢？接着来深入研究其内核当中的实现，具体参考：[veth(4) - Linux manual page (man7.org)](https://man7.org/linux/man-pages/man4/veth.4.html)，[linux/veth.c at master · torvalds/linux (github.com)](https://github.com/torvalds/linux/blob/master/drivers/net/veth.c)\n\nveth的相关源码位于 `drivers/net/veth.c`中，其中的初始化入口是`veth_init`\n\n``` c\nstatic __init int veth_init(void)\n{\n\treturn rtnl_link_register(&veth_link_ops);\n}\n```\n\n初始化函数注册了`veth_link_ops`(veth 设备的操作方法)，它包含了 veth 设备的创建启动和删除等回调函数，具体结构如下:\n\n```c\nstatic struct rtnl_link_ops veth_link_ops = {\n\t.kind\t\t= DRV_NAME,\n\t.priv_size\t= sizeof(struct veth_priv),\n\t.setup\t\t= veth_setup,\n\t.validate\t= veth_validate,\n\t.newlink\t= veth_newlink,\n\t.dellink\t= veth_dellink,\n\t.policy\t\t= veth_policy,\n\t.maxtype\t= VETH_INFO_MAX,\n\t.get_link_net\t= veth_get_link_net,\n\t.get_num_tx_queues\t= veth_get_num_queues,\n\t.get_num_rx_queues\t= veth_get_num_queues,\n};\n```\n\n从 `kind` 到 `setup` 都是创建对应的数据结构并写入常量参数,所以创建的关键还是在 `veth_newlink`,`veth_dellink`，但二者的执行逻辑相关，所以只看其中一个。 \n\n首先是 `veth_newlink`, 不过他的实现较长，只能抓取一部分关键拆分开来看：\n\n```c\nstatic int veth_newlink(struct net *src_net, struct net_device *dev,\n\t\t\tstruct nlattr *tb[], struct nlattr *data[],\n\t\t\tstruct netlink_ext_ack *extack)\n{\n    ...\n    // 由于虚拟网络设备对是由两个网络设备组成,\n    // dev 是虚拟网络设备对的其中一个网络设备，不可能创建单独的设备，那就需要创建一个临时的对端 peer\n    // 因而调用 rtnl_create_link 函数创建对端网络设备的逻辑对象 peer \n\tpeer = rtnl_create_link(net, ifname, name_assign_type,\n\t\t\t\t&veth_link_ops, tbp, extack);\n\terr = register_netdevice(peer);\n    ...\n    // 注册 dev 对象，本质上就在内存里面建立一个 struct 并将信息从文件映射过去\n\terr = register_netdevice(dev);\n\n    ...\n    // 把 peer 和 dev 关联到一起\n\tpriv = netdev_priv(dev);               // 获取 dev 的私有数据部分\n\trcu_assign_pointer(priv->peer, peer);  // 将其 peer 字段指向 dev\n\terr = veth_init_queues(dev, tb);\n\tpriv = netdev_priv(peer);              // 获取 peer 的私有数据部分\n\trcu_assign_pointer(priv->peer, dev);   // 将其 peer 字段指向 dev\n    ...\n\terr = veth_init_queues(peer, tb);\n    \n    // 添加 XDP 访问支持 --> veth 在内核运行流程中接近网卡\n    ...\n\t/* update XDP supported features */\n\tveth_set_xdp_features(dev);\n\tveth_set_xdp_features(peer);\n    ...\n}\n```\n\n在`veth_newlink`当中通过**`register_netdevice`** 注册了两个网络虚拟设备： `peer` 和 `dev`，并通过让 `dev` 的 peer 指针指向创建的 peer，让`peer` 的 peer  指针指向 dev，来完成了 veth 设备的结对。这个过程是符合 veth 的工作逻辑的，由于  veth 总是成对出现，所以在生成新的 veth 时候就需要指定它所连接对端  peer，当然这个过程发生在内核运行当中，并不是有物理上的连接关系，直白来说就是依据文件信息写入到内存，开辟一个空间来存储对应的信息，然后修改指针指向来表示连接关系。\n\n创建完成之后，veth 又是怎么来传输数据的呢？回到之前的 `veth_setup`,启动 veth 的流程，也是将各类函数注册指定到 veth 对象当中\n\n```C\nstatic void veth_setup(struct net_device *dev)\n{\n\tether_setup(dev);\n    ...\n\tdev->netdev_ops = &veth_netdev_ops;\n\tdev->xdp_metadata_ops = &veth_xdp_metadata_ops;\n\tdev->ethtool_ops = &veth_ethtool_ops;\n    ...\n}\n```\n\n可以看到是 veth 对象的操作列表包含三类：`veth_netdev_ops`,`veth_xdp_metadata_ops`,`veth_ethtool_ops`, 具体的列表如下：\n\nnet_device_ops 结构是网络设备的操作函数集结构, 包含了 Linux 网络设备对象的各项操作行为列表，也是  veth 对象调用实现功能的具体行为。\n\n从以下列表其实可以知道，Linux 设备是通用一个网卡的代码数据操作流程及对象的，以下的操作函数对于 ebpf xdp 程序直接操作有一定参考，是EdgeMesh 为来优化的对象，故进一步深入探究。\n\n```C\nstatic const struct net_device_ops veth_netdev_ops = {\n\t.ndo_init            = veth_dev_init,\n\t.ndo_open            = veth_open,\n\t.ndo_stop            = veth_close,\n\t.ndo_start_xmit      = veth_xmit,\n\t.ndo_get_stats64     = veth_get_stats64,\n\t.ndo_set_rx_mode     = veth_set_multicast_list,\n\t.ndo_set_mac_address = eth_mac_addr,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t= veth_poll_controller,\n#endif\n\t.ndo_get_iflink\t\t= veth_get_iflink,\n\t.ndo_fix_features\t= veth_fix_features,\n\t.ndo_set_features\t= veth_set_features,\n\t.ndo_features_check\t= passthru_features_check,\n\t.ndo_set_rx_headroom\t= veth_set_rx_headroom,\n\t.ndo_bpf\t\t= veth_xdp,\n\t.ndo_xdp_xmit\t\t= veth_ndo_xdp_xmit,\n\t.ndo_get_peer_dev\t= veth_peer_dev,\n};\n```\n\n这些函数的具体作用如下整理：\n\n- `ndo_init`: 该函数指向 `veth_dev_init`，网络设备初始化函数，由驱动程序实现，在网卡设备分配之后调用。\n\n- `ndo_open`: 该函数指向 `veth_open`，被调用以打开虚拟网络设备并将其加入网络协议栈，由驱动程序实现，用于开启网络设备并为进程提供网络访问。\n- `ndo_stop`：该函数指向 `veth_close`，由驱动程序实现，被调用以停止虚拟网络设备并将其从网络协议栈中移除。\n- ==`ndo_start_xmit`：该函数指向 `veth_xmit`，由驱动程序实现，用于将给定的网络数据帧发送到指定的网络设备上。==\n- `ndo_get_stats64`：该函数指向 `veth_get_stats64`，由驱动程序实现，用于获取虚拟网络设备当前的统计信息。\n- `ndo_set_rx_mode`：该函数指向 `veth_set_multicast_list`，由驱动程序实现，用于设置网络设备接收模式。\n- `ndo_set_mac_address`：该函数指向 `eth_mac_addr`，用于设置虚拟网络设备的MAC地址。\n- `ndo_poll_controller`：该函数指向 `veth_poll_controller`，由驱动程序实现，veth调用之后触发软中断从 Ringbuffer 当中 poll 数据包\n- `ndo_get_iflink`：该函数指向 `veth_get_iflink`，用于获取虚拟网络设备的网络接口索引号。\n- `ndo_fix_features`：该函数指向 `veth_fix_features`，用于设置虚拟网络设备的特性参数；\n- `ndo_set_features`：该函数指向 `veth_set_features`，用于修改或更新虚拟网络设备已经打开的特性参数。\n- `ndo_features_check`：该函数指向 `passthru_features_check`，检查虚拟网络设备是否包含由 ETS（Enhanced Traffic Service）要求的特征。\n- `ndo_set_rx_headroom`: 该函数指向 `veth_set_rx_headroom`，用于设置虚拟网络设备中下行数据帧包头部的大小。\n- `ndo_bpf`：该函数指向 `veth_xdp`，用于添加eBPF扩展程序入口并进行初始化。\n- `ndo_xdp_xmit`: 该函数指向 `veth_ndo_xdp_xmit`，驱动程序的XDP传输方法入口，将网络数据帧发送到用户提供的XDP扩展程序。\n- `ndo_get_peer_dev`: 该函数指向 `veth_peer_dev`，用于获取与虚拟网络设备配对的网络设备。 \n\n`ethtool_ops`结构则代表了与`ethtool`工具相关的网络设备操作函数集合。`ethtool`用于获取和设置与`ethtool`兼容设备的驱动程序和硬件信息，同时实现均衡网速，流量控制等功能。\n\n``` C\nstatic const struct ethtool_ops veth_ethtool_ops = {\n\t.get_drvinfo\t\t= veth_get_drvinfo,\n\t.get_link\t\t= ethtool_op_get_link,\n\t.get_strings\t\t= veth_get_strings,\n\t.get_sset_count\t\t= veth_get_sset_count,\n\t.get_ethtool_stats\t= veth_get_ethtool_stats,\n\t.get_link_ksettings\t= veth_get_link_ksettings,\n\t.get_ts_info\t\t= ethtool_op_get_ts_info,\n\t.get_channels\t\t= veth_get_channels,\n\t.set_channels\t\t= veth_set_channels,\n};\n```\n\n`xdp_metadata_ops`结构体定义了XDP（eBPF based packet processing）元数据的操作集合，在实现高性能网络数据包处理、过滤和转发的过程中起到重要作用。该操作集与XDP引擎密切相关，包括xsk_frame_parse（对接收的数据包的元数据进行解析）和xsk_frame_init（初始化元数据）等。\n\n```c\nstatic const struct xdp_metadata_ops veth_xdp_metadata_ops = {\n\t.xmo_rx_timestamp\t\t= veth_xdp_rx_timestamp,\n\t.xmo_rx_hash\t\t\t= veth_xdp_rx_hash,\n};\n```\n\n- `xmo_rx_timestamp` ： 该函数指针指向 `veth_xdp_rx_timestamp` 函数，用于获取 XDP 包的接收时间戳，即处理 XDP 包的内核进程把包抓取的时间。该时间可以在 eBPF 程序中使用，例如可用于实现延迟测量(metric)，排除处理器竞争以及路由表测量等。\n\n- `xmo_rx_hash`：该函数指针指向 `veth_xdp_rx_hash`，用于获取 XDP 数据包的接收哈希值。通过接收哈希值，可以在 eBPF 中就各个数据包的接收位置和网络环境进行更好的控制和调节，以优化网络性能。例如在基于哈希的负载均衡中，可以使用哈希值来决定要将数据包路由到哪个接收 CPU 或内核上。\n\n在 Linux 中，这些函数指针被定义为可选项，也就是说并非每个驱动程序都会实现这两个函数指针。`xdp_metadata_ops` 使驱动程序与 eBPF程序 在处理特定的数据包和流量时更加灵活；但反过来说也需要配备一定的环境才能够实现这些调用的功能。\n\n到这里，veth 的创建和各项功能在 Linux 视角的样子就全部呈现了，总的来说 veth 本身是 Linux 中创建的 `net_device` 结构，通过注册所需的初始化和操作行为等特定函数以及对其进行相应的参数配置，最终实例化为 veth 对象，用于虚拟网络的构建。同时更明确了 veth 是工作在二层的数据结构，他传输数据会调用驱动程序实现的 `ndo_start_xmit`函数，在指定了对端之后，数据包发送会存入 skb 并插入 `softnet_data->input_pkt_queue`中，出发软中断，接下来就是对称一般的内核接收过程。\n\n---\n\n## 网桥的连接和传输\n\nveth 可以感性地认知为网卡，它给予了所划分出的 network namspace 一个出入的门，此前的结构如果将 veth 分别指向两个网络空间，就能够实现这二者的通信，但是当所划分的网络空间区域增加的时候，这样子点对点的连接方式显然就很难支撑了。\n\n这样就需要解决单节点大量容器之间的网络互连问题。\n\n参考实际物理网络的结构，Linux 实现并提供了一个完全由软件虚拟出来的交换机，它可以提供很多的虚拟端口，把许多的 veth 连接在一个平面的网络，通过自己的转发功能让虚拟机网卡之间可以通信，这个技术就叫做 bridge。\n\n如何使用 bridge 连接不同的网络空间呢？[Introduction to Linux interfaces for virtual networking | Red Hat Developer](https://developers.redhat.com/blog/2018/10/22/introduction-to-linux-interfaces-for-virtual-networking#team_device)，[Deep dive into Linux Networking and Docker - Bridge, vETH and IPTables - DEV Community](https://dev.to/arriqaaq/diving-into-linux-networking-and-docker-bridge-veth-and-iptables-419a)  等文章也有详尽阐述，不再复述。\n\n其中要关注的点是： bridge 的工作源码都是在 /net/core/dev.c 或者是 /net/bridge 目录下面，也就是说他是工作在二层上的设备（这一点与物理交换相同），但所给的实验来验证连通性是依靠 ping 指令从IP来看的，但这并不意味着 bridge 是依靠 IP  来做转发的。\n\n为了验证这一点，深入来看 bridge 的内核实现\n\n从外部网络到达节点时候，数据包会被网卡先送到 RingBuffer 中，然后依次经过硬中断、软中断处理，在软中断中再以此把包送到设备层（连接bridge）、协议栈，最后唤醒应用程序。\n\n从节点内的应用程序到达外部的时候，会从应用程序调用系统调用，在进入协议栈（传输层、网络层），再进入邻居子系统到网络设备子系统（bridge），之后调用驱动程序触发硬中断到网卡。\n\n在这个过程中，bridge 输入数据包处理工作流程在 `/net/bridge/br_input.c` 中 `br_handle_frame_finish`函数里\n\n```c\nint br_handle_frame_finish(struct net *net, struct sock *sk, struct sk_buff *skb)\n{\n    // 获取 veth 所连接的网桥端口以及 bridge 设备\n\tstruct net_bridge_port *p = br_port_get_rcu(skb->dev);\n    // 创建转发表对象\n\tstruct net_bridge_fdb_entry *dst = NULL;\n    \n\tstruct net_bridge_mcast_port *pmctx;\n\tstruct net_bridge_mdb_entry *mdst;\n\tstruct net_bridge_vlan *vlan;\n\tstruct net_bridge *br;\n\tbr = p->br;\n    \n    // 查找并更新转发表，这个转发表使用的地址是eth_hdr(skb)->h_source\n\tbr_fdb_update(br, p, eth_hdr(skb)->h_source,vid, BIT(BR_FDB_LOCKED));\t\n\tdst = br_fdb_find_rcu(br, eth_hdr(skb)->h_dest, vid);\n    \n    // 转发\n\tif (dst) {\n\t\tbr_forward(dst->dst, skb, local_rcv, false);\n    // 本机访问\n\tif (local_rcv)\n\t\treturn br_pass_frame_up(skb);\n}\n```\n\n其中查找和转发使用的地址是eth_hdr(skb)->h_dest，和物理环境当中的交换机会自动学习端口所对应的节点mac地址一样，软件模拟的 bridge 也会自学习 veth 与 eth_hdr 的对应关系。\n\n总的来说，当创建了 bridge 并把 veth 设备放入其中，网桥就能够为连接的网络空间提供一个平面的网络连接服务。\n\n其实到目前为止，所涉及的网络设备都工作在二层，对应到物理环境就是都使用的 MAC 地址进行寻址和交换信息，这样的网络服务就是 Linux  基本网络服务，能够实现单节点上的网络空间连通性。\n\n可只是这样是无法满足Kubernetes 集群的网络寻址和路由需求的，现有的网络追求平面式的连接服务但是底层依旧还是得通过IP进行寻址；回到容器网络当中，这也意味着希望在容器网络当中的实体能够拥有各自独立、唯一的IP地址，可以是容器、物理机或者是其他的网络设备（比如虚拟路由器）等，容器可以被添加到一个或多个网络中或从一个或多个网络中删除。这就是接下来 CNI 需要满足的功能之一。\n\n---\n\n","source":"_posts/EdgeMesh/2023-ospp-fighting/CNI-LinuxNetwork.md","raw":"---\nlayout: source/_posts/edgemesh/2023-ospp-fighting/\ntitle: CNI 与  Pod 容器网络—— Linux 网络\ncatalog: true\ndate: 2023-04-19 05:02:23\ntags: ospp, Linux, Network\ncategories: Linux, Container\n---\n\n\n# CNI 与  Pod 容器网络—— Linux 网络\n\n> Pod 容器在 kubernetes 网络中是怎样获取他的地址的呢? \n>\n> 如何保障 Pod IP 在整个集群当中的唯一性？\n>\n> 容器流量如何在所给的IP之间相互转发？\n\n---\n\n## 从 namespace 开始\n\nnamespace 技术是 Linux 内核提供的一项非常重要的功能，也是容器虚拟化的基础技术，通过构建系统资源的边界，形成一个相对封闭的资源区域，也就是大家认识的容器。Linux 提供的 namespace 包括以下几个方面：\n\n``` bash\n       Linux provides the following namespaces:\n\n       Namespace   Constant          Isolates\n       Cgroup      CLONE_NEWCGROUP   Cgroup root directory\n       IPC         CLONE_NEWIPC      System V IPC, POSIX message queues\n       Network     CLONE_NEWNET      Network devices, stacks, ports, etc.\n       Mount       CLONE_NEWNS       Mount points\n       PID         CLONE_NEWPID      Process IDs\n       User        CLONE_NEWUSER     User and group IDs\n       UTS         CLONE_NEWUTS      Hostname and NIS domain name\n```\n\n其中网络名字空间(network namespace)是网络虚拟化技术的基础，也是本文最为关注的部分；现有的各项容器技术在实现他们各自的网络连接时所依赖的核心，所以要探究 Pod 网络和 CNI 就必须先从 network namespace 入手。\n\n在 Linux 系统当中，每一个 network  namespace  都有他自己的网络设置，包括（routing table）路由表、（network interface）网络设备、（IP address）IP 地址等等，这样隔离的一个典型好处就是在不同的network namespace 之下程序可以绑定到同一个端口并保持各自的网络约束不变。与其他的 namespace 一样, network namspace 也可以调用 clone() API创建一个通用的 namespace, 然后传入 CLONE_NEWNET 参数来创建 network namespace。不过就简单配置来说， 可以使用 **netns** 执行对 networkname space  的各项增删改查。\n\n依据 network namspace 划分出网络区域就像是创建网络通信的对端，但光有隔离出来的对象并不能构成网络；容器还要和外界进行网络联通才能提供服务。与实际网络场景不相同的是，没有物理实体的交换机和路由器，甚至可用的物理网卡也是受限的，那么如何能够在划分隔离出的区域之间提供通信呢？同时如何能够定位这些区域并让数据包能够正确地从一个 netns 中传输到另一个 netns呢？\n\n---\n\n## veth 的创建和连接\n\n首先要清楚 veth-pairs， veth 是虚拟以太网卡（virtual Ethernet）的缩写，veth 设备总是成对出现的，也因此称之为 veth-pair。可以通过` ip link add veth0 type veth peer name veth1` 等指令来创建管理这些虚拟网卡，eg ：[从docker0开始](https://morningspace.github.io/tech/k8s-net-docker0/) ，[Deep dive into Linux Networking and Docker | Medium](https://medium.com/techlog/diving-into-linux-networking-and-docker-bridge-veth-and-iptables-a05eb27b1e72) 等文章就有讲到其作用和类似操作，不再复述。\n\n但关键在于对于系统来说，veth到底是什么呢？是一个文件，进程还是描述符,他是否直接和物理网卡相关？它的工作原理是什么，是怎样来让容器之间相互通信的呢？接着来深入研究其内核当中的实现，具体参考：[veth(4) - Linux manual page (man7.org)](https://man7.org/linux/man-pages/man4/veth.4.html)，[linux/veth.c at master · torvalds/linux (github.com)](https://github.com/torvalds/linux/blob/master/drivers/net/veth.c)\n\nveth的相关源码位于 `drivers/net/veth.c`中，其中的初始化入口是`veth_init`\n\n``` c\nstatic __init int veth_init(void)\n{\n\treturn rtnl_link_register(&veth_link_ops);\n}\n```\n\n初始化函数注册了`veth_link_ops`(veth 设备的操作方法)，它包含了 veth 设备的创建启动和删除等回调函数，具体结构如下:\n\n```c\nstatic struct rtnl_link_ops veth_link_ops = {\n\t.kind\t\t= DRV_NAME,\n\t.priv_size\t= sizeof(struct veth_priv),\n\t.setup\t\t= veth_setup,\n\t.validate\t= veth_validate,\n\t.newlink\t= veth_newlink,\n\t.dellink\t= veth_dellink,\n\t.policy\t\t= veth_policy,\n\t.maxtype\t= VETH_INFO_MAX,\n\t.get_link_net\t= veth_get_link_net,\n\t.get_num_tx_queues\t= veth_get_num_queues,\n\t.get_num_rx_queues\t= veth_get_num_queues,\n};\n```\n\n从 `kind` 到 `setup` 都是创建对应的数据结构并写入常量参数,所以创建的关键还是在 `veth_newlink`,`veth_dellink`，但二者的执行逻辑相关，所以只看其中一个。 \n\n首先是 `veth_newlink`, 不过他的实现较长，只能抓取一部分关键拆分开来看：\n\n```c\nstatic int veth_newlink(struct net *src_net, struct net_device *dev,\n\t\t\tstruct nlattr *tb[], struct nlattr *data[],\n\t\t\tstruct netlink_ext_ack *extack)\n{\n    ...\n    // 由于虚拟网络设备对是由两个网络设备组成,\n    // dev 是虚拟网络设备对的其中一个网络设备，不可能创建单独的设备，那就需要创建一个临时的对端 peer\n    // 因而调用 rtnl_create_link 函数创建对端网络设备的逻辑对象 peer \n\tpeer = rtnl_create_link(net, ifname, name_assign_type,\n\t\t\t\t&veth_link_ops, tbp, extack);\n\terr = register_netdevice(peer);\n    ...\n    // 注册 dev 对象，本质上就在内存里面建立一个 struct 并将信息从文件映射过去\n\terr = register_netdevice(dev);\n\n    ...\n    // 把 peer 和 dev 关联到一起\n\tpriv = netdev_priv(dev);               // 获取 dev 的私有数据部分\n\trcu_assign_pointer(priv->peer, peer);  // 将其 peer 字段指向 dev\n\terr = veth_init_queues(dev, tb);\n\tpriv = netdev_priv(peer);              // 获取 peer 的私有数据部分\n\trcu_assign_pointer(priv->peer, dev);   // 将其 peer 字段指向 dev\n    ...\n\terr = veth_init_queues(peer, tb);\n    \n    // 添加 XDP 访问支持 --> veth 在内核运行流程中接近网卡\n    ...\n\t/* update XDP supported features */\n\tveth_set_xdp_features(dev);\n\tveth_set_xdp_features(peer);\n    ...\n}\n```\n\n在`veth_newlink`当中通过**`register_netdevice`** 注册了两个网络虚拟设备： `peer` 和 `dev`，并通过让 `dev` 的 peer 指针指向创建的 peer，让`peer` 的 peer  指针指向 dev，来完成了 veth 设备的结对。这个过程是符合 veth 的工作逻辑的，由于  veth 总是成对出现，所以在生成新的 veth 时候就需要指定它所连接对端  peer，当然这个过程发生在内核运行当中，并不是有物理上的连接关系，直白来说就是依据文件信息写入到内存，开辟一个空间来存储对应的信息，然后修改指针指向来表示连接关系。\n\n创建完成之后，veth 又是怎么来传输数据的呢？回到之前的 `veth_setup`,启动 veth 的流程，也是将各类函数注册指定到 veth 对象当中\n\n```C\nstatic void veth_setup(struct net_device *dev)\n{\n\tether_setup(dev);\n    ...\n\tdev->netdev_ops = &veth_netdev_ops;\n\tdev->xdp_metadata_ops = &veth_xdp_metadata_ops;\n\tdev->ethtool_ops = &veth_ethtool_ops;\n    ...\n}\n```\n\n可以看到是 veth 对象的操作列表包含三类：`veth_netdev_ops`,`veth_xdp_metadata_ops`,`veth_ethtool_ops`, 具体的列表如下：\n\nnet_device_ops 结构是网络设备的操作函数集结构, 包含了 Linux 网络设备对象的各项操作行为列表，也是  veth 对象调用实现功能的具体行为。\n\n从以下列表其实可以知道，Linux 设备是通用一个网卡的代码数据操作流程及对象的，以下的操作函数对于 ebpf xdp 程序直接操作有一定参考，是EdgeMesh 为来优化的对象，故进一步深入探究。\n\n```C\nstatic const struct net_device_ops veth_netdev_ops = {\n\t.ndo_init            = veth_dev_init,\n\t.ndo_open            = veth_open,\n\t.ndo_stop            = veth_close,\n\t.ndo_start_xmit      = veth_xmit,\n\t.ndo_get_stats64     = veth_get_stats64,\n\t.ndo_set_rx_mode     = veth_set_multicast_list,\n\t.ndo_set_mac_address = eth_mac_addr,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t= veth_poll_controller,\n#endif\n\t.ndo_get_iflink\t\t= veth_get_iflink,\n\t.ndo_fix_features\t= veth_fix_features,\n\t.ndo_set_features\t= veth_set_features,\n\t.ndo_features_check\t= passthru_features_check,\n\t.ndo_set_rx_headroom\t= veth_set_rx_headroom,\n\t.ndo_bpf\t\t= veth_xdp,\n\t.ndo_xdp_xmit\t\t= veth_ndo_xdp_xmit,\n\t.ndo_get_peer_dev\t= veth_peer_dev,\n};\n```\n\n这些函数的具体作用如下整理：\n\n- `ndo_init`: 该函数指向 `veth_dev_init`，网络设备初始化函数，由驱动程序实现，在网卡设备分配之后调用。\n\n- `ndo_open`: 该函数指向 `veth_open`，被调用以打开虚拟网络设备并将其加入网络协议栈，由驱动程序实现，用于开启网络设备并为进程提供网络访问。\n- `ndo_stop`：该函数指向 `veth_close`，由驱动程序实现，被调用以停止虚拟网络设备并将其从网络协议栈中移除。\n- ==`ndo_start_xmit`：该函数指向 `veth_xmit`，由驱动程序实现，用于将给定的网络数据帧发送到指定的网络设备上。==\n- `ndo_get_stats64`：该函数指向 `veth_get_stats64`，由驱动程序实现，用于获取虚拟网络设备当前的统计信息。\n- `ndo_set_rx_mode`：该函数指向 `veth_set_multicast_list`，由驱动程序实现，用于设置网络设备接收模式。\n- `ndo_set_mac_address`：该函数指向 `eth_mac_addr`，用于设置虚拟网络设备的MAC地址。\n- `ndo_poll_controller`：该函数指向 `veth_poll_controller`，由驱动程序实现，veth调用之后触发软中断从 Ringbuffer 当中 poll 数据包\n- `ndo_get_iflink`：该函数指向 `veth_get_iflink`，用于获取虚拟网络设备的网络接口索引号。\n- `ndo_fix_features`：该函数指向 `veth_fix_features`，用于设置虚拟网络设备的特性参数；\n- `ndo_set_features`：该函数指向 `veth_set_features`，用于修改或更新虚拟网络设备已经打开的特性参数。\n- `ndo_features_check`：该函数指向 `passthru_features_check`，检查虚拟网络设备是否包含由 ETS（Enhanced Traffic Service）要求的特征。\n- `ndo_set_rx_headroom`: 该函数指向 `veth_set_rx_headroom`，用于设置虚拟网络设备中下行数据帧包头部的大小。\n- `ndo_bpf`：该函数指向 `veth_xdp`，用于添加eBPF扩展程序入口并进行初始化。\n- `ndo_xdp_xmit`: 该函数指向 `veth_ndo_xdp_xmit`，驱动程序的XDP传输方法入口，将网络数据帧发送到用户提供的XDP扩展程序。\n- `ndo_get_peer_dev`: 该函数指向 `veth_peer_dev`，用于获取与虚拟网络设备配对的网络设备。 \n\n`ethtool_ops`结构则代表了与`ethtool`工具相关的网络设备操作函数集合。`ethtool`用于获取和设置与`ethtool`兼容设备的驱动程序和硬件信息，同时实现均衡网速，流量控制等功能。\n\n``` C\nstatic const struct ethtool_ops veth_ethtool_ops = {\n\t.get_drvinfo\t\t= veth_get_drvinfo,\n\t.get_link\t\t= ethtool_op_get_link,\n\t.get_strings\t\t= veth_get_strings,\n\t.get_sset_count\t\t= veth_get_sset_count,\n\t.get_ethtool_stats\t= veth_get_ethtool_stats,\n\t.get_link_ksettings\t= veth_get_link_ksettings,\n\t.get_ts_info\t\t= ethtool_op_get_ts_info,\n\t.get_channels\t\t= veth_get_channels,\n\t.set_channels\t\t= veth_set_channels,\n};\n```\n\n`xdp_metadata_ops`结构体定义了XDP（eBPF based packet processing）元数据的操作集合，在实现高性能网络数据包处理、过滤和转发的过程中起到重要作用。该操作集与XDP引擎密切相关，包括xsk_frame_parse（对接收的数据包的元数据进行解析）和xsk_frame_init（初始化元数据）等。\n\n```c\nstatic const struct xdp_metadata_ops veth_xdp_metadata_ops = {\n\t.xmo_rx_timestamp\t\t= veth_xdp_rx_timestamp,\n\t.xmo_rx_hash\t\t\t= veth_xdp_rx_hash,\n};\n```\n\n- `xmo_rx_timestamp` ： 该函数指针指向 `veth_xdp_rx_timestamp` 函数，用于获取 XDP 包的接收时间戳，即处理 XDP 包的内核进程把包抓取的时间。该时间可以在 eBPF 程序中使用，例如可用于实现延迟测量(metric)，排除处理器竞争以及路由表测量等。\n\n- `xmo_rx_hash`：该函数指针指向 `veth_xdp_rx_hash`，用于获取 XDP 数据包的接收哈希值。通过接收哈希值，可以在 eBPF 中就各个数据包的接收位置和网络环境进行更好的控制和调节，以优化网络性能。例如在基于哈希的负载均衡中，可以使用哈希值来决定要将数据包路由到哪个接收 CPU 或内核上。\n\n在 Linux 中，这些函数指针被定义为可选项，也就是说并非每个驱动程序都会实现这两个函数指针。`xdp_metadata_ops` 使驱动程序与 eBPF程序 在处理特定的数据包和流量时更加灵活；但反过来说也需要配备一定的环境才能够实现这些调用的功能。\n\n到这里，veth 的创建和各项功能在 Linux 视角的样子就全部呈现了，总的来说 veth 本身是 Linux 中创建的 `net_device` 结构，通过注册所需的初始化和操作行为等特定函数以及对其进行相应的参数配置，最终实例化为 veth 对象，用于虚拟网络的构建。同时更明确了 veth 是工作在二层的数据结构，他传输数据会调用驱动程序实现的 `ndo_start_xmit`函数，在指定了对端之后，数据包发送会存入 skb 并插入 `softnet_data->input_pkt_queue`中，出发软中断，接下来就是对称一般的内核接收过程。\n\n---\n\n## 网桥的连接和传输\n\nveth 可以感性地认知为网卡，它给予了所划分出的 network namspace 一个出入的门，此前的结构如果将 veth 分别指向两个网络空间，就能够实现这二者的通信，但是当所划分的网络空间区域增加的时候，这样子点对点的连接方式显然就很难支撑了。\n\n这样就需要解决单节点大量容器之间的网络互连问题。\n\n参考实际物理网络的结构，Linux 实现并提供了一个完全由软件虚拟出来的交换机，它可以提供很多的虚拟端口，把许多的 veth 连接在一个平面的网络，通过自己的转发功能让虚拟机网卡之间可以通信，这个技术就叫做 bridge。\n\n如何使用 bridge 连接不同的网络空间呢？[Introduction to Linux interfaces for virtual networking | Red Hat Developer](https://developers.redhat.com/blog/2018/10/22/introduction-to-linux-interfaces-for-virtual-networking#team_device)，[Deep dive into Linux Networking and Docker - Bridge, vETH and IPTables - DEV Community](https://dev.to/arriqaaq/diving-into-linux-networking-and-docker-bridge-veth-and-iptables-419a)  等文章也有详尽阐述，不再复述。\n\n其中要关注的点是： bridge 的工作源码都是在 /net/core/dev.c 或者是 /net/bridge 目录下面，也就是说他是工作在二层上的设备（这一点与物理交换相同），但所给的实验来验证连通性是依靠 ping 指令从IP来看的，但这并不意味着 bridge 是依靠 IP  来做转发的。\n\n为了验证这一点，深入来看 bridge 的内核实现\n\n从外部网络到达节点时候，数据包会被网卡先送到 RingBuffer 中，然后依次经过硬中断、软中断处理，在软中断中再以此把包送到设备层（连接bridge）、协议栈，最后唤醒应用程序。\n\n从节点内的应用程序到达外部的时候，会从应用程序调用系统调用，在进入协议栈（传输层、网络层），再进入邻居子系统到网络设备子系统（bridge），之后调用驱动程序触发硬中断到网卡。\n\n在这个过程中，bridge 输入数据包处理工作流程在 `/net/bridge/br_input.c` 中 `br_handle_frame_finish`函数里\n\n```c\nint br_handle_frame_finish(struct net *net, struct sock *sk, struct sk_buff *skb)\n{\n    // 获取 veth 所连接的网桥端口以及 bridge 设备\n\tstruct net_bridge_port *p = br_port_get_rcu(skb->dev);\n    // 创建转发表对象\n\tstruct net_bridge_fdb_entry *dst = NULL;\n    \n\tstruct net_bridge_mcast_port *pmctx;\n\tstruct net_bridge_mdb_entry *mdst;\n\tstruct net_bridge_vlan *vlan;\n\tstruct net_bridge *br;\n\tbr = p->br;\n    \n    // 查找并更新转发表，这个转发表使用的地址是eth_hdr(skb)->h_source\n\tbr_fdb_update(br, p, eth_hdr(skb)->h_source,vid, BIT(BR_FDB_LOCKED));\t\n\tdst = br_fdb_find_rcu(br, eth_hdr(skb)->h_dest, vid);\n    \n    // 转发\n\tif (dst) {\n\t\tbr_forward(dst->dst, skb, local_rcv, false);\n    // 本机访问\n\tif (local_rcv)\n\t\treturn br_pass_frame_up(skb);\n}\n```\n\n其中查找和转发使用的地址是eth_hdr(skb)->h_dest，和物理环境当中的交换机会自动学习端口所对应的节点mac地址一样，软件模拟的 bridge 也会自学习 veth 与 eth_hdr 的对应关系。\n\n总的来说，当创建了 bridge 并把 veth 设备放入其中，网桥就能够为连接的网络空间提供一个平面的网络连接服务。\n\n其实到目前为止，所涉及的网络设备都工作在二层，对应到物理环境就是都使用的 MAC 地址进行寻址和交换信息，这样的网络服务就是 Linux  基本网络服务，能够实现单节点上的网络空间连通性。\n\n可只是这样是无法满足Kubernetes 集群的网络寻址和路由需求的，现有的网络追求平面式的连接服务但是底层依旧还是得通过IP进行寻址；回到容器网络当中，这也意味着希望在容器网络当中的实体能够拥有各自独立、唯一的IP地址，可以是容器、物理机或者是其他的网络设备（比如虚拟路由器）等，容器可以被添加到一个或多个网络中或从一个或多个网络中删除。这就是接下来 CNI 需要满足的功能之一。\n\n---\n\n","slug":"EdgeMesh/2023-ospp-fighting/CNI-LinuxNetwork","published":1,"updated":"2023-05-28T09:44:52.227Z","comments":1,"photos":[],"link":"","_id":"cli796r0n000rbyjx5iaaddjb","content":"<h1 id=\"CNI-与-Pod-容器网络——-Linux-网络\"><a href=\"#CNI-与-Pod-容器网络——-Linux-网络\" class=\"headerlink\" title=\"CNI 与  Pod 容器网络—— Linux 网络\"></a>CNI 与  Pod 容器网络—— Linux 网络</h1><blockquote>\n<p>Pod 容器在 kubernetes 网络中是怎样获取他的地址的呢? </p>\n<p>如何保障 Pod IP 在整个集群当中的唯一性？</p>\n<p>容器流量如何在所给的IP之间相互转发？</p>\n</blockquote>\n<hr>\n<h2 id=\"从-namespace-开始\"><a href=\"#从-namespace-开始\" class=\"headerlink\" title=\"从 namespace 开始\"></a>从 namespace 开始</h2><p>namespace 技术是 Linux 内核提供的一项非常重要的功能，也是容器虚拟化的基础技术，通过构建系统资源的边界，形成一个相对封闭的资源区域，也就是大家认识的容器。Linux 提供的 namespace 包括以下几个方面：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Linux provides the following namespaces:</span><br><span class=\"line\"></span><br><span class=\"line\">Namespace   Constant          Isolates</span><br><span class=\"line\">Cgroup      CLONE_NEWCGROUP   Cgroup root directory</span><br><span class=\"line\">IPC         CLONE_NEWIPC      System V IPC, POSIX message queues</span><br><span class=\"line\">Network     CLONE_NEWNET      Network devices, stacks, ports, etc.</span><br><span class=\"line\">Mount       CLONE_NEWNS       Mount points</span><br><span class=\"line\">PID         CLONE_NEWPID      Process IDs</span><br><span class=\"line\">User        CLONE_NEWUSER     User and group IDs</span><br><span class=\"line\">UTS         CLONE_NEWUTS      Hostname and NIS domain name</span><br></pre></td></tr></table></figure>\n\n<p>其中网络名字空间(network namespace)是网络虚拟化技术的基础，也是本文最为关注的部分；现有的各项容器技术在实现他们各自的网络连接时所依赖的核心，所以要探究 Pod 网络和 CNI 就必须先从 network namespace 入手。</p>\n<p>在 Linux 系统当中，每一个 network  namespace  都有他自己的网络设置，包括（routing table）路由表、（network interface）网络设备、（IP address）IP 地址等等，这样隔离的一个典型好处就是在不同的network namespace 之下程序可以绑定到同一个端口并保持各自的网络约束不变。与其他的 namespace 一样, network namspace 也可以调用 clone() API创建一个通用的 namespace, 然后传入 CLONE_NEWNET 参数来创建 network namespace。不过就简单配置来说， 可以使用 <strong>netns</strong> 执行对 networkname space  的各项增删改查。</p>\n<p>依据 network namspace 划分出网络区域就像是创建网络通信的对端，但光有隔离出来的对象并不能构成网络；容器还要和外界进行网络联通才能提供服务。与实际网络场景不相同的是，没有物理实体的交换机和路由器，甚至可用的物理网卡也是受限的，那么如何能够在划分隔离出的区域之间提供通信呢？同时如何能够定位这些区域并让数据包能够正确地从一个 netns 中传输到另一个 netns呢？</p>\n<hr>\n<h2 id=\"veth-的创建和连接\"><a href=\"#veth-的创建和连接\" class=\"headerlink\" title=\"veth 的创建和连接\"></a>veth 的创建和连接</h2><p>首先要清楚 veth-pairs， veth 是虚拟以太网卡（virtual Ethernet）的缩写，veth 设备总是成对出现的，也因此称之为 veth-pair。可以通过<code> ip link add veth0 type veth peer name veth1</code> 等指令来创建管理这些虚拟网卡，eg ：<a href=\"https://morningspace.github.io/tech/k8s-net-docker0/\">从docker0开始</a> ，<a href=\"https://medium.com/techlog/diving-into-linux-networking-and-docker-bridge-veth-and-iptables-a05eb27b1e72\">Deep dive into Linux Networking and Docker | Medium</a> 等文章就有讲到其作用和类似操作，不再复述。</p>\n<p>但关键在于对于系统来说，veth到底是什么呢？是一个文件，进程还是描述符,他是否直接和物理网卡相关？它的工作原理是什么，是怎样来让容器之间相互通信的呢？接着来深入研究其内核当中的实现，具体参考：<a href=\"https://man7.org/linux/man-pages/man4/veth.4.html\">veth(4) - Linux manual page (man7.org)</a>，<a href=\"https://github.com/torvalds/linux/blob/master/drivers/net/veth.c\">linux/veth.c at master · torvalds/linux (github.com)</a></p>\n<p>veth的相关源码位于 <code>drivers/net/veth.c</code>中，其中的初始化入口是<code>veth_init</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> __init <span class=\"type\">int</span> <span class=\"title function_\">veth_init</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> rtnl_link_register(&amp;veth_link_ops);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>初始化函数注册了<code>veth_link_ops</code>(veth 设备的操作方法)，它包含了 veth 设备的创建启动和删除等回调函数，具体结构如下:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">rtnl_link_ops</span> <span class=\"title\">veth_link_ops</span> =</span> &#123;</span><br><span class=\"line\">\t.kind\t\t= DRV_NAME,</span><br><span class=\"line\">\t.priv_size\t= <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> veth_priv),</span><br><span class=\"line\">\t.setup\t\t= veth_setup,</span><br><span class=\"line\">\t.validate\t= veth_validate,</span><br><span class=\"line\">\t.newlink\t= veth_newlink,</span><br><span class=\"line\">\t.dellink\t= veth_dellink,</span><br><span class=\"line\">\t.policy\t\t= veth_policy,</span><br><span class=\"line\">\t.maxtype\t= VETH_INFO_MAX,</span><br><span class=\"line\">\t.get_link_net\t= veth_get_link_net,</span><br><span class=\"line\">\t.get_num_tx_queues\t= veth_get_num_queues,</span><br><span class=\"line\">\t.get_num_rx_queues\t= veth_get_num_queues,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>从 <code>kind</code> 到 <code>setup</code> 都是创建对应的数据结构并写入常量参数,所以创建的关键还是在 <code>veth_newlink</code>,<code>veth_dellink</code>，但二者的执行逻辑相关，所以只看其中一个。 </p>\n<p>首先是 <code>veth_newlink</code>, 不过他的实现较长，只能抓取一部分关键拆分开来看：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">veth_newlink</span><span class=\"params\">(<span class=\"keyword\">struct</span> net *src_net, <span class=\"keyword\">struct</span> net_device *dev,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t<span class=\"keyword\">struct</span> nlattr *tb[], <span class=\"keyword\">struct</span> nlattr *data[],</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t<span class=\"keyword\">struct</span> netlink_ext_ack *extack)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// 由于虚拟网络设备对是由两个网络设备组成,</span></span><br><span class=\"line\">    <span class=\"comment\">// dev 是虚拟网络设备对的其中一个网络设备，不可能创建单独的设备，那就需要创建一个临时的对端 peer</span></span><br><span class=\"line\">    <span class=\"comment\">// 因而调用 rtnl_create_link 函数创建对端网络设备的逻辑对象 peer </span></span><br><span class=\"line\">\tpeer = rtnl_create_link(net, ifname, name_assign_type,</span><br><span class=\"line\">\t\t\t\t&amp;veth_link_ops, tbp, extack);</span><br><span class=\"line\">\terr = register_netdevice(peer);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// 注册 dev 对象，本质上就在内存里面建立一个 struct 并将信息从文件映射过去</span></span><br><span class=\"line\">\terr = register_netdevice(dev);</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// 把 peer 和 dev 关联到一起</span></span><br><span class=\"line\">\tpriv = netdev_priv(dev);               <span class=\"comment\">// 获取 dev 的私有数据部分</span></span><br><span class=\"line\">\trcu_assign_pointer(priv-&gt;peer, peer);  <span class=\"comment\">// 将其 peer 字段指向 dev</span></span><br><span class=\"line\">\terr = veth_init_queues(dev, tb);</span><br><span class=\"line\">\tpriv = netdev_priv(peer);              <span class=\"comment\">// 获取 peer 的私有数据部分</span></span><br><span class=\"line\">\trcu_assign_pointer(priv-&gt;peer, dev);   <span class=\"comment\">// 将其 peer 字段指向 dev</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">\terr = veth_init_queues(peer, tb);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 添加 XDP 访问支持 --&gt; veth 在内核运行流程中接近网卡</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">\t<span class=\"comment\">/* update XDP supported features */</span></span><br><span class=\"line\">\tveth_set_xdp_features(dev);</span><br><span class=\"line\">\tveth_set_xdp_features(peer);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在<code>veth_newlink</code>当中通过**<code>register_netdevice</code>** 注册了两个网络虚拟设备： <code>peer</code> 和 <code>dev</code>，并通过让 <code>dev</code> 的 peer 指针指向创建的 peer，让<code>peer</code> 的 peer  指针指向 dev，来完成了 veth 设备的结对。这个过程是符合 veth 的工作逻辑的，由于  veth 总是成对出现，所以在生成新的 veth 时候就需要指定它所连接对端  peer，当然这个过程发生在内核运行当中，并不是有物理上的连接关系，直白来说就是依据文件信息写入到内存，开辟一个空间来存储对应的信息，然后修改指针指向来表示连接关系。</p>\n<p>创建完成之后，veth 又是怎么来传输数据的呢？回到之前的 <code>veth_setup</code>,启动 veth 的流程，也是将各类函数注册指定到 veth 对象当中</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">veth_setup</span><span class=\"params\">(<span class=\"keyword\">struct</span> net_device *dev)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tether_setup(dev);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">\tdev-&gt;netdev_ops = &amp;veth_netdev_ops;</span><br><span class=\"line\">\tdev-&gt;xdp_metadata_ops = &amp;veth_xdp_metadata_ops;</span><br><span class=\"line\">\tdev-&gt;ethtool_ops = &amp;veth_ethtool_ops;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到是 veth 对象的操作列表包含三类：<code>veth_netdev_ops</code>,<code>veth_xdp_metadata_ops</code>,<code>veth_ethtool_ops</code>, 具体的列表如下：</p>\n<p>net_device_ops 结构是网络设备的操作函数集结构, 包含了 Linux 网络设备对象的各项操作行为列表，也是  veth 对象调用实现功能的具体行为。</p>\n<p>从以下列表其实可以知道，Linux 设备是通用一个网卡的代码数据操作流程及对象的，以下的操作函数对于 ebpf xdp 程序直接操作有一定参考，是EdgeMesh 为来优化的对象，故进一步深入探究。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">net_device_ops</span> <span class=\"title\">veth_netdev_ops</span> =</span> &#123;</span><br><span class=\"line\">\t.ndo_init            = veth_dev_init,</span><br><span class=\"line\">\t.ndo_open            = veth_open,</span><br><span class=\"line\">\t.ndo_stop            = veth_close,</span><br><span class=\"line\">\t.ndo_start_xmit      = veth_xmit,</span><br><span class=\"line\">\t.ndo_get_stats64     = veth_get_stats64,</span><br><span class=\"line\">\t.ndo_set_rx_mode     = veth_set_multicast_list,</span><br><span class=\"line\">\t.ndo_set_mac_address = eth_mac_addr,</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> CONFIG_NET_POLL_CONTROLLER</span></span><br><span class=\"line\">\t.ndo_poll_controller\t= veth_poll_controller,</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">\t.ndo_get_iflink\t\t= veth_get_iflink,</span><br><span class=\"line\">\t.ndo_fix_features\t= veth_fix_features,</span><br><span class=\"line\">\t.ndo_set_features\t= veth_set_features,</span><br><span class=\"line\">\t.ndo_features_check\t= passthru_features_check,</span><br><span class=\"line\">\t.ndo_set_rx_headroom\t= veth_set_rx_headroom,</span><br><span class=\"line\">\t.ndo_bpf\t\t= veth_xdp,</span><br><span class=\"line\">\t.ndo_xdp_xmit\t\t= veth_ndo_xdp_xmit,</span><br><span class=\"line\">\t.ndo_get_peer_dev\t= veth_peer_dev,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这些函数的具体作用如下整理：</p>\n<ul>\n<li><p><code>ndo_init</code>: 该函数指向 <code>veth_dev_init</code>，网络设备初始化函数，由驱动程序实现，在网卡设备分配之后调用。</p>\n</li>\n<li><p><code>ndo_open</code>: 该函数指向 <code>veth_open</code>，被调用以打开虚拟网络设备并将其加入网络协议栈，由驱动程序实现，用于开启网络设备并为进程提供网络访问。</p>\n</li>\n<li><p><code>ndo_stop</code>：该函数指向 <code>veth_close</code>，由驱动程序实现，被调用以停止虚拟网络设备并将其从网络协议栈中移除。</p>\n</li>\n<li><p>==<code>ndo_start_xmit</code>：该函数指向 <code>veth_xmit</code>，由驱动程序实现，用于将给定的网络数据帧发送到指定的网络设备上。==</p>\n</li>\n<li><p><code>ndo_get_stats64</code>：该函数指向 <code>veth_get_stats64</code>，由驱动程序实现，用于获取虚拟网络设备当前的统计信息。</p>\n</li>\n<li><p><code>ndo_set_rx_mode</code>：该函数指向 <code>veth_set_multicast_list</code>，由驱动程序实现，用于设置网络设备接收模式。</p>\n</li>\n<li><p><code>ndo_set_mac_address</code>：该函数指向 <code>eth_mac_addr</code>，用于设置虚拟网络设备的MAC地址。</p>\n</li>\n<li><p><code>ndo_poll_controller</code>：该函数指向 <code>veth_poll_controller</code>，由驱动程序实现，veth调用之后触发软中断从 Ringbuffer 当中 poll 数据包</p>\n</li>\n<li><p><code>ndo_get_iflink</code>：该函数指向 <code>veth_get_iflink</code>，用于获取虚拟网络设备的网络接口索引号。</p>\n</li>\n<li><p><code>ndo_fix_features</code>：该函数指向 <code>veth_fix_features</code>，用于设置虚拟网络设备的特性参数；</p>\n</li>\n<li><p><code>ndo_set_features</code>：该函数指向 <code>veth_set_features</code>，用于修改或更新虚拟网络设备已经打开的特性参数。</p>\n</li>\n<li><p><code>ndo_features_check</code>：该函数指向 <code>passthru_features_check</code>，检查虚拟网络设备是否包含由 ETS（Enhanced Traffic Service）要求的特征。</p>\n</li>\n<li><p><code>ndo_set_rx_headroom</code>: 该函数指向 <code>veth_set_rx_headroom</code>，用于设置虚拟网络设备中下行数据帧包头部的大小。</p>\n</li>\n<li><p><code>ndo_bpf</code>：该函数指向 <code>veth_xdp</code>，用于添加eBPF扩展程序入口并进行初始化。</p>\n</li>\n<li><p><code>ndo_xdp_xmit</code>: 该函数指向 <code>veth_ndo_xdp_xmit</code>，驱动程序的XDP传输方法入口，将网络数据帧发送到用户提供的XDP扩展程序。</p>\n</li>\n<li><p><code>ndo_get_peer_dev</code>: 该函数指向 <code>veth_peer_dev</code>，用于获取与虚拟网络设备配对的网络设备。 </p>\n</li>\n</ul>\n<p><code>ethtool_ops</code>结构则代表了与<code>ethtool</code>工具相关的网络设备操作函数集合。<code>ethtool</code>用于获取和设置与<code>ethtool</code>兼容设备的驱动程序和硬件信息，同时实现均衡网速，流量控制等功能。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ethtool_ops</span> <span class=\"title\">veth_ethtool_ops</span> =</span> &#123;</span><br><span class=\"line\">\t.get_drvinfo\t\t= veth_get_drvinfo,</span><br><span class=\"line\">\t.get_link\t\t= ethtool_op_get_link,</span><br><span class=\"line\">\t.get_strings\t\t= veth_get_strings,</span><br><span class=\"line\">\t.get_sset_count\t\t= veth_get_sset_count,</span><br><span class=\"line\">\t.get_ethtool_stats\t= veth_get_ethtool_stats,</span><br><span class=\"line\">\t.get_link_ksettings\t= veth_get_link_ksettings,</span><br><span class=\"line\">\t.get_ts_info\t\t= ethtool_op_get_ts_info,</span><br><span class=\"line\">\t.get_channels\t\t= veth_get_channels,</span><br><span class=\"line\">\t.set_channels\t\t= veth_set_channels,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><code>xdp_metadata_ops</code>结构体定义了XDP（eBPF based packet processing）元数据的操作集合，在实现高性能网络数据包处理、过滤和转发的过程中起到重要作用。该操作集与XDP引擎密切相关，包括xsk_frame_parse（对接收的数据包的元数据进行解析）和xsk_frame_init（初始化元数据）等。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">xdp_metadata_ops</span> <span class=\"title\">veth_xdp_metadata_ops</span> =</span> &#123;</span><br><span class=\"line\">\t.xmo_rx_timestamp\t\t= veth_xdp_rx_timestamp,</span><br><span class=\"line\">\t.xmo_rx_hash\t\t\t= veth_xdp_rx_hash,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><code>xmo_rx_timestamp</code> ： 该函数指针指向 <code>veth_xdp_rx_timestamp</code> 函数，用于获取 XDP 包的接收时间戳，即处理 XDP 包的内核进程把包抓取的时间。该时间可以在 eBPF 程序中使用，例如可用于实现延迟测量(metric)，排除处理器竞争以及路由表测量等。</p>\n</li>\n<li><p><code>xmo_rx_hash</code>：该函数指针指向 <code>veth_xdp_rx_hash</code>，用于获取 XDP 数据包的接收哈希值。通过接收哈希值，可以在 eBPF 中就各个数据包的接收位置和网络环境进行更好的控制和调节，以优化网络性能。例如在基于哈希的负载均衡中，可以使用哈希值来决定要将数据包路由到哪个接收 CPU 或内核上。</p>\n</li>\n</ul>\n<p>在 Linux 中，这些函数指针被定义为可选项，也就是说并非每个驱动程序都会实现这两个函数指针。<code>xdp_metadata_ops</code> 使驱动程序与 eBPF程序 在处理特定的数据包和流量时更加灵活；但反过来说也需要配备一定的环境才能够实现这些调用的功能。</p>\n<p>到这里，veth 的创建和各项功能在 Linux 视角的样子就全部呈现了，总的来说 veth 本身是 Linux 中创建的 <code>net_device</code> 结构，通过注册所需的初始化和操作行为等特定函数以及对其进行相应的参数配置，最终实例化为 veth 对象，用于虚拟网络的构建。同时更明确了 veth 是工作在二层的数据结构，他传输数据会调用驱动程序实现的 <code>ndo_start_xmit</code>函数，在指定了对端之后，数据包发送会存入 skb 并插入 <code>softnet_data-&gt;input_pkt_queue</code>中，出发软中断，接下来就是对称一般的内核接收过程。</p>\n<hr>\n<h2 id=\"网桥的连接和传输\"><a href=\"#网桥的连接和传输\" class=\"headerlink\" title=\"网桥的连接和传输\"></a>网桥的连接和传输</h2><p>veth 可以感性地认知为网卡，它给予了所划分出的 network namspace 一个出入的门，此前的结构如果将 veth 分别指向两个网络空间，就能够实现这二者的通信，但是当所划分的网络空间区域增加的时候，这样子点对点的连接方式显然就很难支撑了。</p>\n<p>这样就需要解决单节点大量容器之间的网络互连问题。</p>\n<p>参考实际物理网络的结构，Linux 实现并提供了一个完全由软件虚拟出来的交换机，它可以提供很多的虚拟端口，把许多的 veth 连接在一个平面的网络，通过自己的转发功能让虚拟机网卡之间可以通信，这个技术就叫做 bridge。</p>\n<p>如何使用 bridge 连接不同的网络空间呢？<a href=\"https://developers.redhat.com/blog/2018/10/22/introduction-to-linux-interfaces-for-virtual-networking#team_device\">Introduction to Linux interfaces for virtual networking | Red Hat Developer</a>，<a href=\"https://dev.to/arriqaaq/diving-into-linux-networking-and-docker-bridge-veth-and-iptables-419a\">Deep dive into Linux Networking and Docker - Bridge, vETH and IPTables - DEV Community</a>  等文章也有详尽阐述，不再复述。</p>\n<p>其中要关注的点是： bridge 的工作源码都是在 /net/core/dev.c 或者是 /net/bridge 目录下面，也就是说他是工作在二层上的设备（这一点与物理交换相同），但所给的实验来验证连通性是依靠 ping 指令从IP来看的，但这并不意味着 bridge 是依靠 IP  来做转发的。</p>\n<p>为了验证这一点，深入来看 bridge 的内核实现</p>\n<p>从外部网络到达节点时候，数据包会被网卡先送到 RingBuffer 中，然后依次经过硬中断、软中断处理，在软中断中再以此把包送到设备层（连接bridge）、协议栈，最后唤醒应用程序。</p>\n<p>从节点内的应用程序到达外部的时候，会从应用程序调用系统调用，在进入协议栈（传输层、网络层），再进入邻居子系统到网络设备子系统（bridge），之后调用驱动程序触发硬中断到网卡。</p>\n<p>在这个过程中，bridge 输入数据包处理工作流程在 <code>/net/bridge/br_input.c</code> 中 <code>br_handle_frame_finish</code>函数里</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">br_handle_frame_finish</span><span class=\"params\">(<span class=\"keyword\">struct</span> net *net, <span class=\"keyword\">struct</span> sock *sk, <span class=\"keyword\">struct</span> sk_buff *skb)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取 veth 所连接的网桥端口以及 bridge 设备</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">net_bridge_port</span> *<span class=\"title\">p</span> =</span> br_port_get_rcu(skb-&gt;dev);</span><br><span class=\"line\">    <span class=\"comment\">// 创建转发表对象</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">net_bridge_fdb_entry</span> *<span class=\"title\">dst</span> =</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">net_bridge_mcast_port</span> *<span class=\"title\">pmctx</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">net_bridge_mdb_entry</span> *<span class=\"title\">mdst</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">net_bridge_vlan</span> *<span class=\"title\">vlan</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">net_bridge</span> *<span class=\"title\">br</span>;</span></span><br><span class=\"line\">\tbr = p-&gt;br;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 查找并更新转发表，这个转发表使用的地址是eth_hdr(skb)-&gt;h_source</span></span><br><span class=\"line\">\tbr_fdb_update(br, p, eth_hdr(skb)-&gt;h_source,vid, BIT(BR_FDB_LOCKED));\t</span><br><span class=\"line\">\tdst = br_fdb_find_rcu(br, eth_hdr(skb)-&gt;h_dest, vid);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 转发</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (dst) &#123;</span><br><span class=\"line\">\t\tbr_forward(dst-&gt;dst, skb, local_rcv, <span class=\"literal\">false</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 本机访问</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (local_rcv)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> br_pass_frame_up(skb);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中查找和转发使用的地址是eth_hdr(skb)-&gt;h_dest，和物理环境当中的交换机会自动学习端口所对应的节点mac地址一样，软件模拟的 bridge 也会自学习 veth 与 eth_hdr 的对应关系。</p>\n<p>总的来说，当创建了 bridge 并把 veth 设备放入其中，网桥就能够为连接的网络空间提供一个平面的网络连接服务。</p>\n<p>其实到目前为止，所涉及的网络设备都工作在二层，对应到物理环境就是都使用的 MAC 地址进行寻址和交换信息，这样的网络服务就是 Linux  基本网络服务，能够实现单节点上的网络空间连通性。</p>\n<p>可只是这样是无法满足Kubernetes 集群的网络寻址和路由需求的，现有的网络追求平面式的连接服务但是底层依旧还是得通过IP进行寻址；回到容器网络当中，这也意味着希望在容器网络当中的实体能够拥有各自独立、唯一的IP地址，可以是容器、物理机或者是其他的网络设备（比如虚拟路由器）等，容器可以被添加到一个或多个网络中或从一个或多个网络中删除。这就是接下来 CNI 需要满足的功能之一。</p>\n<hr>\n","site":{"data":{}},"cover":"/img/cover/sky3.png","cover_type":"img","excerpt":"","more":"<h1 id=\"CNI-与-Pod-容器网络——-Linux-网络\"><a href=\"#CNI-与-Pod-容器网络——-Linux-网络\" class=\"headerlink\" title=\"CNI 与  Pod 容器网络—— Linux 网络\"></a>CNI 与  Pod 容器网络—— Linux 网络</h1><blockquote>\n<p>Pod 容器在 kubernetes 网络中是怎样获取他的地址的呢? </p>\n<p>如何保障 Pod IP 在整个集群当中的唯一性？</p>\n<p>容器流量如何在所给的IP之间相互转发？</p>\n</blockquote>\n<hr>\n<h2 id=\"从-namespace-开始\"><a href=\"#从-namespace-开始\" class=\"headerlink\" title=\"从 namespace 开始\"></a>从 namespace 开始</h2><p>namespace 技术是 Linux 内核提供的一项非常重要的功能，也是容器虚拟化的基础技术，通过构建系统资源的边界，形成一个相对封闭的资源区域，也就是大家认识的容器。Linux 提供的 namespace 包括以下几个方面：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Linux provides the following namespaces:</span><br><span class=\"line\"></span><br><span class=\"line\">Namespace   Constant          Isolates</span><br><span class=\"line\">Cgroup      CLONE_NEWCGROUP   Cgroup root directory</span><br><span class=\"line\">IPC         CLONE_NEWIPC      System V IPC, POSIX message queues</span><br><span class=\"line\">Network     CLONE_NEWNET      Network devices, stacks, ports, etc.</span><br><span class=\"line\">Mount       CLONE_NEWNS       Mount points</span><br><span class=\"line\">PID         CLONE_NEWPID      Process IDs</span><br><span class=\"line\">User        CLONE_NEWUSER     User and group IDs</span><br><span class=\"line\">UTS         CLONE_NEWUTS      Hostname and NIS domain name</span><br></pre></td></tr></table></figure>\n\n<p>其中网络名字空间(network namespace)是网络虚拟化技术的基础，也是本文最为关注的部分；现有的各项容器技术在实现他们各自的网络连接时所依赖的核心，所以要探究 Pod 网络和 CNI 就必须先从 network namespace 入手。</p>\n<p>在 Linux 系统当中，每一个 network  namespace  都有他自己的网络设置，包括（routing table）路由表、（network interface）网络设备、（IP address）IP 地址等等，这样隔离的一个典型好处就是在不同的network namespace 之下程序可以绑定到同一个端口并保持各自的网络约束不变。与其他的 namespace 一样, network namspace 也可以调用 clone() API创建一个通用的 namespace, 然后传入 CLONE_NEWNET 参数来创建 network namespace。不过就简单配置来说， 可以使用 <strong>netns</strong> 执行对 networkname space  的各项增删改查。</p>\n<p>依据 network namspace 划分出网络区域就像是创建网络通信的对端，但光有隔离出来的对象并不能构成网络；容器还要和外界进行网络联通才能提供服务。与实际网络场景不相同的是，没有物理实体的交换机和路由器，甚至可用的物理网卡也是受限的，那么如何能够在划分隔离出的区域之间提供通信呢？同时如何能够定位这些区域并让数据包能够正确地从一个 netns 中传输到另一个 netns呢？</p>\n<hr>\n<h2 id=\"veth-的创建和连接\"><a href=\"#veth-的创建和连接\" class=\"headerlink\" title=\"veth 的创建和连接\"></a>veth 的创建和连接</h2><p>首先要清楚 veth-pairs， veth 是虚拟以太网卡（virtual Ethernet）的缩写，veth 设备总是成对出现的，也因此称之为 veth-pair。可以通过<code> ip link add veth0 type veth peer name veth1</code> 等指令来创建管理这些虚拟网卡，eg ：<a href=\"https://morningspace.github.io/tech/k8s-net-docker0/\">从docker0开始</a> ，<a href=\"https://medium.com/techlog/diving-into-linux-networking-and-docker-bridge-veth-and-iptables-a05eb27b1e72\">Deep dive into Linux Networking and Docker | Medium</a> 等文章就有讲到其作用和类似操作，不再复述。</p>\n<p>但关键在于对于系统来说，veth到底是什么呢？是一个文件，进程还是描述符,他是否直接和物理网卡相关？它的工作原理是什么，是怎样来让容器之间相互通信的呢？接着来深入研究其内核当中的实现，具体参考：<a href=\"https://man7.org/linux/man-pages/man4/veth.4.html\">veth(4) - Linux manual page (man7.org)</a>，<a href=\"https://github.com/torvalds/linux/blob/master/drivers/net/veth.c\">linux/veth.c at master · torvalds/linux (github.com)</a></p>\n<p>veth的相关源码位于 <code>drivers/net/veth.c</code>中，其中的初始化入口是<code>veth_init</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> __init <span class=\"type\">int</span> <span class=\"title function_\">veth_init</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> rtnl_link_register(&amp;veth_link_ops);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>初始化函数注册了<code>veth_link_ops</code>(veth 设备的操作方法)，它包含了 veth 设备的创建启动和删除等回调函数，具体结构如下:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">rtnl_link_ops</span> <span class=\"title\">veth_link_ops</span> =</span> &#123;</span><br><span class=\"line\">\t.kind\t\t= DRV_NAME,</span><br><span class=\"line\">\t.priv_size\t= <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> veth_priv),</span><br><span class=\"line\">\t.setup\t\t= veth_setup,</span><br><span class=\"line\">\t.validate\t= veth_validate,</span><br><span class=\"line\">\t.newlink\t= veth_newlink,</span><br><span class=\"line\">\t.dellink\t= veth_dellink,</span><br><span class=\"line\">\t.policy\t\t= veth_policy,</span><br><span class=\"line\">\t.maxtype\t= VETH_INFO_MAX,</span><br><span class=\"line\">\t.get_link_net\t= veth_get_link_net,</span><br><span class=\"line\">\t.get_num_tx_queues\t= veth_get_num_queues,</span><br><span class=\"line\">\t.get_num_rx_queues\t= veth_get_num_queues,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>从 <code>kind</code> 到 <code>setup</code> 都是创建对应的数据结构并写入常量参数,所以创建的关键还是在 <code>veth_newlink</code>,<code>veth_dellink</code>，但二者的执行逻辑相关，所以只看其中一个。 </p>\n<p>首先是 <code>veth_newlink</code>, 不过他的实现较长，只能抓取一部分关键拆分开来看：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">veth_newlink</span><span class=\"params\">(<span class=\"keyword\">struct</span> net *src_net, <span class=\"keyword\">struct</span> net_device *dev,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t<span class=\"keyword\">struct</span> nlattr *tb[], <span class=\"keyword\">struct</span> nlattr *data[],</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t<span class=\"keyword\">struct</span> netlink_ext_ack *extack)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// 由于虚拟网络设备对是由两个网络设备组成,</span></span><br><span class=\"line\">    <span class=\"comment\">// dev 是虚拟网络设备对的其中一个网络设备，不可能创建单独的设备，那就需要创建一个临时的对端 peer</span></span><br><span class=\"line\">    <span class=\"comment\">// 因而调用 rtnl_create_link 函数创建对端网络设备的逻辑对象 peer </span></span><br><span class=\"line\">\tpeer = rtnl_create_link(net, ifname, name_assign_type,</span><br><span class=\"line\">\t\t\t\t&amp;veth_link_ops, tbp, extack);</span><br><span class=\"line\">\terr = register_netdevice(peer);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// 注册 dev 对象，本质上就在内存里面建立一个 struct 并将信息从文件映射过去</span></span><br><span class=\"line\">\terr = register_netdevice(dev);</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// 把 peer 和 dev 关联到一起</span></span><br><span class=\"line\">\tpriv = netdev_priv(dev);               <span class=\"comment\">// 获取 dev 的私有数据部分</span></span><br><span class=\"line\">\trcu_assign_pointer(priv-&gt;peer, peer);  <span class=\"comment\">// 将其 peer 字段指向 dev</span></span><br><span class=\"line\">\terr = veth_init_queues(dev, tb);</span><br><span class=\"line\">\tpriv = netdev_priv(peer);              <span class=\"comment\">// 获取 peer 的私有数据部分</span></span><br><span class=\"line\">\trcu_assign_pointer(priv-&gt;peer, dev);   <span class=\"comment\">// 将其 peer 字段指向 dev</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">\terr = veth_init_queues(peer, tb);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 添加 XDP 访问支持 --&gt; veth 在内核运行流程中接近网卡</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">\t<span class=\"comment\">/* update XDP supported features */</span></span><br><span class=\"line\">\tveth_set_xdp_features(dev);</span><br><span class=\"line\">\tveth_set_xdp_features(peer);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在<code>veth_newlink</code>当中通过**<code>register_netdevice</code>** 注册了两个网络虚拟设备： <code>peer</code> 和 <code>dev</code>，并通过让 <code>dev</code> 的 peer 指针指向创建的 peer，让<code>peer</code> 的 peer  指针指向 dev，来完成了 veth 设备的结对。这个过程是符合 veth 的工作逻辑的，由于  veth 总是成对出现，所以在生成新的 veth 时候就需要指定它所连接对端  peer，当然这个过程发生在内核运行当中，并不是有物理上的连接关系，直白来说就是依据文件信息写入到内存，开辟一个空间来存储对应的信息，然后修改指针指向来表示连接关系。</p>\n<p>创建完成之后，veth 又是怎么来传输数据的呢？回到之前的 <code>veth_setup</code>,启动 veth 的流程，也是将各类函数注册指定到 veth 对象当中</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">veth_setup</span><span class=\"params\">(<span class=\"keyword\">struct</span> net_device *dev)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tether_setup(dev);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">\tdev-&gt;netdev_ops = &amp;veth_netdev_ops;</span><br><span class=\"line\">\tdev-&gt;xdp_metadata_ops = &amp;veth_xdp_metadata_ops;</span><br><span class=\"line\">\tdev-&gt;ethtool_ops = &amp;veth_ethtool_ops;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到是 veth 对象的操作列表包含三类：<code>veth_netdev_ops</code>,<code>veth_xdp_metadata_ops</code>,<code>veth_ethtool_ops</code>, 具体的列表如下：</p>\n<p>net_device_ops 结构是网络设备的操作函数集结构, 包含了 Linux 网络设备对象的各项操作行为列表，也是  veth 对象调用实现功能的具体行为。</p>\n<p>从以下列表其实可以知道，Linux 设备是通用一个网卡的代码数据操作流程及对象的，以下的操作函数对于 ebpf xdp 程序直接操作有一定参考，是EdgeMesh 为来优化的对象，故进一步深入探究。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">net_device_ops</span> <span class=\"title\">veth_netdev_ops</span> =</span> &#123;</span><br><span class=\"line\">\t.ndo_init            = veth_dev_init,</span><br><span class=\"line\">\t.ndo_open            = veth_open,</span><br><span class=\"line\">\t.ndo_stop            = veth_close,</span><br><span class=\"line\">\t.ndo_start_xmit      = veth_xmit,</span><br><span class=\"line\">\t.ndo_get_stats64     = veth_get_stats64,</span><br><span class=\"line\">\t.ndo_set_rx_mode     = veth_set_multicast_list,</span><br><span class=\"line\">\t.ndo_set_mac_address = eth_mac_addr,</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> CONFIG_NET_POLL_CONTROLLER</span></span><br><span class=\"line\">\t.ndo_poll_controller\t= veth_poll_controller,</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">\t.ndo_get_iflink\t\t= veth_get_iflink,</span><br><span class=\"line\">\t.ndo_fix_features\t= veth_fix_features,</span><br><span class=\"line\">\t.ndo_set_features\t= veth_set_features,</span><br><span class=\"line\">\t.ndo_features_check\t= passthru_features_check,</span><br><span class=\"line\">\t.ndo_set_rx_headroom\t= veth_set_rx_headroom,</span><br><span class=\"line\">\t.ndo_bpf\t\t= veth_xdp,</span><br><span class=\"line\">\t.ndo_xdp_xmit\t\t= veth_ndo_xdp_xmit,</span><br><span class=\"line\">\t.ndo_get_peer_dev\t= veth_peer_dev,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这些函数的具体作用如下整理：</p>\n<ul>\n<li><p><code>ndo_init</code>: 该函数指向 <code>veth_dev_init</code>，网络设备初始化函数，由驱动程序实现，在网卡设备分配之后调用。</p>\n</li>\n<li><p><code>ndo_open</code>: 该函数指向 <code>veth_open</code>，被调用以打开虚拟网络设备并将其加入网络协议栈，由驱动程序实现，用于开启网络设备并为进程提供网络访问。</p>\n</li>\n<li><p><code>ndo_stop</code>：该函数指向 <code>veth_close</code>，由驱动程序实现，被调用以停止虚拟网络设备并将其从网络协议栈中移除。</p>\n</li>\n<li><p>==<code>ndo_start_xmit</code>：该函数指向 <code>veth_xmit</code>，由驱动程序实现，用于将给定的网络数据帧发送到指定的网络设备上。==</p>\n</li>\n<li><p><code>ndo_get_stats64</code>：该函数指向 <code>veth_get_stats64</code>，由驱动程序实现，用于获取虚拟网络设备当前的统计信息。</p>\n</li>\n<li><p><code>ndo_set_rx_mode</code>：该函数指向 <code>veth_set_multicast_list</code>，由驱动程序实现，用于设置网络设备接收模式。</p>\n</li>\n<li><p><code>ndo_set_mac_address</code>：该函数指向 <code>eth_mac_addr</code>，用于设置虚拟网络设备的MAC地址。</p>\n</li>\n<li><p><code>ndo_poll_controller</code>：该函数指向 <code>veth_poll_controller</code>，由驱动程序实现，veth调用之后触发软中断从 Ringbuffer 当中 poll 数据包</p>\n</li>\n<li><p><code>ndo_get_iflink</code>：该函数指向 <code>veth_get_iflink</code>，用于获取虚拟网络设备的网络接口索引号。</p>\n</li>\n<li><p><code>ndo_fix_features</code>：该函数指向 <code>veth_fix_features</code>，用于设置虚拟网络设备的特性参数；</p>\n</li>\n<li><p><code>ndo_set_features</code>：该函数指向 <code>veth_set_features</code>，用于修改或更新虚拟网络设备已经打开的特性参数。</p>\n</li>\n<li><p><code>ndo_features_check</code>：该函数指向 <code>passthru_features_check</code>，检查虚拟网络设备是否包含由 ETS（Enhanced Traffic Service）要求的特征。</p>\n</li>\n<li><p><code>ndo_set_rx_headroom</code>: 该函数指向 <code>veth_set_rx_headroom</code>，用于设置虚拟网络设备中下行数据帧包头部的大小。</p>\n</li>\n<li><p><code>ndo_bpf</code>：该函数指向 <code>veth_xdp</code>，用于添加eBPF扩展程序入口并进行初始化。</p>\n</li>\n<li><p><code>ndo_xdp_xmit</code>: 该函数指向 <code>veth_ndo_xdp_xmit</code>，驱动程序的XDP传输方法入口，将网络数据帧发送到用户提供的XDP扩展程序。</p>\n</li>\n<li><p><code>ndo_get_peer_dev</code>: 该函数指向 <code>veth_peer_dev</code>，用于获取与虚拟网络设备配对的网络设备。 </p>\n</li>\n</ul>\n<p><code>ethtool_ops</code>结构则代表了与<code>ethtool</code>工具相关的网络设备操作函数集合。<code>ethtool</code>用于获取和设置与<code>ethtool</code>兼容设备的驱动程序和硬件信息，同时实现均衡网速，流量控制等功能。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ethtool_ops</span> <span class=\"title\">veth_ethtool_ops</span> =</span> &#123;</span><br><span class=\"line\">\t.get_drvinfo\t\t= veth_get_drvinfo,</span><br><span class=\"line\">\t.get_link\t\t= ethtool_op_get_link,</span><br><span class=\"line\">\t.get_strings\t\t= veth_get_strings,</span><br><span class=\"line\">\t.get_sset_count\t\t= veth_get_sset_count,</span><br><span class=\"line\">\t.get_ethtool_stats\t= veth_get_ethtool_stats,</span><br><span class=\"line\">\t.get_link_ksettings\t= veth_get_link_ksettings,</span><br><span class=\"line\">\t.get_ts_info\t\t= ethtool_op_get_ts_info,</span><br><span class=\"line\">\t.get_channels\t\t= veth_get_channels,</span><br><span class=\"line\">\t.set_channels\t\t= veth_set_channels,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><code>xdp_metadata_ops</code>结构体定义了XDP（eBPF based packet processing）元数据的操作集合，在实现高性能网络数据包处理、过滤和转发的过程中起到重要作用。该操作集与XDP引擎密切相关，包括xsk_frame_parse（对接收的数据包的元数据进行解析）和xsk_frame_init（初始化元数据）等。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">xdp_metadata_ops</span> <span class=\"title\">veth_xdp_metadata_ops</span> =</span> &#123;</span><br><span class=\"line\">\t.xmo_rx_timestamp\t\t= veth_xdp_rx_timestamp,</span><br><span class=\"line\">\t.xmo_rx_hash\t\t\t= veth_xdp_rx_hash,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><code>xmo_rx_timestamp</code> ： 该函数指针指向 <code>veth_xdp_rx_timestamp</code> 函数，用于获取 XDP 包的接收时间戳，即处理 XDP 包的内核进程把包抓取的时间。该时间可以在 eBPF 程序中使用，例如可用于实现延迟测量(metric)，排除处理器竞争以及路由表测量等。</p>\n</li>\n<li><p><code>xmo_rx_hash</code>：该函数指针指向 <code>veth_xdp_rx_hash</code>，用于获取 XDP 数据包的接收哈希值。通过接收哈希值，可以在 eBPF 中就各个数据包的接收位置和网络环境进行更好的控制和调节，以优化网络性能。例如在基于哈希的负载均衡中，可以使用哈希值来决定要将数据包路由到哪个接收 CPU 或内核上。</p>\n</li>\n</ul>\n<p>在 Linux 中，这些函数指针被定义为可选项，也就是说并非每个驱动程序都会实现这两个函数指针。<code>xdp_metadata_ops</code> 使驱动程序与 eBPF程序 在处理特定的数据包和流量时更加灵活；但反过来说也需要配备一定的环境才能够实现这些调用的功能。</p>\n<p>到这里，veth 的创建和各项功能在 Linux 视角的样子就全部呈现了，总的来说 veth 本身是 Linux 中创建的 <code>net_device</code> 结构，通过注册所需的初始化和操作行为等特定函数以及对其进行相应的参数配置，最终实例化为 veth 对象，用于虚拟网络的构建。同时更明确了 veth 是工作在二层的数据结构，他传输数据会调用驱动程序实现的 <code>ndo_start_xmit</code>函数，在指定了对端之后，数据包发送会存入 skb 并插入 <code>softnet_data-&gt;input_pkt_queue</code>中，出发软中断，接下来就是对称一般的内核接收过程。</p>\n<hr>\n<h2 id=\"网桥的连接和传输\"><a href=\"#网桥的连接和传输\" class=\"headerlink\" title=\"网桥的连接和传输\"></a>网桥的连接和传输</h2><p>veth 可以感性地认知为网卡，它给予了所划分出的 network namspace 一个出入的门，此前的结构如果将 veth 分别指向两个网络空间，就能够实现这二者的通信，但是当所划分的网络空间区域增加的时候，这样子点对点的连接方式显然就很难支撑了。</p>\n<p>这样就需要解决单节点大量容器之间的网络互连问题。</p>\n<p>参考实际物理网络的结构，Linux 实现并提供了一个完全由软件虚拟出来的交换机，它可以提供很多的虚拟端口，把许多的 veth 连接在一个平面的网络，通过自己的转发功能让虚拟机网卡之间可以通信，这个技术就叫做 bridge。</p>\n<p>如何使用 bridge 连接不同的网络空间呢？<a href=\"https://developers.redhat.com/blog/2018/10/22/introduction-to-linux-interfaces-for-virtual-networking#team_device\">Introduction to Linux interfaces for virtual networking | Red Hat Developer</a>，<a href=\"https://dev.to/arriqaaq/diving-into-linux-networking-and-docker-bridge-veth-and-iptables-419a\">Deep dive into Linux Networking and Docker - Bridge, vETH and IPTables - DEV Community</a>  等文章也有详尽阐述，不再复述。</p>\n<p>其中要关注的点是： bridge 的工作源码都是在 /net/core/dev.c 或者是 /net/bridge 目录下面，也就是说他是工作在二层上的设备（这一点与物理交换相同），但所给的实验来验证连通性是依靠 ping 指令从IP来看的，但这并不意味着 bridge 是依靠 IP  来做转发的。</p>\n<p>为了验证这一点，深入来看 bridge 的内核实现</p>\n<p>从外部网络到达节点时候，数据包会被网卡先送到 RingBuffer 中，然后依次经过硬中断、软中断处理，在软中断中再以此把包送到设备层（连接bridge）、协议栈，最后唤醒应用程序。</p>\n<p>从节点内的应用程序到达外部的时候，会从应用程序调用系统调用，在进入协议栈（传输层、网络层），再进入邻居子系统到网络设备子系统（bridge），之后调用驱动程序触发硬中断到网卡。</p>\n<p>在这个过程中，bridge 输入数据包处理工作流程在 <code>/net/bridge/br_input.c</code> 中 <code>br_handle_frame_finish</code>函数里</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">br_handle_frame_finish</span><span class=\"params\">(<span class=\"keyword\">struct</span> net *net, <span class=\"keyword\">struct</span> sock *sk, <span class=\"keyword\">struct</span> sk_buff *skb)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取 veth 所连接的网桥端口以及 bridge 设备</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">net_bridge_port</span> *<span class=\"title\">p</span> =</span> br_port_get_rcu(skb-&gt;dev);</span><br><span class=\"line\">    <span class=\"comment\">// 创建转发表对象</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">net_bridge_fdb_entry</span> *<span class=\"title\">dst</span> =</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">net_bridge_mcast_port</span> *<span class=\"title\">pmctx</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">net_bridge_mdb_entry</span> *<span class=\"title\">mdst</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">net_bridge_vlan</span> *<span class=\"title\">vlan</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">net_bridge</span> *<span class=\"title\">br</span>;</span></span><br><span class=\"line\">\tbr = p-&gt;br;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 查找并更新转发表，这个转发表使用的地址是eth_hdr(skb)-&gt;h_source</span></span><br><span class=\"line\">\tbr_fdb_update(br, p, eth_hdr(skb)-&gt;h_source,vid, BIT(BR_FDB_LOCKED));\t</span><br><span class=\"line\">\tdst = br_fdb_find_rcu(br, eth_hdr(skb)-&gt;h_dest, vid);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 转发</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (dst) &#123;</span><br><span class=\"line\">\t\tbr_forward(dst-&gt;dst, skb, local_rcv, <span class=\"literal\">false</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 本机访问</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (local_rcv)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> br_pass_frame_up(skb);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中查找和转发使用的地址是eth_hdr(skb)-&gt;h_dest，和物理环境当中的交换机会自动学习端口所对应的节点mac地址一样，软件模拟的 bridge 也会自学习 veth 与 eth_hdr 的对应关系。</p>\n<p>总的来说，当创建了 bridge 并把 veth 设备放入其中，网桥就能够为连接的网络空间提供一个平面的网络连接服务。</p>\n<p>其实到目前为止，所涉及的网络设备都工作在二层，对应到物理环境就是都使用的 MAC 地址进行寻址和交换信息，这样的网络服务就是 Linux  基本网络服务，能够实现单节点上的网络空间连通性。</p>\n<p>可只是这样是无法满足Kubernetes 集群的网络寻址和路由需求的，现有的网络追求平面式的连接服务但是底层依旧还是得通过IP进行寻址；回到容器网络当中，这也意味着希望在容器网络当中的实体能够拥有各自独立、唯一的IP地址，可以是容器、物理机或者是其他的网络设备（比如虚拟路由器）等，容器可以被添加到一个或多个网络中或从一个或多个网络中删除。这就是接下来 CNI 需要满足的功能之一。</p>\n<hr>\n"},{"title":"Kubernetes 容器网络 CNI — CNI","catalog":true,"date":"2023-04-18T21:02:23.000Z","subtitle":null,"header-img":null,"published":0,"_content":"\n\n\n","source":"_posts/EdgeMesh/2023-ospp-fighting/CNI-PodandContainer.md","raw":"---\ntitle: Kubernetes 容器网络 CNI — CNI \ncatalog: true\ndate: 2023-04-19 05:02:23\nsubtitle:\nheader-img: \ntags: ospp, CNI, Linux, Spec\ncategories: CNI\npublished: false\n---\n\n\n\n","slug":"EdgeMesh/2023-ospp-fighting/CNI-PodandContainer","updated":"2023-05-27T07:19:10.228Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli796r0o000tbyjx1ef60th2","content":"","site":{"data":{}},"cover":"/img/cover/sky.png","cover_type":"img","excerpt":"","more":""},{"layout":"source/_posts/edgemesh/2023-ospp-fighting/","title":"Kubernetes 容器网络 CNI — 现有 CNI 方案的调研","catalog":true,"date":"2023-04-18T21:02:23.000Z","_content":"\n# CNI Plugins 调研\n\n## 1. 通用 CNI 插件\n\n> 主要基于 [containernetworking/plugins: Some reference and example networking plugins, maintained by the CNI team. (github.com)](https://github.com/containernetworking/plugins) ，[CNI](https://www.cni.dev/plugins/current/)\n\n由CNI 官方社区维护的 CNI plugins 主要分为三类：\n\n* `Main: interface-creating`: 主进程 CNI ,直接与 Linux 交流，创建接口、网络空间、对象等\n* `IPAM: IP address allocation`:  地址管理插件，主要负责 IP 地址管理和分配\n* `Meta: other plugins`: 其他的功能插件\n\n\n\n### Main: interface-creating  主进程 CNI \n\n### [`bridge`](https://www.cni.dev/plugins/current/main/bridge/) \n\n​\t创建虚拟网桥，并把本机（host）和容器（更准确说是network namespace）添加到其中\n\n### [`macvlan`](https://www.cni.dev/plugins/current/main/macvlan/)\n\n​\t创建一个新的 MAC 地址，将相关容器的所有流量都转发到该地址\n\n### [`ipvlan`](https://www.cni.dev/plugins/current/main/ipvlan/) \n\n​\t类似于 `macvlan`创建虚拟局域网连接，给容器增加 [ipvlan ](https://www.kernel.org/doc/Documentation/networking/ipvlan.txt)接口，他主要有两种模式：\n\n- L2 模式：  TX 流程完成在容器内的网络堆栈，之后数据包就会传输到本机队列等待发送，这个模式下容器网络可以进行RX/TX多播和广播（如本机启用的话）。\n- L3 模式：容器网络仅能够处理 L3 网络流程，数据包先在容器内处理到 L3，然后再由主设备进行 L2 的处理和路由，再发送出去。这个模式创建的容器网络与本机共享同一个 L2 设备，所以容器网络将不会接收多播/广播流量，也无法发送多播/广播流量\n\n这个模式创建对象的例子\n\n``` c\n  +=============================================================+\n  |  Host: host1                                                |\n  |                                                             |\n  |                                                             |\n  |   +----------------------+      +----------------------+    |\n  |   |   NS:ns0             |      |  NS:ns1              |    |\n  |   |                      |      |                      |    |\n  |   |                      |      |                      |    |\n  |   |        ipvl0         |      |         ipvl1        |    |\n  |   +----------#-----------+      +-----------#----------+    |\n  |              #                              #               |\n  |              ################################               |\n  |                              # eth0                         |\n  +==============================#==============================+\n（a） 创建两个网络命名空间 - ns0、ns1\n\t\tIP 网络添加 NS0\n\t\tIP 网络添加 NS1\n\n（b） 在 eth0（主设备）上创建两个 ipvlan 从站。\n\t\tIP 链路添加链路 eth0 IPvl0 类型 IPvlan 模式 L2\n\t\tIP 链路添加链路 eth0 IPvl1 类型 IPvlan 模式 L2\n\n（c） 将从属服务器分配到相应的网络命名空间\n\t\tIP link set dev ipvl0 netns ns0\n\t\tIP link set dev ipvl1 netns ns1\n\n（d） 现在切换到命名空间（ns0 或 ns1）以配置从属设备\n\t\t- 对于 ns0\n\t\t\t（1） IP netns exec ns0 bash\n\t\t\t（2） IP 链路设置开发 IPvl0 向上\n\t\t\t（3） IP 链路设置开发\n\t\t\t（4） IP -4 地址添加 127.0.0.1 开发 LO\n\t\t\t（5） IP -4 地址添加 $IPADDR 开发 IPvl0\n\t\t\t（6） IP -4 路由通过$ROUTER开发 IPvl0 添加默认值\n\t\t- 对于 ns1\n\t\t\t（1） IP Netns exec NS1 Bash\n\t\t\t（2） IP 链路设置开发 IPvl1 向上\n\t\t\t（3） IP 链路设置开发\n\t\t\t（4） IP -4 地址添加 127.0.0.1 开发 LO\n\t\t\t（5） IP -4 地址添加 $IPADDR 开发 IPvl1\n\t\t\t（6） IP -4 路由通过$ROUTER开发 IPvl1 添加默认值\n```\n\n\n\n### [`ptp`](https://www.cni.dev/plugins/current/main/ptp/) \n\n​\t该插件只会创建 veth 对\n\n### [`host-device`](https://www.cni.dev/plugins/current/main/host-device/)\n\n​\t将现有的网络设备移动到容器中\n\n### [`vlan`](https://www.cni.dev/plugins/current/main/vlan/) \n\n​\t将会创建一个独立于宿主机的 vxlan 网络接口\n\n### Windows: windows specific \n\n#### [`win-bridge`](https://www.cni.dev/plugins/current/main/win-bridge/) \n\n \t创建虚拟网桥并把本机和（单个）容器连接到这个网桥上\n\n#### [`win-overlay`](https://www.cni.dev/plugins/current/main/win-overlay/) \n\n​\t创建 overlay 接口给 容器\n\n---\n\n## 2. IPAM 插件\n\n### [`dhcp`](https://www.cni.dev/plugins/current/ipam/dhcp/) \n\n​\t给对应容器创建守护进程，这个进程用于发送DHCP请求给网关\n\n### [`host-local`](https://www.cni.dev/plugins/current/ipam/host-local/) \n\n​\t依据宿主机的网络信息来分配IP地址，会维护一个描述本机配置的数据文件\n\n### [`static`](https://www.cni.dev/plugins/current/ipam/static/) \n\n​\t分配指定条件的IPv4 和IPv6地址给容器\n\n---\n\n\n\n## 3. Meta 多功能插件\n\n### [`tuning`](https://www.cni.dev/plugins/current/meta/tuning/) \n\n​\t改变现有网络接口的 `sysctl` 参数\n\n### [`portmap`](https://www.cni.dev/plugins/current/meta/portmap/)\n\n​\t使用 iptables 的端口映射插件，建立从宿主机到容器的端口映射\n\n### [`bandwidth`](https://www.cni.dev/plugins/current/meta/bandwidth/) \n\n​\t使用流量控制tbf（token-bucket filter），通过限制入口和出口流量从而控制带宽\n\n### [`sbr`](https://www.cni.dev/plugins/current/meta/sbr/)\n\n \t为网络设备提供源路由的配置功能\n\n### [`firewall`](https://www.cni.dev/plugins/current/meta/firewall/) \n\n通过 `iptables` 增添路由规则来控制允许出入容器的流量\n\n以上这些基础插件的代码位置位于：[plugins/plugins at main · containernetworking/plugins (github.com)](https://github.com/containernetworking/plugins/tree/main/plugins)\n\n\n\n## 第三方 CNI 插件\n\n第三方插件的实现方式较多，尤其是在上述的这些基础 CNI 仅仅能够满足单节点容器地址管理划分创建需求的情况下，依据不同操作系统、不同需求的网络规模和网络规则创建，CNI 的功能和使用也就多种多样了。\n\n为了能够明确插件的实际功能，本文将主要依据功能的不同给 CNI 做一个标签，并整理他们使用时的规范和方法。\n\n\n\n### [Project Calico - a layer 3 virtual network](https://github.com/projectcalico/calico)\n\n> \n\n仓库位置是：[calico/cni-plugin at master · projectcalico/calico (github.com)](https://github.com/projectcalico/calico/tree/master/cni-plugin)\n\n相关文档是：[Configure the Calico CNI plugins | Calico Documentation (tigera.io)](https://docs.tigera.io/calico/latest/reference/configure-cni-plugins)\n\n\n\n### [Weave - a multi-host Docker network](https://github.com/weaveworks/weave)\n\n仓库位置是：[weave/plugin at master · weaveworks/weave (github.com)](https://github.com/weaveworks/weave/tree/master/plugin)\n\n相关文档是：[Integrating Kubernetes and Mesos via the CNI Plugin (weave.works)](https://www.weave.works/docs/net/latest/kubernetes/)\n\n\n\n### [Cilium - BPF & XDP for containers](https://github.com/cilium/cilium)\n\n仓库位置是：[cilium/plugins/cilium-cni at main · cilium/cilium (github.com)](https://github.com/cilium/cilium/tree/main/plugins/cilium-cni)\n\n相关文档是：[CNI Chaining — Cilium 1.13.2 documentation](https://docs.cilium.io/en/stable/installation/cni-chaining/#id1)\n\n\n\n### [Contiv Networking - policy networking for various use cases](https://github.com/contiv/netplugin)\n\n仓库位置是：[contiv/netplugin: Container networking for various use cases (github.com)](https://github.com/contiv/netplugin)\n\n相关文档是：无\n\n\n\n### [SR-IOV](https://github.com/hustcat/sriov-cni)\n\n仓库位置是：[hustcat/sriov-cni: SR-IOV CNI plugin (github.com)](https://github.com/hustcat/sriov-cni)\n\n相关文档是：[What is SR-IOV? - Scott's Weblog - The weblog of an IT pro focusing on cloud computing, Kubernetes, Linux, containers, and networking (scottlowe.org)](https://blog.scottlowe.org/2009/12/02/what-is-sr-iov/)\n\n\n\n### [Infoblox - enterprise IP address management for containers](https://github.com/infobloxopen/cni-infoblox)\n\n仓库位置是：[infobloxopen/cni-infoblox: CNI Infoblox Code (github.com)](https://github.com/infobloxopen/cni-infoblox)\n\n相关文档是：[CNI Networking and IPAM (infoblox.com)](https://blogs.infoblox.com/community/cni-networking-and-ipam/)\n\n\n\n### [Multus - a Multi plugin](https://github.com/k8snetworkplumbingwg/multus-cni)\n\n仓库位置是：[k8snetworkplumbingwg/multus-cni: A CNI meta-plugin for multi-homed pods in Kubernetes (github.com)](https://github.com/k8snetworkplumbingwg/multus-cni)\n\n相关文档是：[multus-cni/how-to-use.md at master · k8snetworkplumbingwg/multus-cni (github.com)](https://github.com/k8snetworkplumbingwg/multus-cni/blob/master/docs/how-to-use.md)\n\n\n\n### [Romana - Layer 3 CNI plugin supporting network policy for Kubernetes](https://github.com/romana/kube)\n\n仓库位置是：[romana/kube: Kubernetes specific components for Romana (github.com)](https://github.com/romana/kube)\n\n相关文档是：[romana/romana: The Romana Project - Installation scripts, documentation, issue tracker and wiki. Start here. (github.com)](https://github.com/romana/romana)\n\n\n\n### [CNI-Genie - generic CNI network plugin](https://github.com/Huawei-PaaS/CNI-Genie)\n\n仓库位置是：[huawei-cloudnative/CNI-Genie: CNI-Genie for choosing pod network of your choice during deployment time. Supported pod networks - Calico, Flannel, Romana, Weave (github.com)](https://github.com/huawei-cloudnative/CNI-Genie)\n\n相关文档是：同一仓库\n\n\n\n### [Nuage CNI - Nuage Networks SDN plugin for network policy kubernetes support](https://github.com/nuagenetworks/nuage-cni)\n\n仓库位置是：[nuagenetworks/nuage-cni: Nuage VSP plugin for the CNI project (github.com)](https://github.com/nuagenetworks/nuage-cni)\n\n相关文档是：同一仓库\n\n\n\n### [Silk - a CNI plugin designed for Cloud Foundry](https://github.com/cloudfoundry-incubator/silk)\n\n仓库位置是：[cloudfoundry/silk: a network fabric for containers. inspired by flannel, designed for Cloud Foundry. (github.com)](https://github.com/cloudfoundry/silk)\n\n相关文档是：同一位置\n\n\n\n### [Linen - a CNI plugin designed for overlay networks with Open vSwitch and fit in SDN/OpenFlow network environment](https://github.com/John-Lin/linen-cni)\n\n仓库位置是：[John-Lin/linen-cni: A CNI plugin designed for overlay networks with Open vSwitch (github.com)](https://github.com/John-Lin/linen-cni)\n\n相关文档是：同一仓库\n\n\n\n### [Vhostuser - a Dataplane network plugin - Supports OVS-DPDK & VPP](https://github.com/intel/vhost-user-net-plugin)\n\n仓库位置是：[intel/userspace-cni-network-plugin (github.com)](https://github.com/intel/userspace-cni-network-plugin)\n\n相关文档是：[Userspace CNI Design document - Google 文档](https://docs.google.com/document/d/1jAFDNWhf6flTlPHmbWavlyLrkFJtAdQlcOnG3qhRYtU/edit#heading=h.jj69b7nmami)\n\n\n\n### [Amazon ECS CNI Plugins - a collection of CNI Plugins to configure containers with Amazon EC2 elastic network interfaces (ENIs)](https://github.com/aws/amazon-ecs-cni-plugins)\n\n仓库位置是：[aws/amazon-ecs-cni-plugins: Networking Plugins repository for ECS Task Networking (github.com)](https://github.com/aws/amazon-ecs-cni-plugins)\n\n相关文档是：[What is Amazon Elastic Container Service? - Amazon Elastic Container Service](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/Welcome.html)\n\n\n\n### [Bonding CNI - a Link aggregating plugin to address failover and high availability network](https://github.com/Intel-Corp/bond-cni)\n\n仓库位置是：[k8snetworkplumbingwg/bond-cni: Bond-cni is for fail-over and high availability of networking in cloudnative orchestration (github.com)](https://github.com/k8snetworkplumbingwg/bond-cni)\n\n相关文档是：同一位置\n\n\n\n### [ovn-kubernetes - an container network plugin built on Open vSwitch (OVS) and Open Virtual Networking (OVN) with support for both Linux and Windows](https://github.com/openvswitch/ovn-kubernetes)\n\n仓库位置是：[ovn-org/ovn-kubernetes: Kubernetes integration for OVN (github.com)](https://github.com/ovn-org/ovn-kubernetes)\n\n相关文档是：[Installing Open vSwitch — Open vSwitch 3.1.90 documentation](https://docs.openvswitch.org/en/latest/intro/install/)\n\n\n\n### [Juniper Contrail](https://www.juniper.net/cloud) / [TungstenFabric](https://tungstenfabric.io/) - Provides overlay SDN solution, delivering multicloud networking, hybrid cloud networking, simultaneous overlay-underlay support, network policy enforcement, network isolation, service chaining and flexible load balancing\n\n仓库位置是：[Enterprise IT Networking Products & Solutions | Juniper Networks US](https://www.juniper.net/us/en/it-networking.html)\n\n相关文档是：[Juniper Networks Brings More Simplicity, Scale and Security to Enterprise Networking with Three-Step Campus Fabric Workflow and New EX Distribution Switch | Juniper Networks Inc.](https://newsroom.juniper.net/news/news-details/2023/Juniper-Networks-Brings-More-Simplicity-Scale-and-Security-to-Enterprise-Networking-with-Three-Step-Campus-Fabric-Workflow-and-New-EX-Distribution-Switch/default.aspx)\n\n> 无法参考，为保证资料完整性留存\n\n\n\n### [Knitter - a CNI plugin supporting multiple networking for Kubernetes](https://github.com/ZTE/Knitter)\n\n仓库位置是：[ZTE/Knitter: Kubernetes network solution (github.com)](https://github.com/ZTE/Knitter)\n\n相关文档是：[Knitter/docs at master · ZTE/Knitter (github.com)](https://github.com/ZTE/Knitter/tree/master/docs)\n\n\n\n### [DANM - a CNI-compliant networking solution for TelCo workloads running on Kubernetes](https://github.com/nokia/danm)\n\n仓库位置是：[nokia/danm: TelCo grade network management in a Kubernetes cluster (github.com)](https://github.com/nokia/danm)\n\n相关文档是：[danm/deployment-guide.md at master · nokia/danm (github.com)](https://github.com/nokia/danm/blob/master/deployment-guide.md)\n\n\n\n### [VMware NSX – a CNI plugin that enables automated NSX L2/L3 networking and L4/L7 Load Balancing; network isolation at the pod, node, and cluster level; and zero-trust security policy for your Kubernetes cluster.](https://docs.vmware.com/en/VMware-NSX-T/2.2/com.vmware.nsxt.ncp_kubernetes.doc/GUID-6AFA724E-BB62-4693-B95C-321E8DDEA7E1.html)\n\n仓库位置是：[weave/plugin at master · weaveworks/weave (github.com)](https://github.com/weaveworks/weave/tree/master/plugin)\n\n相关文档是：[Integrating Kubernetes and Mesos via the CNI Plugin (weave.works)]\n\n\n\n### [cni-route-override - a meta CNI plugin that override route information](https://github.com/redhat-nfvpe/cni-route-override)\n\n仓库位置是：[redhat-nfvpe/cni-route-override: CNI plugin to override routes for a container interface (github.com)](https://github.com/redhat-nfvpe/cni-route-override)\n\n相关文档是：同一位置\n\n\n\n\n\n### [Terway - a collection of CNI Plugins based on alibaba cloud VPC/ECS network product](https://github.com/AliyunContainerService/terway)\n\n仓库位置是：[AliyunContainerService/terway: CNI plugin for Alibaba Cloud VPC/ENI (github.com)](https://github.com/AliyunContainerService/terway)\n\n相关文档是：同一位置\n\n\n\n\n\n### [Cisco ACI CNI - for on-prem and cloud container networking with consistent policy and security model.](https://github.com/noironetworks/aci-containers)\n\n仓库位置是：[noironetworks/aci-containers: Plugins for integrating ACI with container orchestration systems (github.com)](https://github.com/noironetworks/aci-containers)\n\n相关文档是：同一位置\n\n\n\n### [Kube-OVN - a CNI plugin that bases on OVN/OVS and provides advanced features like subnet, static ip, ACL, QoS, etc.](https://github.com/kubeovn/kube-ovn)\n\n仓库位置是：[kubeovn/kube-ovn: A Bridge between SDN and Cloud Native (Project under CNCF) (github.com)](https://github.com/kubeovn/kube-ovn)\n\n相关文档是：[kube-ovn/install.md at master · kubeovn/kube-ovn (github.com)](https://github.com/kubeovn/kube-ovn/blob/master/docs/install.md)\n\n\n\n### [Project Antrea - an Open vSwitch k8s CNI](https://github.com/vmware-tanzu/antrea)\n\n仓库位置是：[antrea-io/antrea: Kubernetes networking based on Open vSwitch (github.com)](https://github.com/antrea-io/antrea)\n\n相关文档是：[antrea/getting-started.md at main · antrea-io/antrea (github.com)](https://github.com/antrea-io/antrea/blob/main/docs/getting-started.md)\n\n\n\n### [OVN4NFV-K8S-Plugin - a OVN based CNI controller plugin to provide cloud native based Service function chaining (SFC), Multiple OVN overlay networking](https://github.com/opnfv/ovn4nfv-k8s-plugin)\n\n仓库位置是：[opnfv/ovn4nfv-k8s-plugin: This repository is archived. Please see https://github.com/akraino-edge-stack/icn-nodus for the latest code.](https://github.com/opnfv/ovn4nfv-k8s-plugin)\n\n相关文档是：同一位置\n\n> 已经关闭\n\n\n\n### [Azure CNI - a CNI plugin that natively extends Azure Virtual Networks to containers](https://github.com/Azure/azure-container-networking)\n\n仓库位置是：[Azure/azure-container-networking: Azure Container Networking Solutions for Linux and Windows Containers (github.com)](https://github.com/Azure/azure-container-networking)\n\n相关文档是：[azure-container-networking/docs at master · Azure/azure-container-networking (github.com)](https://github.com/Azure/azure-container-networking/tree/master/docs)\n\n\n\n### [Hybridnet - a CNI plugin designed for hybrid clouds which provides both overlay and underlay networking for containers in one or more clusters. Overlay and underlay containers can run on the same node and have cluster-wide bidirectional network connectivity.](https://github.com/alibaba/hybridnet)\n\n仓库位置是：[alibaba/hybridnet: A CNI plugin, provides networking environment where overlay and underlay containers can run on the same node and have cluster-wide bidirectional network connectivity. (github.com)](https://github.com/alibaba/hybridnet)\n\n相关文档是：[Home · alibaba/hybridnet Wiki (github.com)](https://github.com/alibaba/hybridnet/wiki)\n\n\n\n### [Spiderpool - An IP Address Management (IPAM) CNI plugin of Kubernetes for managing static ip for underlay network](https://github.com/spidernet-io/spiderpool)\n\n仓库位置是：[spidernet-io/spiderpool: spiderpool: Kubernetes IPAM for underlay network (github.com)](https://github.com/spidernet-io/spiderpool)\n\n相关文档是：[spiderpool/install.md at main · spidernet-io/spiderpool (github.com)](https://github.com/spidernet-io/spiderpool/blob/main/docs/usage/install.md)\n\n\n\n\n\n\n\n\n","source":"_posts/EdgeMesh/2023-ospp-fighting/CNI-ReaseachofCni.md","raw":"---\nlayout: source/_posts/edgemesh/2023-ospp-fighting/\ntitle: Kubernetes 容器网络 CNI — 现有 CNI 方案的调研 \ncatalog: true\ndate: 2023-04-19 05:02:23\ntags: ospp, edgemesh\ncategories: Linux\n---\n\n# CNI Plugins 调研\n\n## 1. 通用 CNI 插件\n\n> 主要基于 [containernetworking/plugins: Some reference and example networking plugins, maintained by the CNI team. (github.com)](https://github.com/containernetworking/plugins) ，[CNI](https://www.cni.dev/plugins/current/)\n\n由CNI 官方社区维护的 CNI plugins 主要分为三类：\n\n* `Main: interface-creating`: 主进程 CNI ,直接与 Linux 交流，创建接口、网络空间、对象等\n* `IPAM: IP address allocation`:  地址管理插件，主要负责 IP 地址管理和分配\n* `Meta: other plugins`: 其他的功能插件\n\n\n\n### Main: interface-creating  主进程 CNI \n\n### [`bridge`](https://www.cni.dev/plugins/current/main/bridge/) \n\n​\t创建虚拟网桥，并把本机（host）和容器（更准确说是network namespace）添加到其中\n\n### [`macvlan`](https://www.cni.dev/plugins/current/main/macvlan/)\n\n​\t创建一个新的 MAC 地址，将相关容器的所有流量都转发到该地址\n\n### [`ipvlan`](https://www.cni.dev/plugins/current/main/ipvlan/) \n\n​\t类似于 `macvlan`创建虚拟局域网连接，给容器增加 [ipvlan ](https://www.kernel.org/doc/Documentation/networking/ipvlan.txt)接口，他主要有两种模式：\n\n- L2 模式：  TX 流程完成在容器内的网络堆栈，之后数据包就会传输到本机队列等待发送，这个模式下容器网络可以进行RX/TX多播和广播（如本机启用的话）。\n- L3 模式：容器网络仅能够处理 L3 网络流程，数据包先在容器内处理到 L3，然后再由主设备进行 L2 的处理和路由，再发送出去。这个模式创建的容器网络与本机共享同一个 L2 设备，所以容器网络将不会接收多播/广播流量，也无法发送多播/广播流量\n\n这个模式创建对象的例子\n\n``` c\n  +=============================================================+\n  |  Host: host1                                                |\n  |                                                             |\n  |                                                             |\n  |   +----------------------+      +----------------------+    |\n  |   |   NS:ns0             |      |  NS:ns1              |    |\n  |   |                      |      |                      |    |\n  |   |                      |      |                      |    |\n  |   |        ipvl0         |      |         ipvl1        |    |\n  |   +----------#-----------+      +-----------#----------+    |\n  |              #                              #               |\n  |              ################################               |\n  |                              # eth0                         |\n  +==============================#==============================+\n（a） 创建两个网络命名空间 - ns0、ns1\n\t\tIP 网络添加 NS0\n\t\tIP 网络添加 NS1\n\n（b） 在 eth0（主设备）上创建两个 ipvlan 从站。\n\t\tIP 链路添加链路 eth0 IPvl0 类型 IPvlan 模式 L2\n\t\tIP 链路添加链路 eth0 IPvl1 类型 IPvlan 模式 L2\n\n（c） 将从属服务器分配到相应的网络命名空间\n\t\tIP link set dev ipvl0 netns ns0\n\t\tIP link set dev ipvl1 netns ns1\n\n（d） 现在切换到命名空间（ns0 或 ns1）以配置从属设备\n\t\t- 对于 ns0\n\t\t\t（1） IP netns exec ns0 bash\n\t\t\t（2） IP 链路设置开发 IPvl0 向上\n\t\t\t（3） IP 链路设置开发\n\t\t\t（4） IP -4 地址添加 127.0.0.1 开发 LO\n\t\t\t（5） IP -4 地址添加 $IPADDR 开发 IPvl0\n\t\t\t（6） IP -4 路由通过$ROUTER开发 IPvl0 添加默认值\n\t\t- 对于 ns1\n\t\t\t（1） IP Netns exec NS1 Bash\n\t\t\t（2） IP 链路设置开发 IPvl1 向上\n\t\t\t（3） IP 链路设置开发\n\t\t\t（4） IP -4 地址添加 127.0.0.1 开发 LO\n\t\t\t（5） IP -4 地址添加 $IPADDR 开发 IPvl1\n\t\t\t（6） IP -4 路由通过$ROUTER开发 IPvl1 添加默认值\n```\n\n\n\n### [`ptp`](https://www.cni.dev/plugins/current/main/ptp/) \n\n​\t该插件只会创建 veth 对\n\n### [`host-device`](https://www.cni.dev/plugins/current/main/host-device/)\n\n​\t将现有的网络设备移动到容器中\n\n### [`vlan`](https://www.cni.dev/plugins/current/main/vlan/) \n\n​\t将会创建一个独立于宿主机的 vxlan 网络接口\n\n### Windows: windows specific \n\n#### [`win-bridge`](https://www.cni.dev/plugins/current/main/win-bridge/) \n\n \t创建虚拟网桥并把本机和（单个）容器连接到这个网桥上\n\n#### [`win-overlay`](https://www.cni.dev/plugins/current/main/win-overlay/) \n\n​\t创建 overlay 接口给 容器\n\n---\n\n## 2. IPAM 插件\n\n### [`dhcp`](https://www.cni.dev/plugins/current/ipam/dhcp/) \n\n​\t给对应容器创建守护进程，这个进程用于发送DHCP请求给网关\n\n### [`host-local`](https://www.cni.dev/plugins/current/ipam/host-local/) \n\n​\t依据宿主机的网络信息来分配IP地址，会维护一个描述本机配置的数据文件\n\n### [`static`](https://www.cni.dev/plugins/current/ipam/static/) \n\n​\t分配指定条件的IPv4 和IPv6地址给容器\n\n---\n\n\n\n## 3. Meta 多功能插件\n\n### [`tuning`](https://www.cni.dev/plugins/current/meta/tuning/) \n\n​\t改变现有网络接口的 `sysctl` 参数\n\n### [`portmap`](https://www.cni.dev/plugins/current/meta/portmap/)\n\n​\t使用 iptables 的端口映射插件，建立从宿主机到容器的端口映射\n\n### [`bandwidth`](https://www.cni.dev/plugins/current/meta/bandwidth/) \n\n​\t使用流量控制tbf（token-bucket filter），通过限制入口和出口流量从而控制带宽\n\n### [`sbr`](https://www.cni.dev/plugins/current/meta/sbr/)\n\n \t为网络设备提供源路由的配置功能\n\n### [`firewall`](https://www.cni.dev/plugins/current/meta/firewall/) \n\n通过 `iptables` 增添路由规则来控制允许出入容器的流量\n\n以上这些基础插件的代码位置位于：[plugins/plugins at main · containernetworking/plugins (github.com)](https://github.com/containernetworking/plugins/tree/main/plugins)\n\n\n\n## 第三方 CNI 插件\n\n第三方插件的实现方式较多，尤其是在上述的这些基础 CNI 仅仅能够满足单节点容器地址管理划分创建需求的情况下，依据不同操作系统、不同需求的网络规模和网络规则创建，CNI 的功能和使用也就多种多样了。\n\n为了能够明确插件的实际功能，本文将主要依据功能的不同给 CNI 做一个标签，并整理他们使用时的规范和方法。\n\n\n\n### [Project Calico - a layer 3 virtual network](https://github.com/projectcalico/calico)\n\n> \n\n仓库位置是：[calico/cni-plugin at master · projectcalico/calico (github.com)](https://github.com/projectcalico/calico/tree/master/cni-plugin)\n\n相关文档是：[Configure the Calico CNI plugins | Calico Documentation (tigera.io)](https://docs.tigera.io/calico/latest/reference/configure-cni-plugins)\n\n\n\n### [Weave - a multi-host Docker network](https://github.com/weaveworks/weave)\n\n仓库位置是：[weave/plugin at master · weaveworks/weave (github.com)](https://github.com/weaveworks/weave/tree/master/plugin)\n\n相关文档是：[Integrating Kubernetes and Mesos via the CNI Plugin (weave.works)](https://www.weave.works/docs/net/latest/kubernetes/)\n\n\n\n### [Cilium - BPF & XDP for containers](https://github.com/cilium/cilium)\n\n仓库位置是：[cilium/plugins/cilium-cni at main · cilium/cilium (github.com)](https://github.com/cilium/cilium/tree/main/plugins/cilium-cni)\n\n相关文档是：[CNI Chaining — Cilium 1.13.2 documentation](https://docs.cilium.io/en/stable/installation/cni-chaining/#id1)\n\n\n\n### [Contiv Networking - policy networking for various use cases](https://github.com/contiv/netplugin)\n\n仓库位置是：[contiv/netplugin: Container networking for various use cases (github.com)](https://github.com/contiv/netplugin)\n\n相关文档是：无\n\n\n\n### [SR-IOV](https://github.com/hustcat/sriov-cni)\n\n仓库位置是：[hustcat/sriov-cni: SR-IOV CNI plugin (github.com)](https://github.com/hustcat/sriov-cni)\n\n相关文档是：[What is SR-IOV? - Scott's Weblog - The weblog of an IT pro focusing on cloud computing, Kubernetes, Linux, containers, and networking (scottlowe.org)](https://blog.scottlowe.org/2009/12/02/what-is-sr-iov/)\n\n\n\n### [Infoblox - enterprise IP address management for containers](https://github.com/infobloxopen/cni-infoblox)\n\n仓库位置是：[infobloxopen/cni-infoblox: CNI Infoblox Code (github.com)](https://github.com/infobloxopen/cni-infoblox)\n\n相关文档是：[CNI Networking and IPAM (infoblox.com)](https://blogs.infoblox.com/community/cni-networking-and-ipam/)\n\n\n\n### [Multus - a Multi plugin](https://github.com/k8snetworkplumbingwg/multus-cni)\n\n仓库位置是：[k8snetworkplumbingwg/multus-cni: A CNI meta-plugin for multi-homed pods in Kubernetes (github.com)](https://github.com/k8snetworkplumbingwg/multus-cni)\n\n相关文档是：[multus-cni/how-to-use.md at master · k8snetworkplumbingwg/multus-cni (github.com)](https://github.com/k8snetworkplumbingwg/multus-cni/blob/master/docs/how-to-use.md)\n\n\n\n### [Romana - Layer 3 CNI plugin supporting network policy for Kubernetes](https://github.com/romana/kube)\n\n仓库位置是：[romana/kube: Kubernetes specific components for Romana (github.com)](https://github.com/romana/kube)\n\n相关文档是：[romana/romana: The Romana Project - Installation scripts, documentation, issue tracker and wiki. Start here. (github.com)](https://github.com/romana/romana)\n\n\n\n### [CNI-Genie - generic CNI network plugin](https://github.com/Huawei-PaaS/CNI-Genie)\n\n仓库位置是：[huawei-cloudnative/CNI-Genie: CNI-Genie for choosing pod network of your choice during deployment time. Supported pod networks - Calico, Flannel, Romana, Weave (github.com)](https://github.com/huawei-cloudnative/CNI-Genie)\n\n相关文档是：同一仓库\n\n\n\n### [Nuage CNI - Nuage Networks SDN plugin for network policy kubernetes support](https://github.com/nuagenetworks/nuage-cni)\n\n仓库位置是：[nuagenetworks/nuage-cni: Nuage VSP plugin for the CNI project (github.com)](https://github.com/nuagenetworks/nuage-cni)\n\n相关文档是：同一仓库\n\n\n\n### [Silk - a CNI plugin designed for Cloud Foundry](https://github.com/cloudfoundry-incubator/silk)\n\n仓库位置是：[cloudfoundry/silk: a network fabric for containers. inspired by flannel, designed for Cloud Foundry. (github.com)](https://github.com/cloudfoundry/silk)\n\n相关文档是：同一位置\n\n\n\n### [Linen - a CNI plugin designed for overlay networks with Open vSwitch and fit in SDN/OpenFlow network environment](https://github.com/John-Lin/linen-cni)\n\n仓库位置是：[John-Lin/linen-cni: A CNI plugin designed for overlay networks with Open vSwitch (github.com)](https://github.com/John-Lin/linen-cni)\n\n相关文档是：同一仓库\n\n\n\n### [Vhostuser - a Dataplane network plugin - Supports OVS-DPDK & VPP](https://github.com/intel/vhost-user-net-plugin)\n\n仓库位置是：[intel/userspace-cni-network-plugin (github.com)](https://github.com/intel/userspace-cni-network-plugin)\n\n相关文档是：[Userspace CNI Design document - Google 文档](https://docs.google.com/document/d/1jAFDNWhf6flTlPHmbWavlyLrkFJtAdQlcOnG3qhRYtU/edit#heading=h.jj69b7nmami)\n\n\n\n### [Amazon ECS CNI Plugins - a collection of CNI Plugins to configure containers with Amazon EC2 elastic network interfaces (ENIs)](https://github.com/aws/amazon-ecs-cni-plugins)\n\n仓库位置是：[aws/amazon-ecs-cni-plugins: Networking Plugins repository for ECS Task Networking (github.com)](https://github.com/aws/amazon-ecs-cni-plugins)\n\n相关文档是：[What is Amazon Elastic Container Service? - Amazon Elastic Container Service](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/Welcome.html)\n\n\n\n### [Bonding CNI - a Link aggregating plugin to address failover and high availability network](https://github.com/Intel-Corp/bond-cni)\n\n仓库位置是：[k8snetworkplumbingwg/bond-cni: Bond-cni is for fail-over and high availability of networking in cloudnative orchestration (github.com)](https://github.com/k8snetworkplumbingwg/bond-cni)\n\n相关文档是：同一位置\n\n\n\n### [ovn-kubernetes - an container network plugin built on Open vSwitch (OVS) and Open Virtual Networking (OVN) with support for both Linux and Windows](https://github.com/openvswitch/ovn-kubernetes)\n\n仓库位置是：[ovn-org/ovn-kubernetes: Kubernetes integration for OVN (github.com)](https://github.com/ovn-org/ovn-kubernetes)\n\n相关文档是：[Installing Open vSwitch — Open vSwitch 3.1.90 documentation](https://docs.openvswitch.org/en/latest/intro/install/)\n\n\n\n### [Juniper Contrail](https://www.juniper.net/cloud) / [TungstenFabric](https://tungstenfabric.io/) - Provides overlay SDN solution, delivering multicloud networking, hybrid cloud networking, simultaneous overlay-underlay support, network policy enforcement, network isolation, service chaining and flexible load balancing\n\n仓库位置是：[Enterprise IT Networking Products & Solutions | Juniper Networks US](https://www.juniper.net/us/en/it-networking.html)\n\n相关文档是：[Juniper Networks Brings More Simplicity, Scale and Security to Enterprise Networking with Three-Step Campus Fabric Workflow and New EX Distribution Switch | Juniper Networks Inc.](https://newsroom.juniper.net/news/news-details/2023/Juniper-Networks-Brings-More-Simplicity-Scale-and-Security-to-Enterprise-Networking-with-Three-Step-Campus-Fabric-Workflow-and-New-EX-Distribution-Switch/default.aspx)\n\n> 无法参考，为保证资料完整性留存\n\n\n\n### [Knitter - a CNI plugin supporting multiple networking for Kubernetes](https://github.com/ZTE/Knitter)\n\n仓库位置是：[ZTE/Knitter: Kubernetes network solution (github.com)](https://github.com/ZTE/Knitter)\n\n相关文档是：[Knitter/docs at master · ZTE/Knitter (github.com)](https://github.com/ZTE/Knitter/tree/master/docs)\n\n\n\n### [DANM - a CNI-compliant networking solution for TelCo workloads running on Kubernetes](https://github.com/nokia/danm)\n\n仓库位置是：[nokia/danm: TelCo grade network management in a Kubernetes cluster (github.com)](https://github.com/nokia/danm)\n\n相关文档是：[danm/deployment-guide.md at master · nokia/danm (github.com)](https://github.com/nokia/danm/blob/master/deployment-guide.md)\n\n\n\n### [VMware NSX – a CNI plugin that enables automated NSX L2/L3 networking and L4/L7 Load Balancing; network isolation at the pod, node, and cluster level; and zero-trust security policy for your Kubernetes cluster.](https://docs.vmware.com/en/VMware-NSX-T/2.2/com.vmware.nsxt.ncp_kubernetes.doc/GUID-6AFA724E-BB62-4693-B95C-321E8DDEA7E1.html)\n\n仓库位置是：[weave/plugin at master · weaveworks/weave (github.com)](https://github.com/weaveworks/weave/tree/master/plugin)\n\n相关文档是：[Integrating Kubernetes and Mesos via the CNI Plugin (weave.works)]\n\n\n\n### [cni-route-override - a meta CNI plugin that override route information](https://github.com/redhat-nfvpe/cni-route-override)\n\n仓库位置是：[redhat-nfvpe/cni-route-override: CNI plugin to override routes for a container interface (github.com)](https://github.com/redhat-nfvpe/cni-route-override)\n\n相关文档是：同一位置\n\n\n\n\n\n### [Terway - a collection of CNI Plugins based on alibaba cloud VPC/ECS network product](https://github.com/AliyunContainerService/terway)\n\n仓库位置是：[AliyunContainerService/terway: CNI plugin for Alibaba Cloud VPC/ENI (github.com)](https://github.com/AliyunContainerService/terway)\n\n相关文档是：同一位置\n\n\n\n\n\n### [Cisco ACI CNI - for on-prem and cloud container networking with consistent policy and security model.](https://github.com/noironetworks/aci-containers)\n\n仓库位置是：[noironetworks/aci-containers: Plugins for integrating ACI with container orchestration systems (github.com)](https://github.com/noironetworks/aci-containers)\n\n相关文档是：同一位置\n\n\n\n### [Kube-OVN - a CNI plugin that bases on OVN/OVS and provides advanced features like subnet, static ip, ACL, QoS, etc.](https://github.com/kubeovn/kube-ovn)\n\n仓库位置是：[kubeovn/kube-ovn: A Bridge between SDN and Cloud Native (Project under CNCF) (github.com)](https://github.com/kubeovn/kube-ovn)\n\n相关文档是：[kube-ovn/install.md at master · kubeovn/kube-ovn (github.com)](https://github.com/kubeovn/kube-ovn/blob/master/docs/install.md)\n\n\n\n### [Project Antrea - an Open vSwitch k8s CNI](https://github.com/vmware-tanzu/antrea)\n\n仓库位置是：[antrea-io/antrea: Kubernetes networking based on Open vSwitch (github.com)](https://github.com/antrea-io/antrea)\n\n相关文档是：[antrea/getting-started.md at main · antrea-io/antrea (github.com)](https://github.com/antrea-io/antrea/blob/main/docs/getting-started.md)\n\n\n\n### [OVN4NFV-K8S-Plugin - a OVN based CNI controller plugin to provide cloud native based Service function chaining (SFC), Multiple OVN overlay networking](https://github.com/opnfv/ovn4nfv-k8s-plugin)\n\n仓库位置是：[opnfv/ovn4nfv-k8s-plugin: This repository is archived. Please see https://github.com/akraino-edge-stack/icn-nodus for the latest code.](https://github.com/opnfv/ovn4nfv-k8s-plugin)\n\n相关文档是：同一位置\n\n> 已经关闭\n\n\n\n### [Azure CNI - a CNI plugin that natively extends Azure Virtual Networks to containers](https://github.com/Azure/azure-container-networking)\n\n仓库位置是：[Azure/azure-container-networking: Azure Container Networking Solutions for Linux and Windows Containers (github.com)](https://github.com/Azure/azure-container-networking)\n\n相关文档是：[azure-container-networking/docs at master · Azure/azure-container-networking (github.com)](https://github.com/Azure/azure-container-networking/tree/master/docs)\n\n\n\n### [Hybridnet - a CNI plugin designed for hybrid clouds which provides both overlay and underlay networking for containers in one or more clusters. Overlay and underlay containers can run on the same node and have cluster-wide bidirectional network connectivity.](https://github.com/alibaba/hybridnet)\n\n仓库位置是：[alibaba/hybridnet: A CNI plugin, provides networking environment where overlay and underlay containers can run on the same node and have cluster-wide bidirectional network connectivity. (github.com)](https://github.com/alibaba/hybridnet)\n\n相关文档是：[Home · alibaba/hybridnet Wiki (github.com)](https://github.com/alibaba/hybridnet/wiki)\n\n\n\n### [Spiderpool - An IP Address Management (IPAM) CNI plugin of Kubernetes for managing static ip for underlay network](https://github.com/spidernet-io/spiderpool)\n\n仓库位置是：[spidernet-io/spiderpool: spiderpool: Kubernetes IPAM for underlay network (github.com)](https://github.com/spidernet-io/spiderpool)\n\n相关文档是：[spiderpool/install.md at main · spidernet-io/spiderpool (github.com)](https://github.com/spidernet-io/spiderpool/blob/main/docs/usage/install.md)\n\n\n\n\n\n\n\n\n","slug":"EdgeMesh/2023-ospp-fighting/CNI-ReaseachofCni","published":1,"updated":"2023-05-28T09:45:54.174Z","comments":1,"photos":[],"link":"","_id":"cli796r0p000xbyjx1pjcfd6z","content":"<h1 id=\"CNI-Plugins-调研\"><a href=\"#CNI-Plugins-调研\" class=\"headerlink\" title=\"CNI Plugins 调研\"></a>CNI Plugins 调研</h1><h2 id=\"1-通用-CNI-插件\"><a href=\"#1-通用-CNI-插件\" class=\"headerlink\" title=\"1. 通用 CNI 插件\"></a>1. 通用 CNI 插件</h2><blockquote>\n<p>主要基于 <a href=\"https://github.com/containernetworking/plugins\">containernetworking/plugins: Some reference and example networking plugins, maintained by the CNI team. (github.com)</a> ，<a href=\"https://www.cni.dev/plugins/current/\">CNI</a></p>\n</blockquote>\n<p>由CNI 官方社区维护的 CNI plugins 主要分为三类：</p>\n<ul>\n<li><code>Main: interface-creating</code>: 主进程 CNI ,直接与 Linux 交流，创建接口、网络空间、对象等</li>\n<li><code>IPAM: IP address allocation</code>:  地址管理插件，主要负责 IP 地址管理和分配</li>\n<li><code>Meta: other plugins</code>: 其他的功能插件</li>\n</ul>\n<h3 id=\"Main-interface-creating-主进程-CNI\"><a href=\"#Main-interface-creating-主进程-CNI\" class=\"headerlink\" title=\"Main: interface-creating  主进程 CNI\"></a>Main: interface-creating  主进程 CNI</h3><h3 id=\"bridge\"><a href=\"#bridge\" class=\"headerlink\" title=\"bridge\"></a><a href=\"https://www.cni.dev/plugins/current/main/bridge/\"><code>bridge</code></a></h3><p>​    创建虚拟网桥，并把本机（host）和容器（更准确说是network namespace）添加到其中</p>\n<h3 id=\"macvlan\"><a href=\"#macvlan\" class=\"headerlink\" title=\"macvlan\"></a><a href=\"https://www.cni.dev/plugins/current/main/macvlan/\"><code>macvlan</code></a></h3><p>​    创建一个新的 MAC 地址，将相关容器的所有流量都转发到该地址</p>\n<h3 id=\"ipvlan\"><a href=\"#ipvlan\" class=\"headerlink\" title=\"ipvlan\"></a><a href=\"https://www.cni.dev/plugins/current/main/ipvlan/\"><code>ipvlan</code></a></h3><p>​    类似于 <code>macvlan</code>创建虚拟局域网连接，给容器增加 <a href=\"https://www.kernel.org/doc/Documentation/networking/ipvlan.txt\">ipvlan </a>接口，他主要有两种模式：</p>\n<ul>\n<li>L2 模式：  TX 流程完成在容器内的网络堆栈，之后数据包就会传输到本机队列等待发送，这个模式下容器网络可以进行RX/TX多播和广播（如本机启用的话）。</li>\n<li>L3 模式：容器网络仅能够处理 L3 网络流程，数据包先在容器内处理到 L3，然后再由主设备进行 L2 的处理和路由，再发送出去。这个模式创建的容器网络与本机共享同一个 L2 设备，所以容器网络将不会接收多播/广播流量，也无法发送多播/广播流量</li>\n</ul>\n<p>这个模式创建对象的例子</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  +=============================================================+</span><br><span class=\"line\">  |  Host: host1                                                |</span><br><span class=\"line\">  |                                                             |</span><br><span class=\"line\">  |                                                             |</span><br><span class=\"line\">  |   +----------------------+      +----------------------+    |</span><br><span class=\"line\">  |   |   NS:ns0             |      |  NS:ns1              |    |</span><br><span class=\"line\">  |   |                      |      |                      |    |</span><br><span class=\"line\">  |   |                      |      |                      |    |</span><br><span class=\"line\">  |   |        ipvl0         |      |         ipvl1        |    |</span><br><span class=\"line\">  |   +----------#-----------+      +-----------#----------+    |</span><br><span class=\"line\">  |              #                              #               |</span><br><span class=\"line\">  |              ################################               |</span><br><span class=\"line\">  |                              # eth0                         |</span><br><span class=\"line\">  +==============================#==============================+</span><br><span class=\"line\">（a） 创建两个网络命名空间 - ns0、ns1</span><br><span class=\"line\">\t\tIP 网络添加 NS0</span><br><span class=\"line\">\t\tIP 网络添加 NS1</span><br><span class=\"line\"></span><br><span class=\"line\">（b） 在 eth0（主设备）上创建两个 ipvlan 从站。</span><br><span class=\"line\">\t\tIP 链路添加链路 eth0 IPvl0 类型 IPvlan 模式 L2</span><br><span class=\"line\">\t\tIP 链路添加链路 eth0 IPvl1 类型 IPvlan 模式 L2</span><br><span class=\"line\"></span><br><span class=\"line\">（c） 将从属服务器分配到相应的网络命名空间</span><br><span class=\"line\">\t\tIP link <span class=\"built_in\">set</span> dev ipvl0 netns ns0</span><br><span class=\"line\">\t\tIP link <span class=\"built_in\">set</span> dev ipvl1 netns ns1</span><br><span class=\"line\"></span><br><span class=\"line\">（d） 现在切换到命名空间（ns0 或 ns1）以配置从属设备</span><br><span class=\"line\">\t\t- 对于 ns0</span><br><span class=\"line\">\t\t\t（<span class=\"number\">1</span>） IP netns exec ns0 bash</span><br><span class=\"line\">\t\t\t（<span class=\"number\">2</span>） IP 链路设置开发 IPvl0 向上</span><br><span class=\"line\">\t\t\t（<span class=\"number\">3</span>） IP 链路设置开发</span><br><span class=\"line\">\t\t\t（<span class=\"number\">4</span>） IP <span class=\"number\">-4</span> 地址添加 <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span> 开发 LO</span><br><span class=\"line\">\t\t\t（<span class=\"number\">5</span>） IP <span class=\"number\">-4</span> 地址添加 $IPADDR 开发 IPvl0</span><br><span class=\"line\">\t\t\t（<span class=\"number\">6</span>） IP <span class=\"number\">-4</span> 路由通过$ROUTER开发 IPvl0 添加默认值</span><br><span class=\"line\">\t\t- 对于 ns1</span><br><span class=\"line\">\t\t\t（<span class=\"number\">1</span>） IP Netns exec NS1 Bash</span><br><span class=\"line\">\t\t\t（<span class=\"number\">2</span>） IP 链路设置开发 IPvl1 向上</span><br><span class=\"line\">\t\t\t（<span class=\"number\">3</span>） IP 链路设置开发</span><br><span class=\"line\">\t\t\t（<span class=\"number\">4</span>） IP <span class=\"number\">-4</span> 地址添加 <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span> 开发 LO</span><br><span class=\"line\">\t\t\t（<span class=\"number\">5</span>） IP <span class=\"number\">-4</span> 地址添加 $IPADDR 开发 IPvl1</span><br><span class=\"line\">\t\t\t（<span class=\"number\">6</span>） IP <span class=\"number\">-4</span> 路由通过$ROUTER开发 IPvl1 添加默认值</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"ptp\"><a href=\"#ptp\" class=\"headerlink\" title=\"ptp\"></a><a href=\"https://www.cni.dev/plugins/current/main/ptp/\"><code>ptp</code></a></h3><p>​    该插件只会创建 veth 对</p>\n<h3 id=\"host-device\"><a href=\"#host-device\" class=\"headerlink\" title=\"host-device\"></a><a href=\"https://www.cni.dev/plugins/current/main/host-device/\"><code>host-device</code></a></h3><p>​    将现有的网络设备移动到容器中</p>\n<h3 id=\"vlan\"><a href=\"#vlan\" class=\"headerlink\" title=\"vlan\"></a><a href=\"https://www.cni.dev/plugins/current/main/vlan/\"><code>vlan</code></a></h3><p>​    将会创建一个独立于宿主机的 vxlan 网络接口</p>\n<h3 id=\"Windows-windows-specific\"><a href=\"#Windows-windows-specific\" class=\"headerlink\" title=\"Windows: windows specific\"></a>Windows: windows specific</h3><h4 id=\"win-bridge\"><a href=\"#win-bridge\" class=\"headerlink\" title=\"win-bridge\"></a><a href=\"https://www.cni.dev/plugins/current/main/win-bridge/\"><code>win-bridge</code></a></h4><pre><code> 创建虚拟网桥并把本机和（单个）容器连接到这个网桥上\n</code></pre>\n<h4 id=\"win-overlay\"><a href=\"#win-overlay\" class=\"headerlink\" title=\"win-overlay\"></a><a href=\"https://www.cni.dev/plugins/current/main/win-overlay/\"><code>win-overlay</code></a></h4><p>​    创建 overlay 接口给 容器</p>\n<hr>\n<h2 id=\"2-IPAM-插件\"><a href=\"#2-IPAM-插件\" class=\"headerlink\" title=\"2. IPAM 插件\"></a>2. IPAM 插件</h2><h3 id=\"dhcp\"><a href=\"#dhcp\" class=\"headerlink\" title=\"dhcp\"></a><a href=\"https://www.cni.dev/plugins/current/ipam/dhcp/\"><code>dhcp</code></a></h3><p>​    给对应容器创建守护进程，这个进程用于发送DHCP请求给网关</p>\n<h3 id=\"host-local\"><a href=\"#host-local\" class=\"headerlink\" title=\"host-local\"></a><a href=\"https://www.cni.dev/plugins/current/ipam/host-local/\"><code>host-local</code></a></h3><p>​    依据宿主机的网络信息来分配IP地址，会维护一个描述本机配置的数据文件</p>\n<h3 id=\"static\"><a href=\"#static\" class=\"headerlink\" title=\"static\"></a><a href=\"https://www.cni.dev/plugins/current/ipam/static/\"><code>static</code></a></h3><p>​    分配指定条件的IPv4 和IPv6地址给容器</p>\n<hr>\n<h2 id=\"3-Meta-多功能插件\"><a href=\"#3-Meta-多功能插件\" class=\"headerlink\" title=\"3. Meta 多功能插件\"></a>3. Meta 多功能插件</h2><h3 id=\"tuning\"><a href=\"#tuning\" class=\"headerlink\" title=\"tuning\"></a><a href=\"https://www.cni.dev/plugins/current/meta/tuning/\"><code>tuning</code></a></h3><p>​    改变现有网络接口的 <code>sysctl</code> 参数</p>\n<h3 id=\"portmap\"><a href=\"#portmap\" class=\"headerlink\" title=\"portmap\"></a><a href=\"https://www.cni.dev/plugins/current/meta/portmap/\"><code>portmap</code></a></h3><p>​    使用 iptables 的端口映射插件，建立从宿主机到容器的端口映射</p>\n<h3 id=\"bandwidth\"><a href=\"#bandwidth\" class=\"headerlink\" title=\"bandwidth\"></a><a href=\"https://www.cni.dev/plugins/current/meta/bandwidth/\"><code>bandwidth</code></a></h3><p>​    使用流量控制tbf（token-bucket filter），通过限制入口和出口流量从而控制带宽</p>\n<h3 id=\"sbr\"><a href=\"#sbr\" class=\"headerlink\" title=\"sbr\"></a><a href=\"https://www.cni.dev/plugins/current/meta/sbr/\"><code>sbr</code></a></h3><pre><code> 为网络设备提供源路由的配置功能\n</code></pre>\n<h3 id=\"firewall\"><a href=\"#firewall\" class=\"headerlink\" title=\"firewall\"></a><a href=\"https://www.cni.dev/plugins/current/meta/firewall/\"><code>firewall</code></a></h3><p>通过 <code>iptables</code> 增添路由规则来控制允许出入容器的流量</p>\n<p>以上这些基础插件的代码位置位于：<a href=\"https://github.com/containernetworking/plugins/tree/main/plugins\">plugins/plugins at main · containernetworking/plugins (github.com)</a></p>\n<h2 id=\"第三方-CNI-插件\"><a href=\"#第三方-CNI-插件\" class=\"headerlink\" title=\"第三方 CNI 插件\"></a>第三方 CNI 插件</h2><p>第三方插件的实现方式较多，尤其是在上述的这些基础 CNI 仅仅能够满足单节点容器地址管理划分创建需求的情况下，依据不同操作系统、不同需求的网络规模和网络规则创建，CNI 的功能和使用也就多种多样了。</p>\n<p>为了能够明确插件的实际功能，本文将主要依据功能的不同给 CNI 做一个标签，并整理他们使用时的规范和方法。</p>\n<h3 id=\"Project-Calico-a-layer-3-virtual-network\"><a href=\"#Project-Calico-a-layer-3-virtual-network\" class=\"headerlink\" title=\"Project Calico - a layer 3 virtual network\"></a><a href=\"https://github.com/projectcalico/calico\">Project Calico - a layer 3 virtual network</a></h3><blockquote>\n</blockquote>\n<p>仓库位置是：<a href=\"https://github.com/projectcalico/calico/tree/master/cni-plugin\">calico/cni-plugin at master · projectcalico/calico (github.com)</a></p>\n<p>相关文档是：<a href=\"https://docs.tigera.io/calico/latest/reference/configure-cni-plugins\">Configure the Calico CNI plugins | Calico Documentation (tigera.io)</a></p>\n<h3 id=\"Weave-a-multi-host-Docker-network\"><a href=\"#Weave-a-multi-host-Docker-network\" class=\"headerlink\" title=\"Weave - a multi-host Docker network\"></a><a href=\"https://github.com/weaveworks/weave\">Weave - a multi-host Docker network</a></h3><p>仓库位置是：<a href=\"https://github.com/weaveworks/weave/tree/master/plugin\">weave/plugin at master · weaveworks/weave (github.com)</a></p>\n<p>相关文档是：<a href=\"https://www.weave.works/docs/net/latest/kubernetes/\">Integrating Kubernetes and Mesos via the CNI Plugin (weave.works)</a></p>\n<h3 id=\"Cilium-BPF-amp-XDP-for-containers\"><a href=\"#Cilium-BPF-amp-XDP-for-containers\" class=\"headerlink\" title=\"Cilium - BPF &amp; XDP for containers\"></a><a href=\"https://github.com/cilium/cilium\">Cilium - BPF &amp; XDP for containers</a></h3><p>仓库位置是：<a href=\"https://github.com/cilium/cilium/tree/main/plugins/cilium-cni\">cilium/plugins/cilium-cni at main · cilium/cilium (github.com)</a></p>\n<p>相关文档是：<a href=\"https://docs.cilium.io/en/stable/installation/cni-chaining/#id1\">CNI Chaining — Cilium 1.13.2 documentation</a></p>\n<h3 id=\"Contiv-Networking-policy-networking-for-various-use-cases\"><a href=\"#Contiv-Networking-policy-networking-for-various-use-cases\" class=\"headerlink\" title=\"Contiv Networking - policy networking for various use cases\"></a><a href=\"https://github.com/contiv/netplugin\">Contiv Networking - policy networking for various use cases</a></h3><p>仓库位置是：<a href=\"https://github.com/contiv/netplugin\">contiv/netplugin: Container networking for various use cases (github.com)</a></p>\n<p>相关文档是：无</p>\n<h3 id=\"SR-IOV\"><a href=\"#SR-IOV\" class=\"headerlink\" title=\"SR-IOV\"></a><a href=\"https://github.com/hustcat/sriov-cni\">SR-IOV</a></h3><p>仓库位置是：<a href=\"https://github.com/hustcat/sriov-cni\">hustcat/sriov-cni: SR-IOV CNI plugin (github.com)</a></p>\n<p>相关文档是：<a href=\"https://blog.scottlowe.org/2009/12/02/what-is-sr-iov/\">What is SR-IOV? - Scott’s Weblog - The weblog of an IT pro focusing on cloud computing, Kubernetes, Linux, containers, and networking (scottlowe.org)</a></p>\n<h3 id=\"Infoblox-enterprise-IP-address-management-for-containers\"><a href=\"#Infoblox-enterprise-IP-address-management-for-containers\" class=\"headerlink\" title=\"Infoblox - enterprise IP address management for containers\"></a><a href=\"https://github.com/infobloxopen/cni-infoblox\">Infoblox - enterprise IP address management for containers</a></h3><p>仓库位置是：<a href=\"https://github.com/infobloxopen/cni-infoblox\">infobloxopen/cni-infoblox: CNI Infoblox Code (github.com)</a></p>\n<p>相关文档是：<a href=\"https://blogs.infoblox.com/community/cni-networking-and-ipam/\">CNI Networking and IPAM (infoblox.com)</a></p>\n<h3 id=\"Multus-a-Multi-plugin\"><a href=\"#Multus-a-Multi-plugin\" class=\"headerlink\" title=\"Multus - a Multi plugin\"></a><a href=\"https://github.com/k8snetworkplumbingwg/multus-cni\">Multus - a Multi plugin</a></h3><p>仓库位置是：<a href=\"https://github.com/k8snetworkplumbingwg/multus-cni\">k8snetworkplumbingwg/multus-cni: A CNI meta-plugin for multi-homed pods in Kubernetes (github.com)</a></p>\n<p>相关文档是：<a href=\"https://github.com/k8snetworkplumbingwg/multus-cni/blob/master/docs/how-to-use.md\">multus-cni/how-to-use.md at master · k8snetworkplumbingwg/multus-cni (github.com)</a></p>\n<h3 id=\"Romana-Layer-3-CNI-plugin-supporting-network-policy-for-Kubernetes\"><a href=\"#Romana-Layer-3-CNI-plugin-supporting-network-policy-for-Kubernetes\" class=\"headerlink\" title=\"Romana - Layer 3 CNI plugin supporting network policy for Kubernetes\"></a><a href=\"https://github.com/romana/kube\">Romana - Layer 3 CNI plugin supporting network policy for Kubernetes</a></h3><p>仓库位置是：<a href=\"https://github.com/romana/kube\">romana/kube: Kubernetes specific components for Romana (github.com)</a></p>\n<p>相关文档是：<a href=\"https://github.com/romana/romana\">romana/romana: The Romana Project - Installation scripts, documentation, issue tracker and wiki. Start here. (github.com)</a></p>\n<h3 id=\"CNI-Genie-generic-CNI-network-plugin\"><a href=\"#CNI-Genie-generic-CNI-network-plugin\" class=\"headerlink\" title=\"CNI-Genie - generic CNI network plugin\"></a><a href=\"https://github.com/Huawei-PaaS/CNI-Genie\">CNI-Genie - generic CNI network plugin</a></h3><p>仓库位置是：<a href=\"https://github.com/huawei-cloudnative/CNI-Genie\">huawei-cloudnative/CNI-Genie: CNI-Genie for choosing pod network of your choice during deployment time. Supported pod networks - Calico, Flannel, Romana, Weave (github.com)</a></p>\n<p>相关文档是：同一仓库</p>\n<h3 id=\"Nuage-CNI-Nuage-Networks-SDN-plugin-for-network-policy-kubernetes-support\"><a href=\"#Nuage-CNI-Nuage-Networks-SDN-plugin-for-network-policy-kubernetes-support\" class=\"headerlink\" title=\"Nuage CNI - Nuage Networks SDN plugin for network policy kubernetes support\"></a><a href=\"https://github.com/nuagenetworks/nuage-cni\">Nuage CNI - Nuage Networks SDN plugin for network policy kubernetes support</a></h3><p>仓库位置是：<a href=\"https://github.com/nuagenetworks/nuage-cni\">nuagenetworks/nuage-cni: Nuage VSP plugin for the CNI project (github.com)</a></p>\n<p>相关文档是：同一仓库</p>\n<h3 id=\"Silk-a-CNI-plugin-designed-for-Cloud-Foundry\"><a href=\"#Silk-a-CNI-plugin-designed-for-Cloud-Foundry\" class=\"headerlink\" title=\"Silk - a CNI plugin designed for Cloud Foundry\"></a><a href=\"https://github.com/cloudfoundry-incubator/silk\">Silk - a CNI plugin designed for Cloud Foundry</a></h3><p>仓库位置是：<a href=\"https://github.com/cloudfoundry/silk\">cloudfoundry/silk: a network fabric for containers. inspired by flannel, designed for Cloud Foundry. (github.com)</a></p>\n<p>相关文档是：同一位置</p>\n<h3 id=\"Linen-a-CNI-plugin-designed-for-overlay-networks-with-Open-vSwitch-and-fit-in-SDN-OpenFlow-network-environment\"><a href=\"#Linen-a-CNI-plugin-designed-for-overlay-networks-with-Open-vSwitch-and-fit-in-SDN-OpenFlow-network-environment\" class=\"headerlink\" title=\"Linen - a CNI plugin designed for overlay networks with Open vSwitch and fit in SDN/OpenFlow network environment\"></a><a href=\"https://github.com/John-Lin/linen-cni\">Linen - a CNI plugin designed for overlay networks with Open vSwitch and fit in SDN/OpenFlow network environment</a></h3><p>仓库位置是：<a href=\"https://github.com/John-Lin/linen-cni\">John-Lin/linen-cni: A CNI plugin designed for overlay networks with Open vSwitch (github.com)</a></p>\n<p>相关文档是：同一仓库</p>\n<h3 id=\"Vhostuser-a-Dataplane-network-plugin-Supports-OVS-DPDK-amp-VPP\"><a href=\"#Vhostuser-a-Dataplane-network-plugin-Supports-OVS-DPDK-amp-VPP\" class=\"headerlink\" title=\"Vhostuser - a Dataplane network plugin - Supports OVS-DPDK &amp; VPP\"></a><a href=\"https://github.com/intel/vhost-user-net-plugin\">Vhostuser - a Dataplane network plugin - Supports OVS-DPDK &amp; VPP</a></h3><p>仓库位置是：<a href=\"https://github.com/intel/userspace-cni-network-plugin\">intel/userspace-cni-network-plugin (github.com)</a></p>\n<p>相关文档是：<a href=\"https://docs.google.com/document/d/1jAFDNWhf6flTlPHmbWavlyLrkFJtAdQlcOnG3qhRYtU/edit#heading=h.jj69b7nmami\">Userspace CNI Design document - Google 文档</a></p>\n<h3 id=\"Amazon-ECS-CNI-Plugins-a-collection-of-CNI-Plugins-to-configure-containers-with-Amazon-EC2-elastic-network-interfaces-ENIs\"><a href=\"#Amazon-ECS-CNI-Plugins-a-collection-of-CNI-Plugins-to-configure-containers-with-Amazon-EC2-elastic-network-interfaces-ENIs\" class=\"headerlink\" title=\"Amazon ECS CNI Plugins - a collection of CNI Plugins to configure containers with Amazon EC2 elastic network interfaces (ENIs)\"></a><a href=\"https://github.com/aws/amazon-ecs-cni-plugins\">Amazon ECS CNI Plugins - a collection of CNI Plugins to configure containers with Amazon EC2 elastic network interfaces (ENIs)</a></h3><p>仓库位置是：<a href=\"https://github.com/aws/amazon-ecs-cni-plugins\">aws/amazon-ecs-cni-plugins: Networking Plugins repository for ECS Task Networking (github.com)</a></p>\n<p>相关文档是：<a href=\"https://docs.aws.amazon.com/AmazonECS/latest/developerguide/Welcome.html\">What is Amazon Elastic Container Service? - Amazon Elastic Container Service</a></p>\n<h3 id=\"Bonding-CNI-a-Link-aggregating-plugin-to-address-failover-and-high-availability-network\"><a href=\"#Bonding-CNI-a-Link-aggregating-plugin-to-address-failover-and-high-availability-network\" class=\"headerlink\" title=\"Bonding CNI - a Link aggregating plugin to address failover and high availability network\"></a><a href=\"https://github.com/Intel-Corp/bond-cni\">Bonding CNI - a Link aggregating plugin to address failover and high availability network</a></h3><p>仓库位置是：<a href=\"https://github.com/k8snetworkplumbingwg/bond-cni\">k8snetworkplumbingwg/bond-cni: Bond-cni is for fail-over and high availability of networking in cloudnative orchestration (github.com)</a></p>\n<p>相关文档是：同一位置</p>\n<h3 id=\"ovn-kubernetes-an-container-network-plugin-built-on-Open-vSwitch-OVS-and-Open-Virtual-Networking-OVN-with-support-for-both-Linux-and-Windows\"><a href=\"#ovn-kubernetes-an-container-network-plugin-built-on-Open-vSwitch-OVS-and-Open-Virtual-Networking-OVN-with-support-for-both-Linux-and-Windows\" class=\"headerlink\" title=\"ovn-kubernetes - an container network plugin built on Open vSwitch (OVS) and Open Virtual Networking (OVN) with support for both Linux and Windows\"></a><a href=\"https://github.com/openvswitch/ovn-kubernetes\">ovn-kubernetes - an container network plugin built on Open vSwitch (OVS) and Open Virtual Networking (OVN) with support for both Linux and Windows</a></h3><p>仓库位置是：<a href=\"https://github.com/ovn-org/ovn-kubernetes\">ovn-org/ovn-kubernetes: Kubernetes integration for OVN (github.com)</a></p>\n<p>相关文档是：<a href=\"https://docs.openvswitch.org/en/latest/intro/install/\">Installing Open vSwitch — Open vSwitch 3.1.90 documentation</a></p>\n<h3 id=\"Juniper-Contrail-TungstenFabric-Provides-overlay-SDN-solution-delivering-multicloud-networking-hybrid-cloud-networking-simultaneous-overlay-underlay-support-network-policy-enforcement-network-isolation-service-chaining-and-flexible-load-balancing\"><a href=\"#Juniper-Contrail-TungstenFabric-Provides-overlay-SDN-solution-delivering-multicloud-networking-hybrid-cloud-networking-simultaneous-overlay-underlay-support-network-policy-enforcement-network-isolation-service-chaining-and-flexible-load-balancing\" class=\"headerlink\" title=\"Juniper Contrail / TungstenFabric - Provides overlay SDN solution, delivering multicloud networking, hybrid cloud networking, simultaneous overlay-underlay support, network policy enforcement, network isolation, service chaining and flexible load balancing\"></a><a href=\"https://www.juniper.net/cloud\">Juniper Contrail</a> / <a href=\"https://tungstenfabric.io/\">TungstenFabric</a> - Provides overlay SDN solution, delivering multicloud networking, hybrid cloud networking, simultaneous overlay-underlay support, network policy enforcement, network isolation, service chaining and flexible load balancing</h3><p>仓库位置是：<a href=\"https://www.juniper.net/us/en/it-networking.html\">Enterprise IT Networking Products &amp; Solutions | Juniper Networks US</a></p>\n<p>相关文档是：<a href=\"https://newsroom.juniper.net/news/news-details/2023/Juniper-Networks-Brings-More-Simplicity-Scale-and-Security-to-Enterprise-Networking-with-Three-Step-Campus-Fabric-Workflow-and-New-EX-Distribution-Switch/default.aspx\">Juniper Networks Brings More Simplicity, Scale and Security to Enterprise Networking with Three-Step Campus Fabric Workflow and New EX Distribution Switch | Juniper Networks Inc.</a></p>\n<blockquote>\n<p>无法参考，为保证资料完整性留存</p>\n</blockquote>\n<h3 id=\"Knitter-a-CNI-plugin-supporting-multiple-networking-for-Kubernetes\"><a href=\"#Knitter-a-CNI-plugin-supporting-multiple-networking-for-Kubernetes\" class=\"headerlink\" title=\"Knitter - a CNI plugin supporting multiple networking for Kubernetes\"></a><a href=\"https://github.com/ZTE/Knitter\">Knitter - a CNI plugin supporting multiple networking for Kubernetes</a></h3><p>仓库位置是：<a href=\"https://github.com/ZTE/Knitter\">ZTE/Knitter: Kubernetes network solution (github.com)</a></p>\n<p>相关文档是：<a href=\"https://github.com/ZTE/Knitter/tree/master/docs\">Knitter/docs at master · ZTE/Knitter (github.com)</a></p>\n<h3 id=\"DANM-a-CNI-compliant-networking-solution-for-TelCo-workloads-running-on-Kubernetes\"><a href=\"#DANM-a-CNI-compliant-networking-solution-for-TelCo-workloads-running-on-Kubernetes\" class=\"headerlink\" title=\"DANM - a CNI-compliant networking solution for TelCo workloads running on Kubernetes\"></a><a href=\"https://github.com/nokia/danm\">DANM - a CNI-compliant networking solution for TelCo workloads running on Kubernetes</a></h3><p>仓库位置是：<a href=\"https://github.com/nokia/danm\">nokia/danm: TelCo grade network management in a Kubernetes cluster (github.com)</a></p>\n<p>相关文档是：<a href=\"https://github.com/nokia/danm/blob/master/deployment-guide.md\">danm/deployment-guide.md at master · nokia/danm (github.com)</a></p>\n<h3 id=\"VMware-NSX-–-a-CNI-plugin-that-enables-automated-NSX-L2-L3-networking-and-L4-L7-Load-Balancing-network-isolation-at-the-pod-node-and-cluster-level-and-zero-trust-security-policy-for-your-Kubernetes-cluster\"><a href=\"#VMware-NSX-–-a-CNI-plugin-that-enables-automated-NSX-L2-L3-networking-and-L4-L7-Load-Balancing-network-isolation-at-the-pod-node-and-cluster-level-and-zero-trust-security-policy-for-your-Kubernetes-cluster\" class=\"headerlink\" title=\"VMware NSX – a CNI plugin that enables automated NSX L2/L3 networking and L4/L7 Load Balancing; network isolation at the pod, node, and cluster level; and zero-trust security policy for your Kubernetes cluster.\"></a><a href=\"https://docs.vmware.com/en/VMware-NSX-T/2.2/com.vmware.nsxt.ncp_kubernetes.doc/GUID-6AFA724E-BB62-4693-B95C-321E8DDEA7E1.html\">VMware NSX – a CNI plugin that enables automated NSX L2/L3 networking and L4/L7 Load Balancing; network isolation at the pod, node, and cluster level; and zero-trust security policy for your Kubernetes cluster.</a></h3><p>仓库位置是：<a href=\"https://github.com/weaveworks/weave/tree/master/plugin\">weave/plugin at master · weaveworks/weave (github.com)</a></p>\n<p>相关文档是：[Integrating Kubernetes and Mesos via the CNI Plugin (weave.works)]</p>\n<h3 id=\"cni-route-override-a-meta-CNI-plugin-that-override-route-information\"><a href=\"#cni-route-override-a-meta-CNI-plugin-that-override-route-information\" class=\"headerlink\" title=\"cni-route-override - a meta CNI plugin that override route information\"></a><a href=\"https://github.com/redhat-nfvpe/cni-route-override\">cni-route-override - a meta CNI plugin that override route information</a></h3><p>仓库位置是：<a href=\"https://github.com/redhat-nfvpe/cni-route-override\">redhat-nfvpe/cni-route-override: CNI plugin to override routes for a container interface (github.com)</a></p>\n<p>相关文档是：同一位置</p>\n<h3 id=\"Terway-a-collection-of-CNI-Plugins-based-on-alibaba-cloud-VPC-ECS-network-product\"><a href=\"#Terway-a-collection-of-CNI-Plugins-based-on-alibaba-cloud-VPC-ECS-network-product\" class=\"headerlink\" title=\"Terway - a collection of CNI Plugins based on alibaba cloud VPC/ECS network product\"></a><a href=\"https://github.com/AliyunContainerService/terway\">Terway - a collection of CNI Plugins based on alibaba cloud VPC/ECS network product</a></h3><p>仓库位置是：<a href=\"https://github.com/AliyunContainerService/terway\">AliyunContainerService/terway: CNI plugin for Alibaba Cloud VPC/ENI (github.com)</a></p>\n<p>相关文档是：同一位置</p>\n<h3 id=\"Cisco-ACI-CNI-for-on-prem-and-cloud-container-networking-with-consistent-policy-and-security-model\"><a href=\"#Cisco-ACI-CNI-for-on-prem-and-cloud-container-networking-with-consistent-policy-and-security-model\" class=\"headerlink\" title=\"Cisco ACI CNI - for on-prem and cloud container networking with consistent policy and security model.\"></a><a href=\"https://github.com/noironetworks/aci-containers\">Cisco ACI CNI - for on-prem and cloud container networking with consistent policy and security model.</a></h3><p>仓库位置是：<a href=\"https://github.com/noironetworks/aci-containers\">noironetworks/aci-containers: Plugins for integrating ACI with container orchestration systems (github.com)</a></p>\n<p>相关文档是：同一位置</p>\n<h3 id=\"Kube-OVN-a-CNI-plugin-that-bases-on-OVN-OVS-and-provides-advanced-features-like-subnet-static-ip-ACL-QoS-etc\"><a href=\"#Kube-OVN-a-CNI-plugin-that-bases-on-OVN-OVS-and-provides-advanced-features-like-subnet-static-ip-ACL-QoS-etc\" class=\"headerlink\" title=\"Kube-OVN - a CNI plugin that bases on OVN/OVS and provides advanced features like subnet, static ip, ACL, QoS, etc.\"></a><a href=\"https://github.com/kubeovn/kube-ovn\">Kube-OVN - a CNI plugin that bases on OVN/OVS and provides advanced features like subnet, static ip, ACL, QoS, etc.</a></h3><p>仓库位置是：<a href=\"https://github.com/kubeovn/kube-ovn\">kubeovn/kube-ovn: A Bridge between SDN and Cloud Native (Project under CNCF) (github.com)</a></p>\n<p>相关文档是：<a href=\"https://github.com/kubeovn/kube-ovn/blob/master/docs/install.md\">kube-ovn/install.md at master · kubeovn/kube-ovn (github.com)</a></p>\n<h3 id=\"Project-Antrea-an-Open-vSwitch-k8s-CNI\"><a href=\"#Project-Antrea-an-Open-vSwitch-k8s-CNI\" class=\"headerlink\" title=\"Project Antrea - an Open vSwitch k8s CNI\"></a><a href=\"https://github.com/vmware-tanzu/antrea\">Project Antrea - an Open vSwitch k8s CNI</a></h3><p>仓库位置是：<a href=\"https://github.com/antrea-io/antrea\">antrea-io/antrea: Kubernetes networking based on Open vSwitch (github.com)</a></p>\n<p>相关文档是：<a href=\"https://github.com/antrea-io/antrea/blob/main/docs/getting-started.md\">antrea/getting-started.md at main · antrea-io/antrea (github.com)</a></p>\n<h3 id=\"OVN4NFV-K8S-Plugin-a-OVN-based-CNI-controller-plugin-to-provide-cloud-native-based-Service-function-chaining-SFC-Multiple-OVN-overlay-networking\"><a href=\"#OVN4NFV-K8S-Plugin-a-OVN-based-CNI-controller-plugin-to-provide-cloud-native-based-Service-function-chaining-SFC-Multiple-OVN-overlay-networking\" class=\"headerlink\" title=\"OVN4NFV-K8S-Plugin - a OVN based CNI controller plugin to provide cloud native based Service function chaining (SFC), Multiple OVN overlay networking\"></a><a href=\"https://github.com/opnfv/ovn4nfv-k8s-plugin\">OVN4NFV-K8S-Plugin - a OVN based CNI controller plugin to provide cloud native based Service function chaining (SFC), Multiple OVN overlay networking</a></h3><p>仓库位置是：<a href=\"https://github.com/opnfv/ovn4nfv-k8s-plugin\">opnfv/ovn4nfv-k8s-plugin: This repository is archived. Please see https://github.com/akraino-edge-stack/icn-nodus for the latest code.</a></p>\n<p>相关文档是：同一位置</p>\n<blockquote>\n<p>已经关闭</p>\n</blockquote>\n<h3 id=\"Azure-CNI-a-CNI-plugin-that-natively-extends-Azure-Virtual-Networks-to-containers\"><a href=\"#Azure-CNI-a-CNI-plugin-that-natively-extends-Azure-Virtual-Networks-to-containers\" class=\"headerlink\" title=\"Azure CNI - a CNI plugin that natively extends Azure Virtual Networks to containers\"></a><a href=\"https://github.com/Azure/azure-container-networking\">Azure CNI - a CNI plugin that natively extends Azure Virtual Networks to containers</a></h3><p>仓库位置是：<a href=\"https://github.com/Azure/azure-container-networking\">Azure/azure-container-networking: Azure Container Networking Solutions for Linux and Windows Containers (github.com)</a></p>\n<p>相关文档是：<a href=\"https://github.com/Azure/azure-container-networking/tree/master/docs\">azure-container-networking/docs at master · Azure/azure-container-networking (github.com)</a></p>\n<h3 id=\"Hybridnet-a-CNI-plugin-designed-for-hybrid-clouds-which-provides-both-overlay-and-underlay-networking-for-containers-in-one-or-more-clusters-Overlay-and-underlay-containers-can-run-on-the-same-node-and-have-cluster-wide-bidirectional-network-connectivity\"><a href=\"#Hybridnet-a-CNI-plugin-designed-for-hybrid-clouds-which-provides-both-overlay-and-underlay-networking-for-containers-in-one-or-more-clusters-Overlay-and-underlay-containers-can-run-on-the-same-node-and-have-cluster-wide-bidirectional-network-connectivity\" class=\"headerlink\" title=\"Hybridnet - a CNI plugin designed for hybrid clouds which provides both overlay and underlay networking for containers in one or more clusters. Overlay and underlay containers can run on the same node and have cluster-wide bidirectional network connectivity.\"></a><a href=\"https://github.com/alibaba/hybridnet\">Hybridnet - a CNI plugin designed for hybrid clouds which provides both overlay and underlay networking for containers in one or more clusters. Overlay and underlay containers can run on the same node and have cluster-wide bidirectional network connectivity.</a></h3><p>仓库位置是：<a href=\"https://github.com/alibaba/hybridnet\">alibaba/hybridnet: A CNI plugin, provides networking environment where overlay and underlay containers can run on the same node and have cluster-wide bidirectional network connectivity. (github.com)</a></p>\n<p>相关文档是：<a href=\"https://github.com/alibaba/hybridnet/wiki\">Home · alibaba/hybridnet Wiki (github.com)</a></p>\n<h3 id=\"Spiderpool-An-IP-Address-Management-IPAM-CNI-plugin-of-Kubernetes-for-managing-static-ip-for-underlay-network\"><a href=\"#Spiderpool-An-IP-Address-Management-IPAM-CNI-plugin-of-Kubernetes-for-managing-static-ip-for-underlay-network\" class=\"headerlink\" title=\"Spiderpool - An IP Address Management (IPAM) CNI plugin of Kubernetes for managing static ip for underlay network\"></a><a href=\"https://github.com/spidernet-io/spiderpool\">Spiderpool - An IP Address Management (IPAM) CNI plugin of Kubernetes for managing static ip for underlay network</a></h3><p>仓库位置是：<a href=\"https://github.com/spidernet-io/spiderpool\">spidernet-io/spiderpool: spiderpool: Kubernetes IPAM for underlay network (github.com)</a></p>\n<p>相关文档是：<a href=\"https://github.com/spidernet-io/spiderpool/blob/main/docs/usage/install.md\">spiderpool/install.md at main · spidernet-io/spiderpool (github.com)</a></p>\n","site":{"data":{}},"cover":"/img/cover/2077_city.png","cover_type":"img","excerpt":"","more":"<h1 id=\"CNI-Plugins-调研\"><a href=\"#CNI-Plugins-调研\" class=\"headerlink\" title=\"CNI Plugins 调研\"></a>CNI Plugins 调研</h1><h2 id=\"1-通用-CNI-插件\"><a href=\"#1-通用-CNI-插件\" class=\"headerlink\" title=\"1. 通用 CNI 插件\"></a>1. 通用 CNI 插件</h2><blockquote>\n<p>主要基于 <a href=\"https://github.com/containernetworking/plugins\">containernetworking/plugins: Some reference and example networking plugins, maintained by the CNI team. (github.com)</a> ，<a href=\"https://www.cni.dev/plugins/current/\">CNI</a></p>\n</blockquote>\n<p>由CNI 官方社区维护的 CNI plugins 主要分为三类：</p>\n<ul>\n<li><code>Main: interface-creating</code>: 主进程 CNI ,直接与 Linux 交流，创建接口、网络空间、对象等</li>\n<li><code>IPAM: IP address allocation</code>:  地址管理插件，主要负责 IP 地址管理和分配</li>\n<li><code>Meta: other plugins</code>: 其他的功能插件</li>\n</ul>\n<h3 id=\"Main-interface-creating-主进程-CNI\"><a href=\"#Main-interface-creating-主进程-CNI\" class=\"headerlink\" title=\"Main: interface-creating  主进程 CNI\"></a>Main: interface-creating  主进程 CNI</h3><h3 id=\"bridge\"><a href=\"#bridge\" class=\"headerlink\" title=\"bridge\"></a><a href=\"https://www.cni.dev/plugins/current/main/bridge/\"><code>bridge</code></a></h3><p>​    创建虚拟网桥，并把本机（host）和容器（更准确说是network namespace）添加到其中</p>\n<h3 id=\"macvlan\"><a href=\"#macvlan\" class=\"headerlink\" title=\"macvlan\"></a><a href=\"https://www.cni.dev/plugins/current/main/macvlan/\"><code>macvlan</code></a></h3><p>​    创建一个新的 MAC 地址，将相关容器的所有流量都转发到该地址</p>\n<h3 id=\"ipvlan\"><a href=\"#ipvlan\" class=\"headerlink\" title=\"ipvlan\"></a><a href=\"https://www.cni.dev/plugins/current/main/ipvlan/\"><code>ipvlan</code></a></h3><p>​    类似于 <code>macvlan</code>创建虚拟局域网连接，给容器增加 <a href=\"https://www.kernel.org/doc/Documentation/networking/ipvlan.txt\">ipvlan </a>接口，他主要有两种模式：</p>\n<ul>\n<li>L2 模式：  TX 流程完成在容器内的网络堆栈，之后数据包就会传输到本机队列等待发送，这个模式下容器网络可以进行RX/TX多播和广播（如本机启用的话）。</li>\n<li>L3 模式：容器网络仅能够处理 L3 网络流程，数据包先在容器内处理到 L3，然后再由主设备进行 L2 的处理和路由，再发送出去。这个模式创建的容器网络与本机共享同一个 L2 设备，所以容器网络将不会接收多播/广播流量，也无法发送多播/广播流量</li>\n</ul>\n<p>这个模式创建对象的例子</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  +=============================================================+</span><br><span class=\"line\">  |  Host: host1                                                |</span><br><span class=\"line\">  |                                                             |</span><br><span class=\"line\">  |                                                             |</span><br><span class=\"line\">  |   +----------------------+      +----------------------+    |</span><br><span class=\"line\">  |   |   NS:ns0             |      |  NS:ns1              |    |</span><br><span class=\"line\">  |   |                      |      |                      |    |</span><br><span class=\"line\">  |   |                      |      |                      |    |</span><br><span class=\"line\">  |   |        ipvl0         |      |         ipvl1        |    |</span><br><span class=\"line\">  |   +----------#-----------+      +-----------#----------+    |</span><br><span class=\"line\">  |              #                              #               |</span><br><span class=\"line\">  |              ################################               |</span><br><span class=\"line\">  |                              # eth0                         |</span><br><span class=\"line\">  +==============================#==============================+</span><br><span class=\"line\">（a） 创建两个网络命名空间 - ns0、ns1</span><br><span class=\"line\">\t\tIP 网络添加 NS0</span><br><span class=\"line\">\t\tIP 网络添加 NS1</span><br><span class=\"line\"></span><br><span class=\"line\">（b） 在 eth0（主设备）上创建两个 ipvlan 从站。</span><br><span class=\"line\">\t\tIP 链路添加链路 eth0 IPvl0 类型 IPvlan 模式 L2</span><br><span class=\"line\">\t\tIP 链路添加链路 eth0 IPvl1 类型 IPvlan 模式 L2</span><br><span class=\"line\"></span><br><span class=\"line\">（c） 将从属服务器分配到相应的网络命名空间</span><br><span class=\"line\">\t\tIP link <span class=\"built_in\">set</span> dev ipvl0 netns ns0</span><br><span class=\"line\">\t\tIP link <span class=\"built_in\">set</span> dev ipvl1 netns ns1</span><br><span class=\"line\"></span><br><span class=\"line\">（d） 现在切换到命名空间（ns0 或 ns1）以配置从属设备</span><br><span class=\"line\">\t\t- 对于 ns0</span><br><span class=\"line\">\t\t\t（<span class=\"number\">1</span>） IP netns exec ns0 bash</span><br><span class=\"line\">\t\t\t（<span class=\"number\">2</span>） IP 链路设置开发 IPvl0 向上</span><br><span class=\"line\">\t\t\t（<span class=\"number\">3</span>） IP 链路设置开发</span><br><span class=\"line\">\t\t\t（<span class=\"number\">4</span>） IP <span class=\"number\">-4</span> 地址添加 <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span> 开发 LO</span><br><span class=\"line\">\t\t\t（<span class=\"number\">5</span>） IP <span class=\"number\">-4</span> 地址添加 $IPADDR 开发 IPvl0</span><br><span class=\"line\">\t\t\t（<span class=\"number\">6</span>） IP <span class=\"number\">-4</span> 路由通过$ROUTER开发 IPvl0 添加默认值</span><br><span class=\"line\">\t\t- 对于 ns1</span><br><span class=\"line\">\t\t\t（<span class=\"number\">1</span>） IP Netns exec NS1 Bash</span><br><span class=\"line\">\t\t\t（<span class=\"number\">2</span>） IP 链路设置开发 IPvl1 向上</span><br><span class=\"line\">\t\t\t（<span class=\"number\">3</span>） IP 链路设置开发</span><br><span class=\"line\">\t\t\t（<span class=\"number\">4</span>） IP <span class=\"number\">-4</span> 地址添加 <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span> 开发 LO</span><br><span class=\"line\">\t\t\t（<span class=\"number\">5</span>） IP <span class=\"number\">-4</span> 地址添加 $IPADDR 开发 IPvl1</span><br><span class=\"line\">\t\t\t（<span class=\"number\">6</span>） IP <span class=\"number\">-4</span> 路由通过$ROUTER开发 IPvl1 添加默认值</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"ptp\"><a href=\"#ptp\" class=\"headerlink\" title=\"ptp\"></a><a href=\"https://www.cni.dev/plugins/current/main/ptp/\"><code>ptp</code></a></h3><p>​    该插件只会创建 veth 对</p>\n<h3 id=\"host-device\"><a href=\"#host-device\" class=\"headerlink\" title=\"host-device\"></a><a href=\"https://www.cni.dev/plugins/current/main/host-device/\"><code>host-device</code></a></h3><p>​    将现有的网络设备移动到容器中</p>\n<h3 id=\"vlan\"><a href=\"#vlan\" class=\"headerlink\" title=\"vlan\"></a><a href=\"https://www.cni.dev/plugins/current/main/vlan/\"><code>vlan</code></a></h3><p>​    将会创建一个独立于宿主机的 vxlan 网络接口</p>\n<h3 id=\"Windows-windows-specific\"><a href=\"#Windows-windows-specific\" class=\"headerlink\" title=\"Windows: windows specific\"></a>Windows: windows specific</h3><h4 id=\"win-bridge\"><a href=\"#win-bridge\" class=\"headerlink\" title=\"win-bridge\"></a><a href=\"https://www.cni.dev/plugins/current/main/win-bridge/\"><code>win-bridge</code></a></h4><pre><code> 创建虚拟网桥并把本机和（单个）容器连接到这个网桥上\n</code></pre>\n<h4 id=\"win-overlay\"><a href=\"#win-overlay\" class=\"headerlink\" title=\"win-overlay\"></a><a href=\"https://www.cni.dev/plugins/current/main/win-overlay/\"><code>win-overlay</code></a></h4><p>​    创建 overlay 接口给 容器</p>\n<hr>\n<h2 id=\"2-IPAM-插件\"><a href=\"#2-IPAM-插件\" class=\"headerlink\" title=\"2. IPAM 插件\"></a>2. IPAM 插件</h2><h3 id=\"dhcp\"><a href=\"#dhcp\" class=\"headerlink\" title=\"dhcp\"></a><a href=\"https://www.cni.dev/plugins/current/ipam/dhcp/\"><code>dhcp</code></a></h3><p>​    给对应容器创建守护进程，这个进程用于发送DHCP请求给网关</p>\n<h3 id=\"host-local\"><a href=\"#host-local\" class=\"headerlink\" title=\"host-local\"></a><a href=\"https://www.cni.dev/plugins/current/ipam/host-local/\"><code>host-local</code></a></h3><p>​    依据宿主机的网络信息来分配IP地址，会维护一个描述本机配置的数据文件</p>\n<h3 id=\"static\"><a href=\"#static\" class=\"headerlink\" title=\"static\"></a><a href=\"https://www.cni.dev/plugins/current/ipam/static/\"><code>static</code></a></h3><p>​    分配指定条件的IPv4 和IPv6地址给容器</p>\n<hr>\n<h2 id=\"3-Meta-多功能插件\"><a href=\"#3-Meta-多功能插件\" class=\"headerlink\" title=\"3. Meta 多功能插件\"></a>3. Meta 多功能插件</h2><h3 id=\"tuning\"><a href=\"#tuning\" class=\"headerlink\" title=\"tuning\"></a><a href=\"https://www.cni.dev/plugins/current/meta/tuning/\"><code>tuning</code></a></h3><p>​    改变现有网络接口的 <code>sysctl</code> 参数</p>\n<h3 id=\"portmap\"><a href=\"#portmap\" class=\"headerlink\" title=\"portmap\"></a><a href=\"https://www.cni.dev/plugins/current/meta/portmap/\"><code>portmap</code></a></h3><p>​    使用 iptables 的端口映射插件，建立从宿主机到容器的端口映射</p>\n<h3 id=\"bandwidth\"><a href=\"#bandwidth\" class=\"headerlink\" title=\"bandwidth\"></a><a href=\"https://www.cni.dev/plugins/current/meta/bandwidth/\"><code>bandwidth</code></a></h3><p>​    使用流量控制tbf（token-bucket filter），通过限制入口和出口流量从而控制带宽</p>\n<h3 id=\"sbr\"><a href=\"#sbr\" class=\"headerlink\" title=\"sbr\"></a><a href=\"https://www.cni.dev/plugins/current/meta/sbr/\"><code>sbr</code></a></h3><pre><code> 为网络设备提供源路由的配置功能\n</code></pre>\n<h3 id=\"firewall\"><a href=\"#firewall\" class=\"headerlink\" title=\"firewall\"></a><a href=\"https://www.cni.dev/plugins/current/meta/firewall/\"><code>firewall</code></a></h3><p>通过 <code>iptables</code> 增添路由规则来控制允许出入容器的流量</p>\n<p>以上这些基础插件的代码位置位于：<a href=\"https://github.com/containernetworking/plugins/tree/main/plugins\">plugins/plugins at main · containernetworking/plugins (github.com)</a></p>\n<h2 id=\"第三方-CNI-插件\"><a href=\"#第三方-CNI-插件\" class=\"headerlink\" title=\"第三方 CNI 插件\"></a>第三方 CNI 插件</h2><p>第三方插件的实现方式较多，尤其是在上述的这些基础 CNI 仅仅能够满足单节点容器地址管理划分创建需求的情况下，依据不同操作系统、不同需求的网络规模和网络规则创建，CNI 的功能和使用也就多种多样了。</p>\n<p>为了能够明确插件的实际功能，本文将主要依据功能的不同给 CNI 做一个标签，并整理他们使用时的规范和方法。</p>\n<h3 id=\"Project-Calico-a-layer-3-virtual-network\"><a href=\"#Project-Calico-a-layer-3-virtual-network\" class=\"headerlink\" title=\"Project Calico - a layer 3 virtual network\"></a><a href=\"https://github.com/projectcalico/calico\">Project Calico - a layer 3 virtual network</a></h3><blockquote>\n</blockquote>\n<p>仓库位置是：<a href=\"https://github.com/projectcalico/calico/tree/master/cni-plugin\">calico/cni-plugin at master · projectcalico/calico (github.com)</a></p>\n<p>相关文档是：<a href=\"https://docs.tigera.io/calico/latest/reference/configure-cni-plugins\">Configure the Calico CNI plugins | Calico Documentation (tigera.io)</a></p>\n<h3 id=\"Weave-a-multi-host-Docker-network\"><a href=\"#Weave-a-multi-host-Docker-network\" class=\"headerlink\" title=\"Weave - a multi-host Docker network\"></a><a href=\"https://github.com/weaveworks/weave\">Weave - a multi-host Docker network</a></h3><p>仓库位置是：<a href=\"https://github.com/weaveworks/weave/tree/master/plugin\">weave/plugin at master · weaveworks/weave (github.com)</a></p>\n<p>相关文档是：<a href=\"https://www.weave.works/docs/net/latest/kubernetes/\">Integrating Kubernetes and Mesos via the CNI Plugin (weave.works)</a></p>\n<h3 id=\"Cilium-BPF-amp-XDP-for-containers\"><a href=\"#Cilium-BPF-amp-XDP-for-containers\" class=\"headerlink\" title=\"Cilium - BPF &amp; XDP for containers\"></a><a href=\"https://github.com/cilium/cilium\">Cilium - BPF &amp; XDP for containers</a></h3><p>仓库位置是：<a href=\"https://github.com/cilium/cilium/tree/main/plugins/cilium-cni\">cilium/plugins/cilium-cni at main · cilium/cilium (github.com)</a></p>\n<p>相关文档是：<a href=\"https://docs.cilium.io/en/stable/installation/cni-chaining/#id1\">CNI Chaining — Cilium 1.13.2 documentation</a></p>\n<h3 id=\"Contiv-Networking-policy-networking-for-various-use-cases\"><a href=\"#Contiv-Networking-policy-networking-for-various-use-cases\" class=\"headerlink\" title=\"Contiv Networking - policy networking for various use cases\"></a><a href=\"https://github.com/contiv/netplugin\">Contiv Networking - policy networking for various use cases</a></h3><p>仓库位置是：<a href=\"https://github.com/contiv/netplugin\">contiv/netplugin: Container networking for various use cases (github.com)</a></p>\n<p>相关文档是：无</p>\n<h3 id=\"SR-IOV\"><a href=\"#SR-IOV\" class=\"headerlink\" title=\"SR-IOV\"></a><a href=\"https://github.com/hustcat/sriov-cni\">SR-IOV</a></h3><p>仓库位置是：<a href=\"https://github.com/hustcat/sriov-cni\">hustcat/sriov-cni: SR-IOV CNI plugin (github.com)</a></p>\n<p>相关文档是：<a href=\"https://blog.scottlowe.org/2009/12/02/what-is-sr-iov/\">What is SR-IOV? - Scott’s Weblog - The weblog of an IT pro focusing on cloud computing, Kubernetes, Linux, containers, and networking (scottlowe.org)</a></p>\n<h3 id=\"Infoblox-enterprise-IP-address-management-for-containers\"><a href=\"#Infoblox-enterprise-IP-address-management-for-containers\" class=\"headerlink\" title=\"Infoblox - enterprise IP address management for containers\"></a><a href=\"https://github.com/infobloxopen/cni-infoblox\">Infoblox - enterprise IP address management for containers</a></h3><p>仓库位置是：<a href=\"https://github.com/infobloxopen/cni-infoblox\">infobloxopen/cni-infoblox: CNI Infoblox Code (github.com)</a></p>\n<p>相关文档是：<a href=\"https://blogs.infoblox.com/community/cni-networking-and-ipam/\">CNI Networking and IPAM (infoblox.com)</a></p>\n<h3 id=\"Multus-a-Multi-plugin\"><a href=\"#Multus-a-Multi-plugin\" class=\"headerlink\" title=\"Multus - a Multi plugin\"></a><a href=\"https://github.com/k8snetworkplumbingwg/multus-cni\">Multus - a Multi plugin</a></h3><p>仓库位置是：<a href=\"https://github.com/k8snetworkplumbingwg/multus-cni\">k8snetworkplumbingwg/multus-cni: A CNI meta-plugin for multi-homed pods in Kubernetes (github.com)</a></p>\n<p>相关文档是：<a href=\"https://github.com/k8snetworkplumbingwg/multus-cni/blob/master/docs/how-to-use.md\">multus-cni/how-to-use.md at master · k8snetworkplumbingwg/multus-cni (github.com)</a></p>\n<h3 id=\"Romana-Layer-3-CNI-plugin-supporting-network-policy-for-Kubernetes\"><a href=\"#Romana-Layer-3-CNI-plugin-supporting-network-policy-for-Kubernetes\" class=\"headerlink\" title=\"Romana - Layer 3 CNI plugin supporting network policy for Kubernetes\"></a><a href=\"https://github.com/romana/kube\">Romana - Layer 3 CNI plugin supporting network policy for Kubernetes</a></h3><p>仓库位置是：<a href=\"https://github.com/romana/kube\">romana/kube: Kubernetes specific components for Romana (github.com)</a></p>\n<p>相关文档是：<a href=\"https://github.com/romana/romana\">romana/romana: The Romana Project - Installation scripts, documentation, issue tracker and wiki. Start here. (github.com)</a></p>\n<h3 id=\"CNI-Genie-generic-CNI-network-plugin\"><a href=\"#CNI-Genie-generic-CNI-network-plugin\" class=\"headerlink\" title=\"CNI-Genie - generic CNI network plugin\"></a><a href=\"https://github.com/Huawei-PaaS/CNI-Genie\">CNI-Genie - generic CNI network plugin</a></h3><p>仓库位置是：<a href=\"https://github.com/huawei-cloudnative/CNI-Genie\">huawei-cloudnative/CNI-Genie: CNI-Genie for choosing pod network of your choice during deployment time. Supported pod networks - Calico, Flannel, Romana, Weave (github.com)</a></p>\n<p>相关文档是：同一仓库</p>\n<h3 id=\"Nuage-CNI-Nuage-Networks-SDN-plugin-for-network-policy-kubernetes-support\"><a href=\"#Nuage-CNI-Nuage-Networks-SDN-plugin-for-network-policy-kubernetes-support\" class=\"headerlink\" title=\"Nuage CNI - Nuage Networks SDN plugin for network policy kubernetes support\"></a><a href=\"https://github.com/nuagenetworks/nuage-cni\">Nuage CNI - Nuage Networks SDN plugin for network policy kubernetes support</a></h3><p>仓库位置是：<a href=\"https://github.com/nuagenetworks/nuage-cni\">nuagenetworks/nuage-cni: Nuage VSP plugin for the CNI project (github.com)</a></p>\n<p>相关文档是：同一仓库</p>\n<h3 id=\"Silk-a-CNI-plugin-designed-for-Cloud-Foundry\"><a href=\"#Silk-a-CNI-plugin-designed-for-Cloud-Foundry\" class=\"headerlink\" title=\"Silk - a CNI plugin designed for Cloud Foundry\"></a><a href=\"https://github.com/cloudfoundry-incubator/silk\">Silk - a CNI plugin designed for Cloud Foundry</a></h3><p>仓库位置是：<a href=\"https://github.com/cloudfoundry/silk\">cloudfoundry/silk: a network fabric for containers. inspired by flannel, designed for Cloud Foundry. (github.com)</a></p>\n<p>相关文档是：同一位置</p>\n<h3 id=\"Linen-a-CNI-plugin-designed-for-overlay-networks-with-Open-vSwitch-and-fit-in-SDN-OpenFlow-network-environment\"><a href=\"#Linen-a-CNI-plugin-designed-for-overlay-networks-with-Open-vSwitch-and-fit-in-SDN-OpenFlow-network-environment\" class=\"headerlink\" title=\"Linen - a CNI plugin designed for overlay networks with Open vSwitch and fit in SDN/OpenFlow network environment\"></a><a href=\"https://github.com/John-Lin/linen-cni\">Linen - a CNI plugin designed for overlay networks with Open vSwitch and fit in SDN/OpenFlow network environment</a></h3><p>仓库位置是：<a href=\"https://github.com/John-Lin/linen-cni\">John-Lin/linen-cni: A CNI plugin designed for overlay networks with Open vSwitch (github.com)</a></p>\n<p>相关文档是：同一仓库</p>\n<h3 id=\"Vhostuser-a-Dataplane-network-plugin-Supports-OVS-DPDK-amp-VPP\"><a href=\"#Vhostuser-a-Dataplane-network-plugin-Supports-OVS-DPDK-amp-VPP\" class=\"headerlink\" title=\"Vhostuser - a Dataplane network plugin - Supports OVS-DPDK &amp; VPP\"></a><a href=\"https://github.com/intel/vhost-user-net-plugin\">Vhostuser - a Dataplane network plugin - Supports OVS-DPDK &amp; VPP</a></h3><p>仓库位置是：<a href=\"https://github.com/intel/userspace-cni-network-plugin\">intel/userspace-cni-network-plugin (github.com)</a></p>\n<p>相关文档是：<a href=\"https://docs.google.com/document/d/1jAFDNWhf6flTlPHmbWavlyLrkFJtAdQlcOnG3qhRYtU/edit#heading=h.jj69b7nmami\">Userspace CNI Design document - Google 文档</a></p>\n<h3 id=\"Amazon-ECS-CNI-Plugins-a-collection-of-CNI-Plugins-to-configure-containers-with-Amazon-EC2-elastic-network-interfaces-ENIs\"><a href=\"#Amazon-ECS-CNI-Plugins-a-collection-of-CNI-Plugins-to-configure-containers-with-Amazon-EC2-elastic-network-interfaces-ENIs\" class=\"headerlink\" title=\"Amazon ECS CNI Plugins - a collection of CNI Plugins to configure containers with Amazon EC2 elastic network interfaces (ENIs)\"></a><a href=\"https://github.com/aws/amazon-ecs-cni-plugins\">Amazon ECS CNI Plugins - a collection of CNI Plugins to configure containers with Amazon EC2 elastic network interfaces (ENIs)</a></h3><p>仓库位置是：<a href=\"https://github.com/aws/amazon-ecs-cni-plugins\">aws/amazon-ecs-cni-plugins: Networking Plugins repository for ECS Task Networking (github.com)</a></p>\n<p>相关文档是：<a href=\"https://docs.aws.amazon.com/AmazonECS/latest/developerguide/Welcome.html\">What is Amazon Elastic Container Service? - Amazon Elastic Container Service</a></p>\n<h3 id=\"Bonding-CNI-a-Link-aggregating-plugin-to-address-failover-and-high-availability-network\"><a href=\"#Bonding-CNI-a-Link-aggregating-plugin-to-address-failover-and-high-availability-network\" class=\"headerlink\" title=\"Bonding CNI - a Link aggregating plugin to address failover and high availability network\"></a><a href=\"https://github.com/Intel-Corp/bond-cni\">Bonding CNI - a Link aggregating plugin to address failover and high availability network</a></h3><p>仓库位置是：<a href=\"https://github.com/k8snetworkplumbingwg/bond-cni\">k8snetworkplumbingwg/bond-cni: Bond-cni is for fail-over and high availability of networking in cloudnative orchestration (github.com)</a></p>\n<p>相关文档是：同一位置</p>\n<h3 id=\"ovn-kubernetes-an-container-network-plugin-built-on-Open-vSwitch-OVS-and-Open-Virtual-Networking-OVN-with-support-for-both-Linux-and-Windows\"><a href=\"#ovn-kubernetes-an-container-network-plugin-built-on-Open-vSwitch-OVS-and-Open-Virtual-Networking-OVN-with-support-for-both-Linux-and-Windows\" class=\"headerlink\" title=\"ovn-kubernetes - an container network plugin built on Open vSwitch (OVS) and Open Virtual Networking (OVN) with support for both Linux and Windows\"></a><a href=\"https://github.com/openvswitch/ovn-kubernetes\">ovn-kubernetes - an container network plugin built on Open vSwitch (OVS) and Open Virtual Networking (OVN) with support for both Linux and Windows</a></h3><p>仓库位置是：<a href=\"https://github.com/ovn-org/ovn-kubernetes\">ovn-org/ovn-kubernetes: Kubernetes integration for OVN (github.com)</a></p>\n<p>相关文档是：<a href=\"https://docs.openvswitch.org/en/latest/intro/install/\">Installing Open vSwitch — Open vSwitch 3.1.90 documentation</a></p>\n<h3 id=\"Juniper-Contrail-TungstenFabric-Provides-overlay-SDN-solution-delivering-multicloud-networking-hybrid-cloud-networking-simultaneous-overlay-underlay-support-network-policy-enforcement-network-isolation-service-chaining-and-flexible-load-balancing\"><a href=\"#Juniper-Contrail-TungstenFabric-Provides-overlay-SDN-solution-delivering-multicloud-networking-hybrid-cloud-networking-simultaneous-overlay-underlay-support-network-policy-enforcement-network-isolation-service-chaining-and-flexible-load-balancing\" class=\"headerlink\" title=\"Juniper Contrail / TungstenFabric - Provides overlay SDN solution, delivering multicloud networking, hybrid cloud networking, simultaneous overlay-underlay support, network policy enforcement, network isolation, service chaining and flexible load balancing\"></a><a href=\"https://www.juniper.net/cloud\">Juniper Contrail</a> / <a href=\"https://tungstenfabric.io/\">TungstenFabric</a> - Provides overlay SDN solution, delivering multicloud networking, hybrid cloud networking, simultaneous overlay-underlay support, network policy enforcement, network isolation, service chaining and flexible load balancing</h3><p>仓库位置是：<a href=\"https://www.juniper.net/us/en/it-networking.html\">Enterprise IT Networking Products &amp; Solutions | Juniper Networks US</a></p>\n<p>相关文档是：<a href=\"https://newsroom.juniper.net/news/news-details/2023/Juniper-Networks-Brings-More-Simplicity-Scale-and-Security-to-Enterprise-Networking-with-Three-Step-Campus-Fabric-Workflow-and-New-EX-Distribution-Switch/default.aspx\">Juniper Networks Brings More Simplicity, Scale and Security to Enterprise Networking with Three-Step Campus Fabric Workflow and New EX Distribution Switch | Juniper Networks Inc.</a></p>\n<blockquote>\n<p>无法参考，为保证资料完整性留存</p>\n</blockquote>\n<h3 id=\"Knitter-a-CNI-plugin-supporting-multiple-networking-for-Kubernetes\"><a href=\"#Knitter-a-CNI-plugin-supporting-multiple-networking-for-Kubernetes\" class=\"headerlink\" title=\"Knitter - a CNI plugin supporting multiple networking for Kubernetes\"></a><a href=\"https://github.com/ZTE/Knitter\">Knitter - a CNI plugin supporting multiple networking for Kubernetes</a></h3><p>仓库位置是：<a href=\"https://github.com/ZTE/Knitter\">ZTE/Knitter: Kubernetes network solution (github.com)</a></p>\n<p>相关文档是：<a href=\"https://github.com/ZTE/Knitter/tree/master/docs\">Knitter/docs at master · ZTE/Knitter (github.com)</a></p>\n<h3 id=\"DANM-a-CNI-compliant-networking-solution-for-TelCo-workloads-running-on-Kubernetes\"><a href=\"#DANM-a-CNI-compliant-networking-solution-for-TelCo-workloads-running-on-Kubernetes\" class=\"headerlink\" title=\"DANM - a CNI-compliant networking solution for TelCo workloads running on Kubernetes\"></a><a href=\"https://github.com/nokia/danm\">DANM - a CNI-compliant networking solution for TelCo workloads running on Kubernetes</a></h3><p>仓库位置是：<a href=\"https://github.com/nokia/danm\">nokia/danm: TelCo grade network management in a Kubernetes cluster (github.com)</a></p>\n<p>相关文档是：<a href=\"https://github.com/nokia/danm/blob/master/deployment-guide.md\">danm/deployment-guide.md at master · nokia/danm (github.com)</a></p>\n<h3 id=\"VMware-NSX-–-a-CNI-plugin-that-enables-automated-NSX-L2-L3-networking-and-L4-L7-Load-Balancing-network-isolation-at-the-pod-node-and-cluster-level-and-zero-trust-security-policy-for-your-Kubernetes-cluster\"><a href=\"#VMware-NSX-–-a-CNI-plugin-that-enables-automated-NSX-L2-L3-networking-and-L4-L7-Load-Balancing-network-isolation-at-the-pod-node-and-cluster-level-and-zero-trust-security-policy-for-your-Kubernetes-cluster\" class=\"headerlink\" title=\"VMware NSX – a CNI plugin that enables automated NSX L2/L3 networking and L4/L7 Load Balancing; network isolation at the pod, node, and cluster level; and zero-trust security policy for your Kubernetes cluster.\"></a><a href=\"https://docs.vmware.com/en/VMware-NSX-T/2.2/com.vmware.nsxt.ncp_kubernetes.doc/GUID-6AFA724E-BB62-4693-B95C-321E8DDEA7E1.html\">VMware NSX – a CNI plugin that enables automated NSX L2/L3 networking and L4/L7 Load Balancing; network isolation at the pod, node, and cluster level; and zero-trust security policy for your Kubernetes cluster.</a></h3><p>仓库位置是：<a href=\"https://github.com/weaveworks/weave/tree/master/plugin\">weave/plugin at master · weaveworks/weave (github.com)</a></p>\n<p>相关文档是：[Integrating Kubernetes and Mesos via the CNI Plugin (weave.works)]</p>\n<h3 id=\"cni-route-override-a-meta-CNI-plugin-that-override-route-information\"><a href=\"#cni-route-override-a-meta-CNI-plugin-that-override-route-information\" class=\"headerlink\" title=\"cni-route-override - a meta CNI plugin that override route information\"></a><a href=\"https://github.com/redhat-nfvpe/cni-route-override\">cni-route-override - a meta CNI plugin that override route information</a></h3><p>仓库位置是：<a href=\"https://github.com/redhat-nfvpe/cni-route-override\">redhat-nfvpe/cni-route-override: CNI plugin to override routes for a container interface (github.com)</a></p>\n<p>相关文档是：同一位置</p>\n<h3 id=\"Terway-a-collection-of-CNI-Plugins-based-on-alibaba-cloud-VPC-ECS-network-product\"><a href=\"#Terway-a-collection-of-CNI-Plugins-based-on-alibaba-cloud-VPC-ECS-network-product\" class=\"headerlink\" title=\"Terway - a collection of CNI Plugins based on alibaba cloud VPC/ECS network product\"></a><a href=\"https://github.com/AliyunContainerService/terway\">Terway - a collection of CNI Plugins based on alibaba cloud VPC/ECS network product</a></h3><p>仓库位置是：<a href=\"https://github.com/AliyunContainerService/terway\">AliyunContainerService/terway: CNI plugin for Alibaba Cloud VPC/ENI (github.com)</a></p>\n<p>相关文档是：同一位置</p>\n<h3 id=\"Cisco-ACI-CNI-for-on-prem-and-cloud-container-networking-with-consistent-policy-and-security-model\"><a href=\"#Cisco-ACI-CNI-for-on-prem-and-cloud-container-networking-with-consistent-policy-and-security-model\" class=\"headerlink\" title=\"Cisco ACI CNI - for on-prem and cloud container networking with consistent policy and security model.\"></a><a href=\"https://github.com/noironetworks/aci-containers\">Cisco ACI CNI - for on-prem and cloud container networking with consistent policy and security model.</a></h3><p>仓库位置是：<a href=\"https://github.com/noironetworks/aci-containers\">noironetworks/aci-containers: Plugins for integrating ACI with container orchestration systems (github.com)</a></p>\n<p>相关文档是：同一位置</p>\n<h3 id=\"Kube-OVN-a-CNI-plugin-that-bases-on-OVN-OVS-and-provides-advanced-features-like-subnet-static-ip-ACL-QoS-etc\"><a href=\"#Kube-OVN-a-CNI-plugin-that-bases-on-OVN-OVS-and-provides-advanced-features-like-subnet-static-ip-ACL-QoS-etc\" class=\"headerlink\" title=\"Kube-OVN - a CNI plugin that bases on OVN/OVS and provides advanced features like subnet, static ip, ACL, QoS, etc.\"></a><a href=\"https://github.com/kubeovn/kube-ovn\">Kube-OVN - a CNI plugin that bases on OVN/OVS and provides advanced features like subnet, static ip, ACL, QoS, etc.</a></h3><p>仓库位置是：<a href=\"https://github.com/kubeovn/kube-ovn\">kubeovn/kube-ovn: A Bridge between SDN and Cloud Native (Project under CNCF) (github.com)</a></p>\n<p>相关文档是：<a href=\"https://github.com/kubeovn/kube-ovn/blob/master/docs/install.md\">kube-ovn/install.md at master · kubeovn/kube-ovn (github.com)</a></p>\n<h3 id=\"Project-Antrea-an-Open-vSwitch-k8s-CNI\"><a href=\"#Project-Antrea-an-Open-vSwitch-k8s-CNI\" class=\"headerlink\" title=\"Project Antrea - an Open vSwitch k8s CNI\"></a><a href=\"https://github.com/vmware-tanzu/antrea\">Project Antrea - an Open vSwitch k8s CNI</a></h3><p>仓库位置是：<a href=\"https://github.com/antrea-io/antrea\">antrea-io/antrea: Kubernetes networking based on Open vSwitch (github.com)</a></p>\n<p>相关文档是：<a href=\"https://github.com/antrea-io/antrea/blob/main/docs/getting-started.md\">antrea/getting-started.md at main · antrea-io/antrea (github.com)</a></p>\n<h3 id=\"OVN4NFV-K8S-Plugin-a-OVN-based-CNI-controller-plugin-to-provide-cloud-native-based-Service-function-chaining-SFC-Multiple-OVN-overlay-networking\"><a href=\"#OVN4NFV-K8S-Plugin-a-OVN-based-CNI-controller-plugin-to-provide-cloud-native-based-Service-function-chaining-SFC-Multiple-OVN-overlay-networking\" class=\"headerlink\" title=\"OVN4NFV-K8S-Plugin - a OVN based CNI controller plugin to provide cloud native based Service function chaining (SFC), Multiple OVN overlay networking\"></a><a href=\"https://github.com/opnfv/ovn4nfv-k8s-plugin\">OVN4NFV-K8S-Plugin - a OVN based CNI controller plugin to provide cloud native based Service function chaining (SFC), Multiple OVN overlay networking</a></h3><p>仓库位置是：<a href=\"https://github.com/opnfv/ovn4nfv-k8s-plugin\">opnfv/ovn4nfv-k8s-plugin: This repository is archived. Please see https://github.com/akraino-edge-stack/icn-nodus for the latest code.</a></p>\n<p>相关文档是：同一位置</p>\n<blockquote>\n<p>已经关闭</p>\n</blockquote>\n<h3 id=\"Azure-CNI-a-CNI-plugin-that-natively-extends-Azure-Virtual-Networks-to-containers\"><a href=\"#Azure-CNI-a-CNI-plugin-that-natively-extends-Azure-Virtual-Networks-to-containers\" class=\"headerlink\" title=\"Azure CNI - a CNI plugin that natively extends Azure Virtual Networks to containers\"></a><a href=\"https://github.com/Azure/azure-container-networking\">Azure CNI - a CNI plugin that natively extends Azure Virtual Networks to containers</a></h3><p>仓库位置是：<a href=\"https://github.com/Azure/azure-container-networking\">Azure/azure-container-networking: Azure Container Networking Solutions for Linux and Windows Containers (github.com)</a></p>\n<p>相关文档是：<a href=\"https://github.com/Azure/azure-container-networking/tree/master/docs\">azure-container-networking/docs at master · Azure/azure-container-networking (github.com)</a></p>\n<h3 id=\"Hybridnet-a-CNI-plugin-designed-for-hybrid-clouds-which-provides-both-overlay-and-underlay-networking-for-containers-in-one-or-more-clusters-Overlay-and-underlay-containers-can-run-on-the-same-node-and-have-cluster-wide-bidirectional-network-connectivity\"><a href=\"#Hybridnet-a-CNI-plugin-designed-for-hybrid-clouds-which-provides-both-overlay-and-underlay-networking-for-containers-in-one-or-more-clusters-Overlay-and-underlay-containers-can-run-on-the-same-node-and-have-cluster-wide-bidirectional-network-connectivity\" class=\"headerlink\" title=\"Hybridnet - a CNI plugin designed for hybrid clouds which provides both overlay and underlay networking for containers in one or more clusters. Overlay and underlay containers can run on the same node and have cluster-wide bidirectional network connectivity.\"></a><a href=\"https://github.com/alibaba/hybridnet\">Hybridnet - a CNI plugin designed for hybrid clouds which provides both overlay and underlay networking for containers in one or more clusters. Overlay and underlay containers can run on the same node and have cluster-wide bidirectional network connectivity.</a></h3><p>仓库位置是：<a href=\"https://github.com/alibaba/hybridnet\">alibaba/hybridnet: A CNI plugin, provides networking environment where overlay and underlay containers can run on the same node and have cluster-wide bidirectional network connectivity. (github.com)</a></p>\n<p>相关文档是：<a href=\"https://github.com/alibaba/hybridnet/wiki\">Home · alibaba/hybridnet Wiki (github.com)</a></p>\n<h3 id=\"Spiderpool-An-IP-Address-Management-IPAM-CNI-plugin-of-Kubernetes-for-managing-static-ip-for-underlay-network\"><a href=\"#Spiderpool-An-IP-Address-Management-IPAM-CNI-plugin-of-Kubernetes-for-managing-static-ip-for-underlay-network\" class=\"headerlink\" title=\"Spiderpool - An IP Address Management (IPAM) CNI plugin of Kubernetes for managing static ip for underlay network\"></a><a href=\"https://github.com/spidernet-io/spiderpool\">Spiderpool - An IP Address Management (IPAM) CNI plugin of Kubernetes for managing static ip for underlay network</a></h3><p>仓库位置是：<a href=\"https://github.com/spidernet-io/spiderpool\">spidernet-io/spiderpool: spiderpool: Kubernetes IPAM for underlay network (github.com)</a></p>\n<p>相关文档是：<a href=\"https://github.com/spidernet-io/spiderpool/blob/main/docs/usage/install.md\">spiderpool/install.md at main · spidernet-io/spiderpool (github.com)</a></p>\n"},{"layout":"source/_posts/edgemesh/2023-ospp-fighting/","title":"Iptables--基础知识.md","date":"2023-05-25T23:41:26.000Z","published":0,"_content":"","source":"_posts/EdgeMesh/2023-ospp-fighting/Iptable-Basic.md","raw":"---\nlayout: source/_posts/edgemesh/2023-ospp-fighting/\ntitle: Iptables--基础知识.md\ndate: 2023-05-26 07:41:26\ntags:\npublished: false\n---\n","slug":"EdgeMesh/2023-ospp-fighting/Iptable-Basic","updated":"2023-05-27T02:26:19.152Z","comments":1,"photos":[],"link":"","_id":"cli796r0q000zbyjxgloaghs0","content":"","site":{"data":{}},"cover":"/img/cover/sky3.png","cover_type":"img","excerpt":"","more":""},{"layout":"source/_posts/edgemesh/2023-ospp-fighting/","title":"cilium & L2 Service","date":"2023-05-25T23:37:48.000Z","published":0,"_content":"","source":"_posts/EdgeMesh/2023-ospp-fighting/cilium-L2-Service.md","raw":"---\nlayout: source/_posts/edgemesh/2023-ospp-fighting/\ntitle: cilium & L2 Service\ndate: 2023-05-26 07:37:48\ntags:\npublished: false\n---\n","slug":"EdgeMesh/2023-ospp-fighting/cilium-L2-Service","updated":"2023-05-27T02:32:22.419Z","comments":1,"photos":[],"link":"","_id":"cli796r0r0014byjxauymf969","content":"","site":{"data":{}},"cover":"/img/cover/sky2.png","cover_type":"img","excerpt":"","more":""},{"title":"Go Pratical knowledge","catalog":true,"date":"2023-04-09T17:18:26.000Z","subtitle":null,"header-img":null,"published":0,"_content":"\n# \n\n``` golang\nCNI_COMMAND=ADD CNI_CONTAINERID=lab-ns CNI_NETNS=/var/run/netns/lab-ns CNI_IFNAME=eth0 CNI_PATH=`pwd` ./bridge <../conf/lab-br0.conf\n\ncat > lab-br0.conf <<\"EOF\"\n{\n    \"cniVersion\": \"0.4.0\",\n    \"name\": \"lab-br0\",\n    \"type\": \"bridge\",\n    \"bridge\": \"lab-br0\",\n    \"isGateway\": true,\n    \"ipMasq\": true,\n    \"ipam\": {\n        \"type\": \"host-local\",\n        \"subnet\": \"10.15.10.0/24\",\n        \"routes\": [\n            { \"dst\": \"0.0.0.0/0\" }\n        ],\n        \"rangeStart\": \"10.15.10.100\",\n        \"rangeEnd\": \"10.15.10.200\",\n        \"gateway\": \"10.15.10.99\"\n    }\n}\nEOF\n\nCNI_COMMAND=ADD CNI_CONTAINERID=e992e95204096b5f22dd4a8b0b5a3348a503c928d5eca71e84eac4fa96379011 CNI_NETNS=/var/run/docker/netns/ab1949fd7d3d CNI_IFNAME=eth0 CNI_PATH=`pwd` ./bridge <../conf/lab-br1.conf\n```","source":"_posts/Go/Go-Pratical-knowledge/Go-Pratical-knowledge.md","raw":"---\ntitle: Go Pratical knowledge\ncatalog: true\ndate: 2023-04-10 01:18:26\nsubtitle:\nheader-img:\ntags:\ncategories:\npublished: false\n---\n\n# \n\n``` golang\nCNI_COMMAND=ADD CNI_CONTAINERID=lab-ns CNI_NETNS=/var/run/netns/lab-ns CNI_IFNAME=eth0 CNI_PATH=`pwd` ./bridge <../conf/lab-br0.conf\n\ncat > lab-br0.conf <<\"EOF\"\n{\n    \"cniVersion\": \"0.4.0\",\n    \"name\": \"lab-br0\",\n    \"type\": \"bridge\",\n    \"bridge\": \"lab-br0\",\n    \"isGateway\": true,\n    \"ipMasq\": true,\n    \"ipam\": {\n        \"type\": \"host-local\",\n        \"subnet\": \"10.15.10.0/24\",\n        \"routes\": [\n            { \"dst\": \"0.0.0.0/0\" }\n        ],\n        \"rangeStart\": \"10.15.10.100\",\n        \"rangeEnd\": \"10.15.10.200\",\n        \"gateway\": \"10.15.10.99\"\n    }\n}\nEOF\n\nCNI_COMMAND=ADD CNI_CONTAINERID=e992e95204096b5f22dd4a8b0b5a3348a503c928d5eca71e84eac4fa96379011 CNI_NETNS=/var/run/docker/netns/ab1949fd7d3d CNI_IFNAME=eth0 CNI_PATH=`pwd` ./bridge <../conf/lab-br1.conf\n```","slug":"Go/Go-Pratical-knowledge/Go-Pratical-knowledge","updated":"2023-04-22T13:24:02.216Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli796r0s0016byjxgh1kec0z","content":"<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h1><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CNI_COMMAND=ADD CNI_CONTAINERID=lab-ns CNI_NETNS=/<span class=\"keyword\">var</span>/run/netns/lab-ns CNI_IFNAME=eth0 CNI_PATH=<span class=\"string\">`pwd`</span> ./bridge &lt;../conf/lab-br0.conf</span><br><span class=\"line\"></span><br><span class=\"line\">cat &gt; lab-br0.conf &lt;&lt;<span class=\"string\">&quot;EOF&quot;</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;cniVersion&quot;</span>: <span class=\"string\">&quot;0.4.0&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;name&quot;</span>: <span class=\"string\">&quot;lab-br0&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;type&quot;</span>: <span class=\"string\">&quot;bridge&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;bridge&quot;</span>: <span class=\"string\">&quot;lab-br0&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;isGateway&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;ipMasq&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;ipam&quot;</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;type&quot;</span>: <span class=\"string\">&quot;host-local&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;subnet&quot;</span>: <span class=\"string\">&quot;10.15.10.0/24&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;routes&quot;</span>: [</span><br><span class=\"line\">            &#123; <span class=\"string\">&quot;dst&quot;</span>: <span class=\"string\">&quot;0.0.0.0/0&quot;</span> &#125;</span><br><span class=\"line\">        ],</span><br><span class=\"line\">        <span class=\"string\">&quot;rangeStart&quot;</span>: <span class=\"string\">&quot;10.15.10.100&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;rangeEnd&quot;</span>: <span class=\"string\">&quot;10.15.10.200&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;gateway&quot;</span>: <span class=\"string\">&quot;10.15.10.99&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EOF</span><br><span class=\"line\"></span><br><span class=\"line\">CNI_COMMAND=ADD CNI_CONTAINERID=e992e95204096b5f22dd4a8b0b5a3348a503c928d5eca71e84eac4fa96379011 CNI_NETNS=/<span class=\"keyword\">var</span>/run/docker/netns/ab1949fd7d3d CNI_IFNAME=eth0 CNI_PATH=<span class=\"string\">`pwd`</span> ./bridge &lt;../conf/lab-br1.conf</span><br></pre></td></tr></table></figure>","site":{"data":{}},"cover":"/img/cover/2077_city.png","cover_type":"img","excerpt":"","more":"<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h1><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CNI_COMMAND=ADD CNI_CONTAINERID=lab-ns CNI_NETNS=/<span class=\"keyword\">var</span>/run/netns/lab-ns CNI_IFNAME=eth0 CNI_PATH=<span class=\"string\">`pwd`</span> ./bridge &lt;../conf/lab-br0.conf</span><br><span class=\"line\"></span><br><span class=\"line\">cat &gt; lab-br0.conf &lt;&lt;<span class=\"string\">&quot;EOF&quot;</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;cniVersion&quot;</span>: <span class=\"string\">&quot;0.4.0&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;name&quot;</span>: <span class=\"string\">&quot;lab-br0&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;type&quot;</span>: <span class=\"string\">&quot;bridge&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;bridge&quot;</span>: <span class=\"string\">&quot;lab-br0&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;isGateway&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;ipMasq&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;ipam&quot;</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;type&quot;</span>: <span class=\"string\">&quot;host-local&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;subnet&quot;</span>: <span class=\"string\">&quot;10.15.10.0/24&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;routes&quot;</span>: [</span><br><span class=\"line\">            &#123; <span class=\"string\">&quot;dst&quot;</span>: <span class=\"string\">&quot;0.0.0.0/0&quot;</span> &#125;</span><br><span class=\"line\">        ],</span><br><span class=\"line\">        <span class=\"string\">&quot;rangeStart&quot;</span>: <span class=\"string\">&quot;10.15.10.100&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;rangeEnd&quot;</span>: <span class=\"string\">&quot;10.15.10.200&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;gateway&quot;</span>: <span class=\"string\">&quot;10.15.10.99&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EOF</span><br><span class=\"line\"></span><br><span class=\"line\">CNI_COMMAND=ADD CNI_CONTAINERID=e992e95204096b5f22dd4a8b0b5a3348a503c928d5eca71e84eac4fa96379011 CNI_NETNS=/<span class=\"keyword\">var</span>/run/docker/netns/ab1949fd7d3d CNI_IFNAME=eth0 CNI_PATH=<span class=\"string\">`pwd`</span> ./bridge &lt;../conf/lab-br1.conf</span><br></pre></td></tr></table></figure>"},{"title":"Go basic examples","catalog":true,"date":"2023-02-09T17:16:19.000Z","subtitle":null,"header-img":null,"_content":"","source":"_posts/Go/Go-basic-knowledge/Go-basic-typeUsage.md","raw":"---\ntitle: Go basic examples\ncatalog: true\ndate: 2023-02-10 01:16:19\nsubtitle:\nheader-img:\ntags:\ncategories: \n\t- Basic\n---","slug":"Go/Go-basic-knowledge/Go-basic-typeUsage","published":1,"updated":"2023-05-01T11:49:39.429Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli796r0t0018byjx39d4bp3q","content":"","site":{"data":{}},"cover":"/img/cover/sky3.png","cover_type":"img","excerpt":"","more":""},{"title":"Go basic knowledge","catalog":true,"date":"2023-02-09T17:16:19.000Z","subtitle":null,"header-img":null,"_content":"# Go 入门知识\n\n> 本章节内容基于 https://tour.go-zh.org/  [Go语言测试平台](https://tour.go-zh.org/list) 索引整理完成\n>\n> 答案训练参考：\n>\n> https://gist.github.com/zyxar/2317744\n>\n> https://gist.github.com/CarlosLanderas/11b4f6727deec051883ddc02edf5cd0b\n>\n> 一些有用书籍索引：\n>\n> [Go语言圣经（中文版）](https://books.studygolang.com/gopl-zh/)\n>\n> [Go语言入门教程，Golang入门教程](http://c.biancheng.net/golang/)\n>\n> [《Go语言标准库》](https://books.studygolang.com/The-Golang-Standard-Library-by-Example/)\n\n# 1. Go 包相关\n\n## 1.1 路径\n\n每个 Go 程序都是由包构成的。\n\n程序从 `main`​​​ 包开始运行。\n\n比如通过导入路径 `\"fmt\"`​​ 和 `\"math/rand\"`​​ 来使用这两个包。\n\n按照约定，包名与导入路径的最后一个元素一致。例如，`\"math/rand\"`​​​ 包中的源码均以 `package rand`​​​ 语句开始。\n\n‍\n\n## 1.2 导入包\n\n圆括号组合了导入，这是“分组”形式的导入语\n\n# 2. 变量\n\n注意类型在变量名之后 \n\n```go\ny int\n```\n\n‍\n\n`var`​​​ 语句用于声明一个变量列表，跟函数的参数列表一样，类型在最后\n\n```go\nvar a ,b c, d int\n```\n\n变量声明可以包含初始值，每个变量对应一个， 逗号隔开，如果初始化值已存在，则可以省略类型；变量会从初始值中获得类型。\n\n```go\nvar i, j int = 1, 2\nvar c, python, java = true, false, \"no!\"\n```\n\n‍\n\n简洁赋值语句 `:=`​​​ 可在类型明确的地方代替 `var`​​​ 声明。\n\n函数外的每个语句都必须以关键字开始（`var`​​​, `func`​​​ 等等），因此 ​`:=`​​​​ 结构不能在函数外使用[相较之下 var 可以写到函数外面，在包层级]\n\n```go\n\tk := 3\n\tc, python, java := true, false, \"no!\"\n```\n\n‍\n\n**Go 的基本类型有**\n\n```\nbool\n\nstring\n\nint  int8  int16  int32  int64\nuint uint8 uint16 uint32 uint64 uintptr\n\nbyte // uint8 的别名\n\nrune // int32 的别名\n    // 表示一个 Unicode 码点\n\nfloat32 float64\n\ncomplex64 complex128\n```\n\n本例展示了几种类型的变量。 同导入语句一样，变量声明也可以“分组”成一个语法块。\n\n```go\nvar (\n\tToBe   bool       = false\n\tMaxInt uint64     = 1<<64 - 1\n\tz      complex128 = cmplx.Sqrt(-5 + 12i)\n)\n```\n\n`int`​​​, `uint`​​​ 和 `uintptr`​​​ 在 32 位系统上通常为 32 位宽，在 64 位系统上则为 64 位宽。 当你需要一个整数值时应使用 `int`​​​ 类型，除非你有特殊的理由使用固定大小或无符号的整数类型。\n\n‍\n\n没有明确初始值的变量声明会被赋予它们的 **零值**。\n\n零值是：\n\n* 数值类型为 `0`​​​，\n* 布尔类型为 `false`​​​，\n* 字符串为 `\"\"`​​​（空字符串）。\n\n‍\n\n表达式 `T(v)`​​​ 将值 `v`​​​ 转换为类型 `T`​​​。\n\n一些关于数值的转换：\n\n```\nvar i int = 42\nvar f float64 = float64(i)\nvar u uint = uint(f)\n```\n\n或者，更加简单的形式：\n\n```\ni := 42\nf := float64(i)\nu := uint(f)\n```\n\n与 C 不同的是，Go 在不同类型的项之间赋值时需要显式转换,，等号右边的数值必须是类型明确的\n\n‍\n\n## 2.1 常量\n\n常量的声明与变量类似，只不过是使用 `const`​​​ 关键字。\n\n常量可以是字符、字符串、布尔值或数值。\n\n常量不能用 `:=`​​​ 语法声明。\n\n```go\nconst World = \"世界\"\n//相较之下，这个申明的world是一个变量，也就是可以改变其类型的\nworld := \"世界\"\n\n\tconst World = \"世界\"\n\tfmt.Println(\"Hello\", World)\n\n\tworld := \"世界\"\n\tfmt.Println(\"Go rules?\", world)\n\tworld = \"是吗\"\n\tfmt.Println(\"Go rules?\", world)\n\t结果是：\n\tHello 世界\n\tGo rules? 世界\n\tGo rules? 是吗\n```\n\n‍\n\n## 2.2 类型推导\n\n在声明一个变量而不指定其类型时（即使用不带类型的 `:=`​​​ 语法或 `var =`​​​ 表达式语法），变量的类型由右值推导得出。\n\n当右值声明了类型时，新变量的类型与其相同：\n\n```\nvar i int\nj := i // j 也是一个 int\n```\n\n不过当右边包含未指明类型的数值常量时，新变量的类型就可能是 `int`​​​, `float64`​​​ 或 `complex128`​​​ 了，这取决于常量的精度：\n\n```\ni := 42           // int\nf := 3.142        // float64\ng := 0.867 + 0.5i // complex128\n```\n\n‍\n\n## 2.3 数值常量\n\n数值常量是高精度的 **值**。\n\n一个未指定类型的常量由上下文来决定其类型。\n\n再尝试一下输出 `needInt(Big)`​​​ 吧。\n\n（`int`​​​ 类型最大可以存储一个 64 位的整数，有时会更小。）\n\n（`int`​​​​ 可以存放最大64位的整数，根据平台不同有时会更少。）\n\n```go\nconst (\n\t// 将 1 左移 100 位来创建一个非常大的数字\n\t// 即这个数的二进制是 1 后面跟着 100 个 0\n\tBig = 1 << 100\n\t// 再往右移 99 位，即 Small = 1 << 1，或者说 Small = 2\n\tSmall = Big >> 99\n)\n```\n\n# 3. 语句\n\n## 3.1 if\n\nGo 的 `if`​​​​ 语句与 `for`​​​​ 循环类似，表达式外无需小括号 `( )`​​​​ ，而大括号 `{ }`​​​​ 则是必须的。\n\n```go\nif x < 0 {\n\treturn sqrt(-x) + \"i\"\n}\n```\n\n## 3.2 for\n\nGo 只有一种循环结构：`for`​​​ 循环。\n\n基本的 `for`​​​ 循环由三部分组成，它们用分号隔开：\n\n* 初始化语句：在第一次迭代前执行\n* 条件表达式：在每次迭代前求值\n* 后置语句：在每次迭代的结尾执行\n\n初始化语句通常为一句短变量声明，该变量声明仅在 `for`​​​ 语句的作用域中可见。\n\n一旦条件表达式的布尔值为 `false`​​​，循环迭代就会终止。\n\n初始化语句和后置语句是可选的，也就是说完全可以只有一个条件，其含义也变成了wihle语句，但是go里面没有while只有for\n\n**注意**：和 C、Java、JavaScript 之类的语言不同，**Go 的 for 语句后面的三个构成部分外没有小括号**， 而包围函数主体的大括号 `{ }`​​​​ 则是必须的。\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tsum := 0\n\tfor i := 0; i < 10; i++ {\n\t\tsum += i\n\t}\n\tfmt.Println(sum)\n}\n\n\nfunc main() {\n\tsum := 1\n\tfor sum < 1000{\n\t\tsum += sum\n\t}\n\tfmt.Println(sum)\n}\n\n```\n\n‍\n\n## 3.3 if 的简短语句\n\n同 `for`​​​ 一样， `if`​​​ 语句可以在条件表达式前执行一个简单的语句。\n\n**该语句声明的变量作用域仅在 ​****`if`**​​​**​ 之内。**也就是说出了if语句，这个变量就没有了\n\n```go\nfunc pow(x, n, lim float64) float64 {\n\tif v := math.Pow(x, n); v < lim {\n\t\treturn v\n\t}\n\treturn lim\n}\n```\n\n‍\n\n## 3.4 if 和 else\n\n在 `if`​​ 的简短语句中声明的变量同样可以在任何对应的 `else`​​ 块中使用。\n\n```go\nif v := math.Pow(x, n); v < lim {\n\t\treturn v\n\t} else {\n\t\tfmt.Printf(\"%g >= %g\\n\", v, lim)\n\t}\n\n\n//一般格式是：\nif {\n}else if {\n}else {}\n```\n\n  \n\n## 3.5 switch\n\n`switch`​​ 是编写一连串 `if - else`​​ 语句的简便方法。它运行第一个值等于条件表达式的 case 语句。\n\nGo 的 switch 语句类似于 C、C++、Java、JavaScript 和 PHP 中的，不过 Go 只运行选定的 case，而非之后所有的 case。 实际上，Go 自动提供了在这些语言中每个 case 后面所需的 `break`​​ 语句。 除非以 `fallthrough`​​ 语句结束，否则分支会自动终止。 Go 的另一点重要的不同在于 switch 的 case 无需为常量，且取值不必为整数。\n\n```go\n\tswitch os := runtime.GOOS; os {\n\tcase \"darwin\":\n\t\tfmt.Println(\"OS X.\")\n\tcase \"linux\":\n\t\tfmt.Println(\"Linux.\")\n\tdefault:\n\t\t// freebsd, openbsd,\n\t\t// plan9, windows...\n\t\tfmt.Printf(\"%s.\\n\", os)\n\t}\n```\n\n‍\n\n## 3.6 switch 的求值顺序\n\nswitch 的 case 语句从上到下顺次执行，直到匹配成功时停止。\n\n（例如，  \n\n```\nswitch i {\ncase 0:\ncase f():\n}\n```\n\n在 `i==0`​​ 时 `f`​​ 不会被调用。  \n\n```go\n\ttoday := time.Now().Weekday()\n\tswitch time.Saturday {\n\tcase today + 0:\n\t\tfmt.Println(\"Today.\")\n\tcase today + 1:\n\t\tfmt.Println(\"Tomorrow.\")\n\tcase today + 2:\n\t\tfmt.Println(\"In two days.\")\n\tdefault:\n\t\tfmt.Println(\"Too far away.\")\n\t}\n```\n\n\n\n## 3.7 没有条件的 switch\n\n没有条件的 switch 同 `switch true`​​ 一样。\n\n这种形式能将一长串 if-then-else 写得更加清晰。\n\n```go\nt := time.Now()\n\tswitch {\n\tcase t.Hour() < 12:\n\t\tfmt.Println(\"Good morning!\")\n\tcase t.Hour() < 17:\n\t\tfmt.Println(\"Good afternoon.\")\n\tdefault:\n\t\tfmt.Println(\"Good evening.\")\n\t}\n```\n\n‍\n\n## 3.8 defer\n\ndefer 语句会将函数推迟到外层函数返回之后执行。\n\n推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用。\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tdefer fmt.Println(\"world\")\n\n\tfmt.Println(\"hello\")\n}\n结果是：\nhello\nworld\n```\n\n‍\n\n## 3.9 defer 栈\n\n推迟的函数调用会被压入一个栈中。当外层函数返回时，被推迟的函数会按照后进先出的顺序调用。  \n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tfmt.Println(\"counting\")\n\n\tfor i := 0; i < 10; i++ {\n\t\tdefer fmt.Println(i)\n\t}\n\n\tfmt.Println(\"done\")\n}\n由于是按照栈的形式来存的\ncounting\ndone\n9\n8\n7\n6\n5\n4\n3\n2\n1\n0\n```\n\n[Defer，Panic,Recover](https://blog.go-zh.org/defer-panic-and-recover)\n\n‍\n\n## 3.10 函数返回\n\n函数可以返回任意数量的返回值, 但是结构上需要结合函数形式\n\n```go\nfunc swap(x, y string) (string, string) {\n\treturn y, x\n}\n```\n\n‍\n\nGo 的返回值可被命名，它们会被视作定义在函数顶部的变量。\n\n返回值的名称应当具有一定的意义，它可以作为文档使用。\n\n没有参数的 `return`​ 语句返回已命名的返回值。也就是 `直接`​ 返回。\n\n直接返回语句应当仅用在下面这样的短函数中。在长的函数中它们会影响代码的可读性。\n\n(x, y int) 中的（）不可以省略\n\n```go\nfunc split(sum int) (x, y int) {\n\tx = sum * 4 / 9\n\ty = sum - x\n\treturn\n}\n```\n\n‍\n\n‍\n\n## 3.11 Retrun and Defer\n\n> ‍\n\n![image](Y:/Blog/blog/source/_posts/Go/Go-basic-knowledge/assets/image-20230228154553-m65t587.png)​\n\n```go\npackage main\n \nimport \"fmt\"\n \n// return语句执行步骤\n// 1、返回值赋值\n// 2、defer语句\n// 3、真正RET返回\nfunc f0() (x int) {\n\tx = 5\n\tdefer func() {\n\t\tx++\n\t}()\n\treturn x //返回值RET=x, x++, RET=x=6\n}\n \nfunc f1() int {\n\tx := 5\n\tdefer func() {\n\t\tx++ //修改的是x，不是返回值\n\t}()\n\treturn x //返回值RET=5, x++, RET=5\n}\n \nfunc f2() (x int) {\n\tdefer func() {\n\t\tx++\n\t}()\n\treturn 5 //返回值RET=x=5, x++, RET=6\n}\n \nfunc f3() (y int) {\n\tx := 5\n\tdefer func() {\n\t\tx++\n\t}()\n\treturn x //返回值RET=y=x=5, x++, RET=5\n}\n \nfunc f4() (x int) {\n\tdefer func(x int) {\n\t\tx++\n\t}(x)\n\treturn 5 //返回值RET=x=5, x`++, RET=5\n}\n \nfunc main() {\n\tfmt.Println(f0()) //6\n\tfmt.Println(f1()) //5\n\tfmt.Println(f2()) //6\n\tfmt.Println(f3()) //5\n\tfmt.Println(f4()) //5\n}\n```\n\n要注意的是实际返回的值和在函数内运算的值是不相同的对象，存在一个赋值的过程\n\n首先要明确 defer 后紧接的代码可以有两种写法：\n\n> 参考文章： \n>\n> [Golang中defer和return的执行顺序 + 相关测试题（面试常考）](https://blog.csdn.net/qq_37102984/article/details/128946146?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EAD_ESQUERY%7Eyljh-1-128946146-blog-116449166.pc_relevant_3mothn_strategy_and_data_recovery&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EAD_ESQUERY%7Eyljh-1-128946146-blog-116449166.pc_relevant_3mothn_strategy_and_data_recovery)\n>\n> [Golang Defer 深入理解](https://blog.csdn.net/qq_14997473/article/details/116449166)\n>\n> [汇编层面](https://cloud.tencent.com/developer/article/1453355)\n>\n> [Return的机制](https://haicoder.net/golang/golang-return.html)\n\n* defer + 表达式，例如：  \n  此时就会直接保留当前变量 x 已有的值到栈中，一直到最后直接打印输出，不再受后续 return x 结果的影响。例如$t e s t 1$ 和 $t e s t 2$中的变量 x 。 **例如 test1 和 test2 中的变量 x。**\n\n  ```go\n  defer fmt.Printf(\"in defer: x = %d\\n\", x\n  ```\n\n* defer + 匿名函数（无入参/有入参），例如：\n\n  ```go\n  defer func() {fmt.Printf(\"in defer: x = %d\\n\", x)}()\n  或者是\n  defer func(n int) {fmt.Printf(\"in defer x as parameter: x = %d\\n\", n) fmt.Printf(\"in defer x after return: x = %d\\n\", x)}(x)\n  ```\n\n  此时需要区分打印输出的变量到底是【defer匿名函数内要访问的变量 n】，还是【defer匿名函数内要访问的变量 x】。\n\n  * 针对【defer匿名函数内要访问的变量 n】，其值取决于在一开始遇到 defer 时入参 n 的值（也就是最开始还没被改变时的变量 x 的值，起初是0）。这个变量 n 的值是独立的，不会受后续 return x 结果的影响。\n  * 针对【defer匿名函数内要访问的变量 x】，由于匿名函数能访问外部函数的变量，也就是说【defer匿名函数内要访问的变量 x】最终会被【defer匿名函数外最终要 return 返回出去的变量 x】所影响。\n\n‍\n\n‍\n\n# 4. 结构及指针\n\n## 4.1 指针\n\nGo 拥有指针。指针保存了值的内存地址。\n\n类型 `*T`​ 是指向 `T`​ 类型值的指针。其零值为 `nil`​。\n\n```\nvar p *int\n```\n\n`&`​​ 操作符会生成一个指向其操作数的指针。\n\n所以当赋值的时候，或者是传输的时候只能够只用&p来表示获取到p的地址，*p是地址指向的内容\n\n```\ni := 42\np = &i\n```\n\n`*`​ 操作符表示指针指向的底层值。\n\n```\nfmt.Println(*p) // 通过指针 p 读取 i\n*p = 21         // 通过指针 p 设置 i\n```\n\n这也就是通常所说的“间接引用”或“重定向”。\n\n与 C 不同，Go 没有指针运算。\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\ti, j := 42, 2701\n\n\tp := &i         // 指向 i\n\tfmt.Println(*p) // 通过指针读取 i 的值\n\t*p = 21         // 通过指针设置 i 的值\n\tfmt.Println(i)  // 查看 i 的值\n\n\tp = &j         // 指向 j\n\t*p = *p / 37   // 通过指针对 j 进行除法运算\n\tfmt.Println(j) // 查看 j 的值\n}\n```\n\n‍\n\n## 4.2 结构体\n\n一个结构体（`struct`​）就是一组字段（field）。\n\n```go\ntype Vertex struct {\n\tX int\n\tY int\n}\n```\n\n## 4.3 结构体字段\n\n结构体字段使用点号来访问。\n\n```go\ntype Vertex struct {\n\tX int\n\tY int\n}\n\nfunc main() {\n\tv := Vertex{1, 2}\n\tv.X = 4\n\tfmt.Println(v.X)\n}\n```\n\n‍\n\n## 4.4 结构体指针\n\n结构体字段可以通过结构体指针来访问。\n\n如果我们有一个指向结构体的指针 `p`​，那么可以通过 `(*p).X`​ 来访问其字段 `X`​。不过这么写太啰嗦了，所以语言也允许我们使用隐式间接引用，直接写 `p.X`​ 就可以。\n\n```go\ntype Vertex struct {\n\tX int\n\tY int\n}\n\nfunc main() {\n\tv := Vertex{1, 2}\n\tp := &v\n\tp.X = 1e9\n\tfmt.Println(v)\n}\n\n```\n\n‍\n\n## 4.5 结构体文法\n\n结构体文法通过直接列出字段的值来新分配一个结构体。\n\n使用 `Name:`​ 语法可以仅列出部分字段。（字段名的顺序无关。）\n\n特殊的前缀 `&`​ 返回一个指向结构体的指针。\n\n```go\ntype Vertex struct {\n\tX, Y int\n}\n\nvar (\n\tv1 = Vertex{1, 2}  // 创建一个 Vertex 类型的结构体\n\tv2 = Vertex{X: 1}  // Y:0 被隐式地赋予\n\tv3 = Vertex{}      // X:0 Y:0\n\tp  = &Vertex{1, 2} // 创建一个 *Vertex 类型的结构体（指针）\n)\n\nfunc main() {\n\tfmt.Println(v1, p, v2, v3)\n}\n```\n\n‍\n\n## 4.6 数组\n\n类型 `[n]T`​ 表示拥有 `n`​ 个 `T`​ 类型的值的数组。\n\n表达式\n\n```\nvar a [10]int\n```\n\n会将变量 `a`​ 声明为拥有 10 个整数的数组。\n\n数组的长度是其类型的一部分，**因此数组不能改变大小**。这看起来是个限制，不过没关系，Go 提供了更加便利的方式来使用数组。\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tvar a [2]string\n\ta[0] = \"Hello\"\n\ta[1] = \"World\"\n\tfmt.Println(a[0], a[1])\n\tfmt.Println(a)\n\n\tprimes := [6]int{2, 3, 5, 7, 11, 13}\n\tfmt.Println(primes)\n}\n```\n\n‍\n\n‍\n\n## 4.7 切片\n\n每个数组的大小都是固定的。而切片则为数组元素提供动态大小的、灵活的视角。在实践中，切片比数组更常用。\n\n切片可以看作是对数组的划分，也就是说原数组是一个全集，切片就是其依据不同标准划分的子集\n\n类型 `[]T`​ 表示一个元素类型为 `T`​ 的切片。\n\n切片通过两个下标来界定，即一个上界和一个下界，二者以冒号分隔：\n\n```\na[low : high]\n```\n\n它会选择一个半开区间，包括第一个元素，但排除最后一个元素。\n\n以下表达式创建了一个切片，它包含 `a`​ 中下标从 1 到 3 的元素：\n\n```\na[1:4]\n```\n\n切片就像数组的引用\n\n切片并不存储任何数据，它只是描述了底层数组中的一段。\n\n更改切片的元素会修改其底层数组中对应的元素。\n\n与它**共享底层数组**的切片都会观测到这些修改（也就是说它是一种深拷贝）\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tnames := [4]string{\n\t\t\"John\",\n\t\t\"Paul\",\n\t\t\"George\",\n\t\t\"Ringo\",\n\t}\n\tfmt.Println(names)\n\n\ta := names[0:2]\n\tb := names[1:3]\n\tfmt.Println(a, b)\n\n\tb[0] = \"XXX\"\n\tfmt.Println(a, b)\n\tfmt.Println(names)\n}\n\n```\n\n‍\n\n## 4.8 切片文法\n\n切片文法类似于没有长度的数组文法。\n\n这是一个数组文法：**构建的是一个数组**\n\n```\n[3]bool{true, true, false}\n```\n\n下面这样则会创建一个和上面相同的数组，然后构建一个引用了它的切片：\n\n```\n[]bool{true, true, false}\n```\n\n‍\n\n## 4.9 切片的默认行为\n\n在进行切片时，你可以利用它的默认行为来忽略上下界。\n\n切片下界的默认值为 `0`​，上界则是该切片的长度。\n\n对于数组\n\n```\nvar a [10]int\n```\n\n来说，以下切片是等价的：\n\n```\na[0:10]\na[:10]\na[0:]\na[:]\n```\n\n可以明确的是：\n\n1. 数组和切片不能够相互赋值\n\n   ```go\n   这个函数不可行，因为s 初始化的是一个数组，之后不能够赋值给切片\n   func main() {\n   \ts := [6]int{2, 3, 5, 7, 11, 13}\n   \ts = s[1:4]\n   \tfmt.Println(s)\n   }\n   报错显示：\n   ./prog.go:8:7: cannot use s[1:4] (value of type []int) as [6]int value in assignment\n   \n   ```\n\n‍\n\n## 4.10 切片的长度与容量\n\n切片拥有 **长度** 和 **容量**。\n\n切片的长度就是它所包含的元素个数。\n\n切片的容量是从它的第一个元素开始数，到其底层数组元素末尾的个数；容量也可以理解为切片总的能够扩展的（包括长度）数量\n\n切片 `s`​ 的长度和容量可通过表达式 `len(s)`​ 和 `cap(s)`​ 来获取。\n\n你可以通过重新切片来扩展一个切片，给它提供足够的容量\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\ts := []int{2, 3, 5, 7, 11, 13}\n\tprintSlice(s)\n\n\t// 截取切片使其长度为 0\n\ts = s[:0]\n\tprintSlice(s)\n\n\t// 拓展其长度\n\ts = s[:4]\n\tprintSlice(s)\n\n\t// 舍弃前两个值\n\ts = s[2:]\n\tprintSlice(s)\n}\n\nfunc printSlice(s []int) {\n\tfmt.Printf(\"len=%d cap=%d %v\\n\", len(s), cap(s), s)\n}\n```\n\n‍\n\n## 4.11 nil 切片\n\n切片的零值是 `nil`​。\n\nnil 切片的长度和容量为 0 且没有底层数组。\n\n‍\n\n## 4.12 用 make 创建切片\n\n切片可以用内建函数 `make`​ 来创建，这也是你创建动态数组的方式。\n\n`make`​ 函数会分配一个元素为零值的数组并返回一个引用了它的切片：\n\n```\na := make([]int, 5)  // len(a)=5\n```\n\n要指定它的容量，需向 `make`​ 传入第三个参数：\n\n```\nb := make([]int, 0, 5) // len(b)=0, cap(b)=5\n\nb = b[:cap(b)] // len(b)=5, cap(b)=5\nb = b[1:]      // len(b)=4, cap(b)=4\n```\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\ta := make([]int, 5)\n\tprintSlice(\"a\", a)\n\n\tb := make([]int, 0, 5)\n\tprintSlice(\"b\", b)\n\n\tc := b[:2]\n\tprintSlice(\"c\", c)\n\n\td := c[2:5]\n\tprintSlice(\"d\", d)\n}\n\nfunc printSlice(s string, x []int) {\n\tfmt.Printf(\"%s len=%d cap=%d %v\\n\",\n\t\ts, len(x), cap(x), x)\n}\n\n结果显示为：\na len=5 cap=5 [0 0 0 0 0]\nb len=0 cap=5 []\nc len=2 cap=5 [0 0]\nd len=3 cap=3 [0 0 0]\n\n```\n\n‍\n\n## 4. 13 创建二维切片：\n\n> 参考文献：\n>\n> [直接参考的](https://www.cnblogs.com/yahuian/p/11934122.html)\n>\n> [Stack  例子讲解：](https://stackoverflow.com/questions/39804861/what-is-a-concise-way-to-create-a-2d-slice-in-go)\n>\n> [make 和  new 的区别](https://stackoverflow.com/questions/9320862/why-would-i-make-or-new)\n>\n> [二维数组的结合](https://stackoverflow.com/questions/39561140/what-is-two-dimensional-arrays-memory-representation)\n\n最常用的方法，需要记忆：\n\n```go\na := make([][]uint8, dy)\nfor i := range a {\n    a[i] = make([]uint8, dx)\n}\n```\n\n```go\n\t// 方法0\n\trow, column := 3, 4\n\tvar answer [][]int\n\tfor i := 0; i < row; i++ {\n\t\tinline := make([]int, column)\n\t\tanswer = append(answer, inline)\n\t}\n\tfmt.Println(answer)\n\n\t// 方法1，最常用\n\tanswer1 := make([][]int, row)\n\tfor i := range answer1 {\n\t\tanswer1[i] = make([]int, column)\n\t}\n\n```\n\n‍\n\n‍\n\n## 4. 14 切片的切片\n\n切片可包含任何类型，甚至包括其它的切片[参照二维数组]\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc main() {\n\t// 创建一个井字板（经典游戏）\n\tboard := [][]string{\n\t\t[]string{\"_\", \"_\", \"_\"},\n\t\t[]string{\"_\", \"_\", \"_\"},\n\t\t[]string{\"_\", \"_\", \"_\"},\n\t}\n\n\t// 两个玩家轮流打上 X 和 O\n\tboard[0][0] = \"X\"\n\tboard[2][2] = \"O\"\n\tboard[1][2] = \"X\"\n\tboard[1][0] = \"O\"\n\tboard[0][2] = \"X\"\n\n\tfor i := 0; i < len(board); i++ {\n\t\tfmt.Printf(\"%s\\n\", strings.Join(board[i], \" \"))\n\t}\n}\n```\n\n## 4. 15 向切片追加元素\n\n为切片追加新的元素是种常用的操作，为此 Go 提供了内建的 `append`​ 函数。内建函数的[文档](https://go-zh.org/pkg/builtin/#append)对此函数有详细的介绍。\n\n```\nfunc append(s []T, vs ...T) []T\n```\n\n`append`​ 的第一个参数 `s`​ 是一个元素类型为 `T`​ 的切片，其余类型为 `T`​ 的值将会追加到该切片的末尾。\n\n`append`​ 的结果是一个包含原切片所有元素加上新添加元素的切片。\n\n当 `s`​ 的底层数组太小，不足以容纳所有给定的值时，它就会分配一个更大的数组。返回的切片会指向这个新分配的数组。\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tvar s []int\n\tprintSlice(s)\n\n\t// 添加一个空切片\n\ts = append(s, 0)\n\tprintSlice(s)\n\n\t// 这个切片会按需增长\n\ts = append(s, 1)\n\tprintSlice(s)\n\n\t// 可以一次性添加多个元素\n\ts = append(s, 2, 3, 4)\n\tprintSlice(s)\n}\n\nfunc printSlice(s []int) {\n\tfmt.Printf(\"len=%d cap=%d %v\\n\", len(s), cap(s), s)\n}\n```\n\n可参考文章：  [Go 切片：用法和本质](https://blog.go-zh.org/go-slices-usage-and-internals)\n\n‍\n\n## 4. 16 Range\n\n`for`​ 循环的 `range`​ 形式可遍历切片或映射。\n\n当使用 `for`​ 循环遍历切片时，每次迭代都会返回两个值。第一个值为当前元素的下标，第二个值为该下标所对应元素的一份副本。\n\n```go\npackage main\n\nimport \"fmt\"\n\nvar pow = []int{1, 2, 4, 8, 16, 32, 64, 128}\n\nfunc main() {\n\tfor i, v := range pow {\n\t\tfmt.Printf(\"2**%d = %d\\n\", i, v)\n\t}\n}\n\n```\n\n‍\n\n## 4. 17 range（续）\n\n可以将下标或值赋予 `_`​ 来忽略它。\n\n```\nfor i, _ := range pow\nfor _, value := range pow\n```\n\n若你只需要索引，忽略第二个变量即可。\n\n```\nfor i := range pow\n```\n\n‍\n\n## 4. 18 映射（Map）\n\n映射将键映射到值。\n\n映射的零值为 `nil`​ 。`nil`​ 映射既没有键，也不能添加键。\n\n`make`​ 函数会返回给定类型的映射，并将其初始化备用。\n\n```go\npackage main\n\nimport \"fmt\"\n\ntype Vertex struct {\n\tLat, Long float64\n}\n\nvar m map[string]Vertex\n\nfunc main() {\n\tm = make(map[string]Vertex)\n\tm[\"Bell Labs\"] = Vertex{\n\t\t40.68433, -74.39967,\n\t}\n\tfmt.Println(m[\"Bell Labs\"])\n}\n```\n\n\n\n## 4. 19 映射的文法\n\n映射的文法与结构体相似，不过必须有键名。\n\n若顶级类型只是一个类型名，你可以在文法的元素中省略它。\n\n```go\npackage main\n\nimport \"fmt\"\n\ntype Vertex struct {\n\tLat, Long float64\n}\n\nvar m = map[string]Vertex{\n\t\"Bell Labs\": {40.68433, -74.39967},\n\t\"Google\":    {37.42202, -122.08408},\n}\n\nfunc main() {\n\tfmt.Println(m)\n}\n\n```\n\n‍\n\n## 4. 20 修改映射\n\n在映射 `m`​ 中插入或修改元素：\n\n```\nm[key] = elem\n```\n\n获取元素：\n\n```\nelem = m[key]\n```\n\n删除元素：\n\n```\ndelete(m, key)\n```\n\n通过双赋值检测某个键是否存在：\n\n```\nelem, ok = m[key]\n```\n\n若 `key`​ 在 `m`​ 中，`ok`​ 为 `true`​ ；否则，`ok`​ 为 `false`​。\n\n若 `key`​ 不在映射中，那么 `elem`​ 是该映射元素类型的零值。\n\n同样的，当从映射中读取某个不存在的键时，结果是映射的元素类型的零值。\n\n**注** ：若 `elem`​ 或 `ok`​ 还未声明，你可以使用短变量声明：\n\n```\nelem, ok := m[key]\n```\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tm := make(map[string]int)\n\n\tm[\"Answer\"] = 42\n\tfmt.Println(\"The value:\", m[\"Answer\"])\n\n\tm[\"Answer\"] = 48\n\tfmt.Println(\"The value:\", m[\"Answer\"])\n\n\tdelete(m, \"Answer\")\n\tfmt.Println(\"The value:\", m[\"Answer\"])\n\n\tv, ok := m[\"Answer\"]\n\tfmt.Println(\"The value:\", v, \"Present?\", ok)\n}\n\n```\n\n‍\n\n‍\n\n## 4. 21 函数值\n\n函数也是值。它们可以像其它值一样传递。\n\n函数值可以用作函数的参数或返回值。\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc compute(fn func(float64, float64) float64) float64 {\n\treturn fn(3, 4)\n}\n\nfunc main() {\n\thypot := func(x, y float64) float64 {\n\t\treturn math.Sqrt(x*x + y*y)\n\t}\n\tfmt.Println(hypot(5, 12))\n\n\tfmt.Println(compute(hypot))\n\tfmt.Println(compute(math.Pow))\n}\n```\n\n‍\n\n## 4. 22 函数的闭包\n\nGo 函数可以是一个闭包。闭包是一个函数值，它引用了其函数体之外的变量。该函数可以访问并赋予其引用的变量的值，换句话说，该函数被这些变量“绑定”在一起。\n\n例如，函数 `adder`​ 返回一个闭包。每个闭包都被绑定在其各自的 `sum`​ 变量上。\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc adder() func(int) int {\n\tsum := 0\n\treturn func(x int) int {\n\t\tsum += x\n\t\treturn sum\n\t}\n}\n\nfunc main() {\n\tpos, neg := adder(), adder()\n\tfor i := 0; i < 10; i++ {\n\t\tfmt.Println(\n\t\t\tpos(i),\n\t\t\tneg(-2*i),\n\t\t)\n\t}\n}\n\n最终的结果是：\n0 0\n1 -2\n3 -6\n6 -12\n10 -20\n15 -30\n21 -42\n28 -56\n36 -72\n45 -90\n```\n\n‍\n\n‍\n\n# 5. 方法和接口\n\n## 5.1 方法\n\nGo 没有类。不过你可以为结构体类型定义方法。\n\n方法就是一类带特殊的 ​**接收者**​ 参数的函数。\n\n方法接收者在它自己的参数列表内，位于 `func`​ 关键字和方法名之间。\n\n在此例中，`Abs`​ 方法拥有一个名为 `v`​，类型为 `Vertex`​ 的接收者。\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Vertex struct {\n\tX, Y float64\n}\n\nfunc (v Vertex) Abs() float64 {\n\treturn math.Sqrt(v.X*v.X + v.Y*v.Y)\n}\n\nfunc main() {\n\tv := Vertex{3, 4}\n\tfmt.Println(v.Abs())\n}\n```\n\n方法即函数\n\n记住：方法只是个带接收者参数的函数。\n\n现在这个 `Abs`​ 的写法就是个正常的函数，功能并没有什么变化。\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Vertex struct {\n\tX, Y float64\n}\n\nfunc Abs(v Vertex) float64 {\n\treturn math.Sqrt(v.X*v.X + v.Y*v.Y)\n}\n\nfunc main() {\n\tv := Vertex{3, 4}\n\tfmt.Println(Abs(v))\n}\n```\n\n但是这个是函数，并不能够通过v对象直接调用\n\n‍\n\n## 5.2 方法（续）\n\n你也可以为非结构体类型声明方法。\n\n在此例中，我们看到了一个带 `Abs`​ 方法的数值类型 `MyFloat`​。\n\n你只能为在同一包内定义的类型的接收者声明方法，而不能为其它包内定义的类型（包括 `int`​ 之类的内建类型）的接收者声明方法。\n\n（译注：就是接收者的类型定义和方法声明必须在同一包内；不能为内建类型声明方法。）\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype MyFloat float64\n\nfunc (f MyFloat) Abs() float64 {\n\tif f < 0 {\n\t\treturn float64(-f)\n\t}\n\treturn float64(f)\n}\n\nfunc main() {\n\tf := MyFloat(-math.Sqrt2)\n\tfmt.Println(f.Abs())\n}\n```\n\n‍\n\n## 5.3 指针接收者\n\n你可以为指针接收者声明方法。\n\n这意味着对于某类型 `T`​，接收者的类型可以用 `*T`​ 的文法。（**此外，****`T`**​**​ 不能是像 ​****`*int`**​**​ 这样的指针，换句话说就是没有双指针。**不能够出现**int这样的结构）\n\n例如，这里为 `*Vertex`​ 定义了 `Scale`​ 方法。\n\n指针接收者的方法可以修改接收者指向的值（就像 `Scale`​ 在这做的）。由于方法经常需要修改它的接收者，指针接收者比值接收者更常用。\n\n试着移除第 16 行 `Scale`​ 函数声明中的 `*`​，观察此程序的行为如何变化。\n\n若使用值接收者，那么 `Scale`​ 方法会对原始 `Vertex`​ 值**的副本**进行操作。（对于函数的其它参数也是如此。）`Scale`​ 方法必须用指针接受者来更改 `main`​ 函数中声明的 `Vertex`​ 的值。也就是说使用指针的时候才能够对原本的数据结构当中的值做修改，但如果使用值接收者，就会修改一个副本，那么函数之间的调用修改就会不起作用，生命周期只在这个函数当中完成。\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Vertex struct {\n\tX, Y float64\n}\n\nfunc (v Vertex) Abs() float64 {\n\treturn math.Sqrt(v.X*v.X + v.Y*v.Y)\n}\n\n//使用指针接收者，结果会是50 ，也就是说本函数的修改，abs能够获取到\nfunc (v *Vertex) Scale(f float64) {\n\tv.X = v.X * f\n\tv.Y = v.Y * f\n}\n//使用值接收者，结果会是5，也就是说本函数的修改只在本函数当中，abs无法感知到v.x,v.y的值发生变化\nfunc (v Vertex) Scale(f float64) {\n\tv.X = v.X * f\n\tv.Y = v.Y * f\n}\n\n\nfunc main() {\n\tv := Vertex{3, 4}\n\tv.Scale(10)\n\tfmt.Println(v.Abs())\n}\n```\n\n![image](Y:/Blog/blog/source/_posts/Go/Go-basic-knowledge/assets/image-20230228103213-yqcw1ma.png)​\n\n‍\n\n## 5.4 方法与指针重定向\n\n比较前两个程序，你大概会注意到**带指针参数的函数必须接受一个指针**：\n\n```\nvar v Vertex\nScaleFunc(v, 5)  // 编译错误！\nScaleFunc(&v, 5) // OK\n```\n\n而以**指针为接收者的方法被调用时，接收者既能为值又能为指针：**\n\n```\nvar v Vertex\nv.Scale(5)  // OK\np := &v\np.Scale(10) // OK\n```\n\n对于语句 `v.Scale(5)`​，即便 `v`​ 是个值而非指针，带指针接收者的方法也能被直接调用。 也就是说，由于 `Scale`​ 方法有一个指针接收者，为方便起见，Go 会将语句 `v.Scale(5)`​ 解释为 `(&v).Scale(5)`​。\n\n```go\npackage main\n\nimport \"fmt\"\n\ntype Vertex struct {\n\tX, Y float64\n}\n\nfunc (v *Vertex) Scale(f float64) {\n\tv.X = v.X * f\n\tv.Y = v.Y * f\n}\n\nfunc ScaleFunc(v *Vertex, f float64) {\n\tv.X = v.X * f\n\tv.Y = v.Y * f\n}\n\nfunc main() {\n\tv := Vertex{3, 4}\n\tv.Scale(2)\n\tScaleFunc(&v, 10)\n\n\tp := &Vertex{4, 3}\n\tp.Scale(3)\n\tScaleFunc(p, 8)\n\n\tfmt.Println(v, p)\n}\n```\n\n同样的事情也发生在相反的方向。\n\n接受一个值作为参数的函数必须接受一个指定类型的值：\n\n```\nvar v Vertex\nfmt.Println(AbsFunc(v))  // OK\nfmt.Println(AbsFunc(&v)) // 编译错误！\n```\n\n而以值为接收者的方法被调用时，接收者既能为值又能为指针：\n\n```\nvar v Vertex\nfmt.Println(v.Abs()) // OK\np := &v\nfmt.Println(p.Abs()) // OK\n```\n\n这种情况下，方法调用 `p.Abs()`​ 会被解释为 `(*p).Abs()`​。\n\n‍\n\n## 5.5 选择值或指针作为接收者\n\n使用指针接收者的原因有二：\n\n首先，方法能够修改其接收者指向的值。\n\n其次，这样可以避免在每次调用方法时复制该值。若值的类型为大型结构体时，这样做会更加高效。\n\n在本例中，`Scale`​ 和 `Abs`​ 接收者的类型为 `*Vertex`​，即便 `Abs`​ 并不需要修改其接收者。\n\n通常来说，所有给定类型的方法都应该有值或指针接收者，但并不应该二者混用。\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Vertex struct {\n\tX, Y float64\n}\n\nfunc (v *Vertex) Scale(f float64) {\n\tv.X = v.X * f\n\tv.Y = v.Y * f\n}\n\nfunc (v *Vertex) Abs() float64 {\n\treturn math.Sqrt(v.X*v.X + v.Y*v.Y)\n}\n\nfunc main() {\n\tv := &Vertex{3, 4}\n\tfmt.Printf(\"Before scaling: %+v, Abs: %v\\n\", v, v.Abs())\n\tv.Scale(5)\n\tfmt.Printf(\"After scaling: %+v, Abs: %v\\n\", v, v.Abs())\n}\n\n结果显示是：\nBefore scaling: &{X:3 Y:4}, Abs: 5\nAfter scaling: &{X:15 Y:20}, Abs: 25\n```\n\n‍\n\n## 5. 6 接口 \n\n**接口类型** 是由一组方法签名定义的集合。\n\n> 参考文献 ：\n>\n> [接口常见知识](https://blog.kennycoder.io/2020/02/03/Golang-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3interface%E5%B8%B8%E8%A6%8B%E7%94%A8%E6%B3%95/)\n\n接口类型的变量可以保存任何实现了这些方法的值。\n\n> 接口就可以理解为一系列动作的集合  \n> **而某个struct能够实现里面的所有方法，那么这个struct就是这个接口的一个实现**\n\n**注意:** 示例代码的 22 行存在一个错误。由于 `Abs`​ 方法只为 `*Vertex`​ （指针类型）定义，因此 `Vertex`​（值类型）并未实现 `Abser`​。\n\n```go\ntype Abser interface {\n\tAbs() float64\n}\n\nfunc main() {\n\tvar a Abser\n\tf := MyFloat(-math.Sqrt2)\n\tv := Vertex{3, 4}\n\n\ta = f  // a MyFloat 实现了 Abser\n\ta = &v // a *Vertex 实现了 Abser\n\n\t// 下面一行，v 是一个 Vertex（而不是 *Vertex）\n\t// 所以没有实现 Abser。\n\ta = v\n\n\tfmt.Println(a.Abs())\n}\n\ntype MyFloat float64\n\nfunc (f MyFloat) Abs() float64 {\n\tif f < 0 {\n\t\treturn float64(-f)\n\t}\n\treturn float64(f)\n}\n\ntype Vertex struct {\n\tX, Y float64\n}\n\nfunc (v *Vertex) Abs() float64 {\n\treturn math.Sqrt(v.X*v.X + v.Y*v.Y)\n}\n\n显示错误：\n./prog.go:22:6: cannot use v (variable of type Vertex) as Abser value in assignment: Vertex does not implement Abser (method Abs has pointer receiver)\n```\n\n‍\n\n## 5.7 接口与隐式实现\n\n类型通过实现一个接口的所有方法来实现该接口。既然无需专门显式声明，也就没有“implements”关键字。\n\n隐式接口从接口的实现中解耦了定义，这样接口的实现可以出现在任何包中，无需提前准备。\n\n因此，也就无需在每一个实现上增加新的接口名称，这样同时也鼓励了明确的接口定义。\n\n```go\npackage main\n\nimport \"fmt\"\n\ntype I interface {\n\tM()\n}\n\ntype T struct {\n\tS string\n}\n\n// 此方法表示类型 T 实现了接口 I，但我们无需显式声明此事。\nfunc (t T) M() {\n\tfmt.Println(t.S)\n}\n\nfunc main() {\n\tvar i I = T{\"hello\"}\n\ti.M()\n}\n```\n\n‍\n\n## 5.8 接口值\n\n接口也是值。它们可以像其它值一样传递。\n\n接口值可以用作函数的参数或返回值。\n\n在内部，接口值可以看做包含值和具体类型的元组：\n\n```\n(value, type)\n```\n\n接口值保存了一个具体底层类型的具体值。\n\n接口值调用方法时会执行其底层类型的同名方法\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype I interface {\n\tM()\n}\n\ntype T struct {\n\tS string\n}\n\nfunc (t *T) M() {\n\tfmt.Println(t.S)\n}\n\ntype F float64\n\nfunc (f F) M() {\n\tfmt.Println(f)\n}\n\nfunc main() {\n\tvar i I\n\n\ti = &T{\"Hello\"}\n\tdescribe(i)\n\ti.M()\n\n\ti = F(math.Pi)\n\tdescribe(i)\n\ti.M()\n}\n\nfunc describe(i I) {\n\tfmt.Printf(\"(%v, %T)\\n\", i, i)\n}\n\n输出结果是：\n//因为 T 实现是传入（* T）\n\n(&{Hello}, *main.T)\nHello\n\n//因为 F 实现是传入（F）\n(3.141592653589793, main.F)\n3.141592653589793\n```\n\n在上述代码当中的接口值是：(&{Hello}, *main.T) 以及 (3.141592653589793, main.F)\n\n‍\n\n## 5.9 底层值为 nil 的接口值\n\n即便接口内的具体值为 nil，方法仍然会被 nil 接收者调用。\n\n在一些语言中，这会触发一个空指针异常，但在 Go 中通常会写一些方法来优雅地处理它（如本例中的 `M`​ 方法）。\n\n**注意:** 保存了 nil 具体值的接口其自身并不为 nil。\n\n```go\npackage main\n\nimport \"fmt\"\n\ntype I interface {\n\tM()\n}\n\ntype T struct {\n\tS string\n}\n\nfunc (t *T) M() {\n\tif t == nil {\n\t\tfmt.Println(\"<nil>\")\n\t\treturn\n\t}\n\tfmt.Println(t.S)\n}\n\nfunc main() {\n\tvar i I\n\n\tvar t *T\n\ti = t\n\tdescribe(i)\n\ti.M()\n\n\ti = &T{\"hello\"}\n\tdescribe(i)\n\ti.M()\n}\n\nfunc describe(i I) {\n\tfmt.Printf(\"(%v, %T)\\n\", i, i)\n}\n\n记结果输出为：\n(<nil>, *main.T)\n<nil>\n(&{hello}, *main.T)\nhello\n```\n\n‍\n\n## 5.10 nil 接口值\n\nnil 接口值既不保存值也不保存具体类型。\n\n为 nil 接口调用方法会产生运行时错误，因为接口的元组内并未包含能够指明该调用哪个 **具体** 方法的类型。\n\n```go\npackage main\n\nimport \"fmt\"\n\ntype I interface {\n\tM()\n}\n\nfunc main() {\n\tvar i I\n\tdescribe(i)\n\ti.M()\n}\n\nfunc describe(i I) {\n\tfmt.Printf(\"(%v, %T)\\n\", i, i)\n}\n\n```\n\n```go\n上述代码会显示：\n(<nil>, <nil>)\npanic: runtime error: invalid memory address or nil pointer dereference\n[signal SIGSEGV: segmentation violation code=0x1 addr=0x0 pc=0x481961]\n\ngoroutine 1 [running]:\nmain.main()\n\t/tmp/sandbox4223192970/prog.go:12 +0x61\n```\n\n‍\n\n以上两者是不同的概念：\n\n第一个是接口对象不为空，但是对象指向的地方为空，也就是说接口申明了之后，还是给了他一个赋值的对象，但这个对象可能还没有初始化\n\n第二个是接口对象为空\n\n‍\n\n## 5.11 空接口\n\n指定了零个方法的接口值被称为 *空接口：*\n\n```\ninterface{}\n```\n\n空接口可保存任何类型的值。（因为每个类型都至少实现了零个方法。）\n\n空接口被用来处理未知类型的值。例如，`fmt.Print`​ 可接受类型为 `interface{}`​ 的任意数量的参数。\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tvar i interface{}\n\tdescribe(i)\n\n\ti = 42\n\tdescribe(i)\n\n\ti = \"hello\"\n\tdescribe(i)\n}\n\nfunc describe(i interface{}) {\n\tfmt.Printf(\"(%v, %T)\\n\", i, i)\n}\n```\n\n‍\n\n## 5.12 类型断言\n\n> [断言具体释义](https://blog.kalan.dev/posts/golang-type-assertion)\n\n**类型断言** 提供了**访问接口值底层具体值**的方式。\n\n```\nt := i.(T)\n```\n\n该语句断言接口值 `i`​ 保存了具体类型 `T`​，并将其底层类型为 `T`​ 的值赋予变量 `t`​。\n\n若 `i`​ 并未保存 `T`​ 类型的值，该语句就会触发一个恐慌。\n\n为了 **判断** 一个接口值是否保存了一个特定的类型，类型断言可返回两个值：其底层值以及一个报告断言是否成功的布尔值。\n\n```\nt, ok := i.(T)\n```\n\n若 `i`​ 保存了一个 `T`​，那么 `t`​ 将会是其底层值，而 `ok`​ 为 `true`​。\n\n否则，`ok`​ 将为 `false`​ 而 `t`​ 将为 `T`​ 类型的零值，程序并不会产生恐慌。\n\n请注意这种语法和读取一个映射时的相同之处。\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tvar i interface{} = \"hello\"\n\n\ts := i.(string)\n\tfmt.Println(s)\n\n\ts, ok := i.(string)\n\tfmt.Println(s, ok)\n\n\tf, ok := i.(float64)\n\tfmt.Println(f, ok)\n\n\tf = i.(float64) // 报错(panic)\n\tfmt.Println(f)\n}\n\n\n结果显示为：\nhello\nhello true\n0 false\npanic: interface conversion: interface {} is string, not float64\n```\n\n‍\n\n## 5.13 类型选择\n\n**类型选择** 是一种按顺序从几个类型断言中选择分支的结构。\n\n类型选择与一般的 switch 语句相似，不过类型选择中的 case 为类型（而非值）， 它们针对给定接口值所存储的值的类型进行比较。\n\n```\nswitch v := i.(type) {\ncase T:\n    // v 的类型为 T\ncase S:\n    // v 的类型为 S\ndefault:\n    // 没有匹配，v 与 i 的类型相同\n}\n```\n\n类型选择中的声明与类型断言 `i.(T)`​ 的语法相同，**只是具体类型 ​****`T`****​ 被替换成了关键字 ​****`type`****。**\n\n此选择语句判断接口值 `i`​ 保存的值类型是 `T`​ 还是 `S`​。在 `T`​ 或 `S`​ 的情况下，变量 `v`​ 会分别按 `T`​ 或 `S`​ 类型保存 `i`​ 拥有的值。在默认（即没有匹配）的情况下，变量 `v`​ 与 `i`​ 的接口类型和值相同。\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc do(i interface{}) {\n\tswitch v := i.(type) {\n\tcase int:\n\t\tfmt.Printf(\"Twice %v is %v\\n\", v, v*2)\n\tcase string:\n\t\tfmt.Printf(\"%q is %v bytes long\\n\", v, len(v))\n\tdefault:\n\t\tfmt.Printf(\"I don't know about type %T!\\n\", v)\n\t}\n}\n\nfunc main() {\n\tdo(21)\n\tdo(\"hello\")\n\tdo(true)\n}\n\n结果是：\nTwice 21 is 42\n\"hello\" is 5 bytes long\nI don't know about type bool!\n```\n\n‍\n\n## 5. 14 Stringer\n\n[fmt](https://go-zh.org/pkg/fmt/)``​ 包中定义的 [Stringer](https://go-zh.org/pkg/fmt/#Stringer)``​ 是最普遍的接口之一。\n\n```\ntype Stringer interface {\n    String() string\n}\n```\n\n`Stringer`​ 是一个可以用字符串描述自己的类型。`fmt`​ 包（还有很多包）都通过此接口来打印值。\n\n```go\npackage main\n\nimport \"fmt\"\n\ntype Person struct {\n\tName string\n\tAge  int\n}\n\nfunc (p Person) String() string {\n\treturn fmt.Sprintf(\"%v (%v years)\", p.Name, p.Age)\n}\n\nfunc main() {\n\ta := Person{\"Arthur Dent\", 42}\n\tz := Person{\"Zaphod Beeblebrox\", 9001}\n\tfmt.Println(a, z)\n}\n\n```\n\n‍\n\n## 5. 15 错误\n\nGo 程序使用 `error`​ 值来表示错误状态。\n\n与 `fmt.Stringer`​ 类似，`error`​ 类型是一个内建接口：\n\n```\ntype error interface {\n    Error() string\n}\n```\n\n（与 `fmt.Stringer`​ 类似，`fmt`​ 包在打印值时也会满足 `error`​。）\n\n通常函数会返回一个 `error`​ 值，调用的它的代码应当判断这个错误是否等于 `nil`​ 来进行错误处理。\n\n```\ni, err := strconv.Atoi(\"42\")\nif err != nil {\n    fmt.Printf(\"couldn't convert number: %v\\n\", err)\n    return\n}\nfmt.Println(\"Converted integer:\", i)\n```\n\n`error`​ 为 nil 时表示成功；非 nil 的 `error`​ 表示失败\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\ntype MyError struct {\n\tWhen time.Time\n\tWhat string\n}\n\nfunc (e *MyError) Error() string {\n\treturn fmt.Sprintf(\"at %v, %s\",\n\t\te.When, e.What)\n}\n\nfunc run() error {\n\treturn &MyError{\n\t\ttime.Now(),\n\t\t\"it didn't work\",\n\t}\n}\n\nfunc main() {\n\tif err := run(); err != nil {\n\t\tfmt.Println(err)\n\t}\n}\n\n```\n\n\n\n## 5. 16 Reader\n\n`io`​ 包指定了 `io.Reader`​ 接口，它表示从数据流的末尾进行读取。\n\nGo 标准库包含了该接口的[许多实现](https://go-zh.org/search?q=Read#Global)，包括文件、网络连接、压缩和加密等等。\n\n`io.Reader`​ 接口有一个 `Read`​ 方法：\n\n```\nfunc (T) Read(b []byte) (n int, err error)\n```\n\n`Read`​ 用数据填充给定的字节切片并返回填充的字节数和错误值。在遇到数据流的结尾时，它会返回一个 `io.EOF`​ 错误。\n\n示例代码创建了一个 [strings.Reader](https://go-zh.org/pkg/strings/#Reader)``​ 并以每次 8 字节的速度读取它的输出。\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"strings\"\n)\n\nfunc main() {\n\tr := strings.NewReader(\"Hello, Reader!\")\n\n\tb := make([]byte, 8)\n\tfor {\n\t\tn, err := r.Read(b)\n\t\tfmt.Printf(\"n = %v err = %v b = %v\\n\", n, err, b)\n\t\tfmt.Printf(\"b[:n] = %q\\n\", b[:n])\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t}\n\t}\n}\n\n输出结果是：\nn = 8 err = <nil> b = [72 101 108 108 111 44 32 82]\nb[:n] = \"Hello, R\"\nn = 6 err = <nil> b = [101 97 100 101 114 33 32 82]\nb[:n] = \"eader!\"\nn = 0 err = EOF b = [101 97 100 101 114 33 32 82]\nb[:n] = \"\"\n```\n\n‍\n\n‍\n\n## 5.17 图像\n\n[image](https://go-zh.org/pkg/image/#Image)``​ 包定义了 `Image`​ 接口：\n\n```\npackage image\n\ntype Image interface {\n    ColorModel() color.Model\n    Bounds() Rectangle\n    At(x, y int) color.Color\n}\n```\n\n**注意:** `Bounds`​ 方法的返回值 `Rectangle`​ 实际上是一个 [image.Rectangle](https://go-zh.org/pkg/image/#Rectangle)``​，它在 `image`​ 包中声明。\n\n（请参阅[文档](https://go-zh.org/pkg/image/#Image)了解全部信息。）\n\n`color.Color`​ 和 `color.Model`​ 类型也是接口，但是通常因为直接使用预定义的实现 `image.RGBA`​ 和 `image.RGBAModel`​ 而被忽视了。这些接口和类型由 [image/color](https://go-zh.org/pkg/image/color/)``​ 包定义。\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"image\"\n)\n\nfunc main() {\n\tm := image.NewRGBA(image.Rect(0, 0, 100, 100))\n\tfmt.Println(m.Bounds())\n\tfmt.Println(m.At(0, 0).RGBA())\n}\n\n```\n\n# 6.  并发编程\n\n## 6.1  Go 协程\n\nGo 协程（goroutine）是由 Go 运行时管理的轻量级线程。\n\n```\ngo f(x, y, z)\n```\n\n会启动一个新的 Go 程并执行\n\n```\nf(x, y, z)\n```\n\n`f`​, `x`​, `y`​ 和 `z`​ 的求值发生在当前的 Go 程中，而 `f`​ 的执行发生在新的 Go 程中。\n\nGo 程在相同的地址空间中运行，因此在访问共享的内存时必须进行同步。[sync](https://go-zh.org/pkg/sync/)``​ 包提供了这种能力，不过在 Go 中并不经常用到。\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc say(s string) {\n\tfor i := 0; i < 5; i++ {\n\t\ttime.Sleep(100 * time.Millisecond)\n\t\tfmt.Println(s)\n\t}\n}\n\nfunc main() {\n\tgo say(\"world\")\n\tsay(\"hello\")\n}\n```\n\n‍\n\n## 6.2 信道\n\n信道是带有类型的管道，你可以通过它用信道操作符 `<-`​ 来发送或者接收值。\n\n```\nch <- v    // 将 v 发送至信道 ch。\nv := <-ch  // 从 ch 接收值并赋予 v。\n```\n\n（“箭头”就是数据流的方向。）\n\n和映射与切片一样，信道在使用前必须创建，也是使用make的形式创建\n\n```\nch := make(chan int)\n```\n\n默认情况下，发送和接收操作在另一端准备好之前都会阻塞。这使得 Go 程可以在没有显式的锁或竞态变量的情况下进行同步。\n\n以下示例对切片中的数进行求和，将任务分配给两个 Go 程。一旦两个 Go 程完成了它们的计算，它就能算出最终的结果。\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc sum(s []int, c chan int) {\n\tsum := 0\n\tfor _, v := range s {\n\t\tsum += v\n\t}\n\tc <- sum // 将和送入 c\n}\n\nfunc main() {\n\ts := []int{7, 2, 8, -9, 4, 0}\n\n\tc := make(chan int)\n\tgo sum(s[:len(s)/2], c)\n\tgo sum(s[len(s)/2:], c)\n\tx, y := <-c, <-c // 从 c 中接收\n\n\tfmt.Println(x, y, x+y)\n}\n\n结果显示为：\n-5 17 12\n```\n\n**同时也可以知道 信道的结构是队列类型，先进先出**\n\n‍\n\n‍\n\n## 6.3 项目带缓冲的信道\n\n信道可以是 *带缓冲的*。将缓冲长度作为第二个参数提供给 `make`​ 来初始化一个带缓冲的信道：\n\n```\nch := make(chan int, 100)\n```\n\n仅当信道的缓冲区填满后，向其发送数据时才会阻塞。当缓冲区为空时，接受方会阻塞。\n\n修改示例填满缓冲区，然后看看会发生什么。\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tch := make(chan int, 2)\n\tch <- 1\n\tch <- 2\n\tfmt.Println(<-ch)\n\tfmt.Println(<-ch)\n}\n```\n\n‍\n\n## 6. 4 信道使用 range 和 close\n\n发送者可通过 `close`​ 关闭一个信道来表示没有需要发送的值了。接收者可以通过为接收表达式分配第二个参数来测试信道是否被关闭：若没有值可以接收且信道已被关闭，那么在执行完\n\n```\nv, ok := <-ch\n```\n\n之后 `ok`​ 会被设置为 `false`​。\n\n循环 `for i := range c`​ 会不断从信道接收值，直到它被关闭。\n\n*注意：* 只有发送者才能关闭信道，而接收者不能。向一个已经关闭的信道发送数据会引发程序恐慌（panic）。\n\n*还要注意：* 信道与文件不同，通常情况下无需关闭它们。只有在必须告诉接收者不再有需要发送的值时才有必要关闭，例如终止一个 `range`​ 循环。\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc fibonacci(n int, c chan int) {\n\tx, y := 0, 1\n\tfor i := 0; i < n; i++ {\n\t\tc <- x\n\t\tx, y = y, x+y\n\t}\n\tclose(c)\n}\n\nfunc main() {\n\tc := make(chan int, 10)\n\tgo fibonacci(cap(c), c)\n\tfor i := range c {\n\t\tfmt.Println(i)\n\t}\n}\n\n结果显示为：\n0\n1\n1\n2\n3\n5\n8\n13\n21\n34\n```\n\n‍\n\n## 6.5 Go 語言如何從 Channel 讀取資料\n\n> 参考文献：\n>\n> [Chan的读取方式](https://blog.wu-boy.com/2022/05/read-data-from-channel-in-go/)\n\n‍\n\n## 6.6 select 语句\n\n`select`​ 语句使一个 Go 程可以等待多个通信操作。\n\n`select`​ 会阻塞到某个分支可以继续执行为止，这时就会执行该分支。当多个分支都准备好时会随机选择一个执行。\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc fibonacci(c, quit chan int) {\n\tx, y := 0, 1\n\tfor {\n\t\tselect {\n\t\tcase c <- x:\n\t\t\tx, y = y, x+y\n\t\tcase <-quit:\n\t\t\tfmt.Println(\"quit\")\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc main() {\n\tc := make(chan int)\n\tquit := make(chan int)\n\tgo func() {\n\t\tfor i := 0; i < 10; i++ {\n\t\t\tfmt.Println(<-c)\n\t\t}\n\t\tquit <- 0\n\t}()\n\tfibonacci(c, quit)\n}\n```\n\n‍\n\n## 6.7 默认选择\n\n当 `select`​ 中的其它分支都没有准备好时，`default`​ 分支就会执行。\n\n为了在尝试发送或者接收时不发生阻塞，可使用 `default`​ 分支：\n\n```\nselect {\ncase i := <-c:\n    // 使用 i\ndefault:\n    // 从 c 中接收会阻塞时执行\n}\n```\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\ttick := time.Tick(100 * time.Millisecond)\n\tboom := time.After(500 * time.Millisecond)\n\tfor {\n\t\tselect {\n\t\tcase i := <-tick:\n\t\t\tfmt.Println(i)\n\t\t\tfmt.Println(\"tick.\")\n\t\tcase <-boom:\n\t\t\tfmt.Println(\"BOOM!\")\n\t\t\treturn\n\t\tdefault:\n\t\t\tfmt.Println(\"    .\")\n\t\t\ttime.Sleep(50 * time.Millisecond)\n\t\t}\n\t}\n}\n```\n\n输出为：\n\n```go\n    .\n    .\n2009-11-10 23:00:00.1 +0000 UTC m=+0.100000001\ntick.\n    .\n    .\n    .\n2009-11-10 23:00:00.2 +0000 UTC m=+0.200000001\ntick.\n    .\n2009-11-10 23:00:00.3 +0000 UTC m=+0.300000001\ntick.\n    .\n    .\n2009-11-10 23:00:00.4 +0000 UTC m=+0.400000001\ntick.\n    .\n    .\nBOOM!\n```\n\n‍\n\n## 6.8 sync.Mutex\n\n我们已经看到信道非常适合在各个 Go 程间进行通信。\n\n但是如果我们并不需要通信呢？比如说，若我们只是想保证每次只有一个 Go 程能够访问一个共享的变量，从而避免冲突？\n\n这里涉及的概念叫做 *互斥（mutual*exclusion）* ，我们通常使用 *互斥锁（Mutex）* 这一数据结构来提供这种机制。\n\nGo 标准库中提供了 [sync.Mutex](https://go-zh.org/pkg/sync/#Mutex)``​ 互斥锁类型及其两个方法：\n\n* `Lock`​\n* `Unlock`​\n\n我们可以通过在代码前调用 `Lock`​ 方法，在代码后调用 `Unlock`​ 方法来保证一段代码的互斥执行。参见 `Inc`​ 方法。\n\n我们也可以用 `defer`​ 语句来保证互斥锁一定会被解锁。参见 `Value`​ 方法。\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\n// SafeCounter 的并发使用是安全的。\ntype SafeCounter struct {\n\tv   map[string]int\n\tmux sync.Mutex\n}\n\n// Inc 增加给定 key 的计数器的值。\nfunc (c *SafeCounter) Inc(key string) {\n\tc.mux.Lock()\n\t// Lock 之后同一时刻只有一个 goroutine 能访问 c.v\n\tc.v[key]++\n\tc.mux.Unlock()\n}\n\n// Value 返回给定 key 的计数器的当前值。\nfunc (c *SafeCounter) Value(key string) int {\n\tc.mux.Lock()\n\t// Lock 之后同一时刻只有一个 goroutine 能访问 c.v\n\tdefer c.mux.Unlock()\n\treturn c.v[key]\n}\n\nfunc main() {\n\tc := SafeCounter{v: make(map[string]int)}\n\tfor i := 0; i < 1000; i++ {\n\t\tgo c.Inc(\"somekey\")\n\t}\n\n\ttime.Sleep(time.Second)\n\tfmt.Println(c.Value(\"somekey\"))\n}\n\n```\n\n‍\n\n# 练习题目（自己答案系列）\n\n## 练习：Stringer\n\n通过让 `IPAddr`​ 类型实现 `fmt.Stringer`​ 来打印点号分隔的地址。\n\n例如，`IPAddr{1, 2, 3, 4}`​ 应当打印为 `\"1.2.3.4\"`​。\n\n```go\npackage main\n\nimport \"fmt\"\n\ntype IPAddr [4]byte\n\n// TODO: 给 IPAddr 添加一个 \"String() string\" 方法\nfunc (ip *IPAddr) String() string{\n\tipAddr:= fmt.Sprintf(\"%d.%d.%d.%d\",ip[0],ip[1],ip[2],ip[3])\n\treturn string(ipAddr)\n\n}\n\n\nfunc main() {\n\thosts := map[string]IPAddr{\n\t\t\"loopback\":  {127, 0, 0, 1},\n\t\t\"googleDNS\": {8, 8, 8, 8},\n\t}\n\tfor name, ip := range hosts {\n\t\tfmt.Printf(\"%v: %v\\n\", name, ip.String())\n\t}\n}\n```\n\n```go\nloopback: 127.0.0.1\ngoogleDNS: 8.8.8.8\n```\n\n‍","source":"_posts/Go/Go-basic-knowledge/Go-basic-knowledge.md","raw":"---\ntitle: Go basic knowledge\ncatalog: true\ndate: 2023-02-10 01:16:19\nsubtitle:\nheader-img:\ntags:\ncategories: \n\t- Basic\n---\n# Go 入门知识\n\n> 本章节内容基于 https://tour.go-zh.org/  [Go语言测试平台](https://tour.go-zh.org/list) 索引整理完成\n>\n> 答案训练参考：\n>\n> https://gist.github.com/zyxar/2317744\n>\n> https://gist.github.com/CarlosLanderas/11b4f6727deec051883ddc02edf5cd0b\n>\n> 一些有用书籍索引：\n>\n> [Go语言圣经（中文版）](https://books.studygolang.com/gopl-zh/)\n>\n> [Go语言入门教程，Golang入门教程](http://c.biancheng.net/golang/)\n>\n> [《Go语言标准库》](https://books.studygolang.com/The-Golang-Standard-Library-by-Example/)\n\n# 1. Go 包相关\n\n## 1.1 路径\n\n每个 Go 程序都是由包构成的。\n\n程序从 `main`​​​ 包开始运行。\n\n比如通过导入路径 `\"fmt\"`​​ 和 `\"math/rand\"`​​ 来使用这两个包。\n\n按照约定，包名与导入路径的最后一个元素一致。例如，`\"math/rand\"`​​​ 包中的源码均以 `package rand`​​​ 语句开始。\n\n‍\n\n## 1.2 导入包\n\n圆括号组合了导入，这是“分组”形式的导入语\n\n# 2. 变量\n\n注意类型在变量名之后 \n\n```go\ny int\n```\n\n‍\n\n`var`​​​ 语句用于声明一个变量列表，跟函数的参数列表一样，类型在最后\n\n```go\nvar a ,b c, d int\n```\n\n变量声明可以包含初始值，每个变量对应一个， 逗号隔开，如果初始化值已存在，则可以省略类型；变量会从初始值中获得类型。\n\n```go\nvar i, j int = 1, 2\nvar c, python, java = true, false, \"no!\"\n```\n\n‍\n\n简洁赋值语句 `:=`​​​ 可在类型明确的地方代替 `var`​​​ 声明。\n\n函数外的每个语句都必须以关键字开始（`var`​​​, `func`​​​ 等等），因此 ​`:=`​​​​ 结构不能在函数外使用[相较之下 var 可以写到函数外面，在包层级]\n\n```go\n\tk := 3\n\tc, python, java := true, false, \"no!\"\n```\n\n‍\n\n**Go 的基本类型有**\n\n```\nbool\n\nstring\n\nint  int8  int16  int32  int64\nuint uint8 uint16 uint32 uint64 uintptr\n\nbyte // uint8 的别名\n\nrune // int32 的别名\n    // 表示一个 Unicode 码点\n\nfloat32 float64\n\ncomplex64 complex128\n```\n\n本例展示了几种类型的变量。 同导入语句一样，变量声明也可以“分组”成一个语法块。\n\n```go\nvar (\n\tToBe   bool       = false\n\tMaxInt uint64     = 1<<64 - 1\n\tz      complex128 = cmplx.Sqrt(-5 + 12i)\n)\n```\n\n`int`​​​, `uint`​​​ 和 `uintptr`​​​ 在 32 位系统上通常为 32 位宽，在 64 位系统上则为 64 位宽。 当你需要一个整数值时应使用 `int`​​​ 类型，除非你有特殊的理由使用固定大小或无符号的整数类型。\n\n‍\n\n没有明确初始值的变量声明会被赋予它们的 **零值**。\n\n零值是：\n\n* 数值类型为 `0`​​​，\n* 布尔类型为 `false`​​​，\n* 字符串为 `\"\"`​​​（空字符串）。\n\n‍\n\n表达式 `T(v)`​​​ 将值 `v`​​​ 转换为类型 `T`​​​。\n\n一些关于数值的转换：\n\n```\nvar i int = 42\nvar f float64 = float64(i)\nvar u uint = uint(f)\n```\n\n或者，更加简单的形式：\n\n```\ni := 42\nf := float64(i)\nu := uint(f)\n```\n\n与 C 不同的是，Go 在不同类型的项之间赋值时需要显式转换,，等号右边的数值必须是类型明确的\n\n‍\n\n## 2.1 常量\n\n常量的声明与变量类似，只不过是使用 `const`​​​ 关键字。\n\n常量可以是字符、字符串、布尔值或数值。\n\n常量不能用 `:=`​​​ 语法声明。\n\n```go\nconst World = \"世界\"\n//相较之下，这个申明的world是一个变量，也就是可以改变其类型的\nworld := \"世界\"\n\n\tconst World = \"世界\"\n\tfmt.Println(\"Hello\", World)\n\n\tworld := \"世界\"\n\tfmt.Println(\"Go rules?\", world)\n\tworld = \"是吗\"\n\tfmt.Println(\"Go rules?\", world)\n\t结果是：\n\tHello 世界\n\tGo rules? 世界\n\tGo rules? 是吗\n```\n\n‍\n\n## 2.2 类型推导\n\n在声明一个变量而不指定其类型时（即使用不带类型的 `:=`​​​ 语法或 `var =`​​​ 表达式语法），变量的类型由右值推导得出。\n\n当右值声明了类型时，新变量的类型与其相同：\n\n```\nvar i int\nj := i // j 也是一个 int\n```\n\n不过当右边包含未指明类型的数值常量时，新变量的类型就可能是 `int`​​​, `float64`​​​ 或 `complex128`​​​ 了，这取决于常量的精度：\n\n```\ni := 42           // int\nf := 3.142        // float64\ng := 0.867 + 0.5i // complex128\n```\n\n‍\n\n## 2.3 数值常量\n\n数值常量是高精度的 **值**。\n\n一个未指定类型的常量由上下文来决定其类型。\n\n再尝试一下输出 `needInt(Big)`​​​ 吧。\n\n（`int`​​​ 类型最大可以存储一个 64 位的整数，有时会更小。）\n\n（`int`​​​​ 可以存放最大64位的整数，根据平台不同有时会更少。）\n\n```go\nconst (\n\t// 将 1 左移 100 位来创建一个非常大的数字\n\t// 即这个数的二进制是 1 后面跟着 100 个 0\n\tBig = 1 << 100\n\t// 再往右移 99 位，即 Small = 1 << 1，或者说 Small = 2\n\tSmall = Big >> 99\n)\n```\n\n# 3. 语句\n\n## 3.1 if\n\nGo 的 `if`​​​​ 语句与 `for`​​​​ 循环类似，表达式外无需小括号 `( )`​​​​ ，而大括号 `{ }`​​​​ 则是必须的。\n\n```go\nif x < 0 {\n\treturn sqrt(-x) + \"i\"\n}\n```\n\n## 3.2 for\n\nGo 只有一种循环结构：`for`​​​ 循环。\n\n基本的 `for`​​​ 循环由三部分组成，它们用分号隔开：\n\n* 初始化语句：在第一次迭代前执行\n* 条件表达式：在每次迭代前求值\n* 后置语句：在每次迭代的结尾执行\n\n初始化语句通常为一句短变量声明，该变量声明仅在 `for`​​​ 语句的作用域中可见。\n\n一旦条件表达式的布尔值为 `false`​​​，循环迭代就会终止。\n\n初始化语句和后置语句是可选的，也就是说完全可以只有一个条件，其含义也变成了wihle语句，但是go里面没有while只有for\n\n**注意**：和 C、Java、JavaScript 之类的语言不同，**Go 的 for 语句后面的三个构成部分外没有小括号**， 而包围函数主体的大括号 `{ }`​​​​ 则是必须的。\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tsum := 0\n\tfor i := 0; i < 10; i++ {\n\t\tsum += i\n\t}\n\tfmt.Println(sum)\n}\n\n\nfunc main() {\n\tsum := 1\n\tfor sum < 1000{\n\t\tsum += sum\n\t}\n\tfmt.Println(sum)\n}\n\n```\n\n‍\n\n## 3.3 if 的简短语句\n\n同 `for`​​​ 一样， `if`​​​ 语句可以在条件表达式前执行一个简单的语句。\n\n**该语句声明的变量作用域仅在 ​****`if`**​​​**​ 之内。**也就是说出了if语句，这个变量就没有了\n\n```go\nfunc pow(x, n, lim float64) float64 {\n\tif v := math.Pow(x, n); v < lim {\n\t\treturn v\n\t}\n\treturn lim\n}\n```\n\n‍\n\n## 3.4 if 和 else\n\n在 `if`​​ 的简短语句中声明的变量同样可以在任何对应的 `else`​​ 块中使用。\n\n```go\nif v := math.Pow(x, n); v < lim {\n\t\treturn v\n\t} else {\n\t\tfmt.Printf(\"%g >= %g\\n\", v, lim)\n\t}\n\n\n//一般格式是：\nif {\n}else if {\n}else {}\n```\n\n  \n\n## 3.5 switch\n\n`switch`​​ 是编写一连串 `if - else`​​ 语句的简便方法。它运行第一个值等于条件表达式的 case 语句。\n\nGo 的 switch 语句类似于 C、C++、Java、JavaScript 和 PHP 中的，不过 Go 只运行选定的 case，而非之后所有的 case。 实际上，Go 自动提供了在这些语言中每个 case 后面所需的 `break`​​ 语句。 除非以 `fallthrough`​​ 语句结束，否则分支会自动终止。 Go 的另一点重要的不同在于 switch 的 case 无需为常量，且取值不必为整数。\n\n```go\n\tswitch os := runtime.GOOS; os {\n\tcase \"darwin\":\n\t\tfmt.Println(\"OS X.\")\n\tcase \"linux\":\n\t\tfmt.Println(\"Linux.\")\n\tdefault:\n\t\t// freebsd, openbsd,\n\t\t// plan9, windows...\n\t\tfmt.Printf(\"%s.\\n\", os)\n\t}\n```\n\n‍\n\n## 3.6 switch 的求值顺序\n\nswitch 的 case 语句从上到下顺次执行，直到匹配成功时停止。\n\n（例如，  \n\n```\nswitch i {\ncase 0:\ncase f():\n}\n```\n\n在 `i==0`​​ 时 `f`​​ 不会被调用。  \n\n```go\n\ttoday := time.Now().Weekday()\n\tswitch time.Saturday {\n\tcase today + 0:\n\t\tfmt.Println(\"Today.\")\n\tcase today + 1:\n\t\tfmt.Println(\"Tomorrow.\")\n\tcase today + 2:\n\t\tfmt.Println(\"In two days.\")\n\tdefault:\n\t\tfmt.Println(\"Too far away.\")\n\t}\n```\n\n\n\n## 3.7 没有条件的 switch\n\n没有条件的 switch 同 `switch true`​​ 一样。\n\n这种形式能将一长串 if-then-else 写得更加清晰。\n\n```go\nt := time.Now()\n\tswitch {\n\tcase t.Hour() < 12:\n\t\tfmt.Println(\"Good morning!\")\n\tcase t.Hour() < 17:\n\t\tfmt.Println(\"Good afternoon.\")\n\tdefault:\n\t\tfmt.Println(\"Good evening.\")\n\t}\n```\n\n‍\n\n## 3.8 defer\n\ndefer 语句会将函数推迟到外层函数返回之后执行。\n\n推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用。\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tdefer fmt.Println(\"world\")\n\n\tfmt.Println(\"hello\")\n}\n结果是：\nhello\nworld\n```\n\n‍\n\n## 3.9 defer 栈\n\n推迟的函数调用会被压入一个栈中。当外层函数返回时，被推迟的函数会按照后进先出的顺序调用。  \n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tfmt.Println(\"counting\")\n\n\tfor i := 0; i < 10; i++ {\n\t\tdefer fmt.Println(i)\n\t}\n\n\tfmt.Println(\"done\")\n}\n由于是按照栈的形式来存的\ncounting\ndone\n9\n8\n7\n6\n5\n4\n3\n2\n1\n0\n```\n\n[Defer，Panic,Recover](https://blog.go-zh.org/defer-panic-and-recover)\n\n‍\n\n## 3.10 函数返回\n\n函数可以返回任意数量的返回值, 但是结构上需要结合函数形式\n\n```go\nfunc swap(x, y string) (string, string) {\n\treturn y, x\n}\n```\n\n‍\n\nGo 的返回值可被命名，它们会被视作定义在函数顶部的变量。\n\n返回值的名称应当具有一定的意义，它可以作为文档使用。\n\n没有参数的 `return`​ 语句返回已命名的返回值。也就是 `直接`​ 返回。\n\n直接返回语句应当仅用在下面这样的短函数中。在长的函数中它们会影响代码的可读性。\n\n(x, y int) 中的（）不可以省略\n\n```go\nfunc split(sum int) (x, y int) {\n\tx = sum * 4 / 9\n\ty = sum - x\n\treturn\n}\n```\n\n‍\n\n‍\n\n## 3.11 Retrun and Defer\n\n> ‍\n\n![image](Y:/Blog/blog/source/_posts/Go/Go-basic-knowledge/assets/image-20230228154553-m65t587.png)​\n\n```go\npackage main\n \nimport \"fmt\"\n \n// return语句执行步骤\n// 1、返回值赋值\n// 2、defer语句\n// 3、真正RET返回\nfunc f0() (x int) {\n\tx = 5\n\tdefer func() {\n\t\tx++\n\t}()\n\treturn x //返回值RET=x, x++, RET=x=6\n}\n \nfunc f1() int {\n\tx := 5\n\tdefer func() {\n\t\tx++ //修改的是x，不是返回值\n\t}()\n\treturn x //返回值RET=5, x++, RET=5\n}\n \nfunc f2() (x int) {\n\tdefer func() {\n\t\tx++\n\t}()\n\treturn 5 //返回值RET=x=5, x++, RET=6\n}\n \nfunc f3() (y int) {\n\tx := 5\n\tdefer func() {\n\t\tx++\n\t}()\n\treturn x //返回值RET=y=x=5, x++, RET=5\n}\n \nfunc f4() (x int) {\n\tdefer func(x int) {\n\t\tx++\n\t}(x)\n\treturn 5 //返回值RET=x=5, x`++, RET=5\n}\n \nfunc main() {\n\tfmt.Println(f0()) //6\n\tfmt.Println(f1()) //5\n\tfmt.Println(f2()) //6\n\tfmt.Println(f3()) //5\n\tfmt.Println(f4()) //5\n}\n```\n\n要注意的是实际返回的值和在函数内运算的值是不相同的对象，存在一个赋值的过程\n\n首先要明确 defer 后紧接的代码可以有两种写法：\n\n> 参考文章： \n>\n> [Golang中defer和return的执行顺序 + 相关测试题（面试常考）](https://blog.csdn.net/qq_37102984/article/details/128946146?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EAD_ESQUERY%7Eyljh-1-128946146-blog-116449166.pc_relevant_3mothn_strategy_and_data_recovery&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EAD_ESQUERY%7Eyljh-1-128946146-blog-116449166.pc_relevant_3mothn_strategy_and_data_recovery)\n>\n> [Golang Defer 深入理解](https://blog.csdn.net/qq_14997473/article/details/116449166)\n>\n> [汇编层面](https://cloud.tencent.com/developer/article/1453355)\n>\n> [Return的机制](https://haicoder.net/golang/golang-return.html)\n\n* defer + 表达式，例如：  \n  此时就会直接保留当前变量 x 已有的值到栈中，一直到最后直接打印输出，不再受后续 return x 结果的影响。例如$t e s t 1$ 和 $t e s t 2$中的变量 x 。 **例如 test1 和 test2 中的变量 x。**\n\n  ```go\n  defer fmt.Printf(\"in defer: x = %d\\n\", x\n  ```\n\n* defer + 匿名函数（无入参/有入参），例如：\n\n  ```go\n  defer func() {fmt.Printf(\"in defer: x = %d\\n\", x)}()\n  或者是\n  defer func(n int) {fmt.Printf(\"in defer x as parameter: x = %d\\n\", n) fmt.Printf(\"in defer x after return: x = %d\\n\", x)}(x)\n  ```\n\n  此时需要区分打印输出的变量到底是【defer匿名函数内要访问的变量 n】，还是【defer匿名函数内要访问的变量 x】。\n\n  * 针对【defer匿名函数内要访问的变量 n】，其值取决于在一开始遇到 defer 时入参 n 的值（也就是最开始还没被改变时的变量 x 的值，起初是0）。这个变量 n 的值是独立的，不会受后续 return x 结果的影响。\n  * 针对【defer匿名函数内要访问的变量 x】，由于匿名函数能访问外部函数的变量，也就是说【defer匿名函数内要访问的变量 x】最终会被【defer匿名函数外最终要 return 返回出去的变量 x】所影响。\n\n‍\n\n‍\n\n# 4. 结构及指针\n\n## 4.1 指针\n\nGo 拥有指针。指针保存了值的内存地址。\n\n类型 `*T`​ 是指向 `T`​ 类型值的指针。其零值为 `nil`​。\n\n```\nvar p *int\n```\n\n`&`​​ 操作符会生成一个指向其操作数的指针。\n\n所以当赋值的时候，或者是传输的时候只能够只用&p来表示获取到p的地址，*p是地址指向的内容\n\n```\ni := 42\np = &i\n```\n\n`*`​ 操作符表示指针指向的底层值。\n\n```\nfmt.Println(*p) // 通过指针 p 读取 i\n*p = 21         // 通过指针 p 设置 i\n```\n\n这也就是通常所说的“间接引用”或“重定向”。\n\n与 C 不同，Go 没有指针运算。\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\ti, j := 42, 2701\n\n\tp := &i         // 指向 i\n\tfmt.Println(*p) // 通过指针读取 i 的值\n\t*p = 21         // 通过指针设置 i 的值\n\tfmt.Println(i)  // 查看 i 的值\n\n\tp = &j         // 指向 j\n\t*p = *p / 37   // 通过指针对 j 进行除法运算\n\tfmt.Println(j) // 查看 j 的值\n}\n```\n\n‍\n\n## 4.2 结构体\n\n一个结构体（`struct`​）就是一组字段（field）。\n\n```go\ntype Vertex struct {\n\tX int\n\tY int\n}\n```\n\n## 4.3 结构体字段\n\n结构体字段使用点号来访问。\n\n```go\ntype Vertex struct {\n\tX int\n\tY int\n}\n\nfunc main() {\n\tv := Vertex{1, 2}\n\tv.X = 4\n\tfmt.Println(v.X)\n}\n```\n\n‍\n\n## 4.4 结构体指针\n\n结构体字段可以通过结构体指针来访问。\n\n如果我们有一个指向结构体的指针 `p`​，那么可以通过 `(*p).X`​ 来访问其字段 `X`​。不过这么写太啰嗦了，所以语言也允许我们使用隐式间接引用，直接写 `p.X`​ 就可以。\n\n```go\ntype Vertex struct {\n\tX int\n\tY int\n}\n\nfunc main() {\n\tv := Vertex{1, 2}\n\tp := &v\n\tp.X = 1e9\n\tfmt.Println(v)\n}\n\n```\n\n‍\n\n## 4.5 结构体文法\n\n结构体文法通过直接列出字段的值来新分配一个结构体。\n\n使用 `Name:`​ 语法可以仅列出部分字段。（字段名的顺序无关。）\n\n特殊的前缀 `&`​ 返回一个指向结构体的指针。\n\n```go\ntype Vertex struct {\n\tX, Y int\n}\n\nvar (\n\tv1 = Vertex{1, 2}  // 创建一个 Vertex 类型的结构体\n\tv2 = Vertex{X: 1}  // Y:0 被隐式地赋予\n\tv3 = Vertex{}      // X:0 Y:0\n\tp  = &Vertex{1, 2} // 创建一个 *Vertex 类型的结构体（指针）\n)\n\nfunc main() {\n\tfmt.Println(v1, p, v2, v3)\n}\n```\n\n‍\n\n## 4.6 数组\n\n类型 `[n]T`​ 表示拥有 `n`​ 个 `T`​ 类型的值的数组。\n\n表达式\n\n```\nvar a [10]int\n```\n\n会将变量 `a`​ 声明为拥有 10 个整数的数组。\n\n数组的长度是其类型的一部分，**因此数组不能改变大小**。这看起来是个限制，不过没关系，Go 提供了更加便利的方式来使用数组。\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tvar a [2]string\n\ta[0] = \"Hello\"\n\ta[1] = \"World\"\n\tfmt.Println(a[0], a[1])\n\tfmt.Println(a)\n\n\tprimes := [6]int{2, 3, 5, 7, 11, 13}\n\tfmt.Println(primes)\n}\n```\n\n‍\n\n‍\n\n## 4.7 切片\n\n每个数组的大小都是固定的。而切片则为数组元素提供动态大小的、灵活的视角。在实践中，切片比数组更常用。\n\n切片可以看作是对数组的划分，也就是说原数组是一个全集，切片就是其依据不同标准划分的子集\n\n类型 `[]T`​ 表示一个元素类型为 `T`​ 的切片。\n\n切片通过两个下标来界定，即一个上界和一个下界，二者以冒号分隔：\n\n```\na[low : high]\n```\n\n它会选择一个半开区间，包括第一个元素，但排除最后一个元素。\n\n以下表达式创建了一个切片，它包含 `a`​ 中下标从 1 到 3 的元素：\n\n```\na[1:4]\n```\n\n切片就像数组的引用\n\n切片并不存储任何数据，它只是描述了底层数组中的一段。\n\n更改切片的元素会修改其底层数组中对应的元素。\n\n与它**共享底层数组**的切片都会观测到这些修改（也就是说它是一种深拷贝）\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tnames := [4]string{\n\t\t\"John\",\n\t\t\"Paul\",\n\t\t\"George\",\n\t\t\"Ringo\",\n\t}\n\tfmt.Println(names)\n\n\ta := names[0:2]\n\tb := names[1:3]\n\tfmt.Println(a, b)\n\n\tb[0] = \"XXX\"\n\tfmt.Println(a, b)\n\tfmt.Println(names)\n}\n\n```\n\n‍\n\n## 4.8 切片文法\n\n切片文法类似于没有长度的数组文法。\n\n这是一个数组文法：**构建的是一个数组**\n\n```\n[3]bool{true, true, false}\n```\n\n下面这样则会创建一个和上面相同的数组，然后构建一个引用了它的切片：\n\n```\n[]bool{true, true, false}\n```\n\n‍\n\n## 4.9 切片的默认行为\n\n在进行切片时，你可以利用它的默认行为来忽略上下界。\n\n切片下界的默认值为 `0`​，上界则是该切片的长度。\n\n对于数组\n\n```\nvar a [10]int\n```\n\n来说，以下切片是等价的：\n\n```\na[0:10]\na[:10]\na[0:]\na[:]\n```\n\n可以明确的是：\n\n1. 数组和切片不能够相互赋值\n\n   ```go\n   这个函数不可行，因为s 初始化的是一个数组，之后不能够赋值给切片\n   func main() {\n   \ts := [6]int{2, 3, 5, 7, 11, 13}\n   \ts = s[1:4]\n   \tfmt.Println(s)\n   }\n   报错显示：\n   ./prog.go:8:7: cannot use s[1:4] (value of type []int) as [6]int value in assignment\n   \n   ```\n\n‍\n\n## 4.10 切片的长度与容量\n\n切片拥有 **长度** 和 **容量**。\n\n切片的长度就是它所包含的元素个数。\n\n切片的容量是从它的第一个元素开始数，到其底层数组元素末尾的个数；容量也可以理解为切片总的能够扩展的（包括长度）数量\n\n切片 `s`​ 的长度和容量可通过表达式 `len(s)`​ 和 `cap(s)`​ 来获取。\n\n你可以通过重新切片来扩展一个切片，给它提供足够的容量\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\ts := []int{2, 3, 5, 7, 11, 13}\n\tprintSlice(s)\n\n\t// 截取切片使其长度为 0\n\ts = s[:0]\n\tprintSlice(s)\n\n\t// 拓展其长度\n\ts = s[:4]\n\tprintSlice(s)\n\n\t// 舍弃前两个值\n\ts = s[2:]\n\tprintSlice(s)\n}\n\nfunc printSlice(s []int) {\n\tfmt.Printf(\"len=%d cap=%d %v\\n\", len(s), cap(s), s)\n}\n```\n\n‍\n\n## 4.11 nil 切片\n\n切片的零值是 `nil`​。\n\nnil 切片的长度和容量为 0 且没有底层数组。\n\n‍\n\n## 4.12 用 make 创建切片\n\n切片可以用内建函数 `make`​ 来创建，这也是你创建动态数组的方式。\n\n`make`​ 函数会分配一个元素为零值的数组并返回一个引用了它的切片：\n\n```\na := make([]int, 5)  // len(a)=5\n```\n\n要指定它的容量，需向 `make`​ 传入第三个参数：\n\n```\nb := make([]int, 0, 5) // len(b)=0, cap(b)=5\n\nb = b[:cap(b)] // len(b)=5, cap(b)=5\nb = b[1:]      // len(b)=4, cap(b)=4\n```\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\ta := make([]int, 5)\n\tprintSlice(\"a\", a)\n\n\tb := make([]int, 0, 5)\n\tprintSlice(\"b\", b)\n\n\tc := b[:2]\n\tprintSlice(\"c\", c)\n\n\td := c[2:5]\n\tprintSlice(\"d\", d)\n}\n\nfunc printSlice(s string, x []int) {\n\tfmt.Printf(\"%s len=%d cap=%d %v\\n\",\n\t\ts, len(x), cap(x), x)\n}\n\n结果显示为：\na len=5 cap=5 [0 0 0 0 0]\nb len=0 cap=5 []\nc len=2 cap=5 [0 0]\nd len=3 cap=3 [0 0 0]\n\n```\n\n‍\n\n## 4. 13 创建二维切片：\n\n> 参考文献：\n>\n> [直接参考的](https://www.cnblogs.com/yahuian/p/11934122.html)\n>\n> [Stack  例子讲解：](https://stackoverflow.com/questions/39804861/what-is-a-concise-way-to-create-a-2d-slice-in-go)\n>\n> [make 和  new 的区别](https://stackoverflow.com/questions/9320862/why-would-i-make-or-new)\n>\n> [二维数组的结合](https://stackoverflow.com/questions/39561140/what-is-two-dimensional-arrays-memory-representation)\n\n最常用的方法，需要记忆：\n\n```go\na := make([][]uint8, dy)\nfor i := range a {\n    a[i] = make([]uint8, dx)\n}\n```\n\n```go\n\t// 方法0\n\trow, column := 3, 4\n\tvar answer [][]int\n\tfor i := 0; i < row; i++ {\n\t\tinline := make([]int, column)\n\t\tanswer = append(answer, inline)\n\t}\n\tfmt.Println(answer)\n\n\t// 方法1，最常用\n\tanswer1 := make([][]int, row)\n\tfor i := range answer1 {\n\t\tanswer1[i] = make([]int, column)\n\t}\n\n```\n\n‍\n\n‍\n\n## 4. 14 切片的切片\n\n切片可包含任何类型，甚至包括其它的切片[参照二维数组]\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc main() {\n\t// 创建一个井字板（经典游戏）\n\tboard := [][]string{\n\t\t[]string{\"_\", \"_\", \"_\"},\n\t\t[]string{\"_\", \"_\", \"_\"},\n\t\t[]string{\"_\", \"_\", \"_\"},\n\t}\n\n\t// 两个玩家轮流打上 X 和 O\n\tboard[0][0] = \"X\"\n\tboard[2][2] = \"O\"\n\tboard[1][2] = \"X\"\n\tboard[1][0] = \"O\"\n\tboard[0][2] = \"X\"\n\n\tfor i := 0; i < len(board); i++ {\n\t\tfmt.Printf(\"%s\\n\", strings.Join(board[i], \" \"))\n\t}\n}\n```\n\n## 4. 15 向切片追加元素\n\n为切片追加新的元素是种常用的操作，为此 Go 提供了内建的 `append`​ 函数。内建函数的[文档](https://go-zh.org/pkg/builtin/#append)对此函数有详细的介绍。\n\n```\nfunc append(s []T, vs ...T) []T\n```\n\n`append`​ 的第一个参数 `s`​ 是一个元素类型为 `T`​ 的切片，其余类型为 `T`​ 的值将会追加到该切片的末尾。\n\n`append`​ 的结果是一个包含原切片所有元素加上新添加元素的切片。\n\n当 `s`​ 的底层数组太小，不足以容纳所有给定的值时，它就会分配一个更大的数组。返回的切片会指向这个新分配的数组。\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tvar s []int\n\tprintSlice(s)\n\n\t// 添加一个空切片\n\ts = append(s, 0)\n\tprintSlice(s)\n\n\t// 这个切片会按需增长\n\ts = append(s, 1)\n\tprintSlice(s)\n\n\t// 可以一次性添加多个元素\n\ts = append(s, 2, 3, 4)\n\tprintSlice(s)\n}\n\nfunc printSlice(s []int) {\n\tfmt.Printf(\"len=%d cap=%d %v\\n\", len(s), cap(s), s)\n}\n```\n\n可参考文章：  [Go 切片：用法和本质](https://blog.go-zh.org/go-slices-usage-and-internals)\n\n‍\n\n## 4. 16 Range\n\n`for`​ 循环的 `range`​ 形式可遍历切片或映射。\n\n当使用 `for`​ 循环遍历切片时，每次迭代都会返回两个值。第一个值为当前元素的下标，第二个值为该下标所对应元素的一份副本。\n\n```go\npackage main\n\nimport \"fmt\"\n\nvar pow = []int{1, 2, 4, 8, 16, 32, 64, 128}\n\nfunc main() {\n\tfor i, v := range pow {\n\t\tfmt.Printf(\"2**%d = %d\\n\", i, v)\n\t}\n}\n\n```\n\n‍\n\n## 4. 17 range（续）\n\n可以将下标或值赋予 `_`​ 来忽略它。\n\n```\nfor i, _ := range pow\nfor _, value := range pow\n```\n\n若你只需要索引，忽略第二个变量即可。\n\n```\nfor i := range pow\n```\n\n‍\n\n## 4. 18 映射（Map）\n\n映射将键映射到值。\n\n映射的零值为 `nil`​ 。`nil`​ 映射既没有键，也不能添加键。\n\n`make`​ 函数会返回给定类型的映射，并将其初始化备用。\n\n```go\npackage main\n\nimport \"fmt\"\n\ntype Vertex struct {\n\tLat, Long float64\n}\n\nvar m map[string]Vertex\n\nfunc main() {\n\tm = make(map[string]Vertex)\n\tm[\"Bell Labs\"] = Vertex{\n\t\t40.68433, -74.39967,\n\t}\n\tfmt.Println(m[\"Bell Labs\"])\n}\n```\n\n\n\n## 4. 19 映射的文法\n\n映射的文法与结构体相似，不过必须有键名。\n\n若顶级类型只是一个类型名，你可以在文法的元素中省略它。\n\n```go\npackage main\n\nimport \"fmt\"\n\ntype Vertex struct {\n\tLat, Long float64\n}\n\nvar m = map[string]Vertex{\n\t\"Bell Labs\": {40.68433, -74.39967},\n\t\"Google\":    {37.42202, -122.08408},\n}\n\nfunc main() {\n\tfmt.Println(m)\n}\n\n```\n\n‍\n\n## 4. 20 修改映射\n\n在映射 `m`​ 中插入或修改元素：\n\n```\nm[key] = elem\n```\n\n获取元素：\n\n```\nelem = m[key]\n```\n\n删除元素：\n\n```\ndelete(m, key)\n```\n\n通过双赋值检测某个键是否存在：\n\n```\nelem, ok = m[key]\n```\n\n若 `key`​ 在 `m`​ 中，`ok`​ 为 `true`​ ；否则，`ok`​ 为 `false`​。\n\n若 `key`​ 不在映射中，那么 `elem`​ 是该映射元素类型的零值。\n\n同样的，当从映射中读取某个不存在的键时，结果是映射的元素类型的零值。\n\n**注** ：若 `elem`​ 或 `ok`​ 还未声明，你可以使用短变量声明：\n\n```\nelem, ok := m[key]\n```\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tm := make(map[string]int)\n\n\tm[\"Answer\"] = 42\n\tfmt.Println(\"The value:\", m[\"Answer\"])\n\n\tm[\"Answer\"] = 48\n\tfmt.Println(\"The value:\", m[\"Answer\"])\n\n\tdelete(m, \"Answer\")\n\tfmt.Println(\"The value:\", m[\"Answer\"])\n\n\tv, ok := m[\"Answer\"]\n\tfmt.Println(\"The value:\", v, \"Present?\", ok)\n}\n\n```\n\n‍\n\n‍\n\n## 4. 21 函数值\n\n函数也是值。它们可以像其它值一样传递。\n\n函数值可以用作函数的参数或返回值。\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc compute(fn func(float64, float64) float64) float64 {\n\treturn fn(3, 4)\n}\n\nfunc main() {\n\thypot := func(x, y float64) float64 {\n\t\treturn math.Sqrt(x*x + y*y)\n\t}\n\tfmt.Println(hypot(5, 12))\n\n\tfmt.Println(compute(hypot))\n\tfmt.Println(compute(math.Pow))\n}\n```\n\n‍\n\n## 4. 22 函数的闭包\n\nGo 函数可以是一个闭包。闭包是一个函数值，它引用了其函数体之外的变量。该函数可以访问并赋予其引用的变量的值，换句话说，该函数被这些变量“绑定”在一起。\n\n例如，函数 `adder`​ 返回一个闭包。每个闭包都被绑定在其各自的 `sum`​ 变量上。\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc adder() func(int) int {\n\tsum := 0\n\treturn func(x int) int {\n\t\tsum += x\n\t\treturn sum\n\t}\n}\n\nfunc main() {\n\tpos, neg := adder(), adder()\n\tfor i := 0; i < 10; i++ {\n\t\tfmt.Println(\n\t\t\tpos(i),\n\t\t\tneg(-2*i),\n\t\t)\n\t}\n}\n\n最终的结果是：\n0 0\n1 -2\n3 -6\n6 -12\n10 -20\n15 -30\n21 -42\n28 -56\n36 -72\n45 -90\n```\n\n‍\n\n‍\n\n# 5. 方法和接口\n\n## 5.1 方法\n\nGo 没有类。不过你可以为结构体类型定义方法。\n\n方法就是一类带特殊的 ​**接收者**​ 参数的函数。\n\n方法接收者在它自己的参数列表内，位于 `func`​ 关键字和方法名之间。\n\n在此例中，`Abs`​ 方法拥有一个名为 `v`​，类型为 `Vertex`​ 的接收者。\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Vertex struct {\n\tX, Y float64\n}\n\nfunc (v Vertex) Abs() float64 {\n\treturn math.Sqrt(v.X*v.X + v.Y*v.Y)\n}\n\nfunc main() {\n\tv := Vertex{3, 4}\n\tfmt.Println(v.Abs())\n}\n```\n\n方法即函数\n\n记住：方法只是个带接收者参数的函数。\n\n现在这个 `Abs`​ 的写法就是个正常的函数，功能并没有什么变化。\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Vertex struct {\n\tX, Y float64\n}\n\nfunc Abs(v Vertex) float64 {\n\treturn math.Sqrt(v.X*v.X + v.Y*v.Y)\n}\n\nfunc main() {\n\tv := Vertex{3, 4}\n\tfmt.Println(Abs(v))\n}\n```\n\n但是这个是函数，并不能够通过v对象直接调用\n\n‍\n\n## 5.2 方法（续）\n\n你也可以为非结构体类型声明方法。\n\n在此例中，我们看到了一个带 `Abs`​ 方法的数值类型 `MyFloat`​。\n\n你只能为在同一包内定义的类型的接收者声明方法，而不能为其它包内定义的类型（包括 `int`​ 之类的内建类型）的接收者声明方法。\n\n（译注：就是接收者的类型定义和方法声明必须在同一包内；不能为内建类型声明方法。）\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype MyFloat float64\n\nfunc (f MyFloat) Abs() float64 {\n\tif f < 0 {\n\t\treturn float64(-f)\n\t}\n\treturn float64(f)\n}\n\nfunc main() {\n\tf := MyFloat(-math.Sqrt2)\n\tfmt.Println(f.Abs())\n}\n```\n\n‍\n\n## 5.3 指针接收者\n\n你可以为指针接收者声明方法。\n\n这意味着对于某类型 `T`​，接收者的类型可以用 `*T`​ 的文法。（**此外，****`T`**​**​ 不能是像 ​****`*int`**​**​ 这样的指针，换句话说就是没有双指针。**不能够出现**int这样的结构）\n\n例如，这里为 `*Vertex`​ 定义了 `Scale`​ 方法。\n\n指针接收者的方法可以修改接收者指向的值（就像 `Scale`​ 在这做的）。由于方法经常需要修改它的接收者，指针接收者比值接收者更常用。\n\n试着移除第 16 行 `Scale`​ 函数声明中的 `*`​，观察此程序的行为如何变化。\n\n若使用值接收者，那么 `Scale`​ 方法会对原始 `Vertex`​ 值**的副本**进行操作。（对于函数的其它参数也是如此。）`Scale`​ 方法必须用指针接受者来更改 `main`​ 函数中声明的 `Vertex`​ 的值。也就是说使用指针的时候才能够对原本的数据结构当中的值做修改，但如果使用值接收者，就会修改一个副本，那么函数之间的调用修改就会不起作用，生命周期只在这个函数当中完成。\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Vertex struct {\n\tX, Y float64\n}\n\nfunc (v Vertex) Abs() float64 {\n\treturn math.Sqrt(v.X*v.X + v.Y*v.Y)\n}\n\n//使用指针接收者，结果会是50 ，也就是说本函数的修改，abs能够获取到\nfunc (v *Vertex) Scale(f float64) {\n\tv.X = v.X * f\n\tv.Y = v.Y * f\n}\n//使用值接收者，结果会是5，也就是说本函数的修改只在本函数当中，abs无法感知到v.x,v.y的值发生变化\nfunc (v Vertex) Scale(f float64) {\n\tv.X = v.X * f\n\tv.Y = v.Y * f\n}\n\n\nfunc main() {\n\tv := Vertex{3, 4}\n\tv.Scale(10)\n\tfmt.Println(v.Abs())\n}\n```\n\n![image](Y:/Blog/blog/source/_posts/Go/Go-basic-knowledge/assets/image-20230228103213-yqcw1ma.png)​\n\n‍\n\n## 5.4 方法与指针重定向\n\n比较前两个程序，你大概会注意到**带指针参数的函数必须接受一个指针**：\n\n```\nvar v Vertex\nScaleFunc(v, 5)  // 编译错误！\nScaleFunc(&v, 5) // OK\n```\n\n而以**指针为接收者的方法被调用时，接收者既能为值又能为指针：**\n\n```\nvar v Vertex\nv.Scale(5)  // OK\np := &v\np.Scale(10) // OK\n```\n\n对于语句 `v.Scale(5)`​，即便 `v`​ 是个值而非指针，带指针接收者的方法也能被直接调用。 也就是说，由于 `Scale`​ 方法有一个指针接收者，为方便起见，Go 会将语句 `v.Scale(5)`​ 解释为 `(&v).Scale(5)`​。\n\n```go\npackage main\n\nimport \"fmt\"\n\ntype Vertex struct {\n\tX, Y float64\n}\n\nfunc (v *Vertex) Scale(f float64) {\n\tv.X = v.X * f\n\tv.Y = v.Y * f\n}\n\nfunc ScaleFunc(v *Vertex, f float64) {\n\tv.X = v.X * f\n\tv.Y = v.Y * f\n}\n\nfunc main() {\n\tv := Vertex{3, 4}\n\tv.Scale(2)\n\tScaleFunc(&v, 10)\n\n\tp := &Vertex{4, 3}\n\tp.Scale(3)\n\tScaleFunc(p, 8)\n\n\tfmt.Println(v, p)\n}\n```\n\n同样的事情也发生在相反的方向。\n\n接受一个值作为参数的函数必须接受一个指定类型的值：\n\n```\nvar v Vertex\nfmt.Println(AbsFunc(v))  // OK\nfmt.Println(AbsFunc(&v)) // 编译错误！\n```\n\n而以值为接收者的方法被调用时，接收者既能为值又能为指针：\n\n```\nvar v Vertex\nfmt.Println(v.Abs()) // OK\np := &v\nfmt.Println(p.Abs()) // OK\n```\n\n这种情况下，方法调用 `p.Abs()`​ 会被解释为 `(*p).Abs()`​。\n\n‍\n\n## 5.5 选择值或指针作为接收者\n\n使用指针接收者的原因有二：\n\n首先，方法能够修改其接收者指向的值。\n\n其次，这样可以避免在每次调用方法时复制该值。若值的类型为大型结构体时，这样做会更加高效。\n\n在本例中，`Scale`​ 和 `Abs`​ 接收者的类型为 `*Vertex`​，即便 `Abs`​ 并不需要修改其接收者。\n\n通常来说，所有给定类型的方法都应该有值或指针接收者，但并不应该二者混用。\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Vertex struct {\n\tX, Y float64\n}\n\nfunc (v *Vertex) Scale(f float64) {\n\tv.X = v.X * f\n\tv.Y = v.Y * f\n}\n\nfunc (v *Vertex) Abs() float64 {\n\treturn math.Sqrt(v.X*v.X + v.Y*v.Y)\n}\n\nfunc main() {\n\tv := &Vertex{3, 4}\n\tfmt.Printf(\"Before scaling: %+v, Abs: %v\\n\", v, v.Abs())\n\tv.Scale(5)\n\tfmt.Printf(\"After scaling: %+v, Abs: %v\\n\", v, v.Abs())\n}\n\n结果显示是：\nBefore scaling: &{X:3 Y:4}, Abs: 5\nAfter scaling: &{X:15 Y:20}, Abs: 25\n```\n\n‍\n\n## 5. 6 接口 \n\n**接口类型** 是由一组方法签名定义的集合。\n\n> 参考文献 ：\n>\n> [接口常见知识](https://blog.kennycoder.io/2020/02/03/Golang-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3interface%E5%B8%B8%E8%A6%8B%E7%94%A8%E6%B3%95/)\n\n接口类型的变量可以保存任何实现了这些方法的值。\n\n> 接口就可以理解为一系列动作的集合  \n> **而某个struct能够实现里面的所有方法，那么这个struct就是这个接口的一个实现**\n\n**注意:** 示例代码的 22 行存在一个错误。由于 `Abs`​ 方法只为 `*Vertex`​ （指针类型）定义，因此 `Vertex`​（值类型）并未实现 `Abser`​。\n\n```go\ntype Abser interface {\n\tAbs() float64\n}\n\nfunc main() {\n\tvar a Abser\n\tf := MyFloat(-math.Sqrt2)\n\tv := Vertex{3, 4}\n\n\ta = f  // a MyFloat 实现了 Abser\n\ta = &v // a *Vertex 实现了 Abser\n\n\t// 下面一行，v 是一个 Vertex（而不是 *Vertex）\n\t// 所以没有实现 Abser。\n\ta = v\n\n\tfmt.Println(a.Abs())\n}\n\ntype MyFloat float64\n\nfunc (f MyFloat) Abs() float64 {\n\tif f < 0 {\n\t\treturn float64(-f)\n\t}\n\treturn float64(f)\n}\n\ntype Vertex struct {\n\tX, Y float64\n}\n\nfunc (v *Vertex) Abs() float64 {\n\treturn math.Sqrt(v.X*v.X + v.Y*v.Y)\n}\n\n显示错误：\n./prog.go:22:6: cannot use v (variable of type Vertex) as Abser value in assignment: Vertex does not implement Abser (method Abs has pointer receiver)\n```\n\n‍\n\n## 5.7 接口与隐式实现\n\n类型通过实现一个接口的所有方法来实现该接口。既然无需专门显式声明，也就没有“implements”关键字。\n\n隐式接口从接口的实现中解耦了定义，这样接口的实现可以出现在任何包中，无需提前准备。\n\n因此，也就无需在每一个实现上增加新的接口名称，这样同时也鼓励了明确的接口定义。\n\n```go\npackage main\n\nimport \"fmt\"\n\ntype I interface {\n\tM()\n}\n\ntype T struct {\n\tS string\n}\n\n// 此方法表示类型 T 实现了接口 I，但我们无需显式声明此事。\nfunc (t T) M() {\n\tfmt.Println(t.S)\n}\n\nfunc main() {\n\tvar i I = T{\"hello\"}\n\ti.M()\n}\n```\n\n‍\n\n## 5.8 接口值\n\n接口也是值。它们可以像其它值一样传递。\n\n接口值可以用作函数的参数或返回值。\n\n在内部，接口值可以看做包含值和具体类型的元组：\n\n```\n(value, type)\n```\n\n接口值保存了一个具体底层类型的具体值。\n\n接口值调用方法时会执行其底层类型的同名方法\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype I interface {\n\tM()\n}\n\ntype T struct {\n\tS string\n}\n\nfunc (t *T) M() {\n\tfmt.Println(t.S)\n}\n\ntype F float64\n\nfunc (f F) M() {\n\tfmt.Println(f)\n}\n\nfunc main() {\n\tvar i I\n\n\ti = &T{\"Hello\"}\n\tdescribe(i)\n\ti.M()\n\n\ti = F(math.Pi)\n\tdescribe(i)\n\ti.M()\n}\n\nfunc describe(i I) {\n\tfmt.Printf(\"(%v, %T)\\n\", i, i)\n}\n\n输出结果是：\n//因为 T 实现是传入（* T）\n\n(&{Hello}, *main.T)\nHello\n\n//因为 F 实现是传入（F）\n(3.141592653589793, main.F)\n3.141592653589793\n```\n\n在上述代码当中的接口值是：(&{Hello}, *main.T) 以及 (3.141592653589793, main.F)\n\n‍\n\n## 5.9 底层值为 nil 的接口值\n\n即便接口内的具体值为 nil，方法仍然会被 nil 接收者调用。\n\n在一些语言中，这会触发一个空指针异常，但在 Go 中通常会写一些方法来优雅地处理它（如本例中的 `M`​ 方法）。\n\n**注意:** 保存了 nil 具体值的接口其自身并不为 nil。\n\n```go\npackage main\n\nimport \"fmt\"\n\ntype I interface {\n\tM()\n}\n\ntype T struct {\n\tS string\n}\n\nfunc (t *T) M() {\n\tif t == nil {\n\t\tfmt.Println(\"<nil>\")\n\t\treturn\n\t}\n\tfmt.Println(t.S)\n}\n\nfunc main() {\n\tvar i I\n\n\tvar t *T\n\ti = t\n\tdescribe(i)\n\ti.M()\n\n\ti = &T{\"hello\"}\n\tdescribe(i)\n\ti.M()\n}\n\nfunc describe(i I) {\n\tfmt.Printf(\"(%v, %T)\\n\", i, i)\n}\n\n记结果输出为：\n(<nil>, *main.T)\n<nil>\n(&{hello}, *main.T)\nhello\n```\n\n‍\n\n## 5.10 nil 接口值\n\nnil 接口值既不保存值也不保存具体类型。\n\n为 nil 接口调用方法会产生运行时错误，因为接口的元组内并未包含能够指明该调用哪个 **具体** 方法的类型。\n\n```go\npackage main\n\nimport \"fmt\"\n\ntype I interface {\n\tM()\n}\n\nfunc main() {\n\tvar i I\n\tdescribe(i)\n\ti.M()\n}\n\nfunc describe(i I) {\n\tfmt.Printf(\"(%v, %T)\\n\", i, i)\n}\n\n```\n\n```go\n上述代码会显示：\n(<nil>, <nil>)\npanic: runtime error: invalid memory address or nil pointer dereference\n[signal SIGSEGV: segmentation violation code=0x1 addr=0x0 pc=0x481961]\n\ngoroutine 1 [running]:\nmain.main()\n\t/tmp/sandbox4223192970/prog.go:12 +0x61\n```\n\n‍\n\n以上两者是不同的概念：\n\n第一个是接口对象不为空，但是对象指向的地方为空，也就是说接口申明了之后，还是给了他一个赋值的对象，但这个对象可能还没有初始化\n\n第二个是接口对象为空\n\n‍\n\n## 5.11 空接口\n\n指定了零个方法的接口值被称为 *空接口：*\n\n```\ninterface{}\n```\n\n空接口可保存任何类型的值。（因为每个类型都至少实现了零个方法。）\n\n空接口被用来处理未知类型的值。例如，`fmt.Print`​ 可接受类型为 `interface{}`​ 的任意数量的参数。\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tvar i interface{}\n\tdescribe(i)\n\n\ti = 42\n\tdescribe(i)\n\n\ti = \"hello\"\n\tdescribe(i)\n}\n\nfunc describe(i interface{}) {\n\tfmt.Printf(\"(%v, %T)\\n\", i, i)\n}\n```\n\n‍\n\n## 5.12 类型断言\n\n> [断言具体释义](https://blog.kalan.dev/posts/golang-type-assertion)\n\n**类型断言** 提供了**访问接口值底层具体值**的方式。\n\n```\nt := i.(T)\n```\n\n该语句断言接口值 `i`​ 保存了具体类型 `T`​，并将其底层类型为 `T`​ 的值赋予变量 `t`​。\n\n若 `i`​ 并未保存 `T`​ 类型的值，该语句就会触发一个恐慌。\n\n为了 **判断** 一个接口值是否保存了一个特定的类型，类型断言可返回两个值：其底层值以及一个报告断言是否成功的布尔值。\n\n```\nt, ok := i.(T)\n```\n\n若 `i`​ 保存了一个 `T`​，那么 `t`​ 将会是其底层值，而 `ok`​ 为 `true`​。\n\n否则，`ok`​ 将为 `false`​ 而 `t`​ 将为 `T`​ 类型的零值，程序并不会产生恐慌。\n\n请注意这种语法和读取一个映射时的相同之处。\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tvar i interface{} = \"hello\"\n\n\ts := i.(string)\n\tfmt.Println(s)\n\n\ts, ok := i.(string)\n\tfmt.Println(s, ok)\n\n\tf, ok := i.(float64)\n\tfmt.Println(f, ok)\n\n\tf = i.(float64) // 报错(panic)\n\tfmt.Println(f)\n}\n\n\n结果显示为：\nhello\nhello true\n0 false\npanic: interface conversion: interface {} is string, not float64\n```\n\n‍\n\n## 5.13 类型选择\n\n**类型选择** 是一种按顺序从几个类型断言中选择分支的结构。\n\n类型选择与一般的 switch 语句相似，不过类型选择中的 case 为类型（而非值）， 它们针对给定接口值所存储的值的类型进行比较。\n\n```\nswitch v := i.(type) {\ncase T:\n    // v 的类型为 T\ncase S:\n    // v 的类型为 S\ndefault:\n    // 没有匹配，v 与 i 的类型相同\n}\n```\n\n类型选择中的声明与类型断言 `i.(T)`​ 的语法相同，**只是具体类型 ​****`T`****​ 被替换成了关键字 ​****`type`****。**\n\n此选择语句判断接口值 `i`​ 保存的值类型是 `T`​ 还是 `S`​。在 `T`​ 或 `S`​ 的情况下，变量 `v`​ 会分别按 `T`​ 或 `S`​ 类型保存 `i`​ 拥有的值。在默认（即没有匹配）的情况下，变量 `v`​ 与 `i`​ 的接口类型和值相同。\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc do(i interface{}) {\n\tswitch v := i.(type) {\n\tcase int:\n\t\tfmt.Printf(\"Twice %v is %v\\n\", v, v*2)\n\tcase string:\n\t\tfmt.Printf(\"%q is %v bytes long\\n\", v, len(v))\n\tdefault:\n\t\tfmt.Printf(\"I don't know about type %T!\\n\", v)\n\t}\n}\n\nfunc main() {\n\tdo(21)\n\tdo(\"hello\")\n\tdo(true)\n}\n\n结果是：\nTwice 21 is 42\n\"hello\" is 5 bytes long\nI don't know about type bool!\n```\n\n‍\n\n## 5. 14 Stringer\n\n[fmt](https://go-zh.org/pkg/fmt/)``​ 包中定义的 [Stringer](https://go-zh.org/pkg/fmt/#Stringer)``​ 是最普遍的接口之一。\n\n```\ntype Stringer interface {\n    String() string\n}\n```\n\n`Stringer`​ 是一个可以用字符串描述自己的类型。`fmt`​ 包（还有很多包）都通过此接口来打印值。\n\n```go\npackage main\n\nimport \"fmt\"\n\ntype Person struct {\n\tName string\n\tAge  int\n}\n\nfunc (p Person) String() string {\n\treturn fmt.Sprintf(\"%v (%v years)\", p.Name, p.Age)\n}\n\nfunc main() {\n\ta := Person{\"Arthur Dent\", 42}\n\tz := Person{\"Zaphod Beeblebrox\", 9001}\n\tfmt.Println(a, z)\n}\n\n```\n\n‍\n\n## 5. 15 错误\n\nGo 程序使用 `error`​ 值来表示错误状态。\n\n与 `fmt.Stringer`​ 类似，`error`​ 类型是一个内建接口：\n\n```\ntype error interface {\n    Error() string\n}\n```\n\n（与 `fmt.Stringer`​ 类似，`fmt`​ 包在打印值时也会满足 `error`​。）\n\n通常函数会返回一个 `error`​ 值，调用的它的代码应当判断这个错误是否等于 `nil`​ 来进行错误处理。\n\n```\ni, err := strconv.Atoi(\"42\")\nif err != nil {\n    fmt.Printf(\"couldn't convert number: %v\\n\", err)\n    return\n}\nfmt.Println(\"Converted integer:\", i)\n```\n\n`error`​ 为 nil 时表示成功；非 nil 的 `error`​ 表示失败\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\ntype MyError struct {\n\tWhen time.Time\n\tWhat string\n}\n\nfunc (e *MyError) Error() string {\n\treturn fmt.Sprintf(\"at %v, %s\",\n\t\te.When, e.What)\n}\n\nfunc run() error {\n\treturn &MyError{\n\t\ttime.Now(),\n\t\t\"it didn't work\",\n\t}\n}\n\nfunc main() {\n\tif err := run(); err != nil {\n\t\tfmt.Println(err)\n\t}\n}\n\n```\n\n\n\n## 5. 16 Reader\n\n`io`​ 包指定了 `io.Reader`​ 接口，它表示从数据流的末尾进行读取。\n\nGo 标准库包含了该接口的[许多实现](https://go-zh.org/search?q=Read#Global)，包括文件、网络连接、压缩和加密等等。\n\n`io.Reader`​ 接口有一个 `Read`​ 方法：\n\n```\nfunc (T) Read(b []byte) (n int, err error)\n```\n\n`Read`​ 用数据填充给定的字节切片并返回填充的字节数和错误值。在遇到数据流的结尾时，它会返回一个 `io.EOF`​ 错误。\n\n示例代码创建了一个 [strings.Reader](https://go-zh.org/pkg/strings/#Reader)``​ 并以每次 8 字节的速度读取它的输出。\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"strings\"\n)\n\nfunc main() {\n\tr := strings.NewReader(\"Hello, Reader!\")\n\n\tb := make([]byte, 8)\n\tfor {\n\t\tn, err := r.Read(b)\n\t\tfmt.Printf(\"n = %v err = %v b = %v\\n\", n, err, b)\n\t\tfmt.Printf(\"b[:n] = %q\\n\", b[:n])\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t}\n\t}\n}\n\n输出结果是：\nn = 8 err = <nil> b = [72 101 108 108 111 44 32 82]\nb[:n] = \"Hello, R\"\nn = 6 err = <nil> b = [101 97 100 101 114 33 32 82]\nb[:n] = \"eader!\"\nn = 0 err = EOF b = [101 97 100 101 114 33 32 82]\nb[:n] = \"\"\n```\n\n‍\n\n‍\n\n## 5.17 图像\n\n[image](https://go-zh.org/pkg/image/#Image)``​ 包定义了 `Image`​ 接口：\n\n```\npackage image\n\ntype Image interface {\n    ColorModel() color.Model\n    Bounds() Rectangle\n    At(x, y int) color.Color\n}\n```\n\n**注意:** `Bounds`​ 方法的返回值 `Rectangle`​ 实际上是一个 [image.Rectangle](https://go-zh.org/pkg/image/#Rectangle)``​，它在 `image`​ 包中声明。\n\n（请参阅[文档](https://go-zh.org/pkg/image/#Image)了解全部信息。）\n\n`color.Color`​ 和 `color.Model`​ 类型也是接口，但是通常因为直接使用预定义的实现 `image.RGBA`​ 和 `image.RGBAModel`​ 而被忽视了。这些接口和类型由 [image/color](https://go-zh.org/pkg/image/color/)``​ 包定义。\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"image\"\n)\n\nfunc main() {\n\tm := image.NewRGBA(image.Rect(0, 0, 100, 100))\n\tfmt.Println(m.Bounds())\n\tfmt.Println(m.At(0, 0).RGBA())\n}\n\n```\n\n# 6.  并发编程\n\n## 6.1  Go 协程\n\nGo 协程（goroutine）是由 Go 运行时管理的轻量级线程。\n\n```\ngo f(x, y, z)\n```\n\n会启动一个新的 Go 程并执行\n\n```\nf(x, y, z)\n```\n\n`f`​, `x`​, `y`​ 和 `z`​ 的求值发生在当前的 Go 程中，而 `f`​ 的执行发生在新的 Go 程中。\n\nGo 程在相同的地址空间中运行，因此在访问共享的内存时必须进行同步。[sync](https://go-zh.org/pkg/sync/)``​ 包提供了这种能力，不过在 Go 中并不经常用到。\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc say(s string) {\n\tfor i := 0; i < 5; i++ {\n\t\ttime.Sleep(100 * time.Millisecond)\n\t\tfmt.Println(s)\n\t}\n}\n\nfunc main() {\n\tgo say(\"world\")\n\tsay(\"hello\")\n}\n```\n\n‍\n\n## 6.2 信道\n\n信道是带有类型的管道，你可以通过它用信道操作符 `<-`​ 来发送或者接收值。\n\n```\nch <- v    // 将 v 发送至信道 ch。\nv := <-ch  // 从 ch 接收值并赋予 v。\n```\n\n（“箭头”就是数据流的方向。）\n\n和映射与切片一样，信道在使用前必须创建，也是使用make的形式创建\n\n```\nch := make(chan int)\n```\n\n默认情况下，发送和接收操作在另一端准备好之前都会阻塞。这使得 Go 程可以在没有显式的锁或竞态变量的情况下进行同步。\n\n以下示例对切片中的数进行求和，将任务分配给两个 Go 程。一旦两个 Go 程完成了它们的计算，它就能算出最终的结果。\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc sum(s []int, c chan int) {\n\tsum := 0\n\tfor _, v := range s {\n\t\tsum += v\n\t}\n\tc <- sum // 将和送入 c\n}\n\nfunc main() {\n\ts := []int{7, 2, 8, -9, 4, 0}\n\n\tc := make(chan int)\n\tgo sum(s[:len(s)/2], c)\n\tgo sum(s[len(s)/2:], c)\n\tx, y := <-c, <-c // 从 c 中接收\n\n\tfmt.Println(x, y, x+y)\n}\n\n结果显示为：\n-5 17 12\n```\n\n**同时也可以知道 信道的结构是队列类型，先进先出**\n\n‍\n\n‍\n\n## 6.3 项目带缓冲的信道\n\n信道可以是 *带缓冲的*。将缓冲长度作为第二个参数提供给 `make`​ 来初始化一个带缓冲的信道：\n\n```\nch := make(chan int, 100)\n```\n\n仅当信道的缓冲区填满后，向其发送数据时才会阻塞。当缓冲区为空时，接受方会阻塞。\n\n修改示例填满缓冲区，然后看看会发生什么。\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tch := make(chan int, 2)\n\tch <- 1\n\tch <- 2\n\tfmt.Println(<-ch)\n\tfmt.Println(<-ch)\n}\n```\n\n‍\n\n## 6. 4 信道使用 range 和 close\n\n发送者可通过 `close`​ 关闭一个信道来表示没有需要发送的值了。接收者可以通过为接收表达式分配第二个参数来测试信道是否被关闭：若没有值可以接收且信道已被关闭，那么在执行完\n\n```\nv, ok := <-ch\n```\n\n之后 `ok`​ 会被设置为 `false`​。\n\n循环 `for i := range c`​ 会不断从信道接收值，直到它被关闭。\n\n*注意：* 只有发送者才能关闭信道，而接收者不能。向一个已经关闭的信道发送数据会引发程序恐慌（panic）。\n\n*还要注意：* 信道与文件不同，通常情况下无需关闭它们。只有在必须告诉接收者不再有需要发送的值时才有必要关闭，例如终止一个 `range`​ 循环。\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc fibonacci(n int, c chan int) {\n\tx, y := 0, 1\n\tfor i := 0; i < n; i++ {\n\t\tc <- x\n\t\tx, y = y, x+y\n\t}\n\tclose(c)\n}\n\nfunc main() {\n\tc := make(chan int, 10)\n\tgo fibonacci(cap(c), c)\n\tfor i := range c {\n\t\tfmt.Println(i)\n\t}\n}\n\n结果显示为：\n0\n1\n1\n2\n3\n5\n8\n13\n21\n34\n```\n\n‍\n\n## 6.5 Go 語言如何從 Channel 讀取資料\n\n> 参考文献：\n>\n> [Chan的读取方式](https://blog.wu-boy.com/2022/05/read-data-from-channel-in-go/)\n\n‍\n\n## 6.6 select 语句\n\n`select`​ 语句使一个 Go 程可以等待多个通信操作。\n\n`select`​ 会阻塞到某个分支可以继续执行为止，这时就会执行该分支。当多个分支都准备好时会随机选择一个执行。\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc fibonacci(c, quit chan int) {\n\tx, y := 0, 1\n\tfor {\n\t\tselect {\n\t\tcase c <- x:\n\t\t\tx, y = y, x+y\n\t\tcase <-quit:\n\t\t\tfmt.Println(\"quit\")\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc main() {\n\tc := make(chan int)\n\tquit := make(chan int)\n\tgo func() {\n\t\tfor i := 0; i < 10; i++ {\n\t\t\tfmt.Println(<-c)\n\t\t}\n\t\tquit <- 0\n\t}()\n\tfibonacci(c, quit)\n}\n```\n\n‍\n\n## 6.7 默认选择\n\n当 `select`​ 中的其它分支都没有准备好时，`default`​ 分支就会执行。\n\n为了在尝试发送或者接收时不发生阻塞，可使用 `default`​ 分支：\n\n```\nselect {\ncase i := <-c:\n    // 使用 i\ndefault:\n    // 从 c 中接收会阻塞时执行\n}\n```\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\ttick := time.Tick(100 * time.Millisecond)\n\tboom := time.After(500 * time.Millisecond)\n\tfor {\n\t\tselect {\n\t\tcase i := <-tick:\n\t\t\tfmt.Println(i)\n\t\t\tfmt.Println(\"tick.\")\n\t\tcase <-boom:\n\t\t\tfmt.Println(\"BOOM!\")\n\t\t\treturn\n\t\tdefault:\n\t\t\tfmt.Println(\"    .\")\n\t\t\ttime.Sleep(50 * time.Millisecond)\n\t\t}\n\t}\n}\n```\n\n输出为：\n\n```go\n    .\n    .\n2009-11-10 23:00:00.1 +0000 UTC m=+0.100000001\ntick.\n    .\n    .\n    .\n2009-11-10 23:00:00.2 +0000 UTC m=+0.200000001\ntick.\n    .\n2009-11-10 23:00:00.3 +0000 UTC m=+0.300000001\ntick.\n    .\n    .\n2009-11-10 23:00:00.4 +0000 UTC m=+0.400000001\ntick.\n    .\n    .\nBOOM!\n```\n\n‍\n\n## 6.8 sync.Mutex\n\n我们已经看到信道非常适合在各个 Go 程间进行通信。\n\n但是如果我们并不需要通信呢？比如说，若我们只是想保证每次只有一个 Go 程能够访问一个共享的变量，从而避免冲突？\n\n这里涉及的概念叫做 *互斥（mutual*exclusion）* ，我们通常使用 *互斥锁（Mutex）* 这一数据结构来提供这种机制。\n\nGo 标准库中提供了 [sync.Mutex](https://go-zh.org/pkg/sync/#Mutex)``​ 互斥锁类型及其两个方法：\n\n* `Lock`​\n* `Unlock`​\n\n我们可以通过在代码前调用 `Lock`​ 方法，在代码后调用 `Unlock`​ 方法来保证一段代码的互斥执行。参见 `Inc`​ 方法。\n\n我们也可以用 `defer`​ 语句来保证互斥锁一定会被解锁。参见 `Value`​ 方法。\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\n// SafeCounter 的并发使用是安全的。\ntype SafeCounter struct {\n\tv   map[string]int\n\tmux sync.Mutex\n}\n\n// Inc 增加给定 key 的计数器的值。\nfunc (c *SafeCounter) Inc(key string) {\n\tc.mux.Lock()\n\t// Lock 之后同一时刻只有一个 goroutine 能访问 c.v\n\tc.v[key]++\n\tc.mux.Unlock()\n}\n\n// Value 返回给定 key 的计数器的当前值。\nfunc (c *SafeCounter) Value(key string) int {\n\tc.mux.Lock()\n\t// Lock 之后同一时刻只有一个 goroutine 能访问 c.v\n\tdefer c.mux.Unlock()\n\treturn c.v[key]\n}\n\nfunc main() {\n\tc := SafeCounter{v: make(map[string]int)}\n\tfor i := 0; i < 1000; i++ {\n\t\tgo c.Inc(\"somekey\")\n\t}\n\n\ttime.Sleep(time.Second)\n\tfmt.Println(c.Value(\"somekey\"))\n}\n\n```\n\n‍\n\n# 练习题目（自己答案系列）\n\n## 练习：Stringer\n\n通过让 `IPAddr`​ 类型实现 `fmt.Stringer`​ 来打印点号分隔的地址。\n\n例如，`IPAddr{1, 2, 3, 4}`​ 应当打印为 `\"1.2.3.4\"`​。\n\n```go\npackage main\n\nimport \"fmt\"\n\ntype IPAddr [4]byte\n\n// TODO: 给 IPAddr 添加一个 \"String() string\" 方法\nfunc (ip *IPAddr) String() string{\n\tipAddr:= fmt.Sprintf(\"%d.%d.%d.%d\",ip[0],ip[1],ip[2],ip[3])\n\treturn string(ipAddr)\n\n}\n\n\nfunc main() {\n\thosts := map[string]IPAddr{\n\t\t\"loopback\":  {127, 0, 0, 1},\n\t\t\"googleDNS\": {8, 8, 8, 8},\n\t}\n\tfor name, ip := range hosts {\n\t\tfmt.Printf(\"%v: %v\\n\", name, ip.String())\n\t}\n}\n```\n\n```go\nloopback: 127.0.0.1\ngoogleDNS: 8.8.8.8\n```\n\n‍","slug":"Go/Go-basic-knowledge/Go-basic-knowledge","published":1,"updated":"2023-04-25T02:08:53.765Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli796r0u001cbyjxaf8pgc8a","content":"<h1 id=\"Go-入门知识\"><a href=\"#Go-入门知识\" class=\"headerlink\" title=\"Go 入门知识\"></a>Go 入门知识</h1><blockquote>\n<p>本章节内容基于 <a href=\"https://tour.go-zh.org/\">https://tour.go-zh.org/</a>  <a href=\"https://tour.go-zh.org/list\">Go语言测试平台</a> 索引整理完成</p>\n<p>答案训练参考：</p>\n<p><a href=\"https://gist.github.com/zyxar/2317744\">https://gist.github.com/zyxar/2317744</a></p>\n<p><a href=\"https://gist.github.com/CarlosLanderas/11b4f6727deec051883ddc02edf5cd0b\">https://gist.github.com/CarlosLanderas/11b4f6727deec051883ddc02edf5cd0b</a></p>\n<p>一些有用书籍索引：</p>\n<p><a href=\"https://books.studygolang.com/gopl-zh/\">Go语言圣经（中文版）</a></p>\n<p><a href=\"http://c.biancheng.net/golang/\">Go语言入门教程，Golang入门教程</a></p>\n<p><a href=\"https://books.studygolang.com/The-Golang-Standard-Library-by-Example/\">《Go语言标准库》</a></p>\n</blockquote>\n<h1 id=\"1-Go-包相关\"><a href=\"#1-Go-包相关\" class=\"headerlink\" title=\"1. Go 包相关\"></a>1. Go 包相关</h1><h2 id=\"1-1-路径\"><a href=\"#1-1-路径\" class=\"headerlink\" title=\"1.1 路径\"></a>1.1 路径</h2><p>每个 Go 程序都是由包构成的。</p>\n<p>程序从 <code>main</code>​​​ 包开始运行。</p>\n<p>比如通过导入路径 <code>&quot;fmt&quot;</code>​​ 和 <code>&quot;math/rand&quot;</code>​​ 来使用这两个包。</p>\n<p>按照约定，包名与导入路径的最后一个元素一致。例如，<code>&quot;math/rand&quot;</code>​​​ 包中的源码均以 <code>package rand</code>​​​ 语句开始。</p>\n<p>‍</p>\n<h2 id=\"1-2-导入包\"><a href=\"#1-2-导入包\" class=\"headerlink\" title=\"1.2 导入包\"></a>1.2 导入包</h2><p>圆括号组合了导入，这是“分组”形式的导入语</p>\n<h1 id=\"2-变量\"><a href=\"#2-变量\" class=\"headerlink\" title=\"2. 变量\"></a>2. 变量</h1><p>注意类型在变量名之后 </p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">y <span class=\"type\">int</span></span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<p><code>var</code>​​​ 语句用于声明一个变量列表，跟函数的参数列表一样，类型在最后</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a ,b c, d <span class=\"type\">int</span></span><br></pre></td></tr></table></figure>\n\n<p>变量声明可以包含初始值，每个变量对应一个， 逗号隔开，如果初始化值已存在，则可以省略类型；变量会从初始值中获得类型。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> i, j <span class=\"type\">int</span> = <span class=\"number\">1</span>, <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> c, python, java = <span class=\"literal\">true</span>, <span class=\"literal\">false</span>, <span class=\"string\">&quot;no!&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<p>简洁赋值语句 <code>:=</code>​​​ 可在类型明确的地方代替 <code>var</code>​​​ 声明。</p>\n<p>函数外的每个语句都必须以关键字开始（<code>var</code>​​​, <code>func</code>​​​ 等等），因此 ​<code>:=</code>​​​​ 结构不能在函数外使用[相较之下 var 可以写到函数外面，在包层级]</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">k := <span class=\"number\">3</span></span><br><span class=\"line\">c, python, java := <span class=\"literal\">true</span>, <span class=\"literal\">false</span>, <span class=\"string\">&quot;no!&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<p><strong>Go 的基本类型有</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bool</span><br><span class=\"line\"></span><br><span class=\"line\">string</span><br><span class=\"line\"></span><br><span class=\"line\">int  int8  int16  int32  int64</span><br><span class=\"line\">uint uint8 uint16 uint32 uint64 uintptr</span><br><span class=\"line\"></span><br><span class=\"line\">byte // uint8 的别名</span><br><span class=\"line\"></span><br><span class=\"line\">rune // int32 的别名</span><br><span class=\"line\">    // 表示一个 Unicode 码点</span><br><span class=\"line\"></span><br><span class=\"line\">float32 float64</span><br><span class=\"line\"></span><br><span class=\"line\">complex64 complex128</span><br></pre></td></tr></table></figure>\n\n<p>本例展示了几种类型的变量。 同导入语句一样，变量声明也可以“分组”成一个语法块。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> (</span><br><span class=\"line\">\tToBe   <span class=\"type\">bool</span>       = <span class=\"literal\">false</span></span><br><span class=\"line\">\tMaxInt <span class=\"type\">uint64</span>     = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">64</span> - <span class=\"number\">1</span></span><br><span class=\"line\">\tz      <span class=\"type\">complex128</span> = cmplx.Sqrt(<span class=\"number\">-5</span> + <span class=\"number\">12i</span>)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p><code>int</code>​​​, <code>uint</code>​​​ 和 <code>uintptr</code>​​​ 在 32 位系统上通常为 32 位宽，在 64 位系统上则为 64 位宽。 当你需要一个整数值时应使用 <code>int</code>​​​ 类型，除非你有特殊的理由使用固定大小或无符号的整数类型。</p>\n<p>‍</p>\n<p>没有明确初始值的变量声明会被赋予它们的 <strong>零值</strong>。</p>\n<p>零值是：</p>\n<ul>\n<li>数值类型为 <code>0</code>​​​，</li>\n<li>布尔类型为 <code>false</code>​​​，</li>\n<li>字符串为 <code>&quot;&quot;</code>​​​（空字符串）。</li>\n</ul>\n<p>‍</p>\n<p>表达式 <code>T(v)</code>​​​ 将值 <code>v</code>​​​ 转换为类型 <code>T</code>​​​。</p>\n<p>一些关于数值的转换：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var i int = 42</span><br><span class=\"line\">var f float64 = float64(i)</span><br><span class=\"line\">var u uint = uint(f)</span><br></pre></td></tr></table></figure>\n\n<p>或者，更加简单的形式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i := 42</span><br><span class=\"line\">f := float64(i)</span><br><span class=\"line\">u := uint(f)</span><br></pre></td></tr></table></figure>\n\n<p>与 C 不同的是，Go 在不同类型的项之间赋值时需要显式转换,，等号右边的数值必须是类型明确的</p>\n<p>‍</p>\n<h2 id=\"2-1-常量\"><a href=\"#2-1-常量\" class=\"headerlink\" title=\"2.1 常量\"></a>2.1 常量</h2><p>常量的声明与变量类似，只不过是使用 <code>const</code>​​​ 关键字。</p>\n<p>常量可以是字符、字符串、布尔值或数值。</p>\n<p>常量不能用 <code>:=</code>​​​ 语法声明。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> World = <span class=\"string\">&quot;世界&quot;</span></span><br><span class=\"line\"><span class=\"comment\">//相较之下，这个申明的world是一个变量，也就是可以改变其类型的</span></span><br><span class=\"line\">world := <span class=\"string\">&quot;世界&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> World = <span class=\"string\">&quot;世界&quot;</span></span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;Hello&quot;</span>, World)</span><br><span class=\"line\"></span><br><span class=\"line\">\tworld := <span class=\"string\">&quot;世界&quot;</span></span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;Go rules?&quot;</span>, world)</span><br><span class=\"line\">\tworld = <span class=\"string\">&quot;是吗&quot;</span></span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;Go rules?&quot;</span>, world)</span><br><span class=\"line\">\t结果是：</span><br><span class=\"line\">\tHello 世界</span><br><span class=\"line\">\tGo rules? 世界</span><br><span class=\"line\">\tGo rules? 是吗</span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<h2 id=\"2-2-类型推导\"><a href=\"#2-2-类型推导\" class=\"headerlink\" title=\"2.2 类型推导\"></a>2.2 类型推导</h2><p>在声明一个变量而不指定其类型时（即使用不带类型的 <code>:=</code>​​​ 语法或 <code>var =</code>​​​ 表达式语法），变量的类型由右值推导得出。</p>\n<p>当右值声明了类型时，新变量的类型与其相同：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var i int</span><br><span class=\"line\">j := i // j 也是一个 int</span><br></pre></td></tr></table></figure>\n\n<p>不过当右边包含未指明类型的数值常量时，新变量的类型就可能是 <code>int</code>​​​, <code>float64</code>​​​ 或 <code>complex128</code>​​​ 了，这取决于常量的精度：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i := 42           // int</span><br><span class=\"line\">f := 3.142        // float64</span><br><span class=\"line\">g := 0.867 + 0.5i // complex128</span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<h2 id=\"2-3-数值常量\"><a href=\"#2-3-数值常量\" class=\"headerlink\" title=\"2.3 数值常量\"></a>2.3 数值常量</h2><p>数值常量是高精度的 <strong>值</strong>。</p>\n<p>一个未指定类型的常量由上下文来决定其类型。</p>\n<p>再尝试一下输出 <code>needInt(Big)</code>​​​ 吧。</p>\n<p>（<code>int</code>​​​ 类型最大可以存储一个 64 位的整数，有时会更小。）</p>\n<p>（<code>int</code>​​​​ 可以存放最大64位的整数，根据平台不同有时会更少。）</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">\t<span class=\"comment\">// 将 1 左移 100 位来创建一个非常大的数字</span></span><br><span class=\"line\">\t<span class=\"comment\">// 即这个数的二进制是 1 后面跟着 100 个 0</span></span><br><span class=\"line\">\tBig = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">100</span></span><br><span class=\"line\">\t<span class=\"comment\">// 再往右移 99 位，即 Small = 1 &lt;&lt; 1，或者说 Small = 2</span></span><br><span class=\"line\">\tSmall = Big &gt;&gt; <span class=\"number\">99</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"3-语句\"><a href=\"#3-语句\" class=\"headerlink\" title=\"3. 语句\"></a>3. 语句</h1><h2 id=\"3-1-if\"><a href=\"#3-1-if\" class=\"headerlink\" title=\"3.1 if\"></a>3.1 if</h2><p>Go 的 <code>if</code>​​​​ 语句与 <code>for</code>​​​​ 循环类似，表达式外无需小括号 <code>( )</code>​​​​ ，而大括号 <code>&#123; &#125;</code>​​​​ 则是必须的。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> x &lt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> sqrt(-x) + <span class=\"string\">&quot;i&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-2-for\"><a href=\"#3-2-for\" class=\"headerlink\" title=\"3.2 for\"></a>3.2 for</h2><p>Go 只有一种循环结构：<code>for</code>​​​ 循环。</p>\n<p>基本的 <code>for</code>​​​ 循环由三部分组成，它们用分号隔开：</p>\n<ul>\n<li>初始化语句：在第一次迭代前执行</li>\n<li>条件表达式：在每次迭代前求值</li>\n<li>后置语句：在每次迭代的结尾执行</li>\n</ul>\n<p>初始化语句通常为一句短变量声明，该变量声明仅在 <code>for</code>​​​ 语句的作用域中可见。</p>\n<p>一旦条件表达式的布尔值为 <code>false</code>​​​，循环迭代就会终止。</p>\n<p>初始化语句和后置语句是可选的，也就是说完全可以只有一个条件，其含义也变成了wihle语句，但是go里面没有while只有for</p>\n<p><strong>注意</strong>：和 C、Java、JavaScript 之类的语言不同，<strong>Go 的 for 语句后面的三个构成部分外没有小括号</strong>， 而包围函数主体的大括号 <code>&#123; &#125;</code>​​​​ 则是必须的。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tsum := <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++ &#123;</span><br><span class=\"line\">\t\tsum += i</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfmt.Println(sum)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tsum := <span class=\"number\">1</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> sum &lt; <span class=\"number\">1000</span>&#123;</span><br><span class=\"line\">\t\tsum += sum</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfmt.Println(sum)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<h2 id=\"3-3-if-的简短语句\"><a href=\"#3-3-if-的简短语句\" class=\"headerlink\" title=\"3.3 if 的简短语句\"></a>3.3 if 的简短语句</h2><p>同 <code>for</code>​​​ 一样， <code>if</code>​​​ 语句可以在条件表达式前执行一个简单的语句。</p>\n<p><strong>该语句声明的变量作用域仅在 ​</strong><strong><code>if</code><strong>​​​</strong>​ 之内。</strong>也就是说出了if语句，这个变量就没有了</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">pow</span><span class=\"params\">(x, n, lim <span class=\"type\">float64</span>)</span></span> <span class=\"type\">float64</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> v := math.Pow(x, n); v &lt; lim &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> v</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> lim</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<h2 id=\"3-4-if-和-else\"><a href=\"#3-4-if-和-else\" class=\"headerlink\" title=\"3.4 if 和 else\"></a>3.4 if 和 else</h2><p>在 <code>if</code>​​ 的简短语句中声明的变量同样可以在任何对应的 <code>else</code>​​ 块中使用。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> v := math.Pow(x, n); v &lt; lim &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> v</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tfmt.Printf(<span class=\"string\">&quot;%g &gt;= %g\\n&quot;</span>, v, lim)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//一般格式是：</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> &#123;</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> &#123;</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span> &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-5-switch\"><a href=\"#3-5-switch\" class=\"headerlink\" title=\"3.5 switch\"></a>3.5 switch</h2><p><code>switch</code>​​ 是编写一连串 <code>if - else</code>​​ 语句的简便方法。它运行第一个值等于条件表达式的 case 语句。</p>\n<p>Go 的 switch 语句类似于 C、C++、Java、JavaScript 和 PHP 中的，不过 Go 只运行选定的 case，而非之后所有的 case。 实际上，Go 自动提供了在这些语言中每个 case 后面所需的 <code>break</code>​​ 语句。 除非以 <code>fallthrough</code>​​ 语句结束，否则分支会自动终止。 Go 的另一点重要的不同在于 switch 的 case 无需为常量，且取值不必为整数。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">switch</span> os := runtime.GOOS; os &#123;</span><br><span class=\"line\"><span class=\"keyword\">case</span> <span class=\"string\">&quot;darwin&quot;</span>:</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;OS X.&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">case</span> <span class=\"string\">&quot;linux&quot;</span>:</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;Linux.&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t<span class=\"comment\">// freebsd, openbsd,</span></span><br><span class=\"line\">\t<span class=\"comment\">// plan9, windows...</span></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;%s.\\n&quot;</span>, os)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<h2 id=\"3-6-switch-的求值顺序\"><a href=\"#3-6-switch-的求值顺序\" class=\"headerlink\" title=\"3.6 switch 的求值顺序\"></a>3.6 switch 的求值顺序</h2><p>switch 的 case 语句从上到下顺次执行，直到匹配成功时停止。</p>\n<p>（例如，  </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">switch i &#123;</span><br><span class=\"line\">case 0:</span><br><span class=\"line\">case f():</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在 <code>i==0</code>​​ 时 <code>f</code>​​ 不会被调用。  </p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">today := time.Now().Weekday()</span><br><span class=\"line\"><span class=\"keyword\">switch</span> time.Saturday &#123;</span><br><span class=\"line\"><span class=\"keyword\">case</span> today + <span class=\"number\">0</span>:</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;Today.&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">case</span> today + <span class=\"number\">1</span>:</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;Tomorrow.&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">case</span> today + <span class=\"number\">2</span>:</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;In two days.&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">default</span>:</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;Too far away.&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"3-7-没有条件的-switch\"><a href=\"#3-7-没有条件的-switch\" class=\"headerlink\" title=\"3.7 没有条件的 switch\"></a>3.7 没有条件的 switch</h2><p>没有条件的 switch 同 <code>switch true</code>​​ 一样。</p>\n<p>这种形式能将一长串 if-then-else 写得更加清晰。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">t := time.Now()</span><br><span class=\"line\">\t<span class=\"keyword\">switch</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> t.Hour() &lt; <span class=\"number\">12</span>:</span><br><span class=\"line\">\t\tfmt.Println(<span class=\"string\">&quot;Good morning!&quot;</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> t.Hour() &lt; <span class=\"number\">17</span>:</span><br><span class=\"line\">\t\tfmt.Println(<span class=\"string\">&quot;Good afternoon.&quot;</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\tfmt.Println(<span class=\"string\">&quot;Good evening.&quot;</span>)</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<h2 id=\"3-8-defer\"><a href=\"#3-8-defer\" class=\"headerlink\" title=\"3.8 defer\"></a>3.8 defer</h2><p>defer 语句会将函数推迟到外层函数返回之后执行。</p>\n<p>推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> fmt.Println(<span class=\"string\">&quot;world&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;hello&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">结果是：</span><br><span class=\"line\">hello</span><br><span class=\"line\">world</span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<h2 id=\"3-9-defer-栈\"><a href=\"#3-9-defer-栈\" class=\"headerlink\" title=\"3.9 defer 栈\"></a>3.9 defer 栈</h2><p>推迟的函数调用会被压入一个栈中。当外层函数返回时，被推迟的函数会按照后进先出的顺序调用。  </p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;counting&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++ &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">defer</span> fmt.Println(i)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;done&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">由于是按照栈的形式来存的</span><br><span class=\"line\">counting</span><br><span class=\"line\">done</span><br><span class=\"line\"><span class=\"number\">9</span></span><br><span class=\"line\"><span class=\"number\">8</span></span><br><span class=\"line\"><span class=\"number\">7</span></span><br><span class=\"line\"><span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://blog.go-zh.org/defer-panic-and-recover\">Defer，Panic,Recover</a></p>\n<p>‍</p>\n<h2 id=\"3-10-函数返回\"><a href=\"#3-10-函数返回\" class=\"headerlink\" title=\"3.10 函数返回\"></a>3.10 函数返回</h2><p>函数可以返回任意数量的返回值, 但是结构上需要结合函数形式</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">swap</span><span class=\"params\">(x, y <span class=\"type\">string</span>)</span></span> (<span class=\"type\">string</span>, <span class=\"type\">string</span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> y, x</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<p>Go 的返回值可被命名，它们会被视作定义在函数顶部的变量。</p>\n<p>返回值的名称应当具有一定的意义，它可以作为文档使用。</p>\n<p>没有参数的 <code>return</code>​ 语句返回已命名的返回值。也就是 <code>直接</code>​ 返回。</p>\n<p>直接返回语句应当仅用在下面这样的短函数中。在长的函数中它们会影响代码的可读性。</p>\n<p>(x, y int) 中的（）不可以省略</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">split</span><span class=\"params\">(sum <span class=\"type\">int</span>)</span></span> (x, y <span class=\"type\">int</span>) &#123;</span><br><span class=\"line\">\tx = sum * <span class=\"number\">4</span> / <span class=\"number\">9</span></span><br><span class=\"line\">\ty = sum - x</span><br><span class=\"line\">\t<span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<p>‍</p>\n<h2 id=\"3-11-Retrun-and-Defer\"><a href=\"#3-11-Retrun-and-Defer\" class=\"headerlink\" title=\"3.11 Retrun and Defer\"></a>3.11 Retrun and Defer</h2><blockquote>\n<p>‍</p>\n</blockquote>\n<p><img src=\"Y:/Blog/blog/source/_posts/Go/Go-basic-knowledge/assets/image-20230228154553-m65t587.png\" alt=\"image\">​</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// return语句执行步骤</span></span><br><span class=\"line\"><span class=\"comment\">// 1、返回值赋值</span></span><br><span class=\"line\"><span class=\"comment\">// 2、defer语句</span></span><br><span class=\"line\"><span class=\"comment\">// 3、真正RET返回</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f0</span><span class=\"params\">()</span></span> (x <span class=\"type\">int</span>) &#123;</span><br><span class=\"line\">\tx = <span class=\"number\">5</span></span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\tx++</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x <span class=\"comment\">//返回值RET=x, x++, RET=x=6</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f1</span><span class=\"params\">()</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\tx := <span class=\"number\">5</span></span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\tx++ <span class=\"comment\">//修改的是x，不是返回值</span></span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x <span class=\"comment\">//返回值RET=5, x++, RET=5</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f2</span><span class=\"params\">()</span></span> (x <span class=\"type\">int</span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\tx++</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">5</span> <span class=\"comment\">//返回值RET=x=5, x++, RET=6</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f3</span><span class=\"params\">()</span></span> (y <span class=\"type\">int</span>) &#123;</span><br><span class=\"line\">\tx := <span class=\"number\">5</span></span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\tx++</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x <span class=\"comment\">//返回值RET=y=x=5, x++, RET=5</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f4</span><span class=\"params\">()</span></span> (x <span class=\"type\">int</span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(x <span class=\"type\">int</span>)</span></span> &#123;</span><br><span class=\"line\">\t\tx++</span><br><span class=\"line\">\t&#125;(x)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">5</span> <span class=\"comment\">//返回值RET=x=5, x`++, RET=5</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tfmt.Println(f0()) <span class=\"comment\">//6</span></span><br><span class=\"line\">\tfmt.Println(f1()) <span class=\"comment\">//5</span></span><br><span class=\"line\">\tfmt.Println(f2()) <span class=\"comment\">//6</span></span><br><span class=\"line\">\tfmt.Println(f3()) <span class=\"comment\">//5</span></span><br><span class=\"line\">\tfmt.Println(f4()) <span class=\"comment\">//5</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>要注意的是实际返回的值和在函数内运算的值是不相同的对象，存在一个赋值的过程</p>\n<p>首先要明确 defer 后紧接的代码可以有两种写法：</p>\n<blockquote>\n<p>参考文章： </p>\n<p><a href=\"https://blog.csdn.net/qq_37102984/article/details/128946146?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~AD_ESQUERY~yljh-1-128946146-blog-116449166.pc_relevant_3mothn_strategy_and_data_recovery&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~AD_ESQUERY~yljh-1-128946146-blog-116449166.pc_relevant_3mothn_strategy_and_data_recovery\">Golang中defer和return的执行顺序 + 相关测试题（面试常考）</a></p>\n<p><a href=\"https://blog.csdn.net/qq_14997473/article/details/116449166\">Golang Defer 深入理解</a></p>\n<p><a href=\"https://cloud.tencent.com/developer/article/1453355\">汇编层面</a></p>\n<p><a href=\"https://haicoder.net/golang/golang-return.html\">Return的机制</a></p>\n</blockquote>\n<ul>\n<li><p>defer + 表达式，例如：<br>此时就会直接保留当前变量 x 已有的值到栈中，一直到最后直接打印输出，不再受后续 return x 结果的影响。例如$t e s t 1$ 和 $t e s t 2$中的变量 x 。 <strong>例如 test1 和 test2 中的变量 x。</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">defer</span> fmt.Printf(<span class=\"string\">&quot;in defer: x = %d\\n&quot;</span>, x</span><br></pre></td></tr></table></figure></li>\n<li><p>defer + 匿名函数（无入参/有入参），例如：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;fmt.Printf(<span class=\"string\">&quot;in defer: x = %d\\n&quot;</span>, x)&#125;()</span><br><span class=\"line\">或者是</span><br><span class=\"line\"><span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(n <span class=\"type\">int</span>)</span></span> &#123;fmt.Printf(<span class=\"string\">&quot;in defer x as parameter: x = %d\\n&quot;</span>, n) fmt.Printf(<span class=\"string\">&quot;in defer x after return: x = %d\\n&quot;</span>, x)&#125;(x)</span><br></pre></td></tr></table></figure>\n\n<p>此时需要区分打印输出的变量到底是【defer匿名函数内要访问的变量 n】，还是【defer匿名函数内要访问的变量 x】。</p>\n<ul>\n<li>针对【defer匿名函数内要访问的变量 n】，其值取决于在一开始遇到 defer 时入参 n 的值（也就是最开始还没被改变时的变量 x 的值，起初是0）。这个变量 n 的值是独立的，不会受后续 return x 结果的影响。</li>\n<li>针对【defer匿名函数内要访问的变量 x】，由于匿名函数能访问外部函数的变量，也就是说【defer匿名函数内要访问的变量 x】最终会被【defer匿名函数外最终要 return 返回出去的变量 x】所影响。</li>\n</ul>\n</li>\n</ul>\n<p>‍</p>\n<p>‍</p>\n<h1 id=\"4-结构及指针\"><a href=\"#4-结构及指针\" class=\"headerlink\" title=\"4. 结构及指针\"></a>4. 结构及指针</h1><h2 id=\"4-1-指针\"><a href=\"#4-1-指针\" class=\"headerlink\" title=\"4.1 指针\"></a>4.1 指针</h2><p>Go 拥有指针。指针保存了值的内存地址。</p>\n<p>类型 <code>*T</code>​ 是指向 <code>T</code>​ 类型值的指针。其零值为 <code>nil</code>​。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var p *int</span><br></pre></td></tr></table></figure>\n\n<p><code>&amp;</code>​​ 操作符会生成一个指向其操作数的指针。</p>\n<p>所以当赋值的时候，或者是传输的时候只能够只用&amp;p来表示获取到p的地址，*p是地址指向的内容</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i := 42</span><br><span class=\"line\">p = &amp;i</span><br></pre></td></tr></table></figure>\n\n<p><code>*</code>​ 操作符表示指针指向的底层值。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fmt.Println(*p) // 通过指针 p 读取 i</span><br><span class=\"line\">*p = 21         // 通过指针 p 设置 i</span><br></pre></td></tr></table></figure>\n\n<p>这也就是通常所说的“间接引用”或“重定向”。</p>\n<p>与 C 不同，Go 没有指针运算。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\ti, j := <span class=\"number\">42</span>, <span class=\"number\">2701</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tp := &amp;i         <span class=\"comment\">// 指向 i</span></span><br><span class=\"line\">\tfmt.Println(*p) <span class=\"comment\">// 通过指针读取 i 的值</span></span><br><span class=\"line\">\t*p = <span class=\"number\">21</span>         <span class=\"comment\">// 通过指针设置 i 的值</span></span><br><span class=\"line\">\tfmt.Println(i)  <span class=\"comment\">// 查看 i 的值</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tp = &amp;j         <span class=\"comment\">// 指向 j</span></span><br><span class=\"line\">\t*p = *p / <span class=\"number\">37</span>   <span class=\"comment\">// 通过指针对 j 进行除法运算</span></span><br><span class=\"line\">\tfmt.Println(j) <span class=\"comment\">// 查看 j 的值</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<h2 id=\"4-2-结构体\"><a href=\"#4-2-结构体\" class=\"headerlink\" title=\"4.2 结构体\"></a>4.2 结构体</h2><p>一个结构体（<code>struct</code>​）就是一组字段（field）。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Vertex <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tX <span class=\"type\">int</span></span><br><span class=\"line\">\tY <span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-3-结构体字段\"><a href=\"#4-3-结构体字段\" class=\"headerlink\" title=\"4.3 结构体字段\"></a>4.3 结构体字段</h2><p>结构体字段使用点号来访问。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Vertex <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tX <span class=\"type\">int</span></span><br><span class=\"line\">\tY <span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tv := Vertex&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;</span><br><span class=\"line\">\tv.X = <span class=\"number\">4</span></span><br><span class=\"line\">\tfmt.Println(v.X)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<h2 id=\"4-4-结构体指针\"><a href=\"#4-4-结构体指针\" class=\"headerlink\" title=\"4.4 结构体指针\"></a>4.4 结构体指针</h2><p>结构体字段可以通过结构体指针来访问。</p>\n<p>如果我们有一个指向结构体的指针 <code>p</code>​，那么可以通过 <code>(*p).X</code>​ 来访问其字段 <code>X</code>​。不过这么写太啰嗦了，所以语言也允许我们使用隐式间接引用，直接写 <code>p.X</code>​ 就可以。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Vertex <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tX <span class=\"type\">int</span></span><br><span class=\"line\">\tY <span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tv := Vertex&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;</span><br><span class=\"line\">\tp := &amp;v</span><br><span class=\"line\">\tp.X = <span class=\"number\">1e9</span></span><br><span class=\"line\">\tfmt.Println(v)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<h2 id=\"4-5-结构体文法\"><a href=\"#4-5-结构体文法\" class=\"headerlink\" title=\"4.5 结构体文法\"></a>4.5 结构体文法</h2><p>结构体文法通过直接列出字段的值来新分配一个结构体。</p>\n<p>使用 <code>Name:</code>​ 语法可以仅列出部分字段。（字段名的顺序无关。）</p>\n<p>特殊的前缀 <code>&amp;</code>​ 返回一个指向结构体的指针。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Vertex <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tX, Y <span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> (</span><br><span class=\"line\">\tv1 = Vertex&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;  <span class=\"comment\">// 创建一个 Vertex 类型的结构体</span></span><br><span class=\"line\">\tv2 = Vertex&#123;X: <span class=\"number\">1</span>&#125;  <span class=\"comment\">// Y:0 被隐式地赋予</span></span><br><span class=\"line\">\tv3 = Vertex&#123;&#125;      <span class=\"comment\">// X:0 Y:0</span></span><br><span class=\"line\">\tp  = &amp;Vertex&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>&#125; <span class=\"comment\">// 创建一个 *Vertex 类型的结构体（指针）</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tfmt.Println(v1, p, v2, v3)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<h2 id=\"4-6-数组\"><a href=\"#4-6-数组\" class=\"headerlink\" title=\"4.6 数组\"></a>4.6 数组</h2><p>类型 <code>[n]T</code>​ 表示拥有 <code>n</code>​ 个 <code>T</code>​ 类型的值的数组。</p>\n<p>表达式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a [10]int</span><br></pre></td></tr></table></figure>\n\n<p>会将变量 <code>a</code>​ 声明为拥有 10 个整数的数组。</p>\n<p>数组的长度是其类型的一部分，<strong>因此数组不能改变大小</strong>。这看起来是个限制，不过没关系，Go 提供了更加便利的方式来使用数组。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> a [<span class=\"number\">2</span>]<span class=\"type\">string</span></span><br><span class=\"line\">\ta[<span class=\"number\">0</span>] = <span class=\"string\">&quot;Hello&quot;</span></span><br><span class=\"line\">\ta[<span class=\"number\">1</span>] = <span class=\"string\">&quot;World&quot;</span></span><br><span class=\"line\">\tfmt.Println(a[<span class=\"number\">0</span>], a[<span class=\"number\">1</span>])</span><br><span class=\"line\">\tfmt.Println(a)</span><br><span class=\"line\"></span><br><span class=\"line\">\tprimes := [<span class=\"number\">6</span>]<span class=\"type\">int</span>&#123;<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">11</span>, <span class=\"number\">13</span>&#125;</span><br><span class=\"line\">\tfmt.Println(primes)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<p>‍</p>\n<h2 id=\"4-7-切片\"><a href=\"#4-7-切片\" class=\"headerlink\" title=\"4.7 切片\"></a>4.7 切片</h2><p>每个数组的大小都是固定的。而切片则为数组元素提供动态大小的、灵活的视角。在实践中，切片比数组更常用。</p>\n<p>切片可以看作是对数组的划分，也就是说原数组是一个全集，切片就是其依据不同标准划分的子集</p>\n<p>类型 <code>[]T</code>​ 表示一个元素类型为 <code>T</code>​ 的切片。</p>\n<p>切片通过两个下标来界定，即一个上界和一个下界，二者以冒号分隔：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a[low : high]</span><br></pre></td></tr></table></figure>\n\n<p>它会选择一个半开区间，包括第一个元素，但排除最后一个元素。</p>\n<p>以下表达式创建了一个切片，它包含 <code>a</code>​ 中下标从 1 到 3 的元素：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a[1:4]</span><br></pre></td></tr></table></figure>\n\n<p>切片就像数组的引用</p>\n<p>切片并不存储任何数据，它只是描述了底层数组中的一段。</p>\n<p>更改切片的元素会修改其底层数组中对应的元素。</p>\n<p>与它<strong>共享底层数组</strong>的切片都会观测到这些修改（也就是说它是一种深拷贝）</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tnames := [<span class=\"number\">4</span>]<span class=\"type\">string</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"string\">&quot;John&quot;</span>,</span><br><span class=\"line\">\t\t<span class=\"string\">&quot;Paul&quot;</span>,</span><br><span class=\"line\">\t\t<span class=\"string\">&quot;George&quot;</span>,</span><br><span class=\"line\">\t\t<span class=\"string\">&quot;Ringo&quot;</span>,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfmt.Println(names)</span><br><span class=\"line\"></span><br><span class=\"line\">\ta := names[<span class=\"number\">0</span>:<span class=\"number\">2</span>]</span><br><span class=\"line\">\tb := names[<span class=\"number\">1</span>:<span class=\"number\">3</span>]</span><br><span class=\"line\">\tfmt.Println(a, b)</span><br><span class=\"line\"></span><br><span class=\"line\">\tb[<span class=\"number\">0</span>] = <span class=\"string\">&quot;XXX&quot;</span></span><br><span class=\"line\">\tfmt.Println(a, b)</span><br><span class=\"line\">\tfmt.Println(names)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<h2 id=\"4-8-切片文法\"><a href=\"#4-8-切片文法\" class=\"headerlink\" title=\"4.8 切片文法\"></a>4.8 切片文法</h2><p>切片文法类似于没有长度的数组文法。</p>\n<p>这是一个数组文法：<strong>构建的是一个数组</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[3]bool&#123;true, true, false&#125;</span><br></pre></td></tr></table></figure>\n\n<p>下面这样则会创建一个和上面相同的数组，然后构建一个引用了它的切片：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[]bool&#123;true, true, false&#125;</span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<h2 id=\"4-9-切片的默认行为\"><a href=\"#4-9-切片的默认行为\" class=\"headerlink\" title=\"4.9 切片的默认行为\"></a>4.9 切片的默认行为</h2><p>在进行切片时，你可以利用它的默认行为来忽略上下界。</p>\n<p>切片下界的默认值为 <code>0</code>​，上界则是该切片的长度。</p>\n<p>对于数组</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a [10]int</span><br></pre></td></tr></table></figure>\n\n<p>来说，以下切片是等价的：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a[0:10]</span><br><span class=\"line\">a[:10]</span><br><span class=\"line\">a[0:]</span><br><span class=\"line\">a[:]</span><br></pre></td></tr></table></figure>\n\n<p>可以明确的是：</p>\n<ol>\n<li><p>数组和切片不能够相互赋值</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这个函数不可行，因为s 初始化的是一个数组，之后不能够赋值给切片</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\ts := [<span class=\"number\">6</span>]<span class=\"type\">int</span>&#123;<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">11</span>, <span class=\"number\">13</span>&#125;</span><br><span class=\"line\">\ts = s[<span class=\"number\">1</span>:<span class=\"number\">4</span>]</span><br><span class=\"line\">\tfmt.Println(s)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">报错显示：</span><br><span class=\"line\">./prog.<span class=\"keyword\">go</span>:<span class=\"number\">8</span>:<span class=\"number\">7</span>: cannot use s[<span class=\"number\">1</span>:<span class=\"number\">4</span>] (value of <span class=\"keyword\">type</span> []<span class=\"type\">int</span>) as [<span class=\"number\">6</span>]<span class=\"type\">int</span> value in assignment</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>‍</p>\n<h2 id=\"4-10-切片的长度与容量\"><a href=\"#4-10-切片的长度与容量\" class=\"headerlink\" title=\"4.10 切片的长度与容量\"></a>4.10 切片的长度与容量</h2><p>切片拥有 <strong>长度</strong> 和 <strong>容量</strong>。</p>\n<p>切片的长度就是它所包含的元素个数。</p>\n<p>切片的容量是从它的第一个元素开始数，到其底层数组元素末尾的个数；容量也可以理解为切片总的能够扩展的（包括长度）数量</p>\n<p>切片 <code>s</code>​ 的长度和容量可通过表达式 <code>len(s)</code>​ 和 <code>cap(s)</code>​ 来获取。</p>\n<p>你可以通过重新切片来扩展一个切片，给它提供足够的容量</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\ts := []<span class=\"type\">int</span>&#123;<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">11</span>, <span class=\"number\">13</span>&#125;</span><br><span class=\"line\">\tprintSlice(s)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 截取切片使其长度为 0</span></span><br><span class=\"line\">\ts = s[:<span class=\"number\">0</span>]</span><br><span class=\"line\">\tprintSlice(s)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 拓展其长度</span></span><br><span class=\"line\">\ts = s[:<span class=\"number\">4</span>]</span><br><span class=\"line\">\tprintSlice(s)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 舍弃前两个值</span></span><br><span class=\"line\">\ts = s[<span class=\"number\">2</span>:]</span><br><span class=\"line\">\tprintSlice(s)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">printSlice</span><span class=\"params\">(s []<span class=\"type\">int</span>)</span></span> &#123;</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;len=%d cap=%d %v\\n&quot;</span>, <span class=\"built_in\">len</span>(s), <span class=\"built_in\">cap</span>(s), s)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<h2 id=\"4-11-nil-切片\"><a href=\"#4-11-nil-切片\" class=\"headerlink\" title=\"4.11 nil 切片\"></a>4.11 nil 切片</h2><p>切片的零值是 <code>nil</code>​。</p>\n<p>nil 切片的长度和容量为 0 且没有底层数组。</p>\n<p>‍</p>\n<h2 id=\"4-12-用-make-创建切片\"><a href=\"#4-12-用-make-创建切片\" class=\"headerlink\" title=\"4.12 用 make 创建切片\"></a>4.12 用 make 创建切片</h2><p>切片可以用内建函数 <code>make</code>​ 来创建，这也是你创建动态数组的方式。</p>\n<p><code>make</code>​ 函数会分配一个元素为零值的数组并返回一个引用了它的切片：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a := make([]int, 5)  // len(a)=5</span><br></pre></td></tr></table></figure>\n\n<p>要指定它的容量，需向 <code>make</code>​ 传入第三个参数：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">b := make([]int, 0, 5) // len(b)=0, cap(b)=5</span><br><span class=\"line\"></span><br><span class=\"line\">b = b[:cap(b)] // len(b)=5, cap(b)=5</span><br><span class=\"line\">b = b[1:]      // len(b)=4, cap(b)=4</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\ta := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\">\tprintSlice(<span class=\"string\">&quot;a&quot;</span>, a)</span><br><span class=\"line\"></span><br><span class=\"line\">\tb := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, <span class=\"number\">0</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\">\tprintSlice(<span class=\"string\">&quot;b&quot;</span>, b)</span><br><span class=\"line\"></span><br><span class=\"line\">\tc := b[:<span class=\"number\">2</span>]</span><br><span class=\"line\">\tprintSlice(<span class=\"string\">&quot;c&quot;</span>, c)</span><br><span class=\"line\"></span><br><span class=\"line\">\td := c[<span class=\"number\">2</span>:<span class=\"number\">5</span>]</span><br><span class=\"line\">\tprintSlice(<span class=\"string\">&quot;d&quot;</span>, d)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">printSlice</span><span class=\"params\">(s <span class=\"type\">string</span>, x []<span class=\"type\">int</span>)</span></span> &#123;</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;%s len=%d cap=%d %v\\n&quot;</span>,</span><br><span class=\"line\">\t\ts, <span class=\"built_in\">len</span>(x), <span class=\"built_in\">cap</span>(x), x)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">结果显示为：</span><br><span class=\"line\">a <span class=\"built_in\">len</span>=<span class=\"number\">5</span> <span class=\"built_in\">cap</span>=<span class=\"number\">5</span> [<span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">0</span>]</span><br><span class=\"line\">b <span class=\"built_in\">len</span>=<span class=\"number\">0</span> <span class=\"built_in\">cap</span>=<span class=\"number\">5</span> []</span><br><span class=\"line\">c <span class=\"built_in\">len</span>=<span class=\"number\">2</span> <span class=\"built_in\">cap</span>=<span class=\"number\">5</span> [<span class=\"number\">0</span> <span class=\"number\">0</span>]</span><br><span class=\"line\">d <span class=\"built_in\">len</span>=<span class=\"number\">3</span> <span class=\"built_in\">cap</span>=<span class=\"number\">3</span> [<span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">0</span>]</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<h2 id=\"4-13-创建二维切片：\"><a href=\"#4-13-创建二维切片：\" class=\"headerlink\" title=\"4. 13 创建二维切片：\"></a>4. 13 创建二维切片：</h2><blockquote>\n<p>参考文献：</p>\n<p><a href=\"https://www.cnblogs.com/yahuian/p/11934122.html\">直接参考的</a></p>\n<p><a href=\"https://stackoverflow.com/questions/39804861/what-is-a-concise-way-to-create-a-2d-slice-in-go\">Stack  例子讲解：</a></p>\n<p><a href=\"https://stackoverflow.com/questions/9320862/why-would-i-make-or-new\">make 和  new 的区别</a></p>\n<p><a href=\"https://stackoverflow.com/questions/39561140/what-is-two-dimensional-arrays-memory-representation\">二维数组的结合</a></p>\n</blockquote>\n<p>最常用的方法，需要记忆：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a := <span class=\"built_in\">make</span>([][]<span class=\"type\">uint8</span>, dy)</span><br><span class=\"line\"><span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> a &#123;</span><br><span class=\"line\">    a[i] = <span class=\"built_in\">make</span>([]<span class=\"type\">uint8</span>, dx)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方法0</span></span><br><span class=\"line\">row, column := <span class=\"number\">3</span>, <span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> answer [][]<span class=\"type\">int</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; row; i++ &#123;</span><br><span class=\"line\">\tinline := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, column)</span><br><span class=\"line\">\tanswer = <span class=\"built_in\">append</span>(answer, inline)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fmt.Println(answer)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方法1，最常用</span></span><br><span class=\"line\">answer1 := <span class=\"built_in\">make</span>([][]<span class=\"type\">int</span>, row)</span><br><span class=\"line\"><span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> answer1 &#123;</span><br><span class=\"line\">\tanswer1[i] = <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, column)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<p>‍</p>\n<h2 id=\"4-14-切片的切片\"><a href=\"#4-14-切片的切片\" class=\"headerlink\" title=\"4. 14 切片的切片\"></a>4. 14 切片的切片</h2><p>切片可包含任何类型，甚至包括其它的切片[参照二维数组]</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;strings&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 创建一个井字板（经典游戏）</span></span><br><span class=\"line\">\tboard := [][]<span class=\"type\">string</span>&#123;</span><br><span class=\"line\">\t\t[]<span class=\"type\">string</span>&#123;<span class=\"string\">&quot;_&quot;</span>, <span class=\"string\">&quot;_&quot;</span>, <span class=\"string\">&quot;_&quot;</span>&#125;,</span><br><span class=\"line\">\t\t[]<span class=\"type\">string</span>&#123;<span class=\"string\">&quot;_&quot;</span>, <span class=\"string\">&quot;_&quot;</span>, <span class=\"string\">&quot;_&quot;</span>&#125;,</span><br><span class=\"line\">\t\t[]<span class=\"type\">string</span>&#123;<span class=\"string\">&quot;_&quot;</span>, <span class=\"string\">&quot;_&quot;</span>, <span class=\"string\">&quot;_&quot;</span>&#125;,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 两个玩家轮流打上 X 和 O</span></span><br><span class=\"line\">\tboard[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"string\">&quot;X&quot;</span></span><br><span class=\"line\">\tboard[<span class=\"number\">2</span>][<span class=\"number\">2</span>] = <span class=\"string\">&quot;O&quot;</span></span><br><span class=\"line\">\tboard[<span class=\"number\">1</span>][<span class=\"number\">2</span>] = <span class=\"string\">&quot;X&quot;</span></span><br><span class=\"line\">\tboard[<span class=\"number\">1</span>][<span class=\"number\">0</span>] = <span class=\"string\">&quot;O&quot;</span></span><br><span class=\"line\">\tboard[<span class=\"number\">0</span>][<span class=\"number\">2</span>] = <span class=\"string\">&quot;X&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(board); i++ &#123;</span><br><span class=\"line\">\t\tfmt.Printf(<span class=\"string\">&quot;%s\\n&quot;</span>, strings.Join(board[i], <span class=\"string\">&quot; &quot;</span>))</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-15-向切片追加元素\"><a href=\"#4-15-向切片追加元素\" class=\"headerlink\" title=\"4. 15 向切片追加元素\"></a>4. 15 向切片追加元素</h2><p>为切片追加新的元素是种常用的操作，为此 Go 提供了内建的 <code>append</code>​ 函数。内建函数的<a href=\"https://go-zh.org/pkg/builtin/#append\">文档</a>对此函数有详细的介绍。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func append(s []T, vs ...T) []T</span><br></pre></td></tr></table></figure>\n\n<p><code>append</code>​ 的第一个参数 <code>s</code>​ 是一个元素类型为 <code>T</code>​ 的切片，其余类型为 <code>T</code>​ 的值将会追加到该切片的末尾。</p>\n<p><code>append</code>​ 的结果是一个包含原切片所有元素加上新添加元素的切片。</p>\n<p>当 <code>s</code>​ 的底层数组太小，不足以容纳所有给定的值时，它就会分配一个更大的数组。返回的切片会指向这个新分配的数组。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> s []<span class=\"type\">int</span></span><br><span class=\"line\">\tprintSlice(s)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 添加一个空切片</span></span><br><span class=\"line\">\ts = <span class=\"built_in\">append</span>(s, <span class=\"number\">0</span>)</span><br><span class=\"line\">\tprintSlice(s)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 这个切片会按需增长</span></span><br><span class=\"line\">\ts = <span class=\"built_in\">append</span>(s, <span class=\"number\">1</span>)</span><br><span class=\"line\">\tprintSlice(s)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 可以一次性添加多个元素</span></span><br><span class=\"line\">\ts = <span class=\"built_in\">append</span>(s, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\">\tprintSlice(s)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">printSlice</span><span class=\"params\">(s []<span class=\"type\">int</span>)</span></span> &#123;</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;len=%d cap=%d %v\\n&quot;</span>, <span class=\"built_in\">len</span>(s), <span class=\"built_in\">cap</span>(s), s)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可参考文章：  <a href=\"https://blog.go-zh.org/go-slices-usage-and-internals\">Go 切片：用法和本质</a></p>\n<p>‍</p>\n<h2 id=\"4-16-Range\"><a href=\"#4-16-Range\" class=\"headerlink\" title=\"4. 16 Range\"></a>4. 16 Range</h2><p><code>for</code>​ 循环的 <code>range</code>​ 形式可遍历切片或映射。</p>\n<p>当使用 <code>for</code>​ 循环遍历切片时，每次迭代都会返回两个值。第一个值为当前元素的下标，第二个值为该下标所对应元素的一份副本。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> pow = []<span class=\"type\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">8</span>, <span class=\"number\">16</span>, <span class=\"number\">32</span>, <span class=\"number\">64</span>, <span class=\"number\">128</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i, v := <span class=\"keyword\">range</span> pow &#123;</span><br><span class=\"line\">\t\tfmt.Printf(<span class=\"string\">&quot;2**%d = %d\\n&quot;</span>, i, v)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<h2 id=\"4-17-range（续）\"><a href=\"#4-17-range（续）\" class=\"headerlink\" title=\"4. 17 range（续）\"></a>4. 17 range（续）</h2><p>可以将下标或值赋予 <code>_</code>​ 来忽略它。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for i, _ := range pow</span><br><span class=\"line\">for _, value := range pow</span><br></pre></td></tr></table></figure>\n\n<p>若你只需要索引，忽略第二个变量即可。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for i := range pow</span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<h2 id=\"4-18-映射（Map）\"><a href=\"#4-18-映射（Map）\" class=\"headerlink\" title=\"4. 18 映射（Map）\"></a>4. 18 映射（Map）</h2><p>映射将键映射到值。</p>\n<p>映射的零值为 <code>nil</code>​ 。<code>nil</code>​ 映射既没有键，也不能添加键。</p>\n<p><code>make</code>​ 函数会返回给定类型的映射，并将其初始化备用。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Vertex <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tLat, Long <span class=\"type\">float64</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> m <span class=\"keyword\">map</span>[<span class=\"type\">string</span>]Vertex</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tm = <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">string</span>]Vertex)</span><br><span class=\"line\">\tm[<span class=\"string\">&quot;Bell Labs&quot;</span>] = Vertex&#123;</span><br><span class=\"line\">\t\t<span class=\"number\">40.68433</span>, <span class=\"number\">-74.39967</span>,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfmt.Println(m[<span class=\"string\">&quot;Bell Labs&quot;</span>])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"4-19-映射的文法\"><a href=\"#4-19-映射的文法\" class=\"headerlink\" title=\"4. 19 映射的文法\"></a>4. 19 映射的文法</h2><p>映射的文法与结构体相似，不过必须有键名。</p>\n<p>若顶级类型只是一个类型名，你可以在文法的元素中省略它。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Vertex <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tLat, Long <span class=\"type\">float64</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> m = <span class=\"keyword\">map</span>[<span class=\"type\">string</span>]Vertex&#123;</span><br><span class=\"line\">\t<span class=\"string\">&quot;Bell Labs&quot;</span>: &#123;<span class=\"number\">40.68433</span>, <span class=\"number\">-74.39967</span>&#125;,</span><br><span class=\"line\">\t<span class=\"string\">&quot;Google&quot;</span>:    &#123;<span class=\"number\">37.42202</span>, <span class=\"number\">-122.08408</span>&#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tfmt.Println(m)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<h2 id=\"4-20-修改映射\"><a href=\"#4-20-修改映射\" class=\"headerlink\" title=\"4. 20 修改映射\"></a>4. 20 修改映射</h2><p>在映射 <code>m</code>​ 中插入或修改元素：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">m[key] = elem</span><br></pre></td></tr></table></figure>\n\n<p>获取元素：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">elem = m[key]</span><br></pre></td></tr></table></figure>\n\n<p>删除元素：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">delete(m, key)</span><br></pre></td></tr></table></figure>\n\n<p>通过双赋值检测某个键是否存在：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">elem, ok = m[key]</span><br></pre></td></tr></table></figure>\n\n<p>若 <code>key</code>​ 在 <code>m</code>​ 中，<code>ok</code>​ 为 <code>true</code>​ ；否则，<code>ok</code>​ 为 <code>false</code>​。</p>\n<p>若 <code>key</code>​ 不在映射中，那么 <code>elem</code>​ 是该映射元素类型的零值。</p>\n<p>同样的，当从映射中读取某个不存在的键时，结果是映射的元素类型的零值。</p>\n<p><strong>注</strong> ：若 <code>elem</code>​ 或 <code>ok</code>​ 还未声明，你可以使用短变量声明：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">elem, ok := m[key]</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tm := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"type\">int</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\tm[<span class=\"string\">&quot;Answer&quot;</span>] = <span class=\"number\">42</span></span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;The value:&quot;</span>, m[<span class=\"string\">&quot;Answer&quot;</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">\tm[<span class=\"string\">&quot;Answer&quot;</span>] = <span class=\"number\">48</span></span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;The value:&quot;</span>, m[<span class=\"string\">&quot;Answer&quot;</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">delete</span>(m, <span class=\"string\">&quot;Answer&quot;</span>)</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;The value:&quot;</span>, m[<span class=\"string\">&quot;Answer&quot;</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">\tv, ok := m[<span class=\"string\">&quot;Answer&quot;</span>]</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;The value:&quot;</span>, v, <span class=\"string\">&quot;Present?&quot;</span>, ok)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<p>‍</p>\n<h2 id=\"4-21-函数值\"><a href=\"#4-21-函数值\" class=\"headerlink\" title=\"4. 21 函数值\"></a>4. 21 函数值</h2><p>函数也是值。它们可以像其它值一样传递。</p>\n<p>函数值可以用作函数的参数或返回值。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;math&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">compute</span><span class=\"params\">(fn <span class=\"keyword\">func</span>(<span class=\"type\">float64</span>, <span class=\"type\">float64</span>)</span></span> <span class=\"type\">float64</span>) <span class=\"type\">float64</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> fn(<span class=\"number\">3</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\thypot := <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(x, y <span class=\"type\">float64</span>)</span></span> <span class=\"type\">float64</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> math.Sqrt(x*x + y*y)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfmt.Println(hypot(<span class=\"number\">5</span>, <span class=\"number\">12</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">\tfmt.Println(compute(hypot))</span><br><span class=\"line\">\tfmt.Println(compute(math.Pow))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<h2 id=\"4-22-函数的闭包\"><a href=\"#4-22-函数的闭包\" class=\"headerlink\" title=\"4. 22 函数的闭包\"></a>4. 22 函数的闭包</h2><p>Go 函数可以是一个闭包。闭包是一个函数值，它引用了其函数体之外的变量。该函数可以访问并赋予其引用的变量的值，换句话说，该函数被这些变量“绑定”在一起。</p>\n<p>例如，函数 <code>adder</code>​ 返回一个闭包。每个闭包都被绑定在其各自的 <code>sum</code>​ 变量上。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">adder</span><span class=\"params\">()</span></span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(<span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\tsum := <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(x <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\t\tsum += x</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> sum</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tpos, neg := adder(), adder()</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++ &#123;</span><br><span class=\"line\">\t\tfmt.Println(</span><br><span class=\"line\">\t\t\tpos(i),</span><br><span class=\"line\">\t\t\tneg(<span class=\"number\">-2</span>*i),</span><br><span class=\"line\">\t\t)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">最终的结果是：</span><br><span class=\"line\"><span class=\"number\">0</span> <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">1</span> <span class=\"number\">-2</span></span><br><span class=\"line\"><span class=\"number\">3</span> <span class=\"number\">-6</span></span><br><span class=\"line\"><span class=\"number\">6</span> <span class=\"number\">-12</span></span><br><span class=\"line\"><span class=\"number\">10</span> <span class=\"number\">-20</span></span><br><span class=\"line\"><span class=\"number\">15</span> <span class=\"number\">-30</span></span><br><span class=\"line\"><span class=\"number\">21</span> <span class=\"number\">-42</span></span><br><span class=\"line\"><span class=\"number\">28</span> <span class=\"number\">-56</span></span><br><span class=\"line\"><span class=\"number\">36</span> <span class=\"number\">-72</span></span><br><span class=\"line\"><span class=\"number\">45</span> <span class=\"number\">-90</span></span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<p>‍</p>\n<h1 id=\"5-方法和接口\"><a href=\"#5-方法和接口\" class=\"headerlink\" title=\"5. 方法和接口\"></a>5. 方法和接口</h1><h2 id=\"5-1-方法\"><a href=\"#5-1-方法\" class=\"headerlink\" title=\"5.1 方法\"></a>5.1 方法</h2><p>Go 没有类。不过你可以为结构体类型定义方法。</p>\n<p>方法就是一类带特殊的 ​<strong>接收者</strong>​ 参数的函数。</p>\n<p>方法接收者在它自己的参数列表内，位于 <code>func</code>​ 关键字和方法名之间。</p>\n<p>在此例中，<code>Abs</code>​ 方法拥有一个名为 <code>v</code>​，类型为 <code>Vertex</code>​ 的接收者。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;math&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Vertex <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tX, Y <span class=\"type\">float64</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(v Vertex)</span></span> Abs() <span class=\"type\">float64</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tv := Vertex&#123;<span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;</span><br><span class=\"line\">\tfmt.Println(v.Abs())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>方法即函数</p>\n<p>记住：方法只是个带接收者参数的函数。</p>\n<p>现在这个 <code>Abs</code>​ 的写法就是个正常的函数，功能并没有什么变化。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;math&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Vertex <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tX, Y <span class=\"type\">float64</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Abs</span><span class=\"params\">(v Vertex)</span></span> <span class=\"type\">float64</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tv := Vertex&#123;<span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;</span><br><span class=\"line\">\tfmt.Println(Abs(v))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是这个是函数，并不能够通过v对象直接调用</p>\n<p>‍</p>\n<h2 id=\"5-2-方法（续）\"><a href=\"#5-2-方法（续）\" class=\"headerlink\" title=\"5.2 方法（续）\"></a>5.2 方法（续）</h2><p>你也可以为非结构体类型声明方法。</p>\n<p>在此例中，我们看到了一个带 <code>Abs</code>​ 方法的数值类型 <code>MyFloat</code>​。</p>\n<p>你只能为在同一包内定义的类型的接收者声明方法，而不能为其它包内定义的类型（包括 <code>int</code>​ 之类的内建类型）的接收者声明方法。</p>\n<p>（译注：就是接收者的类型定义和方法声明必须在同一包内；不能为内建类型声明方法。）</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;math&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> MyFloat <span class=\"type\">float64</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(f MyFloat)</span></span> Abs() <span class=\"type\">float64</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> f &lt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"type\">float64</span>(-f)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"type\">float64</span>(f)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tf := MyFloat(-math.Sqrt2)</span><br><span class=\"line\">\tfmt.Println(f.Abs())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<h2 id=\"5-3-指针接收者\"><a href=\"#5-3-指针接收者\" class=\"headerlink\" title=\"5.3 指针接收者\"></a>5.3 指针接收者</h2><p>你可以为指针接收者声明方法。</p>\n<p>这意味着对于某类型 <code>T</code>​，接收者的类型可以用 <code>*T</code>​ 的文法。（<strong>此外，</strong><strong><code>T</code><strong>​</strong>​ 不能是像 ​</strong><strong><code>*int</code><strong>​</strong>​ 这样的指针，换句话说就是没有双指针。</strong>不能够出现**int这样的结构）</p>\n<p>例如，这里为 <code>*Vertex</code>​ 定义了 <code>Scale</code>​ 方法。</p>\n<p>指针接收者的方法可以修改接收者指向的值（就像 <code>Scale</code>​ 在这做的）。由于方法经常需要修改它的接收者，指针接收者比值接收者更常用。</p>\n<p>试着移除第 16 行 <code>Scale</code>​ 函数声明中的 <code>*</code>​，观察此程序的行为如何变化。</p>\n<p>若使用值接收者，那么 <code>Scale</code>​ 方法会对原始 <code>Vertex</code>​ 值<strong>的副本</strong>进行操作。（对于函数的其它参数也是如此。）<code>Scale</code>​ 方法必须用指针接受者来更改 <code>main</code>​ 函数中声明的 <code>Vertex</code>​ 的值。也就是说使用指针的时候才能够对原本的数据结构当中的值做修改，但如果使用值接收者，就会修改一个副本，那么函数之间的调用修改就会不起作用，生命周期只在这个函数当中完成。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;math&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Vertex <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tX, Y <span class=\"type\">float64</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(v Vertex)</span></span> Abs() <span class=\"type\">float64</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//使用指针接收者，结果会是50 ，也就是说本函数的修改，abs能够获取到</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(v *Vertex)</span></span> Scale(f <span class=\"type\">float64</span>) &#123;</span><br><span class=\"line\">\tv.X = v.X * f</span><br><span class=\"line\">\tv.Y = v.Y * f</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//使用值接收者，结果会是5，也就是说本函数的修改只在本函数当中，abs无法感知到v.x,v.y的值发生变化</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(v Vertex)</span></span> Scale(f <span class=\"type\">float64</span>) &#123;</span><br><span class=\"line\">\tv.X = v.X * f</span><br><span class=\"line\">\tv.Y = v.Y * f</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tv := Vertex&#123;<span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;</span><br><span class=\"line\">\tv.Scale(<span class=\"number\">10</span>)</span><br><span class=\"line\">\tfmt.Println(v.Abs())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"Y:/Blog/blog/source/_posts/Go/Go-basic-knowledge/assets/image-20230228103213-yqcw1ma.png\" alt=\"image\">​</p>\n<p>‍</p>\n<h2 id=\"5-4-方法与指针重定向\"><a href=\"#5-4-方法与指针重定向\" class=\"headerlink\" title=\"5.4 方法与指针重定向\"></a>5.4 方法与指针重定向</h2><p>比较前两个程序，你大概会注意到<strong>带指针参数的函数必须接受一个指针</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var v Vertex</span><br><span class=\"line\">ScaleFunc(v, 5)  // 编译错误！</span><br><span class=\"line\">ScaleFunc(&amp;v, 5) // OK</span><br></pre></td></tr></table></figure>\n\n<p>而以<strong>指针为接收者的方法被调用时，接收者既能为值又能为指针：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var v Vertex</span><br><span class=\"line\">v.Scale(5)  // OK</span><br><span class=\"line\">p := &amp;v</span><br><span class=\"line\">p.Scale(10) // OK</span><br></pre></td></tr></table></figure>\n\n<p>对于语句 <code>v.Scale(5)</code>​，即便 <code>v</code>​ 是个值而非指针，带指针接收者的方法也能被直接调用。 也就是说，由于 <code>Scale</code>​ 方法有一个指针接收者，为方便起见，Go 会将语句 <code>v.Scale(5)</code>​ 解释为 <code>(&amp;v).Scale(5)</code>​。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Vertex <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tX, Y <span class=\"type\">float64</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(v *Vertex)</span></span> Scale(f <span class=\"type\">float64</span>) &#123;</span><br><span class=\"line\">\tv.X = v.X * f</span><br><span class=\"line\">\tv.Y = v.Y * f</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">ScaleFunc</span><span class=\"params\">(v *Vertex, f <span class=\"type\">float64</span>)</span></span> &#123;</span><br><span class=\"line\">\tv.X = v.X * f</span><br><span class=\"line\">\tv.Y = v.Y * f</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tv := Vertex&#123;<span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;</span><br><span class=\"line\">\tv.Scale(<span class=\"number\">2</span>)</span><br><span class=\"line\">\tScaleFunc(&amp;v, <span class=\"number\">10</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\tp := &amp;Vertex&#123;<span class=\"number\">4</span>, <span class=\"number\">3</span>&#125;</span><br><span class=\"line\">\tp.Scale(<span class=\"number\">3</span>)</span><br><span class=\"line\">\tScaleFunc(p, <span class=\"number\">8</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\tfmt.Println(v, p)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同样的事情也发生在相反的方向。</p>\n<p>接受一个值作为参数的函数必须接受一个指定类型的值：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var v Vertex</span><br><span class=\"line\">fmt.Println(AbsFunc(v))  // OK</span><br><span class=\"line\">fmt.Println(AbsFunc(&amp;v)) // 编译错误！</span><br></pre></td></tr></table></figure>\n\n<p>而以值为接收者的方法被调用时，接收者既能为值又能为指针：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var v Vertex</span><br><span class=\"line\">fmt.Println(v.Abs()) // OK</span><br><span class=\"line\">p := &amp;v</span><br><span class=\"line\">fmt.Println(p.Abs()) // OK</span><br></pre></td></tr></table></figure>\n\n<p>这种情况下，方法调用 <code>p.Abs()</code>​ 会被解释为 <code>(*p).Abs()</code>​。</p>\n<p>‍</p>\n<h2 id=\"5-5-选择值或指针作为接收者\"><a href=\"#5-5-选择值或指针作为接收者\" class=\"headerlink\" title=\"5.5 选择值或指针作为接收者\"></a>5.5 选择值或指针作为接收者</h2><p>使用指针接收者的原因有二：</p>\n<p>首先，方法能够修改其接收者指向的值。</p>\n<p>其次，这样可以避免在每次调用方法时复制该值。若值的类型为大型结构体时，这样做会更加高效。</p>\n<p>在本例中，<code>Scale</code>​ 和 <code>Abs</code>​ 接收者的类型为 <code>*Vertex</code>​，即便 <code>Abs</code>​ 并不需要修改其接收者。</p>\n<p>通常来说，所有给定类型的方法都应该有值或指针接收者，但并不应该二者混用。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;math&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Vertex <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tX, Y <span class=\"type\">float64</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(v *Vertex)</span></span> Scale(f <span class=\"type\">float64</span>) &#123;</span><br><span class=\"line\">\tv.X = v.X * f</span><br><span class=\"line\">\tv.Y = v.Y * f</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(v *Vertex)</span></span> Abs() <span class=\"type\">float64</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tv := &amp;Vertex&#123;<span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;Before scaling: %+v, Abs: %v\\n&quot;</span>, v, v.Abs())</span><br><span class=\"line\">\tv.Scale(<span class=\"number\">5</span>)</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;After scaling: %+v, Abs: %v\\n&quot;</span>, v, v.Abs())</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">结果显示是：</span><br><span class=\"line\">Before scaling: &amp;&#123;X:<span class=\"number\">3</span> Y:<span class=\"number\">4</span>&#125;, Abs: <span class=\"number\">5</span></span><br><span class=\"line\">After scaling: &amp;&#123;X:<span class=\"number\">15</span> Y:<span class=\"number\">20</span>&#125;, Abs: <span class=\"number\">25</span></span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<h2 id=\"5-6-接口\"><a href=\"#5-6-接口\" class=\"headerlink\" title=\"5. 6 接口\"></a>5. 6 接口</h2><p><strong>接口类型</strong> 是由一组方法签名定义的集合。</p>\n<blockquote>\n<p>参考文献 ：</p>\n<p><a href=\"https://blog.kennycoder.io/2020/02/03/Golang-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3interface%E5%B8%B8%E8%A6%8B%E7%94%A8%E6%B3%95/\">接口常见知识</a></p>\n</blockquote>\n<p>接口类型的变量可以保存任何实现了这些方法的值。</p>\n<blockquote>\n<p>接口就可以理解为一系列动作的集合<br><strong>而某个struct能够实现里面的所有方法，那么这个struct就是这个接口的一个实现</strong></p>\n</blockquote>\n<p><strong>注意:</strong> 示例代码的 22 行存在一个错误。由于 <code>Abs</code>​ 方法只为 <code>*Vertex</code>​ （指针类型）定义，因此 <code>Vertex</code>​（值类型）并未实现 <code>Abser</code>​。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Abser <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">\tAbs() <span class=\"type\">float64</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> a Abser</span><br><span class=\"line\">\tf := MyFloat(-math.Sqrt2)</span><br><span class=\"line\">\tv := Vertex&#123;<span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\ta = f  <span class=\"comment\">// a MyFloat 实现了 Abser</span></span><br><span class=\"line\">\ta = &amp;v <span class=\"comment\">// a *Vertex 实现了 Abser</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 下面一行，v 是一个 Vertex（而不是 *Vertex）</span></span><br><span class=\"line\">\t<span class=\"comment\">// 所以没有实现 Abser。</span></span><br><span class=\"line\">\ta = v</span><br><span class=\"line\"></span><br><span class=\"line\">\tfmt.Println(a.Abs())</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> MyFloat <span class=\"type\">float64</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(f MyFloat)</span></span> Abs() <span class=\"type\">float64</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> f &lt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"type\">float64</span>(-f)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"type\">float64</span>(f)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Vertex <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tX, Y <span class=\"type\">float64</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(v *Vertex)</span></span> Abs() <span class=\"type\">float64</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">显示错误：</span><br><span class=\"line\">./prog.<span class=\"keyword\">go</span>:<span class=\"number\">22</span>:<span class=\"number\">6</span>: cannot use v (variable of <span class=\"keyword\">type</span> Vertex) as Abser value in assignment: Vertex does not implement Abser (method Abs has pointer receiver)</span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<h2 id=\"5-7-接口与隐式实现\"><a href=\"#5-7-接口与隐式实现\" class=\"headerlink\" title=\"5.7 接口与隐式实现\"></a>5.7 接口与隐式实现</h2><p>类型通过实现一个接口的所有方法来实现该接口。既然无需专门显式声明，也就没有“implements”关键字。</p>\n<p>隐式接口从接口的实现中解耦了定义，这样接口的实现可以出现在任何包中，无需提前准备。</p>\n<p>因此，也就无需在每一个实现上增加新的接口名称，这样同时也鼓励了明确的接口定义。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> I <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">\tM()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> T <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tS <span class=\"type\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 此方法表示类型 T 实现了接口 I，但我们无需显式声明此事。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(t T)</span></span> M() &#123;</span><br><span class=\"line\">\tfmt.Println(t.S)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> i I = T&#123;<span class=\"string\">&quot;hello&quot;</span>&#125;</span><br><span class=\"line\">\ti.M()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<h2 id=\"5-8-接口值\"><a href=\"#5-8-接口值\" class=\"headerlink\" title=\"5.8 接口值\"></a>5.8 接口值</h2><p>接口也是值。它们可以像其它值一样传递。</p>\n<p>接口值可以用作函数的参数或返回值。</p>\n<p>在内部，接口值可以看做包含值和具体类型的元组：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(value, type)</span><br></pre></td></tr></table></figure>\n\n<p>接口值保存了一个具体底层类型的具体值。</p>\n<p>接口值调用方法时会执行其底层类型的同名方法</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;math&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> I <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">\tM()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> T <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tS <span class=\"type\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(t *T)</span></span> M() &#123;</span><br><span class=\"line\">\tfmt.Println(t.S)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> F <span class=\"type\">float64</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(f F)</span></span> M() &#123;</span><br><span class=\"line\">\tfmt.Println(f)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> i I</span><br><span class=\"line\"></span><br><span class=\"line\">\ti = &amp;T&#123;<span class=\"string\">&quot;Hello&quot;</span>&#125;</span><br><span class=\"line\">\tdescribe(i)</span><br><span class=\"line\">\ti.M()</span><br><span class=\"line\"></span><br><span class=\"line\">\ti = F(math.Pi)</span><br><span class=\"line\">\tdescribe(i)</span><br><span class=\"line\">\ti.M()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">describe</span><span class=\"params\">(i I)</span></span> &#123;</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;(%v, %T)\\n&quot;</span>, i, i)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">输出结果是：</span><br><span class=\"line\"><span class=\"comment\">//因为 T 实现是传入（* T）</span></span><br><span class=\"line\"></span><br><span class=\"line\">(&amp;&#123;Hello&#125;, *main.T)</span><br><span class=\"line\">Hello</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//因为 F 实现是传入（F）</span></span><br><span class=\"line\">(<span class=\"number\">3.141592653589793</span>, main.F)</span><br><span class=\"line\"><span class=\"number\">3.141592653589793</span></span><br></pre></td></tr></table></figure>\n\n<p>在上述代码当中的接口值是：(&amp;{Hello}, *main.T) 以及 (3.141592653589793, main.F)</p>\n<p>‍</p>\n<h2 id=\"5-9-底层值为-nil-的接口值\"><a href=\"#5-9-底层值为-nil-的接口值\" class=\"headerlink\" title=\"5.9 底层值为 nil 的接口值\"></a>5.9 底层值为 nil 的接口值</h2><p>即便接口内的具体值为 nil，方法仍然会被 nil 接收者调用。</p>\n<p>在一些语言中，这会触发一个空指针异常，但在 Go 中通常会写一些方法来优雅地处理它（如本例中的 <code>M</code>​ 方法）。</p>\n<p><strong>注意:</strong> 保存了 nil 具体值的接口其自身并不为 nil。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> I <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">\tM()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> T <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tS <span class=\"type\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(t *T)</span></span> M() &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> t == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tfmt.Println(<span class=\"string\">&quot;&lt;nil&gt;&quot;</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfmt.Println(t.S)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> i I</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> t *T</span><br><span class=\"line\">\ti = t</span><br><span class=\"line\">\tdescribe(i)</span><br><span class=\"line\">\ti.M()</span><br><span class=\"line\"></span><br><span class=\"line\">\ti = &amp;T&#123;<span class=\"string\">&quot;hello&quot;</span>&#125;</span><br><span class=\"line\">\tdescribe(i)</span><br><span class=\"line\">\ti.M()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">describe</span><span class=\"params\">(i I)</span></span> &#123;</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;(%v, %T)\\n&quot;</span>, i, i)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">记结果输出为：</span><br><span class=\"line\">(&lt;<span class=\"literal\">nil</span>&gt;, *main.T)</span><br><span class=\"line\">&lt;<span class=\"literal\">nil</span>&gt;</span><br><span class=\"line\">(&amp;&#123;hello&#125;, *main.T)</span><br><span class=\"line\">hello</span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<h2 id=\"5-10-nil-接口值\"><a href=\"#5-10-nil-接口值\" class=\"headerlink\" title=\"5.10 nil 接口值\"></a>5.10 nil 接口值</h2><p>nil 接口值既不保存值也不保存具体类型。</p>\n<p>为 nil 接口调用方法会产生运行时错误，因为接口的元组内并未包含能够指明该调用哪个 <strong>具体</strong> 方法的类型。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> I <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">\tM()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> i I</span><br><span class=\"line\">\tdescribe(i)</span><br><span class=\"line\">\ti.M()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">describe</span><span class=\"params\">(i I)</span></span> &#123;</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;(%v, %T)\\n&quot;</span>, i, i)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">上述代码会显示：</span><br><span class=\"line\">(&lt;<span class=\"literal\">nil</span>&gt;, &lt;<span class=\"literal\">nil</span>&gt;)</span><br><span class=\"line\"><span class=\"built_in\">panic</span>: runtime <span class=\"type\">error</span>: invalid memory address or <span class=\"literal\">nil</span> pointer dereference</span><br><span class=\"line\">[signal SIGSEGV: segmentation violation code=<span class=\"number\">0x1</span> addr=<span class=\"number\">0x0</span> pc=<span class=\"number\">0x481961</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">goroutine <span class=\"number\">1</span> [running]:</span><br><span class=\"line\">main.main()</span><br><span class=\"line\">\t/tmp/sandbox4223192970/prog.<span class=\"keyword\">go</span>:<span class=\"number\">12</span> +<span class=\"number\">0x61</span></span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<p>以上两者是不同的概念：</p>\n<p>第一个是接口对象不为空，但是对象指向的地方为空，也就是说接口申明了之后，还是给了他一个赋值的对象，但这个对象可能还没有初始化</p>\n<p>第二个是接口对象为空</p>\n<p>‍</p>\n<h2 id=\"5-11-空接口\"><a href=\"#5-11-空接口\" class=\"headerlink\" title=\"5.11 空接口\"></a>5.11 空接口</h2><p>指定了零个方法的接口值被称为 <em>空接口：</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>空接口可保存任何类型的值。（因为每个类型都至少实现了零个方法。）</p>\n<p>空接口被用来处理未知类型的值。例如，<code>fmt.Print</code>​ 可接受类型为 <code>interface&#123;&#125;</code>​ 的任意数量的参数。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> i <span class=\"keyword\">interface</span>&#123;&#125;</span><br><span class=\"line\">\tdescribe(i)</span><br><span class=\"line\"></span><br><span class=\"line\">\ti = <span class=\"number\">42</span></span><br><span class=\"line\">\tdescribe(i)</span><br><span class=\"line\"></span><br><span class=\"line\">\ti = <span class=\"string\">&quot;hello&quot;</span></span><br><span class=\"line\">\tdescribe(i)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">describe</span><span class=\"params\">(i <span class=\"keyword\">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;(%v, %T)\\n&quot;</span>, i, i)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<h2 id=\"5-12-类型断言\"><a href=\"#5-12-类型断言\" class=\"headerlink\" title=\"5.12 类型断言\"></a>5.12 类型断言</h2><blockquote>\n<p><a href=\"https://blog.kalan.dev/posts/golang-type-assertion\">断言具体释义</a></p>\n</blockquote>\n<p><strong>类型断言</strong> 提供了<strong>访问接口值底层具体值</strong>的方式。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">t := i.(T)</span><br></pre></td></tr></table></figure>\n\n<p>该语句断言接口值 <code>i</code>​ 保存了具体类型 <code>T</code>​，并将其底层类型为 <code>T</code>​ 的值赋予变量 <code>t</code>​。</p>\n<p>若 <code>i</code>​ 并未保存 <code>T</code>​ 类型的值，该语句就会触发一个恐慌。</p>\n<p>为了 <strong>判断</strong> 一个接口值是否保存了一个特定的类型，类型断言可返回两个值：其底层值以及一个报告断言是否成功的布尔值。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">t, ok := i.(T)</span><br></pre></td></tr></table></figure>\n\n<p>若 <code>i</code>​ 保存了一个 <code>T</code>​，那么 <code>t</code>​ 将会是其底层值，而 <code>ok</code>​ 为 <code>true</code>​。</p>\n<p>否则，<code>ok</code>​ 将为 <code>false</code>​ 而 <code>t</code>​ 将为 <code>T</code>​ 类型的零值，程序并不会产生恐慌。</p>\n<p>请注意这种语法和读取一个映射时的相同之处。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> i <span class=\"keyword\">interface</span>&#123;&#125; = <span class=\"string\">&quot;hello&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\ts := i.(<span class=\"type\">string</span>)</span><br><span class=\"line\">\tfmt.Println(s)</span><br><span class=\"line\"></span><br><span class=\"line\">\ts, ok := i.(<span class=\"type\">string</span>)</span><br><span class=\"line\">\tfmt.Println(s, ok)</span><br><span class=\"line\"></span><br><span class=\"line\">\tf, ok := i.(<span class=\"type\">float64</span>)</span><br><span class=\"line\">\tfmt.Println(f, ok)</span><br><span class=\"line\"></span><br><span class=\"line\">\tf = i.(<span class=\"type\">float64</span>) <span class=\"comment\">// 报错(panic)</span></span><br><span class=\"line\">\tfmt.Println(f)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">结果显示为：</span><br><span class=\"line\">hello</span><br><span class=\"line\">hello <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"number\">0</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"built_in\">panic</span>: <span class=\"keyword\">interface</span> conversion: <span class=\"keyword\">interface</span> &#123;&#125; is <span class=\"type\">string</span>, not <span class=\"type\">float64</span></span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<h2 id=\"5-13-类型选择\"><a href=\"#5-13-类型选择\" class=\"headerlink\" title=\"5.13 类型选择\"></a>5.13 类型选择</h2><p><strong>类型选择</strong> 是一种按顺序从几个类型断言中选择分支的结构。</p>\n<p>类型选择与一般的 switch 语句相似，不过类型选择中的 case 为类型（而非值）， 它们针对给定接口值所存储的值的类型进行比较。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">switch v := i.(type) &#123;</span><br><span class=\"line\">case T:</span><br><span class=\"line\">    // v 的类型为 T</span><br><span class=\"line\">case S:</span><br><span class=\"line\">    // v 的类型为 S</span><br><span class=\"line\">default:</span><br><span class=\"line\">    // 没有匹配，v 与 i 的类型相同</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>类型选择中的声明与类型断言 <code>i.(T)</code>​ 的语法相同，<strong>只是具体类型 ​</strong>**<code>T</code><strong><strong>​ 被替换成了关键字 ​</strong></strong><code>type</code>**<strong>。</strong></p>\n<p>此选择语句判断接口值 <code>i</code>​ 保存的值类型是 <code>T</code>​ 还是 <code>S</code>​。在 <code>T</code>​ 或 <code>S</code>​ 的情况下，变量 <code>v</code>​ 会分别按 <code>T</code>​ 或 <code>S</code>​ 类型保存 <code>i</code>​ 拥有的值。在默认（即没有匹配）的情况下，变量 <code>v</code>​ 与 <code>i</code>​ 的接口类型和值相同。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">do</span><span class=\"params\">(i <span class=\"keyword\">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">switch</span> v := i.(<span class=\"keyword\">type</span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> <span class=\"type\">int</span>:</span><br><span class=\"line\">\t\tfmt.Printf(<span class=\"string\">&quot;Twice %v is %v\\n&quot;</span>, v, v*<span class=\"number\">2</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> <span class=\"type\">string</span>:</span><br><span class=\"line\">\t\tfmt.Printf(<span class=\"string\">&quot;%q is %v bytes long\\n&quot;</span>, v, <span class=\"built_in\">len</span>(v))</span><br><span class=\"line\">\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\tfmt.Printf(<span class=\"string\">&quot;I don&#x27;t know about type %T!\\n&quot;</span>, v)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tdo(<span class=\"number\">21</span>)</span><br><span class=\"line\">\tdo(<span class=\"string\">&quot;hello&quot;</span>)</span><br><span class=\"line\">\tdo(<span class=\"literal\">true</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">结果是：</span><br><span class=\"line\">Twice <span class=\"number\">21</span> is <span class=\"number\">42</span></span><br><span class=\"line\"><span class=\"string\">&quot;hello&quot;</span> is <span class=\"number\">5</span> bytes long</span><br><span class=\"line\">I don<span class=\"string\">&#x27;t know about type bool!</span></span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<h2 id=\"5-14-Stringer\"><a href=\"#5-14-Stringer\" class=\"headerlink\" title=\"5. 14 Stringer\"></a>5. 14 Stringer</h2><p><a href=\"https://go-zh.org/pkg/fmt/\">fmt</a><code>​ 包中定义的 [Stringer](https://go-zh.org/pkg/fmt/#Stringer)</code>​ 是最普遍的接口之一。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type Stringer interface &#123;</span><br><span class=\"line\">    String() string</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>Stringer</code>​ 是一个可以用字符串描述自己的类型。<code>fmt</code>​ 包（还有很多包）都通过此接口来打印值。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Person <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tName <span class=\"type\">string</span></span><br><span class=\"line\">\tAge  <span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p Person)</span></span> String() <span class=\"type\">string</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> fmt.Sprintf(<span class=\"string\">&quot;%v (%v years)&quot;</span>, p.Name, p.Age)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\ta := Person&#123;<span class=\"string\">&quot;Arthur Dent&quot;</span>, <span class=\"number\">42</span>&#125;</span><br><span class=\"line\">\tz := Person&#123;<span class=\"string\">&quot;Zaphod Beeblebrox&quot;</span>, <span class=\"number\">9001</span>&#125;</span><br><span class=\"line\">\tfmt.Println(a, z)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<h2 id=\"5-15-错误\"><a href=\"#5-15-错误\" class=\"headerlink\" title=\"5. 15 错误\"></a>5. 15 错误</h2><p>Go 程序使用 <code>error</code>​ 值来表示错误状态。</p>\n<p>与 <code>fmt.Stringer</code>​ 类似，<code>error</code>​ 类型是一个内建接口：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type error interface &#123;</span><br><span class=\"line\">    Error() string</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（与 <code>fmt.Stringer</code>​ 类似，<code>fmt</code>​ 包在打印值时也会满足 <code>error</code>​。）</p>\n<p>通常函数会返回一个 <code>error</code>​ 值，调用的它的代码应当判断这个错误是否等于 <code>nil</code>​ 来进行错误处理。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i, err := strconv.Atoi(&quot;42&quot;)</span><br><span class=\"line\">if err != nil &#123;</span><br><span class=\"line\">    fmt.Printf(&quot;couldn&#x27;t convert number: %v\\n&quot;, err)</span><br><span class=\"line\">    return</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fmt.Println(&quot;Converted integer:&quot;, i)</span><br></pre></td></tr></table></figure>\n\n<p><code>error</code>​ 为 nil 时表示成功；非 nil 的 <code>error</code>​ 表示失败</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;time&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> MyError <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tWhen time.Time</span><br><span class=\"line\">\tWhat <span class=\"type\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(e *MyError)</span></span> Error() <span class=\"type\">string</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> fmt.Sprintf(<span class=\"string\">&quot;at %v, %s&quot;</span>,</span><br><span class=\"line\">\t\te.When, e.What)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">run</span><span class=\"params\">()</span></span> <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;MyError&#123;</span><br><span class=\"line\">\t\ttime.Now(),</span><br><span class=\"line\">\t\t<span class=\"string\">&quot;it didn&#x27;t work&quot;</span>,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err := run(); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tfmt.Println(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"5-16-Reader\"><a href=\"#5-16-Reader\" class=\"headerlink\" title=\"5. 16 Reader\"></a>5. 16 Reader</h2><p><code>io</code>​ 包指定了 <code>io.Reader</code>​ 接口，它表示从数据流的末尾进行读取。</p>\n<p>Go 标准库包含了该接口的<a href=\"https://go-zh.org/search?q=Read#Global\">许多实现</a>，包括文件、网络连接、压缩和加密等等。</p>\n<p><code>io.Reader</code>​ 接口有一个 <code>Read</code>​ 方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func (T) Read(b []byte) (n int, err error)</span><br></pre></td></tr></table></figure>\n\n<p><code>Read</code>​ 用数据填充给定的字节切片并返回填充的字节数和错误值。在遇到数据流的结尾时，它会返回一个 <code>io.EOF</code>​ 错误。</p>\n<p>示例代码创建了一个 <a href=\"https://go-zh.org/pkg/strings/#Reader\">strings.Reader</a>``​ 并以每次 8 字节的速度读取它的输出。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;io&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;strings&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tr := strings.NewReader(<span class=\"string\">&quot;Hello, Reader!&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\tb := <span class=\"built_in\">make</span>([]<span class=\"type\">byte</span>, <span class=\"number\">8</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\tn, err := r.Read(b)</span><br><span class=\"line\">\t\tfmt.Printf(<span class=\"string\">&quot;n = %v err = %v b = %v\\n&quot;</span>, n, err, b)</span><br><span class=\"line\">\t\tfmt.Printf(<span class=\"string\">&quot;b[:n] = %q\\n&quot;</span>, b[:n])</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err == io.EOF &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">输出结果是：</span><br><span class=\"line\">n = <span class=\"number\">8</span> err = &lt;<span class=\"literal\">nil</span>&gt; b = [<span class=\"number\">72</span> <span class=\"number\">101</span> <span class=\"number\">108</span> <span class=\"number\">108</span> <span class=\"number\">111</span> <span class=\"number\">44</span> <span class=\"number\">32</span> <span class=\"number\">82</span>]</span><br><span class=\"line\">b[:n] = <span class=\"string\">&quot;Hello, R&quot;</span></span><br><span class=\"line\">n = <span class=\"number\">6</span> err = &lt;<span class=\"literal\">nil</span>&gt; b = [<span class=\"number\">101</span> <span class=\"number\">97</span> <span class=\"number\">100</span> <span class=\"number\">101</span> <span class=\"number\">114</span> <span class=\"number\">33</span> <span class=\"number\">32</span> <span class=\"number\">82</span>]</span><br><span class=\"line\">b[:n] = <span class=\"string\">&quot;eader!&quot;</span></span><br><span class=\"line\">n = <span class=\"number\">0</span> err = EOF b = [<span class=\"number\">101</span> <span class=\"number\">97</span> <span class=\"number\">100</span> <span class=\"number\">101</span> <span class=\"number\">114</span> <span class=\"number\">33</span> <span class=\"number\">32</span> <span class=\"number\">82</span>]</span><br><span class=\"line\">b[:n] = <span class=\"string\">&quot;&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<p>‍</p>\n<h2 id=\"5-17-图像\"><a href=\"#5-17-图像\" class=\"headerlink\" title=\"5.17 图像\"></a>5.17 图像</h2><p><a href=\"https://go-zh.org/pkg/image/#Image\">image</a>``​ 包定义了 <code>Image</code>​ 接口：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package image</span><br><span class=\"line\"></span><br><span class=\"line\">type Image interface &#123;</span><br><span class=\"line\">    ColorModel() color.Model</span><br><span class=\"line\">    Bounds() Rectangle</span><br><span class=\"line\">    At(x, y int) color.Color</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意:</strong> <code>Bounds</code>​ 方法的返回值 <code>Rectangle</code>​ 实际上是一个 <a href=\"https://go-zh.org/pkg/image/#Rectangle\">image.Rectangle</a>``​，它在 <code>image</code>​ 包中声明。</p>\n<p>（请参阅<a href=\"https://go-zh.org/pkg/image/#Image\">文档</a>了解全部信息。）</p>\n<p><code>color.Color</code>​ 和 <code>color.Model</code>​ 类型也是接口，但是通常因为直接使用预定义的实现 <code>image.RGBA</code>​ 和 <code>image.RGBAModel</code>​ 而被忽视了。这些接口和类型由 <a href=\"https://go-zh.org/pkg/image/color/\">image/color</a>``​ 包定义。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;image&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tm := image.NewRGBA(image.Rect(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">100</span>, <span class=\"number\">100</span>))</span><br><span class=\"line\">\tfmt.Println(m.Bounds())</span><br><span class=\"line\">\tfmt.Println(m.At(<span class=\"number\">0</span>, <span class=\"number\">0</span>).RGBA())</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"6-并发编程\"><a href=\"#6-并发编程\" class=\"headerlink\" title=\"6.  并发编程\"></a>6.  并发编程</h1><h2 id=\"6-1-Go-协程\"><a href=\"#6-1-Go-协程\" class=\"headerlink\" title=\"6.1  Go 协程\"></a>6.1  Go 协程</h2><p>Go 协程（goroutine）是由 Go 运行时管理的轻量级线程。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go f(x, y, z)</span><br></pre></td></tr></table></figure>\n\n<p>会启动一个新的 Go 程并执行</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f(x, y, z)</span><br></pre></td></tr></table></figure>\n\n<p><code>f</code>​, <code>x</code>​, <code>y</code>​ 和 <code>z</code>​ 的求值发生在当前的 Go 程中，而 <code>f</code>​ 的执行发生在新的 Go 程中。</p>\n<p>Go 程在相同的地址空间中运行，因此在访问共享的内存时必须进行同步。<a href=\"https://go-zh.org/pkg/sync/\">sync</a>``​ 包提供了这种能力，不过在 Go 中并不经常用到。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;time&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">say</span><span class=\"params\">(s <span class=\"type\">string</span>)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++ &#123;</span><br><span class=\"line\">\t\ttime.Sleep(<span class=\"number\">100</span> * time.Millisecond)</span><br><span class=\"line\">\t\tfmt.Println(s)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> say(<span class=\"string\">&quot;world&quot;</span>)</span><br><span class=\"line\">\tsay(<span class=\"string\">&quot;hello&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<h2 id=\"6-2-信道\"><a href=\"#6-2-信道\" class=\"headerlink\" title=\"6.2 信道\"></a>6.2 信道</h2><p>信道是带有类型的管道，你可以通过它用信道操作符 <code>&lt;-</code>​ 来发送或者接收值。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ch &lt;- v    // 将 v 发送至信道 ch。</span><br><span class=\"line\">v := &lt;-ch  // 从 ch 接收值并赋予 v。</span><br></pre></td></tr></table></figure>\n\n<p>（“箭头”就是数据流的方向。）</p>\n<p>和映射与切片一样，信道在使用前必须创建，也是使用make的形式创建</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ch := make(chan int)</span><br></pre></td></tr></table></figure>\n\n<p>默认情况下，发送和接收操作在另一端准备好之前都会阻塞。这使得 Go 程可以在没有显式的锁或竞态变量的情况下进行同步。</p>\n<p>以下示例对切片中的数进行求和，将任务分配给两个 Go 程。一旦两个 Go 程完成了它们的计算，它就能算出最终的结果。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">sum</span><span class=\"params\">(s []<span class=\"type\">int</span>, c <span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span></span> &#123;</span><br><span class=\"line\">\tsum := <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, v := <span class=\"keyword\">range</span> s &#123;</span><br><span class=\"line\">\t\tsum += v</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tc &lt;- sum <span class=\"comment\">// 将和送入 c</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\ts := []<span class=\"type\">int</span>&#123;<span class=\"number\">7</span>, <span class=\"number\">2</span>, <span class=\"number\">8</span>, <span class=\"number\">-9</span>, <span class=\"number\">4</span>, <span class=\"number\">0</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tc := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> sum(s[:<span class=\"built_in\">len</span>(s)/<span class=\"number\">2</span>], c)</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> sum(s[<span class=\"built_in\">len</span>(s)/<span class=\"number\">2</span>:], c)</span><br><span class=\"line\">\tx, y := &lt;-c, &lt;-c <span class=\"comment\">// 从 c 中接收</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tfmt.Println(x, y, x+y)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">结果显示为：</span><br><span class=\"line\"><span class=\"number\">-5</span> <span class=\"number\">17</span> <span class=\"number\">12</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>同时也可以知道 信道的结构是队列类型，先进先出</strong></p>\n<p>‍</p>\n<p>‍</p>\n<h2 id=\"6-3-项目带缓冲的信道\"><a href=\"#6-3-项目带缓冲的信道\" class=\"headerlink\" title=\"6.3 项目带缓冲的信道\"></a>6.3 项目带缓冲的信道</h2><p>信道可以是 <em>带缓冲的</em>。将缓冲长度作为第二个参数提供给 <code>make</code>​ 来初始化一个带缓冲的信道：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ch := make(chan int, 100)</span><br></pre></td></tr></table></figure>\n\n<p>仅当信道的缓冲区填满后，向其发送数据时才会阻塞。当缓冲区为空时，接受方会阻塞。</p>\n<p>修改示例填满缓冲区，然后看看会发生什么。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">\tch &lt;- <span class=\"number\">1</span></span><br><span class=\"line\">\tch &lt;- <span class=\"number\">2</span></span><br><span class=\"line\">\tfmt.Println(&lt;-ch)</span><br><span class=\"line\">\tfmt.Println(&lt;-ch)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<h2 id=\"6-4-信道使用-range-和-close\"><a href=\"#6-4-信道使用-range-和-close\" class=\"headerlink\" title=\"6. 4 信道使用 range 和 close\"></a>6. 4 信道使用 range 和 close</h2><p>发送者可通过 <code>close</code>​ 关闭一个信道来表示没有需要发送的值了。接收者可以通过为接收表达式分配第二个参数来测试信道是否被关闭：若没有值可以接收且信道已被关闭，那么在执行完</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">v, ok := &lt;-ch</span><br></pre></td></tr></table></figure>\n\n<p>之后 <code>ok</code>​ 会被设置为 <code>false</code>​。</p>\n<p>循环 <code>for i := range c</code>​ 会不断从信道接收值，直到它被关闭。</p>\n<p><em>注意：</em> 只有发送者才能关闭信道，而接收者不能。向一个已经关闭的信道发送数据会引发程序恐慌（panic）。</p>\n<p><em>还要注意：</em> 信道与文件不同，通常情况下无需关闭它们。只有在必须告诉接收者不再有需要发送的值时才有必要关闭，例如终止一个 <code>range</code>​ 循环。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">fibonacci</span><span class=\"params\">(n <span class=\"type\">int</span>, c <span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span></span> &#123;</span><br><span class=\"line\">\tx, y := <span class=\"number\">0</span>, <span class=\"number\">1</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; n; i++ &#123;</span><br><span class=\"line\">\t\tc &lt;- x</span><br><span class=\"line\">\t\tx, y = y, x+y</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">close</span>(c)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tc := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>, <span class=\"number\">10</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> fibonacci(<span class=\"built_in\">cap</span>(c), c)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> c &#123;</span><br><span class=\"line\">\t\tfmt.Println(i)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">结果显示为：</span><br><span class=\"line\"><span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"number\">8</span></span><br><span class=\"line\"><span class=\"number\">13</span></span><br><span class=\"line\"><span class=\"number\">21</span></span><br><span class=\"line\"><span class=\"number\">34</span></span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<h2 id=\"6-5-Go-語言如何從-Channel-讀取資料\"><a href=\"#6-5-Go-語言如何從-Channel-讀取資料\" class=\"headerlink\" title=\"6.5 Go 語言如何從 Channel 讀取資料\"></a>6.5 Go 語言如何從 Channel 讀取資料</h2><blockquote>\n<p>参考文献：</p>\n<p><a href=\"https://blog.wu-boy.com/2022/05/read-data-from-channel-in-go/\">Chan的读取方式</a></p>\n</blockquote>\n<p>‍</p>\n<h2 id=\"6-6-select-语句\"><a href=\"#6-6-select-语句\" class=\"headerlink\" title=\"6.6 select 语句\"></a>6.6 select 语句</h2><p><code>select</code>​ 语句使一个 Go 程可以等待多个通信操作。</p>\n<p><code>select</code>​ 会阻塞到某个分支可以继续执行为止，这时就会执行该分支。当多个分支都准备好时会随机选择一个执行。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">fibonacci</span><span class=\"params\">(c, quit <span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span></span> &#123;</span><br><span class=\"line\">\tx, y := <span class=\"number\">0</span>, <span class=\"number\">1</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> c &lt;- x:</span><br><span class=\"line\">\t\t\tx, y = y, x+y</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> &lt;-quit:</span><br><span class=\"line\">\t\t\tfmt.Println(<span class=\"string\">&quot;quit&quot;</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tc := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\">\tquit := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++ &#123;</span><br><span class=\"line\">\t\t\tfmt.Println(&lt;-c)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tquit &lt;- <span class=\"number\">0</span></span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\tfibonacci(c, quit)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<h2 id=\"6-7-默认选择\"><a href=\"#6-7-默认选择\" class=\"headerlink\" title=\"6.7 默认选择\"></a>6.7 默认选择</h2><p>当 <code>select</code>​ 中的其它分支都没有准备好时，<code>default</code>​ 分支就会执行。</p>\n<p>为了在尝试发送或者接收时不发生阻塞，可使用 <code>default</code>​ 分支：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select &#123;</span><br><span class=\"line\">case i := &lt;-c:</span><br><span class=\"line\">    // 使用 i</span><br><span class=\"line\">default:</span><br><span class=\"line\">    // 从 c 中接收会阻塞时执行</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;time&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\ttick := time.Tick(<span class=\"number\">100</span> * time.Millisecond)</span><br><span class=\"line\">\tboom := time.After(<span class=\"number\">500</span> * time.Millisecond)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> i := &lt;-tick:</span><br><span class=\"line\">\t\t\tfmt.Println(i)</span><br><span class=\"line\">\t\t\tfmt.Println(<span class=\"string\">&quot;tick.&quot;</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> &lt;-boom:</span><br><span class=\"line\">\t\t\tfmt.Println(<span class=\"string\">&quot;BOOM!&quot;</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t\tfmt.Println(<span class=\"string\">&quot;    .&quot;</span>)</span><br><span class=\"line\">\t\t\ttime.Sleep(<span class=\"number\">50</span> * time.Millisecond)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出为：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    .</span><br><span class=\"line\">    .</span><br><span class=\"line\"><span class=\"number\">2009</span><span class=\"number\">-11</span><span class=\"number\">-10</span> <span class=\"number\">23</span>:<span class=\"number\">00</span>:<span class=\"number\">00.1</span> +<span class=\"number\">0000</span> UTC m=+<span class=\"number\">0.100000001</span></span><br><span class=\"line\">tick.</span><br><span class=\"line\">    .</span><br><span class=\"line\">    .</span><br><span class=\"line\">    .</span><br><span class=\"line\"><span class=\"number\">2009</span><span class=\"number\">-11</span><span class=\"number\">-10</span> <span class=\"number\">23</span>:<span class=\"number\">00</span>:<span class=\"number\">00.2</span> +<span class=\"number\">0000</span> UTC m=+<span class=\"number\">0.200000001</span></span><br><span class=\"line\">tick.</span><br><span class=\"line\">    .</span><br><span class=\"line\"><span class=\"number\">2009</span><span class=\"number\">-11</span><span class=\"number\">-10</span> <span class=\"number\">23</span>:<span class=\"number\">00</span>:<span class=\"number\">00.3</span> +<span class=\"number\">0000</span> UTC m=+<span class=\"number\">0.300000001</span></span><br><span class=\"line\">tick.</span><br><span class=\"line\">    .</span><br><span class=\"line\">    .</span><br><span class=\"line\"><span class=\"number\">2009</span><span class=\"number\">-11</span><span class=\"number\">-10</span> <span class=\"number\">23</span>:<span class=\"number\">00</span>:<span class=\"number\">00.4</span> +<span class=\"number\">0000</span> UTC m=+<span class=\"number\">0.400000001</span></span><br><span class=\"line\">tick.</span><br><span class=\"line\">    .</span><br><span class=\"line\">    .</span><br><span class=\"line\">BOOM!</span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<h2 id=\"6-8-sync-Mutex\"><a href=\"#6-8-sync-Mutex\" class=\"headerlink\" title=\"6.8 sync.Mutex\"></a>6.8 sync.Mutex</h2><p>我们已经看到信道非常适合在各个 Go 程间进行通信。</p>\n<p>但是如果我们并不需要通信呢？比如说，若我们只是想保证每次只有一个 Go 程能够访问一个共享的变量，从而避免冲突？</p>\n<p>这里涉及的概念叫做 <em>互斥（mutual</em>exclusion）* ，我们通常使用 <em>互斥锁（Mutex）</em> 这一数据结构来提供这种机制。</p>\n<p>Go 标准库中提供了 <a href=\"https://go-zh.org/pkg/sync/#Mutex\">sync.Mutex</a>``​ 互斥锁类型及其两个方法：</p>\n<ul>\n<li><code>Lock</code>​</li>\n<li><code>Unlock</code>​</li>\n</ul>\n<p>我们可以通过在代码前调用 <code>Lock</code>​ 方法，在代码后调用 <code>Unlock</code>​ 方法来保证一段代码的互斥执行。参见 <code>Inc</code>​ 方法。</p>\n<p>我们也可以用 <code>defer</code>​ 语句来保证互斥锁一定会被解锁。参见 <code>Value</code>​ 方法。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;sync&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;time&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// SafeCounter 的并发使用是安全的。</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> SafeCounter <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tv   <span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"type\">int</span></span><br><span class=\"line\">\tmux sync.Mutex</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Inc 增加给定 key 的计数器的值。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *SafeCounter)</span></span> Inc(key <span class=\"type\">string</span>) &#123;</span><br><span class=\"line\">\tc.mux.Lock()</span><br><span class=\"line\">\t<span class=\"comment\">// Lock 之后同一时刻只有一个 goroutine 能访问 c.v</span></span><br><span class=\"line\">\tc.v[key]++</span><br><span class=\"line\">\tc.mux.Unlock()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Value 返回给定 key 的计数器的当前值。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *SafeCounter)</span></span> Value(key <span class=\"type\">string</span>) <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\tc.mux.Lock()</span><br><span class=\"line\">\t<span class=\"comment\">// Lock 之后同一时刻只有一个 goroutine 能访问 c.v</span></span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> c.mux.Unlock()</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> c.v[key]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tc := SafeCounter&#123;v: <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"type\">int</span>)&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++ &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">go</span> c.Inc(<span class=\"string\">&quot;somekey&quot;</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\ttime.Sleep(time.Second)</span><br><span class=\"line\">\tfmt.Println(c.Value(<span class=\"string\">&quot;somekey&quot;</span>))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<h1 id=\"练习题目（自己答案系列）\"><a href=\"#练习题目（自己答案系列）\" class=\"headerlink\" title=\"练习题目（自己答案系列）\"></a>练习题目（自己答案系列）</h1><h2 id=\"练习：Stringer\"><a href=\"#练习：Stringer\" class=\"headerlink\" title=\"练习：Stringer\"></a>练习：Stringer</h2><p>通过让 <code>IPAddr</code>​ 类型实现 <code>fmt.Stringer</code>​ 来打印点号分隔的地址。</p>\n<p>例如，<code>IPAddr&#123;1, 2, 3, 4&#125;</code>​ 应当打印为 <code>&quot;1.2.3.4&quot;</code>​。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> IPAddr [<span class=\"number\">4</span>]<span class=\"type\">byte</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// <span class=\"doctag\">TODO:</span> 给 IPAddr 添加一个 &quot;String() string&quot; 方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(ip *IPAddr)</span></span> String() <span class=\"type\">string</span>&#123;</span><br><span class=\"line\">\tipAddr:= fmt.Sprintf(<span class=\"string\">&quot;%d.%d.%d.%d&quot;</span>,ip[<span class=\"number\">0</span>],ip[<span class=\"number\">1</span>],ip[<span class=\"number\">2</span>],ip[<span class=\"number\">3</span>])</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"type\">string</span>(ipAddr)</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\thosts := <span class=\"keyword\">map</span>[<span class=\"type\">string</span>]IPAddr&#123;</span><br><span class=\"line\">\t\t<span class=\"string\">&quot;loopback&quot;</span>:  &#123;<span class=\"number\">127</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>&#125;,</span><br><span class=\"line\">\t\t<span class=\"string\">&quot;googleDNS&quot;</span>: &#123;<span class=\"number\">8</span>, <span class=\"number\">8</span>, <span class=\"number\">8</span>, <span class=\"number\">8</span>&#125;,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> name, ip := <span class=\"keyword\">range</span> hosts &#123;</span><br><span class=\"line\">\t\tfmt.Printf(<span class=\"string\">&quot;%v: %v\\n&quot;</span>, name, ip.String())</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loopback: <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span></span><br><span class=\"line\">googleDNS: <span class=\"number\">8.8</span><span class=\"number\">.8</span><span class=\"number\">.8</span></span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n","site":{"data":{}},"cover":"/img/cover/sky4.png","cover_type":"img","excerpt":"","more":"<h1 id=\"Go-入门知识\"><a href=\"#Go-入门知识\" class=\"headerlink\" title=\"Go 入门知识\"></a>Go 入门知识</h1><blockquote>\n<p>本章节内容基于 <a href=\"https://tour.go-zh.org/\">https://tour.go-zh.org/</a>  <a href=\"https://tour.go-zh.org/list\">Go语言测试平台</a> 索引整理完成</p>\n<p>答案训练参考：</p>\n<p><a href=\"https://gist.github.com/zyxar/2317744\">https://gist.github.com/zyxar/2317744</a></p>\n<p><a href=\"https://gist.github.com/CarlosLanderas/11b4f6727deec051883ddc02edf5cd0b\">https://gist.github.com/CarlosLanderas/11b4f6727deec051883ddc02edf5cd0b</a></p>\n<p>一些有用书籍索引：</p>\n<p><a href=\"https://books.studygolang.com/gopl-zh/\">Go语言圣经（中文版）</a></p>\n<p><a href=\"http://c.biancheng.net/golang/\">Go语言入门教程，Golang入门教程</a></p>\n<p><a href=\"https://books.studygolang.com/The-Golang-Standard-Library-by-Example/\">《Go语言标准库》</a></p>\n</blockquote>\n<h1 id=\"1-Go-包相关\"><a href=\"#1-Go-包相关\" class=\"headerlink\" title=\"1. Go 包相关\"></a>1. Go 包相关</h1><h2 id=\"1-1-路径\"><a href=\"#1-1-路径\" class=\"headerlink\" title=\"1.1 路径\"></a>1.1 路径</h2><p>每个 Go 程序都是由包构成的。</p>\n<p>程序从 <code>main</code>​​​ 包开始运行。</p>\n<p>比如通过导入路径 <code>&quot;fmt&quot;</code>​​ 和 <code>&quot;math/rand&quot;</code>​​ 来使用这两个包。</p>\n<p>按照约定，包名与导入路径的最后一个元素一致。例如，<code>&quot;math/rand&quot;</code>​​​ 包中的源码均以 <code>package rand</code>​​​ 语句开始。</p>\n<p>‍</p>\n<h2 id=\"1-2-导入包\"><a href=\"#1-2-导入包\" class=\"headerlink\" title=\"1.2 导入包\"></a>1.2 导入包</h2><p>圆括号组合了导入，这是“分组”形式的导入语</p>\n<h1 id=\"2-变量\"><a href=\"#2-变量\" class=\"headerlink\" title=\"2. 变量\"></a>2. 变量</h1><p>注意类型在变量名之后 </p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">y <span class=\"type\">int</span></span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<p><code>var</code>​​​ 语句用于声明一个变量列表，跟函数的参数列表一样，类型在最后</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a ,b c, d <span class=\"type\">int</span></span><br></pre></td></tr></table></figure>\n\n<p>变量声明可以包含初始值，每个变量对应一个， 逗号隔开，如果初始化值已存在，则可以省略类型；变量会从初始值中获得类型。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> i, j <span class=\"type\">int</span> = <span class=\"number\">1</span>, <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> c, python, java = <span class=\"literal\">true</span>, <span class=\"literal\">false</span>, <span class=\"string\">&quot;no!&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<p>简洁赋值语句 <code>:=</code>​​​ 可在类型明确的地方代替 <code>var</code>​​​ 声明。</p>\n<p>函数外的每个语句都必须以关键字开始（<code>var</code>​​​, <code>func</code>​​​ 等等），因此 ​<code>:=</code>​​​​ 结构不能在函数外使用[相较之下 var 可以写到函数外面，在包层级]</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">k := <span class=\"number\">3</span></span><br><span class=\"line\">c, python, java := <span class=\"literal\">true</span>, <span class=\"literal\">false</span>, <span class=\"string\">&quot;no!&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<p><strong>Go 的基本类型有</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bool</span><br><span class=\"line\"></span><br><span class=\"line\">string</span><br><span class=\"line\"></span><br><span class=\"line\">int  int8  int16  int32  int64</span><br><span class=\"line\">uint uint8 uint16 uint32 uint64 uintptr</span><br><span class=\"line\"></span><br><span class=\"line\">byte // uint8 的别名</span><br><span class=\"line\"></span><br><span class=\"line\">rune // int32 的别名</span><br><span class=\"line\">    // 表示一个 Unicode 码点</span><br><span class=\"line\"></span><br><span class=\"line\">float32 float64</span><br><span class=\"line\"></span><br><span class=\"line\">complex64 complex128</span><br></pre></td></tr></table></figure>\n\n<p>本例展示了几种类型的变量。 同导入语句一样，变量声明也可以“分组”成一个语法块。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> (</span><br><span class=\"line\">\tToBe   <span class=\"type\">bool</span>       = <span class=\"literal\">false</span></span><br><span class=\"line\">\tMaxInt <span class=\"type\">uint64</span>     = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">64</span> - <span class=\"number\">1</span></span><br><span class=\"line\">\tz      <span class=\"type\">complex128</span> = cmplx.Sqrt(<span class=\"number\">-5</span> + <span class=\"number\">12i</span>)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p><code>int</code>​​​, <code>uint</code>​​​ 和 <code>uintptr</code>​​​ 在 32 位系统上通常为 32 位宽，在 64 位系统上则为 64 位宽。 当你需要一个整数值时应使用 <code>int</code>​​​ 类型，除非你有特殊的理由使用固定大小或无符号的整数类型。</p>\n<p>‍</p>\n<p>没有明确初始值的变量声明会被赋予它们的 <strong>零值</strong>。</p>\n<p>零值是：</p>\n<ul>\n<li>数值类型为 <code>0</code>​​​，</li>\n<li>布尔类型为 <code>false</code>​​​，</li>\n<li>字符串为 <code>&quot;&quot;</code>​​​（空字符串）。</li>\n</ul>\n<p>‍</p>\n<p>表达式 <code>T(v)</code>​​​ 将值 <code>v</code>​​​ 转换为类型 <code>T</code>​​​。</p>\n<p>一些关于数值的转换：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var i int = 42</span><br><span class=\"line\">var f float64 = float64(i)</span><br><span class=\"line\">var u uint = uint(f)</span><br></pre></td></tr></table></figure>\n\n<p>或者，更加简单的形式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i := 42</span><br><span class=\"line\">f := float64(i)</span><br><span class=\"line\">u := uint(f)</span><br></pre></td></tr></table></figure>\n\n<p>与 C 不同的是，Go 在不同类型的项之间赋值时需要显式转换,，等号右边的数值必须是类型明确的</p>\n<p>‍</p>\n<h2 id=\"2-1-常量\"><a href=\"#2-1-常量\" class=\"headerlink\" title=\"2.1 常量\"></a>2.1 常量</h2><p>常量的声明与变量类似，只不过是使用 <code>const</code>​​​ 关键字。</p>\n<p>常量可以是字符、字符串、布尔值或数值。</p>\n<p>常量不能用 <code>:=</code>​​​ 语法声明。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> World = <span class=\"string\">&quot;世界&quot;</span></span><br><span class=\"line\"><span class=\"comment\">//相较之下，这个申明的world是一个变量，也就是可以改变其类型的</span></span><br><span class=\"line\">world := <span class=\"string\">&quot;世界&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> World = <span class=\"string\">&quot;世界&quot;</span></span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;Hello&quot;</span>, World)</span><br><span class=\"line\"></span><br><span class=\"line\">\tworld := <span class=\"string\">&quot;世界&quot;</span></span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;Go rules?&quot;</span>, world)</span><br><span class=\"line\">\tworld = <span class=\"string\">&quot;是吗&quot;</span></span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;Go rules?&quot;</span>, world)</span><br><span class=\"line\">\t结果是：</span><br><span class=\"line\">\tHello 世界</span><br><span class=\"line\">\tGo rules? 世界</span><br><span class=\"line\">\tGo rules? 是吗</span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<h2 id=\"2-2-类型推导\"><a href=\"#2-2-类型推导\" class=\"headerlink\" title=\"2.2 类型推导\"></a>2.2 类型推导</h2><p>在声明一个变量而不指定其类型时（即使用不带类型的 <code>:=</code>​​​ 语法或 <code>var =</code>​​​ 表达式语法），变量的类型由右值推导得出。</p>\n<p>当右值声明了类型时，新变量的类型与其相同：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var i int</span><br><span class=\"line\">j := i // j 也是一个 int</span><br></pre></td></tr></table></figure>\n\n<p>不过当右边包含未指明类型的数值常量时，新变量的类型就可能是 <code>int</code>​​​, <code>float64</code>​​​ 或 <code>complex128</code>​​​ 了，这取决于常量的精度：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i := 42           // int</span><br><span class=\"line\">f := 3.142        // float64</span><br><span class=\"line\">g := 0.867 + 0.5i // complex128</span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<h2 id=\"2-3-数值常量\"><a href=\"#2-3-数值常量\" class=\"headerlink\" title=\"2.3 数值常量\"></a>2.3 数值常量</h2><p>数值常量是高精度的 <strong>值</strong>。</p>\n<p>一个未指定类型的常量由上下文来决定其类型。</p>\n<p>再尝试一下输出 <code>needInt(Big)</code>​​​ 吧。</p>\n<p>（<code>int</code>​​​ 类型最大可以存储一个 64 位的整数，有时会更小。）</p>\n<p>（<code>int</code>​​​​ 可以存放最大64位的整数，根据平台不同有时会更少。）</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">\t<span class=\"comment\">// 将 1 左移 100 位来创建一个非常大的数字</span></span><br><span class=\"line\">\t<span class=\"comment\">// 即这个数的二进制是 1 后面跟着 100 个 0</span></span><br><span class=\"line\">\tBig = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">100</span></span><br><span class=\"line\">\t<span class=\"comment\">// 再往右移 99 位，即 Small = 1 &lt;&lt; 1，或者说 Small = 2</span></span><br><span class=\"line\">\tSmall = Big &gt;&gt; <span class=\"number\">99</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"3-语句\"><a href=\"#3-语句\" class=\"headerlink\" title=\"3. 语句\"></a>3. 语句</h1><h2 id=\"3-1-if\"><a href=\"#3-1-if\" class=\"headerlink\" title=\"3.1 if\"></a>3.1 if</h2><p>Go 的 <code>if</code>​​​​ 语句与 <code>for</code>​​​​ 循环类似，表达式外无需小括号 <code>( )</code>​​​​ ，而大括号 <code>&#123; &#125;</code>​​​​ 则是必须的。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> x &lt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> sqrt(-x) + <span class=\"string\">&quot;i&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-2-for\"><a href=\"#3-2-for\" class=\"headerlink\" title=\"3.2 for\"></a>3.2 for</h2><p>Go 只有一种循环结构：<code>for</code>​​​ 循环。</p>\n<p>基本的 <code>for</code>​​​ 循环由三部分组成，它们用分号隔开：</p>\n<ul>\n<li>初始化语句：在第一次迭代前执行</li>\n<li>条件表达式：在每次迭代前求值</li>\n<li>后置语句：在每次迭代的结尾执行</li>\n</ul>\n<p>初始化语句通常为一句短变量声明，该变量声明仅在 <code>for</code>​​​ 语句的作用域中可见。</p>\n<p>一旦条件表达式的布尔值为 <code>false</code>​​​，循环迭代就会终止。</p>\n<p>初始化语句和后置语句是可选的，也就是说完全可以只有一个条件，其含义也变成了wihle语句，但是go里面没有while只有for</p>\n<p><strong>注意</strong>：和 C、Java、JavaScript 之类的语言不同，<strong>Go 的 for 语句后面的三个构成部分外没有小括号</strong>， 而包围函数主体的大括号 <code>&#123; &#125;</code>​​​​ 则是必须的。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tsum := <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++ &#123;</span><br><span class=\"line\">\t\tsum += i</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfmt.Println(sum)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tsum := <span class=\"number\">1</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> sum &lt; <span class=\"number\">1000</span>&#123;</span><br><span class=\"line\">\t\tsum += sum</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfmt.Println(sum)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<h2 id=\"3-3-if-的简短语句\"><a href=\"#3-3-if-的简短语句\" class=\"headerlink\" title=\"3.3 if 的简短语句\"></a>3.3 if 的简短语句</h2><p>同 <code>for</code>​​​ 一样， <code>if</code>​​​ 语句可以在条件表达式前执行一个简单的语句。</p>\n<p><strong>该语句声明的变量作用域仅在 ​</strong><strong><code>if</code><strong>​​​</strong>​ 之内。</strong>也就是说出了if语句，这个变量就没有了</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">pow</span><span class=\"params\">(x, n, lim <span class=\"type\">float64</span>)</span></span> <span class=\"type\">float64</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> v := math.Pow(x, n); v &lt; lim &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> v</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> lim</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<h2 id=\"3-4-if-和-else\"><a href=\"#3-4-if-和-else\" class=\"headerlink\" title=\"3.4 if 和 else\"></a>3.4 if 和 else</h2><p>在 <code>if</code>​​ 的简短语句中声明的变量同样可以在任何对应的 <code>else</code>​​ 块中使用。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> v := math.Pow(x, n); v &lt; lim &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> v</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tfmt.Printf(<span class=\"string\">&quot;%g &gt;= %g\\n&quot;</span>, v, lim)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//一般格式是：</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> &#123;</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> &#123;</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span> &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-5-switch\"><a href=\"#3-5-switch\" class=\"headerlink\" title=\"3.5 switch\"></a>3.5 switch</h2><p><code>switch</code>​​ 是编写一连串 <code>if - else</code>​​ 语句的简便方法。它运行第一个值等于条件表达式的 case 语句。</p>\n<p>Go 的 switch 语句类似于 C、C++、Java、JavaScript 和 PHP 中的，不过 Go 只运行选定的 case，而非之后所有的 case。 实际上，Go 自动提供了在这些语言中每个 case 后面所需的 <code>break</code>​​ 语句。 除非以 <code>fallthrough</code>​​ 语句结束，否则分支会自动终止。 Go 的另一点重要的不同在于 switch 的 case 无需为常量，且取值不必为整数。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">switch</span> os := runtime.GOOS; os &#123;</span><br><span class=\"line\"><span class=\"keyword\">case</span> <span class=\"string\">&quot;darwin&quot;</span>:</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;OS X.&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">case</span> <span class=\"string\">&quot;linux&quot;</span>:</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;Linux.&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t<span class=\"comment\">// freebsd, openbsd,</span></span><br><span class=\"line\">\t<span class=\"comment\">// plan9, windows...</span></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;%s.\\n&quot;</span>, os)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<h2 id=\"3-6-switch-的求值顺序\"><a href=\"#3-6-switch-的求值顺序\" class=\"headerlink\" title=\"3.6 switch 的求值顺序\"></a>3.6 switch 的求值顺序</h2><p>switch 的 case 语句从上到下顺次执行，直到匹配成功时停止。</p>\n<p>（例如，  </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">switch i &#123;</span><br><span class=\"line\">case 0:</span><br><span class=\"line\">case f():</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在 <code>i==0</code>​​ 时 <code>f</code>​​ 不会被调用。  </p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">today := time.Now().Weekday()</span><br><span class=\"line\"><span class=\"keyword\">switch</span> time.Saturday &#123;</span><br><span class=\"line\"><span class=\"keyword\">case</span> today + <span class=\"number\">0</span>:</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;Today.&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">case</span> today + <span class=\"number\">1</span>:</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;Tomorrow.&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">case</span> today + <span class=\"number\">2</span>:</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;In two days.&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">default</span>:</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;Too far away.&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"3-7-没有条件的-switch\"><a href=\"#3-7-没有条件的-switch\" class=\"headerlink\" title=\"3.7 没有条件的 switch\"></a>3.7 没有条件的 switch</h2><p>没有条件的 switch 同 <code>switch true</code>​​ 一样。</p>\n<p>这种形式能将一长串 if-then-else 写得更加清晰。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">t := time.Now()</span><br><span class=\"line\">\t<span class=\"keyword\">switch</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> t.Hour() &lt; <span class=\"number\">12</span>:</span><br><span class=\"line\">\t\tfmt.Println(<span class=\"string\">&quot;Good morning!&quot;</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> t.Hour() &lt; <span class=\"number\">17</span>:</span><br><span class=\"line\">\t\tfmt.Println(<span class=\"string\">&quot;Good afternoon.&quot;</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\tfmt.Println(<span class=\"string\">&quot;Good evening.&quot;</span>)</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<h2 id=\"3-8-defer\"><a href=\"#3-8-defer\" class=\"headerlink\" title=\"3.8 defer\"></a>3.8 defer</h2><p>defer 语句会将函数推迟到外层函数返回之后执行。</p>\n<p>推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> fmt.Println(<span class=\"string\">&quot;world&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;hello&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">结果是：</span><br><span class=\"line\">hello</span><br><span class=\"line\">world</span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<h2 id=\"3-9-defer-栈\"><a href=\"#3-9-defer-栈\" class=\"headerlink\" title=\"3.9 defer 栈\"></a>3.9 defer 栈</h2><p>推迟的函数调用会被压入一个栈中。当外层函数返回时，被推迟的函数会按照后进先出的顺序调用。  </p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;counting&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++ &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">defer</span> fmt.Println(i)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;done&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">由于是按照栈的形式来存的</span><br><span class=\"line\">counting</span><br><span class=\"line\">done</span><br><span class=\"line\"><span class=\"number\">9</span></span><br><span class=\"line\"><span class=\"number\">8</span></span><br><span class=\"line\"><span class=\"number\">7</span></span><br><span class=\"line\"><span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://blog.go-zh.org/defer-panic-and-recover\">Defer，Panic,Recover</a></p>\n<p>‍</p>\n<h2 id=\"3-10-函数返回\"><a href=\"#3-10-函数返回\" class=\"headerlink\" title=\"3.10 函数返回\"></a>3.10 函数返回</h2><p>函数可以返回任意数量的返回值, 但是结构上需要结合函数形式</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">swap</span><span class=\"params\">(x, y <span class=\"type\">string</span>)</span></span> (<span class=\"type\">string</span>, <span class=\"type\">string</span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> y, x</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<p>Go 的返回值可被命名，它们会被视作定义在函数顶部的变量。</p>\n<p>返回值的名称应当具有一定的意义，它可以作为文档使用。</p>\n<p>没有参数的 <code>return</code>​ 语句返回已命名的返回值。也就是 <code>直接</code>​ 返回。</p>\n<p>直接返回语句应当仅用在下面这样的短函数中。在长的函数中它们会影响代码的可读性。</p>\n<p>(x, y int) 中的（）不可以省略</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">split</span><span class=\"params\">(sum <span class=\"type\">int</span>)</span></span> (x, y <span class=\"type\">int</span>) &#123;</span><br><span class=\"line\">\tx = sum * <span class=\"number\">4</span> / <span class=\"number\">9</span></span><br><span class=\"line\">\ty = sum - x</span><br><span class=\"line\">\t<span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<p>‍</p>\n<h2 id=\"3-11-Retrun-and-Defer\"><a href=\"#3-11-Retrun-and-Defer\" class=\"headerlink\" title=\"3.11 Retrun and Defer\"></a>3.11 Retrun and Defer</h2><blockquote>\n<p>‍</p>\n</blockquote>\n<p><img src=\"Y:/Blog/blog/source/_posts/Go/Go-basic-knowledge/assets/image-20230228154553-m65t587.png\" alt=\"image\">​</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// return语句执行步骤</span></span><br><span class=\"line\"><span class=\"comment\">// 1、返回值赋值</span></span><br><span class=\"line\"><span class=\"comment\">// 2、defer语句</span></span><br><span class=\"line\"><span class=\"comment\">// 3、真正RET返回</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f0</span><span class=\"params\">()</span></span> (x <span class=\"type\">int</span>) &#123;</span><br><span class=\"line\">\tx = <span class=\"number\">5</span></span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\tx++</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x <span class=\"comment\">//返回值RET=x, x++, RET=x=6</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f1</span><span class=\"params\">()</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\tx := <span class=\"number\">5</span></span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\tx++ <span class=\"comment\">//修改的是x，不是返回值</span></span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x <span class=\"comment\">//返回值RET=5, x++, RET=5</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f2</span><span class=\"params\">()</span></span> (x <span class=\"type\">int</span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\tx++</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">5</span> <span class=\"comment\">//返回值RET=x=5, x++, RET=6</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f3</span><span class=\"params\">()</span></span> (y <span class=\"type\">int</span>) &#123;</span><br><span class=\"line\">\tx := <span class=\"number\">5</span></span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\tx++</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x <span class=\"comment\">//返回值RET=y=x=5, x++, RET=5</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f4</span><span class=\"params\">()</span></span> (x <span class=\"type\">int</span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(x <span class=\"type\">int</span>)</span></span> &#123;</span><br><span class=\"line\">\t\tx++</span><br><span class=\"line\">\t&#125;(x)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">5</span> <span class=\"comment\">//返回值RET=x=5, x`++, RET=5</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tfmt.Println(f0()) <span class=\"comment\">//6</span></span><br><span class=\"line\">\tfmt.Println(f1()) <span class=\"comment\">//5</span></span><br><span class=\"line\">\tfmt.Println(f2()) <span class=\"comment\">//6</span></span><br><span class=\"line\">\tfmt.Println(f3()) <span class=\"comment\">//5</span></span><br><span class=\"line\">\tfmt.Println(f4()) <span class=\"comment\">//5</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>要注意的是实际返回的值和在函数内运算的值是不相同的对象，存在一个赋值的过程</p>\n<p>首先要明确 defer 后紧接的代码可以有两种写法：</p>\n<blockquote>\n<p>参考文章： </p>\n<p><a href=\"https://blog.csdn.net/qq_37102984/article/details/128946146?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~AD_ESQUERY~yljh-1-128946146-blog-116449166.pc_relevant_3mothn_strategy_and_data_recovery&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~AD_ESQUERY~yljh-1-128946146-blog-116449166.pc_relevant_3mothn_strategy_and_data_recovery\">Golang中defer和return的执行顺序 + 相关测试题（面试常考）</a></p>\n<p><a href=\"https://blog.csdn.net/qq_14997473/article/details/116449166\">Golang Defer 深入理解</a></p>\n<p><a href=\"https://cloud.tencent.com/developer/article/1453355\">汇编层面</a></p>\n<p><a href=\"https://haicoder.net/golang/golang-return.html\">Return的机制</a></p>\n</blockquote>\n<ul>\n<li><p>defer + 表达式，例如：<br>此时就会直接保留当前变量 x 已有的值到栈中，一直到最后直接打印输出，不再受后续 return x 结果的影响。例如$t e s t 1$ 和 $t e s t 2$中的变量 x 。 <strong>例如 test1 和 test2 中的变量 x。</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">defer</span> fmt.Printf(<span class=\"string\">&quot;in defer: x = %d\\n&quot;</span>, x</span><br></pre></td></tr></table></figure></li>\n<li><p>defer + 匿名函数（无入参/有入参），例如：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;fmt.Printf(<span class=\"string\">&quot;in defer: x = %d\\n&quot;</span>, x)&#125;()</span><br><span class=\"line\">或者是</span><br><span class=\"line\"><span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(n <span class=\"type\">int</span>)</span></span> &#123;fmt.Printf(<span class=\"string\">&quot;in defer x as parameter: x = %d\\n&quot;</span>, n) fmt.Printf(<span class=\"string\">&quot;in defer x after return: x = %d\\n&quot;</span>, x)&#125;(x)</span><br></pre></td></tr></table></figure>\n\n<p>此时需要区分打印输出的变量到底是【defer匿名函数内要访问的变量 n】，还是【defer匿名函数内要访问的变量 x】。</p>\n<ul>\n<li>针对【defer匿名函数内要访问的变量 n】，其值取决于在一开始遇到 defer 时入参 n 的值（也就是最开始还没被改变时的变量 x 的值，起初是0）。这个变量 n 的值是独立的，不会受后续 return x 结果的影响。</li>\n<li>针对【defer匿名函数内要访问的变量 x】，由于匿名函数能访问外部函数的变量，也就是说【defer匿名函数内要访问的变量 x】最终会被【defer匿名函数外最终要 return 返回出去的变量 x】所影响。</li>\n</ul>\n</li>\n</ul>\n<p>‍</p>\n<p>‍</p>\n<h1 id=\"4-结构及指针\"><a href=\"#4-结构及指针\" class=\"headerlink\" title=\"4. 结构及指针\"></a>4. 结构及指针</h1><h2 id=\"4-1-指针\"><a href=\"#4-1-指针\" class=\"headerlink\" title=\"4.1 指针\"></a>4.1 指针</h2><p>Go 拥有指针。指针保存了值的内存地址。</p>\n<p>类型 <code>*T</code>​ 是指向 <code>T</code>​ 类型值的指针。其零值为 <code>nil</code>​。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var p *int</span><br></pre></td></tr></table></figure>\n\n<p><code>&amp;</code>​​ 操作符会生成一个指向其操作数的指针。</p>\n<p>所以当赋值的时候，或者是传输的时候只能够只用&amp;p来表示获取到p的地址，*p是地址指向的内容</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i := 42</span><br><span class=\"line\">p = &amp;i</span><br></pre></td></tr></table></figure>\n\n<p><code>*</code>​ 操作符表示指针指向的底层值。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fmt.Println(*p) // 通过指针 p 读取 i</span><br><span class=\"line\">*p = 21         // 通过指针 p 设置 i</span><br></pre></td></tr></table></figure>\n\n<p>这也就是通常所说的“间接引用”或“重定向”。</p>\n<p>与 C 不同，Go 没有指针运算。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\ti, j := <span class=\"number\">42</span>, <span class=\"number\">2701</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tp := &amp;i         <span class=\"comment\">// 指向 i</span></span><br><span class=\"line\">\tfmt.Println(*p) <span class=\"comment\">// 通过指针读取 i 的值</span></span><br><span class=\"line\">\t*p = <span class=\"number\">21</span>         <span class=\"comment\">// 通过指针设置 i 的值</span></span><br><span class=\"line\">\tfmt.Println(i)  <span class=\"comment\">// 查看 i 的值</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tp = &amp;j         <span class=\"comment\">// 指向 j</span></span><br><span class=\"line\">\t*p = *p / <span class=\"number\">37</span>   <span class=\"comment\">// 通过指针对 j 进行除法运算</span></span><br><span class=\"line\">\tfmt.Println(j) <span class=\"comment\">// 查看 j 的值</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<h2 id=\"4-2-结构体\"><a href=\"#4-2-结构体\" class=\"headerlink\" title=\"4.2 结构体\"></a>4.2 结构体</h2><p>一个结构体（<code>struct</code>​）就是一组字段（field）。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Vertex <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tX <span class=\"type\">int</span></span><br><span class=\"line\">\tY <span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-3-结构体字段\"><a href=\"#4-3-结构体字段\" class=\"headerlink\" title=\"4.3 结构体字段\"></a>4.3 结构体字段</h2><p>结构体字段使用点号来访问。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Vertex <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tX <span class=\"type\">int</span></span><br><span class=\"line\">\tY <span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tv := Vertex&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;</span><br><span class=\"line\">\tv.X = <span class=\"number\">4</span></span><br><span class=\"line\">\tfmt.Println(v.X)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<h2 id=\"4-4-结构体指针\"><a href=\"#4-4-结构体指针\" class=\"headerlink\" title=\"4.4 结构体指针\"></a>4.4 结构体指针</h2><p>结构体字段可以通过结构体指针来访问。</p>\n<p>如果我们有一个指向结构体的指针 <code>p</code>​，那么可以通过 <code>(*p).X</code>​ 来访问其字段 <code>X</code>​。不过这么写太啰嗦了，所以语言也允许我们使用隐式间接引用，直接写 <code>p.X</code>​ 就可以。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Vertex <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tX <span class=\"type\">int</span></span><br><span class=\"line\">\tY <span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tv := Vertex&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;</span><br><span class=\"line\">\tp := &amp;v</span><br><span class=\"line\">\tp.X = <span class=\"number\">1e9</span></span><br><span class=\"line\">\tfmt.Println(v)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<h2 id=\"4-5-结构体文法\"><a href=\"#4-5-结构体文法\" class=\"headerlink\" title=\"4.5 结构体文法\"></a>4.5 结构体文法</h2><p>结构体文法通过直接列出字段的值来新分配一个结构体。</p>\n<p>使用 <code>Name:</code>​ 语法可以仅列出部分字段。（字段名的顺序无关。）</p>\n<p>特殊的前缀 <code>&amp;</code>​ 返回一个指向结构体的指针。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Vertex <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tX, Y <span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> (</span><br><span class=\"line\">\tv1 = Vertex&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;  <span class=\"comment\">// 创建一个 Vertex 类型的结构体</span></span><br><span class=\"line\">\tv2 = Vertex&#123;X: <span class=\"number\">1</span>&#125;  <span class=\"comment\">// Y:0 被隐式地赋予</span></span><br><span class=\"line\">\tv3 = Vertex&#123;&#125;      <span class=\"comment\">// X:0 Y:0</span></span><br><span class=\"line\">\tp  = &amp;Vertex&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>&#125; <span class=\"comment\">// 创建一个 *Vertex 类型的结构体（指针）</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tfmt.Println(v1, p, v2, v3)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<h2 id=\"4-6-数组\"><a href=\"#4-6-数组\" class=\"headerlink\" title=\"4.6 数组\"></a>4.6 数组</h2><p>类型 <code>[n]T</code>​ 表示拥有 <code>n</code>​ 个 <code>T</code>​ 类型的值的数组。</p>\n<p>表达式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a [10]int</span><br></pre></td></tr></table></figure>\n\n<p>会将变量 <code>a</code>​ 声明为拥有 10 个整数的数组。</p>\n<p>数组的长度是其类型的一部分，<strong>因此数组不能改变大小</strong>。这看起来是个限制，不过没关系，Go 提供了更加便利的方式来使用数组。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> a [<span class=\"number\">2</span>]<span class=\"type\">string</span></span><br><span class=\"line\">\ta[<span class=\"number\">0</span>] = <span class=\"string\">&quot;Hello&quot;</span></span><br><span class=\"line\">\ta[<span class=\"number\">1</span>] = <span class=\"string\">&quot;World&quot;</span></span><br><span class=\"line\">\tfmt.Println(a[<span class=\"number\">0</span>], a[<span class=\"number\">1</span>])</span><br><span class=\"line\">\tfmt.Println(a)</span><br><span class=\"line\"></span><br><span class=\"line\">\tprimes := [<span class=\"number\">6</span>]<span class=\"type\">int</span>&#123;<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">11</span>, <span class=\"number\">13</span>&#125;</span><br><span class=\"line\">\tfmt.Println(primes)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<p>‍</p>\n<h2 id=\"4-7-切片\"><a href=\"#4-7-切片\" class=\"headerlink\" title=\"4.7 切片\"></a>4.7 切片</h2><p>每个数组的大小都是固定的。而切片则为数组元素提供动态大小的、灵活的视角。在实践中，切片比数组更常用。</p>\n<p>切片可以看作是对数组的划分，也就是说原数组是一个全集，切片就是其依据不同标准划分的子集</p>\n<p>类型 <code>[]T</code>​ 表示一个元素类型为 <code>T</code>​ 的切片。</p>\n<p>切片通过两个下标来界定，即一个上界和一个下界，二者以冒号分隔：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a[low : high]</span><br></pre></td></tr></table></figure>\n\n<p>它会选择一个半开区间，包括第一个元素，但排除最后一个元素。</p>\n<p>以下表达式创建了一个切片，它包含 <code>a</code>​ 中下标从 1 到 3 的元素：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a[1:4]</span><br></pre></td></tr></table></figure>\n\n<p>切片就像数组的引用</p>\n<p>切片并不存储任何数据，它只是描述了底层数组中的一段。</p>\n<p>更改切片的元素会修改其底层数组中对应的元素。</p>\n<p>与它<strong>共享底层数组</strong>的切片都会观测到这些修改（也就是说它是一种深拷贝）</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tnames := [<span class=\"number\">4</span>]<span class=\"type\">string</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"string\">&quot;John&quot;</span>,</span><br><span class=\"line\">\t\t<span class=\"string\">&quot;Paul&quot;</span>,</span><br><span class=\"line\">\t\t<span class=\"string\">&quot;George&quot;</span>,</span><br><span class=\"line\">\t\t<span class=\"string\">&quot;Ringo&quot;</span>,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfmt.Println(names)</span><br><span class=\"line\"></span><br><span class=\"line\">\ta := names[<span class=\"number\">0</span>:<span class=\"number\">2</span>]</span><br><span class=\"line\">\tb := names[<span class=\"number\">1</span>:<span class=\"number\">3</span>]</span><br><span class=\"line\">\tfmt.Println(a, b)</span><br><span class=\"line\"></span><br><span class=\"line\">\tb[<span class=\"number\">0</span>] = <span class=\"string\">&quot;XXX&quot;</span></span><br><span class=\"line\">\tfmt.Println(a, b)</span><br><span class=\"line\">\tfmt.Println(names)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<h2 id=\"4-8-切片文法\"><a href=\"#4-8-切片文法\" class=\"headerlink\" title=\"4.8 切片文法\"></a>4.8 切片文法</h2><p>切片文法类似于没有长度的数组文法。</p>\n<p>这是一个数组文法：<strong>构建的是一个数组</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[3]bool&#123;true, true, false&#125;</span><br></pre></td></tr></table></figure>\n\n<p>下面这样则会创建一个和上面相同的数组，然后构建一个引用了它的切片：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[]bool&#123;true, true, false&#125;</span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<h2 id=\"4-9-切片的默认行为\"><a href=\"#4-9-切片的默认行为\" class=\"headerlink\" title=\"4.9 切片的默认行为\"></a>4.9 切片的默认行为</h2><p>在进行切片时，你可以利用它的默认行为来忽略上下界。</p>\n<p>切片下界的默认值为 <code>0</code>​，上界则是该切片的长度。</p>\n<p>对于数组</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a [10]int</span><br></pre></td></tr></table></figure>\n\n<p>来说，以下切片是等价的：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a[0:10]</span><br><span class=\"line\">a[:10]</span><br><span class=\"line\">a[0:]</span><br><span class=\"line\">a[:]</span><br></pre></td></tr></table></figure>\n\n<p>可以明确的是：</p>\n<ol>\n<li><p>数组和切片不能够相互赋值</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这个函数不可行，因为s 初始化的是一个数组，之后不能够赋值给切片</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\ts := [<span class=\"number\">6</span>]<span class=\"type\">int</span>&#123;<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">11</span>, <span class=\"number\">13</span>&#125;</span><br><span class=\"line\">\ts = s[<span class=\"number\">1</span>:<span class=\"number\">4</span>]</span><br><span class=\"line\">\tfmt.Println(s)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">报错显示：</span><br><span class=\"line\">./prog.<span class=\"keyword\">go</span>:<span class=\"number\">8</span>:<span class=\"number\">7</span>: cannot use s[<span class=\"number\">1</span>:<span class=\"number\">4</span>] (value of <span class=\"keyword\">type</span> []<span class=\"type\">int</span>) as [<span class=\"number\">6</span>]<span class=\"type\">int</span> value in assignment</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>‍</p>\n<h2 id=\"4-10-切片的长度与容量\"><a href=\"#4-10-切片的长度与容量\" class=\"headerlink\" title=\"4.10 切片的长度与容量\"></a>4.10 切片的长度与容量</h2><p>切片拥有 <strong>长度</strong> 和 <strong>容量</strong>。</p>\n<p>切片的长度就是它所包含的元素个数。</p>\n<p>切片的容量是从它的第一个元素开始数，到其底层数组元素末尾的个数；容量也可以理解为切片总的能够扩展的（包括长度）数量</p>\n<p>切片 <code>s</code>​ 的长度和容量可通过表达式 <code>len(s)</code>​ 和 <code>cap(s)</code>​ 来获取。</p>\n<p>你可以通过重新切片来扩展一个切片，给它提供足够的容量</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\ts := []<span class=\"type\">int</span>&#123;<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">11</span>, <span class=\"number\">13</span>&#125;</span><br><span class=\"line\">\tprintSlice(s)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 截取切片使其长度为 0</span></span><br><span class=\"line\">\ts = s[:<span class=\"number\">0</span>]</span><br><span class=\"line\">\tprintSlice(s)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 拓展其长度</span></span><br><span class=\"line\">\ts = s[:<span class=\"number\">4</span>]</span><br><span class=\"line\">\tprintSlice(s)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 舍弃前两个值</span></span><br><span class=\"line\">\ts = s[<span class=\"number\">2</span>:]</span><br><span class=\"line\">\tprintSlice(s)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">printSlice</span><span class=\"params\">(s []<span class=\"type\">int</span>)</span></span> &#123;</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;len=%d cap=%d %v\\n&quot;</span>, <span class=\"built_in\">len</span>(s), <span class=\"built_in\">cap</span>(s), s)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<h2 id=\"4-11-nil-切片\"><a href=\"#4-11-nil-切片\" class=\"headerlink\" title=\"4.11 nil 切片\"></a>4.11 nil 切片</h2><p>切片的零值是 <code>nil</code>​。</p>\n<p>nil 切片的长度和容量为 0 且没有底层数组。</p>\n<p>‍</p>\n<h2 id=\"4-12-用-make-创建切片\"><a href=\"#4-12-用-make-创建切片\" class=\"headerlink\" title=\"4.12 用 make 创建切片\"></a>4.12 用 make 创建切片</h2><p>切片可以用内建函数 <code>make</code>​ 来创建，这也是你创建动态数组的方式。</p>\n<p><code>make</code>​ 函数会分配一个元素为零值的数组并返回一个引用了它的切片：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a := make([]int, 5)  // len(a)=5</span><br></pre></td></tr></table></figure>\n\n<p>要指定它的容量，需向 <code>make</code>​ 传入第三个参数：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">b := make([]int, 0, 5) // len(b)=0, cap(b)=5</span><br><span class=\"line\"></span><br><span class=\"line\">b = b[:cap(b)] // len(b)=5, cap(b)=5</span><br><span class=\"line\">b = b[1:]      // len(b)=4, cap(b)=4</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\ta := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\">\tprintSlice(<span class=\"string\">&quot;a&quot;</span>, a)</span><br><span class=\"line\"></span><br><span class=\"line\">\tb := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, <span class=\"number\">0</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\">\tprintSlice(<span class=\"string\">&quot;b&quot;</span>, b)</span><br><span class=\"line\"></span><br><span class=\"line\">\tc := b[:<span class=\"number\">2</span>]</span><br><span class=\"line\">\tprintSlice(<span class=\"string\">&quot;c&quot;</span>, c)</span><br><span class=\"line\"></span><br><span class=\"line\">\td := c[<span class=\"number\">2</span>:<span class=\"number\">5</span>]</span><br><span class=\"line\">\tprintSlice(<span class=\"string\">&quot;d&quot;</span>, d)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">printSlice</span><span class=\"params\">(s <span class=\"type\">string</span>, x []<span class=\"type\">int</span>)</span></span> &#123;</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;%s len=%d cap=%d %v\\n&quot;</span>,</span><br><span class=\"line\">\t\ts, <span class=\"built_in\">len</span>(x), <span class=\"built_in\">cap</span>(x), x)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">结果显示为：</span><br><span class=\"line\">a <span class=\"built_in\">len</span>=<span class=\"number\">5</span> <span class=\"built_in\">cap</span>=<span class=\"number\">5</span> [<span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">0</span>]</span><br><span class=\"line\">b <span class=\"built_in\">len</span>=<span class=\"number\">0</span> <span class=\"built_in\">cap</span>=<span class=\"number\">5</span> []</span><br><span class=\"line\">c <span class=\"built_in\">len</span>=<span class=\"number\">2</span> <span class=\"built_in\">cap</span>=<span class=\"number\">5</span> [<span class=\"number\">0</span> <span class=\"number\">0</span>]</span><br><span class=\"line\">d <span class=\"built_in\">len</span>=<span class=\"number\">3</span> <span class=\"built_in\">cap</span>=<span class=\"number\">3</span> [<span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">0</span>]</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<h2 id=\"4-13-创建二维切片：\"><a href=\"#4-13-创建二维切片：\" class=\"headerlink\" title=\"4. 13 创建二维切片：\"></a>4. 13 创建二维切片：</h2><blockquote>\n<p>参考文献：</p>\n<p><a href=\"https://www.cnblogs.com/yahuian/p/11934122.html\">直接参考的</a></p>\n<p><a href=\"https://stackoverflow.com/questions/39804861/what-is-a-concise-way-to-create-a-2d-slice-in-go\">Stack  例子讲解：</a></p>\n<p><a href=\"https://stackoverflow.com/questions/9320862/why-would-i-make-or-new\">make 和  new 的区别</a></p>\n<p><a href=\"https://stackoverflow.com/questions/39561140/what-is-two-dimensional-arrays-memory-representation\">二维数组的结合</a></p>\n</blockquote>\n<p>最常用的方法，需要记忆：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a := <span class=\"built_in\">make</span>([][]<span class=\"type\">uint8</span>, dy)</span><br><span class=\"line\"><span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> a &#123;</span><br><span class=\"line\">    a[i] = <span class=\"built_in\">make</span>([]<span class=\"type\">uint8</span>, dx)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方法0</span></span><br><span class=\"line\">row, column := <span class=\"number\">3</span>, <span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> answer [][]<span class=\"type\">int</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; row; i++ &#123;</span><br><span class=\"line\">\tinline := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, column)</span><br><span class=\"line\">\tanswer = <span class=\"built_in\">append</span>(answer, inline)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fmt.Println(answer)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方法1，最常用</span></span><br><span class=\"line\">answer1 := <span class=\"built_in\">make</span>([][]<span class=\"type\">int</span>, row)</span><br><span class=\"line\"><span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> answer1 &#123;</span><br><span class=\"line\">\tanswer1[i] = <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, column)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<p>‍</p>\n<h2 id=\"4-14-切片的切片\"><a href=\"#4-14-切片的切片\" class=\"headerlink\" title=\"4. 14 切片的切片\"></a>4. 14 切片的切片</h2><p>切片可包含任何类型，甚至包括其它的切片[参照二维数组]</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;strings&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 创建一个井字板（经典游戏）</span></span><br><span class=\"line\">\tboard := [][]<span class=\"type\">string</span>&#123;</span><br><span class=\"line\">\t\t[]<span class=\"type\">string</span>&#123;<span class=\"string\">&quot;_&quot;</span>, <span class=\"string\">&quot;_&quot;</span>, <span class=\"string\">&quot;_&quot;</span>&#125;,</span><br><span class=\"line\">\t\t[]<span class=\"type\">string</span>&#123;<span class=\"string\">&quot;_&quot;</span>, <span class=\"string\">&quot;_&quot;</span>, <span class=\"string\">&quot;_&quot;</span>&#125;,</span><br><span class=\"line\">\t\t[]<span class=\"type\">string</span>&#123;<span class=\"string\">&quot;_&quot;</span>, <span class=\"string\">&quot;_&quot;</span>, <span class=\"string\">&quot;_&quot;</span>&#125;,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 两个玩家轮流打上 X 和 O</span></span><br><span class=\"line\">\tboard[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"string\">&quot;X&quot;</span></span><br><span class=\"line\">\tboard[<span class=\"number\">2</span>][<span class=\"number\">2</span>] = <span class=\"string\">&quot;O&quot;</span></span><br><span class=\"line\">\tboard[<span class=\"number\">1</span>][<span class=\"number\">2</span>] = <span class=\"string\">&quot;X&quot;</span></span><br><span class=\"line\">\tboard[<span class=\"number\">1</span>][<span class=\"number\">0</span>] = <span class=\"string\">&quot;O&quot;</span></span><br><span class=\"line\">\tboard[<span class=\"number\">0</span>][<span class=\"number\">2</span>] = <span class=\"string\">&quot;X&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(board); i++ &#123;</span><br><span class=\"line\">\t\tfmt.Printf(<span class=\"string\">&quot;%s\\n&quot;</span>, strings.Join(board[i], <span class=\"string\">&quot; &quot;</span>))</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-15-向切片追加元素\"><a href=\"#4-15-向切片追加元素\" class=\"headerlink\" title=\"4. 15 向切片追加元素\"></a>4. 15 向切片追加元素</h2><p>为切片追加新的元素是种常用的操作，为此 Go 提供了内建的 <code>append</code>​ 函数。内建函数的<a href=\"https://go-zh.org/pkg/builtin/#append\">文档</a>对此函数有详细的介绍。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func append(s []T, vs ...T) []T</span><br></pre></td></tr></table></figure>\n\n<p><code>append</code>​ 的第一个参数 <code>s</code>​ 是一个元素类型为 <code>T</code>​ 的切片，其余类型为 <code>T</code>​ 的值将会追加到该切片的末尾。</p>\n<p><code>append</code>​ 的结果是一个包含原切片所有元素加上新添加元素的切片。</p>\n<p>当 <code>s</code>​ 的底层数组太小，不足以容纳所有给定的值时，它就会分配一个更大的数组。返回的切片会指向这个新分配的数组。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> s []<span class=\"type\">int</span></span><br><span class=\"line\">\tprintSlice(s)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 添加一个空切片</span></span><br><span class=\"line\">\ts = <span class=\"built_in\">append</span>(s, <span class=\"number\">0</span>)</span><br><span class=\"line\">\tprintSlice(s)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 这个切片会按需增长</span></span><br><span class=\"line\">\ts = <span class=\"built_in\">append</span>(s, <span class=\"number\">1</span>)</span><br><span class=\"line\">\tprintSlice(s)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 可以一次性添加多个元素</span></span><br><span class=\"line\">\ts = <span class=\"built_in\">append</span>(s, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\">\tprintSlice(s)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">printSlice</span><span class=\"params\">(s []<span class=\"type\">int</span>)</span></span> &#123;</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;len=%d cap=%d %v\\n&quot;</span>, <span class=\"built_in\">len</span>(s), <span class=\"built_in\">cap</span>(s), s)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可参考文章：  <a href=\"https://blog.go-zh.org/go-slices-usage-and-internals\">Go 切片：用法和本质</a></p>\n<p>‍</p>\n<h2 id=\"4-16-Range\"><a href=\"#4-16-Range\" class=\"headerlink\" title=\"4. 16 Range\"></a>4. 16 Range</h2><p><code>for</code>​ 循环的 <code>range</code>​ 形式可遍历切片或映射。</p>\n<p>当使用 <code>for</code>​ 循环遍历切片时，每次迭代都会返回两个值。第一个值为当前元素的下标，第二个值为该下标所对应元素的一份副本。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> pow = []<span class=\"type\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">8</span>, <span class=\"number\">16</span>, <span class=\"number\">32</span>, <span class=\"number\">64</span>, <span class=\"number\">128</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i, v := <span class=\"keyword\">range</span> pow &#123;</span><br><span class=\"line\">\t\tfmt.Printf(<span class=\"string\">&quot;2**%d = %d\\n&quot;</span>, i, v)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<h2 id=\"4-17-range（续）\"><a href=\"#4-17-range（续）\" class=\"headerlink\" title=\"4. 17 range（续）\"></a>4. 17 range（续）</h2><p>可以将下标或值赋予 <code>_</code>​ 来忽略它。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for i, _ := range pow</span><br><span class=\"line\">for _, value := range pow</span><br></pre></td></tr></table></figure>\n\n<p>若你只需要索引，忽略第二个变量即可。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for i := range pow</span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<h2 id=\"4-18-映射（Map）\"><a href=\"#4-18-映射（Map）\" class=\"headerlink\" title=\"4. 18 映射（Map）\"></a>4. 18 映射（Map）</h2><p>映射将键映射到值。</p>\n<p>映射的零值为 <code>nil</code>​ 。<code>nil</code>​ 映射既没有键，也不能添加键。</p>\n<p><code>make</code>​ 函数会返回给定类型的映射，并将其初始化备用。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Vertex <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tLat, Long <span class=\"type\">float64</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> m <span class=\"keyword\">map</span>[<span class=\"type\">string</span>]Vertex</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tm = <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">string</span>]Vertex)</span><br><span class=\"line\">\tm[<span class=\"string\">&quot;Bell Labs&quot;</span>] = Vertex&#123;</span><br><span class=\"line\">\t\t<span class=\"number\">40.68433</span>, <span class=\"number\">-74.39967</span>,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfmt.Println(m[<span class=\"string\">&quot;Bell Labs&quot;</span>])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"4-19-映射的文法\"><a href=\"#4-19-映射的文法\" class=\"headerlink\" title=\"4. 19 映射的文法\"></a>4. 19 映射的文法</h2><p>映射的文法与结构体相似，不过必须有键名。</p>\n<p>若顶级类型只是一个类型名，你可以在文法的元素中省略它。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Vertex <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tLat, Long <span class=\"type\">float64</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> m = <span class=\"keyword\">map</span>[<span class=\"type\">string</span>]Vertex&#123;</span><br><span class=\"line\">\t<span class=\"string\">&quot;Bell Labs&quot;</span>: &#123;<span class=\"number\">40.68433</span>, <span class=\"number\">-74.39967</span>&#125;,</span><br><span class=\"line\">\t<span class=\"string\">&quot;Google&quot;</span>:    &#123;<span class=\"number\">37.42202</span>, <span class=\"number\">-122.08408</span>&#125;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tfmt.Println(m)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<h2 id=\"4-20-修改映射\"><a href=\"#4-20-修改映射\" class=\"headerlink\" title=\"4. 20 修改映射\"></a>4. 20 修改映射</h2><p>在映射 <code>m</code>​ 中插入或修改元素：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">m[key] = elem</span><br></pre></td></tr></table></figure>\n\n<p>获取元素：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">elem = m[key]</span><br></pre></td></tr></table></figure>\n\n<p>删除元素：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">delete(m, key)</span><br></pre></td></tr></table></figure>\n\n<p>通过双赋值检测某个键是否存在：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">elem, ok = m[key]</span><br></pre></td></tr></table></figure>\n\n<p>若 <code>key</code>​ 在 <code>m</code>​ 中，<code>ok</code>​ 为 <code>true</code>​ ；否则，<code>ok</code>​ 为 <code>false</code>​。</p>\n<p>若 <code>key</code>​ 不在映射中，那么 <code>elem</code>​ 是该映射元素类型的零值。</p>\n<p>同样的，当从映射中读取某个不存在的键时，结果是映射的元素类型的零值。</p>\n<p><strong>注</strong> ：若 <code>elem</code>​ 或 <code>ok</code>​ 还未声明，你可以使用短变量声明：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">elem, ok := m[key]</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tm := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"type\">int</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\tm[<span class=\"string\">&quot;Answer&quot;</span>] = <span class=\"number\">42</span></span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;The value:&quot;</span>, m[<span class=\"string\">&quot;Answer&quot;</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">\tm[<span class=\"string\">&quot;Answer&quot;</span>] = <span class=\"number\">48</span></span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;The value:&quot;</span>, m[<span class=\"string\">&quot;Answer&quot;</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">delete</span>(m, <span class=\"string\">&quot;Answer&quot;</span>)</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;The value:&quot;</span>, m[<span class=\"string\">&quot;Answer&quot;</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">\tv, ok := m[<span class=\"string\">&quot;Answer&quot;</span>]</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;The value:&quot;</span>, v, <span class=\"string\">&quot;Present?&quot;</span>, ok)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<p>‍</p>\n<h2 id=\"4-21-函数值\"><a href=\"#4-21-函数值\" class=\"headerlink\" title=\"4. 21 函数值\"></a>4. 21 函数值</h2><p>函数也是值。它们可以像其它值一样传递。</p>\n<p>函数值可以用作函数的参数或返回值。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;math&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">compute</span><span class=\"params\">(fn <span class=\"keyword\">func</span>(<span class=\"type\">float64</span>, <span class=\"type\">float64</span>)</span></span> <span class=\"type\">float64</span>) <span class=\"type\">float64</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> fn(<span class=\"number\">3</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\thypot := <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(x, y <span class=\"type\">float64</span>)</span></span> <span class=\"type\">float64</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> math.Sqrt(x*x + y*y)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfmt.Println(hypot(<span class=\"number\">5</span>, <span class=\"number\">12</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">\tfmt.Println(compute(hypot))</span><br><span class=\"line\">\tfmt.Println(compute(math.Pow))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<h2 id=\"4-22-函数的闭包\"><a href=\"#4-22-函数的闭包\" class=\"headerlink\" title=\"4. 22 函数的闭包\"></a>4. 22 函数的闭包</h2><p>Go 函数可以是一个闭包。闭包是一个函数值，它引用了其函数体之外的变量。该函数可以访问并赋予其引用的变量的值，换句话说，该函数被这些变量“绑定”在一起。</p>\n<p>例如，函数 <code>adder</code>​ 返回一个闭包。每个闭包都被绑定在其各自的 <code>sum</code>​ 变量上。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">adder</span><span class=\"params\">()</span></span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(<span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\tsum := <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(x <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\t\tsum += x</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> sum</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tpos, neg := adder(), adder()</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++ &#123;</span><br><span class=\"line\">\t\tfmt.Println(</span><br><span class=\"line\">\t\t\tpos(i),</span><br><span class=\"line\">\t\t\tneg(<span class=\"number\">-2</span>*i),</span><br><span class=\"line\">\t\t)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">最终的结果是：</span><br><span class=\"line\"><span class=\"number\">0</span> <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">1</span> <span class=\"number\">-2</span></span><br><span class=\"line\"><span class=\"number\">3</span> <span class=\"number\">-6</span></span><br><span class=\"line\"><span class=\"number\">6</span> <span class=\"number\">-12</span></span><br><span class=\"line\"><span class=\"number\">10</span> <span class=\"number\">-20</span></span><br><span class=\"line\"><span class=\"number\">15</span> <span class=\"number\">-30</span></span><br><span class=\"line\"><span class=\"number\">21</span> <span class=\"number\">-42</span></span><br><span class=\"line\"><span class=\"number\">28</span> <span class=\"number\">-56</span></span><br><span class=\"line\"><span class=\"number\">36</span> <span class=\"number\">-72</span></span><br><span class=\"line\"><span class=\"number\">45</span> <span class=\"number\">-90</span></span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<p>‍</p>\n<h1 id=\"5-方法和接口\"><a href=\"#5-方法和接口\" class=\"headerlink\" title=\"5. 方法和接口\"></a>5. 方法和接口</h1><h2 id=\"5-1-方法\"><a href=\"#5-1-方法\" class=\"headerlink\" title=\"5.1 方法\"></a>5.1 方法</h2><p>Go 没有类。不过你可以为结构体类型定义方法。</p>\n<p>方法就是一类带特殊的 ​<strong>接收者</strong>​ 参数的函数。</p>\n<p>方法接收者在它自己的参数列表内，位于 <code>func</code>​ 关键字和方法名之间。</p>\n<p>在此例中，<code>Abs</code>​ 方法拥有一个名为 <code>v</code>​，类型为 <code>Vertex</code>​ 的接收者。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;math&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Vertex <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tX, Y <span class=\"type\">float64</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(v Vertex)</span></span> Abs() <span class=\"type\">float64</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tv := Vertex&#123;<span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;</span><br><span class=\"line\">\tfmt.Println(v.Abs())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>方法即函数</p>\n<p>记住：方法只是个带接收者参数的函数。</p>\n<p>现在这个 <code>Abs</code>​ 的写法就是个正常的函数，功能并没有什么变化。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;math&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Vertex <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tX, Y <span class=\"type\">float64</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Abs</span><span class=\"params\">(v Vertex)</span></span> <span class=\"type\">float64</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tv := Vertex&#123;<span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;</span><br><span class=\"line\">\tfmt.Println(Abs(v))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是这个是函数，并不能够通过v对象直接调用</p>\n<p>‍</p>\n<h2 id=\"5-2-方法（续）\"><a href=\"#5-2-方法（续）\" class=\"headerlink\" title=\"5.2 方法（续）\"></a>5.2 方法（续）</h2><p>你也可以为非结构体类型声明方法。</p>\n<p>在此例中，我们看到了一个带 <code>Abs</code>​ 方法的数值类型 <code>MyFloat</code>​。</p>\n<p>你只能为在同一包内定义的类型的接收者声明方法，而不能为其它包内定义的类型（包括 <code>int</code>​ 之类的内建类型）的接收者声明方法。</p>\n<p>（译注：就是接收者的类型定义和方法声明必须在同一包内；不能为内建类型声明方法。）</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;math&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> MyFloat <span class=\"type\">float64</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(f MyFloat)</span></span> Abs() <span class=\"type\">float64</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> f &lt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"type\">float64</span>(-f)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"type\">float64</span>(f)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tf := MyFloat(-math.Sqrt2)</span><br><span class=\"line\">\tfmt.Println(f.Abs())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<h2 id=\"5-3-指针接收者\"><a href=\"#5-3-指针接收者\" class=\"headerlink\" title=\"5.3 指针接收者\"></a>5.3 指针接收者</h2><p>你可以为指针接收者声明方法。</p>\n<p>这意味着对于某类型 <code>T</code>​，接收者的类型可以用 <code>*T</code>​ 的文法。（<strong>此外，</strong><strong><code>T</code><strong>​</strong>​ 不能是像 ​</strong><strong><code>*int</code><strong>​</strong>​ 这样的指针，换句话说就是没有双指针。</strong>不能够出现**int这样的结构）</p>\n<p>例如，这里为 <code>*Vertex</code>​ 定义了 <code>Scale</code>​ 方法。</p>\n<p>指针接收者的方法可以修改接收者指向的值（就像 <code>Scale</code>​ 在这做的）。由于方法经常需要修改它的接收者，指针接收者比值接收者更常用。</p>\n<p>试着移除第 16 行 <code>Scale</code>​ 函数声明中的 <code>*</code>​，观察此程序的行为如何变化。</p>\n<p>若使用值接收者，那么 <code>Scale</code>​ 方法会对原始 <code>Vertex</code>​ 值<strong>的副本</strong>进行操作。（对于函数的其它参数也是如此。）<code>Scale</code>​ 方法必须用指针接受者来更改 <code>main</code>​ 函数中声明的 <code>Vertex</code>​ 的值。也就是说使用指针的时候才能够对原本的数据结构当中的值做修改，但如果使用值接收者，就会修改一个副本，那么函数之间的调用修改就会不起作用，生命周期只在这个函数当中完成。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;math&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Vertex <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tX, Y <span class=\"type\">float64</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(v Vertex)</span></span> Abs() <span class=\"type\">float64</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//使用指针接收者，结果会是50 ，也就是说本函数的修改，abs能够获取到</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(v *Vertex)</span></span> Scale(f <span class=\"type\">float64</span>) &#123;</span><br><span class=\"line\">\tv.X = v.X * f</span><br><span class=\"line\">\tv.Y = v.Y * f</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//使用值接收者，结果会是5，也就是说本函数的修改只在本函数当中，abs无法感知到v.x,v.y的值发生变化</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(v Vertex)</span></span> Scale(f <span class=\"type\">float64</span>) &#123;</span><br><span class=\"line\">\tv.X = v.X * f</span><br><span class=\"line\">\tv.Y = v.Y * f</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tv := Vertex&#123;<span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;</span><br><span class=\"line\">\tv.Scale(<span class=\"number\">10</span>)</span><br><span class=\"line\">\tfmt.Println(v.Abs())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"Y:/Blog/blog/source/_posts/Go/Go-basic-knowledge/assets/image-20230228103213-yqcw1ma.png\" alt=\"image\">​</p>\n<p>‍</p>\n<h2 id=\"5-4-方法与指针重定向\"><a href=\"#5-4-方法与指针重定向\" class=\"headerlink\" title=\"5.4 方法与指针重定向\"></a>5.4 方法与指针重定向</h2><p>比较前两个程序，你大概会注意到<strong>带指针参数的函数必须接受一个指针</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var v Vertex</span><br><span class=\"line\">ScaleFunc(v, 5)  // 编译错误！</span><br><span class=\"line\">ScaleFunc(&amp;v, 5) // OK</span><br></pre></td></tr></table></figure>\n\n<p>而以<strong>指针为接收者的方法被调用时，接收者既能为值又能为指针：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var v Vertex</span><br><span class=\"line\">v.Scale(5)  // OK</span><br><span class=\"line\">p := &amp;v</span><br><span class=\"line\">p.Scale(10) // OK</span><br></pre></td></tr></table></figure>\n\n<p>对于语句 <code>v.Scale(5)</code>​，即便 <code>v</code>​ 是个值而非指针，带指针接收者的方法也能被直接调用。 也就是说，由于 <code>Scale</code>​ 方法有一个指针接收者，为方便起见，Go 会将语句 <code>v.Scale(5)</code>​ 解释为 <code>(&amp;v).Scale(5)</code>​。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Vertex <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tX, Y <span class=\"type\">float64</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(v *Vertex)</span></span> Scale(f <span class=\"type\">float64</span>) &#123;</span><br><span class=\"line\">\tv.X = v.X * f</span><br><span class=\"line\">\tv.Y = v.Y * f</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">ScaleFunc</span><span class=\"params\">(v *Vertex, f <span class=\"type\">float64</span>)</span></span> &#123;</span><br><span class=\"line\">\tv.X = v.X * f</span><br><span class=\"line\">\tv.Y = v.Y * f</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tv := Vertex&#123;<span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;</span><br><span class=\"line\">\tv.Scale(<span class=\"number\">2</span>)</span><br><span class=\"line\">\tScaleFunc(&amp;v, <span class=\"number\">10</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\tp := &amp;Vertex&#123;<span class=\"number\">4</span>, <span class=\"number\">3</span>&#125;</span><br><span class=\"line\">\tp.Scale(<span class=\"number\">3</span>)</span><br><span class=\"line\">\tScaleFunc(p, <span class=\"number\">8</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\tfmt.Println(v, p)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同样的事情也发生在相反的方向。</p>\n<p>接受一个值作为参数的函数必须接受一个指定类型的值：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var v Vertex</span><br><span class=\"line\">fmt.Println(AbsFunc(v))  // OK</span><br><span class=\"line\">fmt.Println(AbsFunc(&amp;v)) // 编译错误！</span><br></pre></td></tr></table></figure>\n\n<p>而以值为接收者的方法被调用时，接收者既能为值又能为指针：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var v Vertex</span><br><span class=\"line\">fmt.Println(v.Abs()) // OK</span><br><span class=\"line\">p := &amp;v</span><br><span class=\"line\">fmt.Println(p.Abs()) // OK</span><br></pre></td></tr></table></figure>\n\n<p>这种情况下，方法调用 <code>p.Abs()</code>​ 会被解释为 <code>(*p).Abs()</code>​。</p>\n<p>‍</p>\n<h2 id=\"5-5-选择值或指针作为接收者\"><a href=\"#5-5-选择值或指针作为接收者\" class=\"headerlink\" title=\"5.5 选择值或指针作为接收者\"></a>5.5 选择值或指针作为接收者</h2><p>使用指针接收者的原因有二：</p>\n<p>首先，方法能够修改其接收者指向的值。</p>\n<p>其次，这样可以避免在每次调用方法时复制该值。若值的类型为大型结构体时，这样做会更加高效。</p>\n<p>在本例中，<code>Scale</code>​ 和 <code>Abs</code>​ 接收者的类型为 <code>*Vertex</code>​，即便 <code>Abs</code>​ 并不需要修改其接收者。</p>\n<p>通常来说，所有给定类型的方法都应该有值或指针接收者，但并不应该二者混用。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;math&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Vertex <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tX, Y <span class=\"type\">float64</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(v *Vertex)</span></span> Scale(f <span class=\"type\">float64</span>) &#123;</span><br><span class=\"line\">\tv.X = v.X * f</span><br><span class=\"line\">\tv.Y = v.Y * f</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(v *Vertex)</span></span> Abs() <span class=\"type\">float64</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tv := &amp;Vertex&#123;<span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;Before scaling: %+v, Abs: %v\\n&quot;</span>, v, v.Abs())</span><br><span class=\"line\">\tv.Scale(<span class=\"number\">5</span>)</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;After scaling: %+v, Abs: %v\\n&quot;</span>, v, v.Abs())</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">结果显示是：</span><br><span class=\"line\">Before scaling: &amp;&#123;X:<span class=\"number\">3</span> Y:<span class=\"number\">4</span>&#125;, Abs: <span class=\"number\">5</span></span><br><span class=\"line\">After scaling: &amp;&#123;X:<span class=\"number\">15</span> Y:<span class=\"number\">20</span>&#125;, Abs: <span class=\"number\">25</span></span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<h2 id=\"5-6-接口\"><a href=\"#5-6-接口\" class=\"headerlink\" title=\"5. 6 接口\"></a>5. 6 接口</h2><p><strong>接口类型</strong> 是由一组方法签名定义的集合。</p>\n<blockquote>\n<p>参考文献 ：</p>\n<p><a href=\"https://blog.kennycoder.io/2020/02/03/Golang-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3interface%E5%B8%B8%E8%A6%8B%E7%94%A8%E6%B3%95/\">接口常见知识</a></p>\n</blockquote>\n<p>接口类型的变量可以保存任何实现了这些方法的值。</p>\n<blockquote>\n<p>接口就可以理解为一系列动作的集合<br><strong>而某个struct能够实现里面的所有方法，那么这个struct就是这个接口的一个实现</strong></p>\n</blockquote>\n<p><strong>注意:</strong> 示例代码的 22 行存在一个错误。由于 <code>Abs</code>​ 方法只为 <code>*Vertex</code>​ （指针类型）定义，因此 <code>Vertex</code>​（值类型）并未实现 <code>Abser</code>​。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Abser <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">\tAbs() <span class=\"type\">float64</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> a Abser</span><br><span class=\"line\">\tf := MyFloat(-math.Sqrt2)</span><br><span class=\"line\">\tv := Vertex&#123;<span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\ta = f  <span class=\"comment\">// a MyFloat 实现了 Abser</span></span><br><span class=\"line\">\ta = &amp;v <span class=\"comment\">// a *Vertex 实现了 Abser</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 下面一行，v 是一个 Vertex（而不是 *Vertex）</span></span><br><span class=\"line\">\t<span class=\"comment\">// 所以没有实现 Abser。</span></span><br><span class=\"line\">\ta = v</span><br><span class=\"line\"></span><br><span class=\"line\">\tfmt.Println(a.Abs())</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> MyFloat <span class=\"type\">float64</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(f MyFloat)</span></span> Abs() <span class=\"type\">float64</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> f &lt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"type\">float64</span>(-f)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"type\">float64</span>(f)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Vertex <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tX, Y <span class=\"type\">float64</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(v *Vertex)</span></span> Abs() <span class=\"type\">float64</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">显示错误：</span><br><span class=\"line\">./prog.<span class=\"keyword\">go</span>:<span class=\"number\">22</span>:<span class=\"number\">6</span>: cannot use v (variable of <span class=\"keyword\">type</span> Vertex) as Abser value in assignment: Vertex does not implement Abser (method Abs has pointer receiver)</span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<h2 id=\"5-7-接口与隐式实现\"><a href=\"#5-7-接口与隐式实现\" class=\"headerlink\" title=\"5.7 接口与隐式实现\"></a>5.7 接口与隐式实现</h2><p>类型通过实现一个接口的所有方法来实现该接口。既然无需专门显式声明，也就没有“implements”关键字。</p>\n<p>隐式接口从接口的实现中解耦了定义，这样接口的实现可以出现在任何包中，无需提前准备。</p>\n<p>因此，也就无需在每一个实现上增加新的接口名称，这样同时也鼓励了明确的接口定义。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> I <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">\tM()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> T <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tS <span class=\"type\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 此方法表示类型 T 实现了接口 I，但我们无需显式声明此事。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(t T)</span></span> M() &#123;</span><br><span class=\"line\">\tfmt.Println(t.S)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> i I = T&#123;<span class=\"string\">&quot;hello&quot;</span>&#125;</span><br><span class=\"line\">\ti.M()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<h2 id=\"5-8-接口值\"><a href=\"#5-8-接口值\" class=\"headerlink\" title=\"5.8 接口值\"></a>5.8 接口值</h2><p>接口也是值。它们可以像其它值一样传递。</p>\n<p>接口值可以用作函数的参数或返回值。</p>\n<p>在内部，接口值可以看做包含值和具体类型的元组：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(value, type)</span><br></pre></td></tr></table></figure>\n\n<p>接口值保存了一个具体底层类型的具体值。</p>\n<p>接口值调用方法时会执行其底层类型的同名方法</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;math&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> I <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">\tM()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> T <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tS <span class=\"type\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(t *T)</span></span> M() &#123;</span><br><span class=\"line\">\tfmt.Println(t.S)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> F <span class=\"type\">float64</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(f F)</span></span> M() &#123;</span><br><span class=\"line\">\tfmt.Println(f)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> i I</span><br><span class=\"line\"></span><br><span class=\"line\">\ti = &amp;T&#123;<span class=\"string\">&quot;Hello&quot;</span>&#125;</span><br><span class=\"line\">\tdescribe(i)</span><br><span class=\"line\">\ti.M()</span><br><span class=\"line\"></span><br><span class=\"line\">\ti = F(math.Pi)</span><br><span class=\"line\">\tdescribe(i)</span><br><span class=\"line\">\ti.M()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">describe</span><span class=\"params\">(i I)</span></span> &#123;</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;(%v, %T)\\n&quot;</span>, i, i)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">输出结果是：</span><br><span class=\"line\"><span class=\"comment\">//因为 T 实现是传入（* T）</span></span><br><span class=\"line\"></span><br><span class=\"line\">(&amp;&#123;Hello&#125;, *main.T)</span><br><span class=\"line\">Hello</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//因为 F 实现是传入（F）</span></span><br><span class=\"line\">(<span class=\"number\">3.141592653589793</span>, main.F)</span><br><span class=\"line\"><span class=\"number\">3.141592653589793</span></span><br></pre></td></tr></table></figure>\n\n<p>在上述代码当中的接口值是：(&amp;{Hello}, *main.T) 以及 (3.141592653589793, main.F)</p>\n<p>‍</p>\n<h2 id=\"5-9-底层值为-nil-的接口值\"><a href=\"#5-9-底层值为-nil-的接口值\" class=\"headerlink\" title=\"5.9 底层值为 nil 的接口值\"></a>5.9 底层值为 nil 的接口值</h2><p>即便接口内的具体值为 nil，方法仍然会被 nil 接收者调用。</p>\n<p>在一些语言中，这会触发一个空指针异常，但在 Go 中通常会写一些方法来优雅地处理它（如本例中的 <code>M</code>​ 方法）。</p>\n<p><strong>注意:</strong> 保存了 nil 具体值的接口其自身并不为 nil。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> I <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">\tM()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> T <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tS <span class=\"type\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(t *T)</span></span> M() &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> t == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tfmt.Println(<span class=\"string\">&quot;&lt;nil&gt;&quot;</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfmt.Println(t.S)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> i I</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> t *T</span><br><span class=\"line\">\ti = t</span><br><span class=\"line\">\tdescribe(i)</span><br><span class=\"line\">\ti.M()</span><br><span class=\"line\"></span><br><span class=\"line\">\ti = &amp;T&#123;<span class=\"string\">&quot;hello&quot;</span>&#125;</span><br><span class=\"line\">\tdescribe(i)</span><br><span class=\"line\">\ti.M()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">describe</span><span class=\"params\">(i I)</span></span> &#123;</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;(%v, %T)\\n&quot;</span>, i, i)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">记结果输出为：</span><br><span class=\"line\">(&lt;<span class=\"literal\">nil</span>&gt;, *main.T)</span><br><span class=\"line\">&lt;<span class=\"literal\">nil</span>&gt;</span><br><span class=\"line\">(&amp;&#123;hello&#125;, *main.T)</span><br><span class=\"line\">hello</span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<h2 id=\"5-10-nil-接口值\"><a href=\"#5-10-nil-接口值\" class=\"headerlink\" title=\"5.10 nil 接口值\"></a>5.10 nil 接口值</h2><p>nil 接口值既不保存值也不保存具体类型。</p>\n<p>为 nil 接口调用方法会产生运行时错误，因为接口的元组内并未包含能够指明该调用哪个 <strong>具体</strong> 方法的类型。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> I <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">\tM()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> i I</span><br><span class=\"line\">\tdescribe(i)</span><br><span class=\"line\">\ti.M()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">describe</span><span class=\"params\">(i I)</span></span> &#123;</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;(%v, %T)\\n&quot;</span>, i, i)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">上述代码会显示：</span><br><span class=\"line\">(&lt;<span class=\"literal\">nil</span>&gt;, &lt;<span class=\"literal\">nil</span>&gt;)</span><br><span class=\"line\"><span class=\"built_in\">panic</span>: runtime <span class=\"type\">error</span>: invalid memory address or <span class=\"literal\">nil</span> pointer dereference</span><br><span class=\"line\">[signal SIGSEGV: segmentation violation code=<span class=\"number\">0x1</span> addr=<span class=\"number\">0x0</span> pc=<span class=\"number\">0x481961</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">goroutine <span class=\"number\">1</span> [running]:</span><br><span class=\"line\">main.main()</span><br><span class=\"line\">\t/tmp/sandbox4223192970/prog.<span class=\"keyword\">go</span>:<span class=\"number\">12</span> +<span class=\"number\">0x61</span></span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<p>以上两者是不同的概念：</p>\n<p>第一个是接口对象不为空，但是对象指向的地方为空，也就是说接口申明了之后，还是给了他一个赋值的对象，但这个对象可能还没有初始化</p>\n<p>第二个是接口对象为空</p>\n<p>‍</p>\n<h2 id=\"5-11-空接口\"><a href=\"#5-11-空接口\" class=\"headerlink\" title=\"5.11 空接口\"></a>5.11 空接口</h2><p>指定了零个方法的接口值被称为 <em>空接口：</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>空接口可保存任何类型的值。（因为每个类型都至少实现了零个方法。）</p>\n<p>空接口被用来处理未知类型的值。例如，<code>fmt.Print</code>​ 可接受类型为 <code>interface&#123;&#125;</code>​ 的任意数量的参数。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> i <span class=\"keyword\">interface</span>&#123;&#125;</span><br><span class=\"line\">\tdescribe(i)</span><br><span class=\"line\"></span><br><span class=\"line\">\ti = <span class=\"number\">42</span></span><br><span class=\"line\">\tdescribe(i)</span><br><span class=\"line\"></span><br><span class=\"line\">\ti = <span class=\"string\">&quot;hello&quot;</span></span><br><span class=\"line\">\tdescribe(i)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">describe</span><span class=\"params\">(i <span class=\"keyword\">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;(%v, %T)\\n&quot;</span>, i, i)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<h2 id=\"5-12-类型断言\"><a href=\"#5-12-类型断言\" class=\"headerlink\" title=\"5.12 类型断言\"></a>5.12 类型断言</h2><blockquote>\n<p><a href=\"https://blog.kalan.dev/posts/golang-type-assertion\">断言具体释义</a></p>\n</blockquote>\n<p><strong>类型断言</strong> 提供了<strong>访问接口值底层具体值</strong>的方式。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">t := i.(T)</span><br></pre></td></tr></table></figure>\n\n<p>该语句断言接口值 <code>i</code>​ 保存了具体类型 <code>T</code>​，并将其底层类型为 <code>T</code>​ 的值赋予变量 <code>t</code>​。</p>\n<p>若 <code>i</code>​ 并未保存 <code>T</code>​ 类型的值，该语句就会触发一个恐慌。</p>\n<p>为了 <strong>判断</strong> 一个接口值是否保存了一个特定的类型，类型断言可返回两个值：其底层值以及一个报告断言是否成功的布尔值。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">t, ok := i.(T)</span><br></pre></td></tr></table></figure>\n\n<p>若 <code>i</code>​ 保存了一个 <code>T</code>​，那么 <code>t</code>​ 将会是其底层值，而 <code>ok</code>​ 为 <code>true</code>​。</p>\n<p>否则，<code>ok</code>​ 将为 <code>false</code>​ 而 <code>t</code>​ 将为 <code>T</code>​ 类型的零值，程序并不会产生恐慌。</p>\n<p>请注意这种语法和读取一个映射时的相同之处。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> i <span class=\"keyword\">interface</span>&#123;&#125; = <span class=\"string\">&quot;hello&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\ts := i.(<span class=\"type\">string</span>)</span><br><span class=\"line\">\tfmt.Println(s)</span><br><span class=\"line\"></span><br><span class=\"line\">\ts, ok := i.(<span class=\"type\">string</span>)</span><br><span class=\"line\">\tfmt.Println(s, ok)</span><br><span class=\"line\"></span><br><span class=\"line\">\tf, ok := i.(<span class=\"type\">float64</span>)</span><br><span class=\"line\">\tfmt.Println(f, ok)</span><br><span class=\"line\"></span><br><span class=\"line\">\tf = i.(<span class=\"type\">float64</span>) <span class=\"comment\">// 报错(panic)</span></span><br><span class=\"line\">\tfmt.Println(f)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">结果显示为：</span><br><span class=\"line\">hello</span><br><span class=\"line\">hello <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"number\">0</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"built_in\">panic</span>: <span class=\"keyword\">interface</span> conversion: <span class=\"keyword\">interface</span> &#123;&#125; is <span class=\"type\">string</span>, not <span class=\"type\">float64</span></span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<h2 id=\"5-13-类型选择\"><a href=\"#5-13-类型选择\" class=\"headerlink\" title=\"5.13 类型选择\"></a>5.13 类型选择</h2><p><strong>类型选择</strong> 是一种按顺序从几个类型断言中选择分支的结构。</p>\n<p>类型选择与一般的 switch 语句相似，不过类型选择中的 case 为类型（而非值）， 它们针对给定接口值所存储的值的类型进行比较。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">switch v := i.(type) &#123;</span><br><span class=\"line\">case T:</span><br><span class=\"line\">    // v 的类型为 T</span><br><span class=\"line\">case S:</span><br><span class=\"line\">    // v 的类型为 S</span><br><span class=\"line\">default:</span><br><span class=\"line\">    // 没有匹配，v 与 i 的类型相同</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>类型选择中的声明与类型断言 <code>i.(T)</code>​ 的语法相同，<strong>只是具体类型 ​</strong>**<code>T</code><strong><strong>​ 被替换成了关键字 ​</strong></strong><code>type</code>**<strong>。</strong></p>\n<p>此选择语句判断接口值 <code>i</code>​ 保存的值类型是 <code>T</code>​ 还是 <code>S</code>​。在 <code>T</code>​ 或 <code>S</code>​ 的情况下，变量 <code>v</code>​ 会分别按 <code>T</code>​ 或 <code>S</code>​ 类型保存 <code>i</code>​ 拥有的值。在默认（即没有匹配）的情况下，变量 <code>v</code>​ 与 <code>i</code>​ 的接口类型和值相同。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">do</span><span class=\"params\">(i <span class=\"keyword\">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">switch</span> v := i.(<span class=\"keyword\">type</span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> <span class=\"type\">int</span>:</span><br><span class=\"line\">\t\tfmt.Printf(<span class=\"string\">&quot;Twice %v is %v\\n&quot;</span>, v, v*<span class=\"number\">2</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> <span class=\"type\">string</span>:</span><br><span class=\"line\">\t\tfmt.Printf(<span class=\"string\">&quot;%q is %v bytes long\\n&quot;</span>, v, <span class=\"built_in\">len</span>(v))</span><br><span class=\"line\">\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\tfmt.Printf(<span class=\"string\">&quot;I don&#x27;t know about type %T!\\n&quot;</span>, v)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tdo(<span class=\"number\">21</span>)</span><br><span class=\"line\">\tdo(<span class=\"string\">&quot;hello&quot;</span>)</span><br><span class=\"line\">\tdo(<span class=\"literal\">true</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">结果是：</span><br><span class=\"line\">Twice <span class=\"number\">21</span> is <span class=\"number\">42</span></span><br><span class=\"line\"><span class=\"string\">&quot;hello&quot;</span> is <span class=\"number\">5</span> bytes long</span><br><span class=\"line\">I don<span class=\"string\">&#x27;t know about type bool!</span></span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<h2 id=\"5-14-Stringer\"><a href=\"#5-14-Stringer\" class=\"headerlink\" title=\"5. 14 Stringer\"></a>5. 14 Stringer</h2><p><a href=\"https://go-zh.org/pkg/fmt/\">fmt</a><code>​ 包中定义的 [Stringer](https://go-zh.org/pkg/fmt/#Stringer)</code>​ 是最普遍的接口之一。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type Stringer interface &#123;</span><br><span class=\"line\">    String() string</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>Stringer</code>​ 是一个可以用字符串描述自己的类型。<code>fmt</code>​ 包（还有很多包）都通过此接口来打印值。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Person <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tName <span class=\"type\">string</span></span><br><span class=\"line\">\tAge  <span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p Person)</span></span> String() <span class=\"type\">string</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> fmt.Sprintf(<span class=\"string\">&quot;%v (%v years)&quot;</span>, p.Name, p.Age)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\ta := Person&#123;<span class=\"string\">&quot;Arthur Dent&quot;</span>, <span class=\"number\">42</span>&#125;</span><br><span class=\"line\">\tz := Person&#123;<span class=\"string\">&quot;Zaphod Beeblebrox&quot;</span>, <span class=\"number\">9001</span>&#125;</span><br><span class=\"line\">\tfmt.Println(a, z)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<h2 id=\"5-15-错误\"><a href=\"#5-15-错误\" class=\"headerlink\" title=\"5. 15 错误\"></a>5. 15 错误</h2><p>Go 程序使用 <code>error</code>​ 值来表示错误状态。</p>\n<p>与 <code>fmt.Stringer</code>​ 类似，<code>error</code>​ 类型是一个内建接口：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type error interface &#123;</span><br><span class=\"line\">    Error() string</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（与 <code>fmt.Stringer</code>​ 类似，<code>fmt</code>​ 包在打印值时也会满足 <code>error</code>​。）</p>\n<p>通常函数会返回一个 <code>error</code>​ 值，调用的它的代码应当判断这个错误是否等于 <code>nil</code>​ 来进行错误处理。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i, err := strconv.Atoi(&quot;42&quot;)</span><br><span class=\"line\">if err != nil &#123;</span><br><span class=\"line\">    fmt.Printf(&quot;couldn&#x27;t convert number: %v\\n&quot;, err)</span><br><span class=\"line\">    return</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fmt.Println(&quot;Converted integer:&quot;, i)</span><br></pre></td></tr></table></figure>\n\n<p><code>error</code>​ 为 nil 时表示成功；非 nil 的 <code>error</code>​ 表示失败</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;time&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> MyError <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tWhen time.Time</span><br><span class=\"line\">\tWhat <span class=\"type\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(e *MyError)</span></span> Error() <span class=\"type\">string</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> fmt.Sprintf(<span class=\"string\">&quot;at %v, %s&quot;</span>,</span><br><span class=\"line\">\t\te.When, e.What)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">run</span><span class=\"params\">()</span></span> <span class=\"type\">error</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;MyError&#123;</span><br><span class=\"line\">\t\ttime.Now(),</span><br><span class=\"line\">\t\t<span class=\"string\">&quot;it didn&#x27;t work&quot;</span>,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err := run(); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tfmt.Println(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"5-16-Reader\"><a href=\"#5-16-Reader\" class=\"headerlink\" title=\"5. 16 Reader\"></a>5. 16 Reader</h2><p><code>io</code>​ 包指定了 <code>io.Reader</code>​ 接口，它表示从数据流的末尾进行读取。</p>\n<p>Go 标准库包含了该接口的<a href=\"https://go-zh.org/search?q=Read#Global\">许多实现</a>，包括文件、网络连接、压缩和加密等等。</p>\n<p><code>io.Reader</code>​ 接口有一个 <code>Read</code>​ 方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func (T) Read(b []byte) (n int, err error)</span><br></pre></td></tr></table></figure>\n\n<p><code>Read</code>​ 用数据填充给定的字节切片并返回填充的字节数和错误值。在遇到数据流的结尾时，它会返回一个 <code>io.EOF</code>​ 错误。</p>\n<p>示例代码创建了一个 <a href=\"https://go-zh.org/pkg/strings/#Reader\">strings.Reader</a>``​ 并以每次 8 字节的速度读取它的输出。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;io&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;strings&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tr := strings.NewReader(<span class=\"string\">&quot;Hello, Reader!&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\tb := <span class=\"built_in\">make</span>([]<span class=\"type\">byte</span>, <span class=\"number\">8</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\tn, err := r.Read(b)</span><br><span class=\"line\">\t\tfmt.Printf(<span class=\"string\">&quot;n = %v err = %v b = %v\\n&quot;</span>, n, err, b)</span><br><span class=\"line\">\t\tfmt.Printf(<span class=\"string\">&quot;b[:n] = %q\\n&quot;</span>, b[:n])</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err == io.EOF &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">输出结果是：</span><br><span class=\"line\">n = <span class=\"number\">8</span> err = &lt;<span class=\"literal\">nil</span>&gt; b = [<span class=\"number\">72</span> <span class=\"number\">101</span> <span class=\"number\">108</span> <span class=\"number\">108</span> <span class=\"number\">111</span> <span class=\"number\">44</span> <span class=\"number\">32</span> <span class=\"number\">82</span>]</span><br><span class=\"line\">b[:n] = <span class=\"string\">&quot;Hello, R&quot;</span></span><br><span class=\"line\">n = <span class=\"number\">6</span> err = &lt;<span class=\"literal\">nil</span>&gt; b = [<span class=\"number\">101</span> <span class=\"number\">97</span> <span class=\"number\">100</span> <span class=\"number\">101</span> <span class=\"number\">114</span> <span class=\"number\">33</span> <span class=\"number\">32</span> <span class=\"number\">82</span>]</span><br><span class=\"line\">b[:n] = <span class=\"string\">&quot;eader!&quot;</span></span><br><span class=\"line\">n = <span class=\"number\">0</span> err = EOF b = [<span class=\"number\">101</span> <span class=\"number\">97</span> <span class=\"number\">100</span> <span class=\"number\">101</span> <span class=\"number\">114</span> <span class=\"number\">33</span> <span class=\"number\">32</span> <span class=\"number\">82</span>]</span><br><span class=\"line\">b[:n] = <span class=\"string\">&quot;&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<p>‍</p>\n<h2 id=\"5-17-图像\"><a href=\"#5-17-图像\" class=\"headerlink\" title=\"5.17 图像\"></a>5.17 图像</h2><p><a href=\"https://go-zh.org/pkg/image/#Image\">image</a>``​ 包定义了 <code>Image</code>​ 接口：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package image</span><br><span class=\"line\"></span><br><span class=\"line\">type Image interface &#123;</span><br><span class=\"line\">    ColorModel() color.Model</span><br><span class=\"line\">    Bounds() Rectangle</span><br><span class=\"line\">    At(x, y int) color.Color</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意:</strong> <code>Bounds</code>​ 方法的返回值 <code>Rectangle</code>​ 实际上是一个 <a href=\"https://go-zh.org/pkg/image/#Rectangle\">image.Rectangle</a>``​，它在 <code>image</code>​ 包中声明。</p>\n<p>（请参阅<a href=\"https://go-zh.org/pkg/image/#Image\">文档</a>了解全部信息。）</p>\n<p><code>color.Color</code>​ 和 <code>color.Model</code>​ 类型也是接口，但是通常因为直接使用预定义的实现 <code>image.RGBA</code>​ 和 <code>image.RGBAModel</code>​ 而被忽视了。这些接口和类型由 <a href=\"https://go-zh.org/pkg/image/color/\">image/color</a>``​ 包定义。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;image&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tm := image.NewRGBA(image.Rect(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">100</span>, <span class=\"number\">100</span>))</span><br><span class=\"line\">\tfmt.Println(m.Bounds())</span><br><span class=\"line\">\tfmt.Println(m.At(<span class=\"number\">0</span>, <span class=\"number\">0</span>).RGBA())</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"6-并发编程\"><a href=\"#6-并发编程\" class=\"headerlink\" title=\"6.  并发编程\"></a>6.  并发编程</h1><h2 id=\"6-1-Go-协程\"><a href=\"#6-1-Go-协程\" class=\"headerlink\" title=\"6.1  Go 协程\"></a>6.1  Go 协程</h2><p>Go 协程（goroutine）是由 Go 运行时管理的轻量级线程。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go f(x, y, z)</span><br></pre></td></tr></table></figure>\n\n<p>会启动一个新的 Go 程并执行</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f(x, y, z)</span><br></pre></td></tr></table></figure>\n\n<p><code>f</code>​, <code>x</code>​, <code>y</code>​ 和 <code>z</code>​ 的求值发生在当前的 Go 程中，而 <code>f</code>​ 的执行发生在新的 Go 程中。</p>\n<p>Go 程在相同的地址空间中运行，因此在访问共享的内存时必须进行同步。<a href=\"https://go-zh.org/pkg/sync/\">sync</a>``​ 包提供了这种能力，不过在 Go 中并不经常用到。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;time&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">say</span><span class=\"params\">(s <span class=\"type\">string</span>)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++ &#123;</span><br><span class=\"line\">\t\ttime.Sleep(<span class=\"number\">100</span> * time.Millisecond)</span><br><span class=\"line\">\t\tfmt.Println(s)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> say(<span class=\"string\">&quot;world&quot;</span>)</span><br><span class=\"line\">\tsay(<span class=\"string\">&quot;hello&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<h2 id=\"6-2-信道\"><a href=\"#6-2-信道\" class=\"headerlink\" title=\"6.2 信道\"></a>6.2 信道</h2><p>信道是带有类型的管道，你可以通过它用信道操作符 <code>&lt;-</code>​ 来发送或者接收值。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ch &lt;- v    // 将 v 发送至信道 ch。</span><br><span class=\"line\">v := &lt;-ch  // 从 ch 接收值并赋予 v。</span><br></pre></td></tr></table></figure>\n\n<p>（“箭头”就是数据流的方向。）</p>\n<p>和映射与切片一样，信道在使用前必须创建，也是使用make的形式创建</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ch := make(chan int)</span><br></pre></td></tr></table></figure>\n\n<p>默认情况下，发送和接收操作在另一端准备好之前都会阻塞。这使得 Go 程可以在没有显式的锁或竞态变量的情况下进行同步。</p>\n<p>以下示例对切片中的数进行求和，将任务分配给两个 Go 程。一旦两个 Go 程完成了它们的计算，它就能算出最终的结果。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">sum</span><span class=\"params\">(s []<span class=\"type\">int</span>, c <span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span></span> &#123;</span><br><span class=\"line\">\tsum := <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, v := <span class=\"keyword\">range</span> s &#123;</span><br><span class=\"line\">\t\tsum += v</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tc &lt;- sum <span class=\"comment\">// 将和送入 c</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\ts := []<span class=\"type\">int</span>&#123;<span class=\"number\">7</span>, <span class=\"number\">2</span>, <span class=\"number\">8</span>, <span class=\"number\">-9</span>, <span class=\"number\">4</span>, <span class=\"number\">0</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tc := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> sum(s[:<span class=\"built_in\">len</span>(s)/<span class=\"number\">2</span>], c)</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> sum(s[<span class=\"built_in\">len</span>(s)/<span class=\"number\">2</span>:], c)</span><br><span class=\"line\">\tx, y := &lt;-c, &lt;-c <span class=\"comment\">// 从 c 中接收</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tfmt.Println(x, y, x+y)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">结果显示为：</span><br><span class=\"line\"><span class=\"number\">-5</span> <span class=\"number\">17</span> <span class=\"number\">12</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>同时也可以知道 信道的结构是队列类型，先进先出</strong></p>\n<p>‍</p>\n<p>‍</p>\n<h2 id=\"6-3-项目带缓冲的信道\"><a href=\"#6-3-项目带缓冲的信道\" class=\"headerlink\" title=\"6.3 项目带缓冲的信道\"></a>6.3 项目带缓冲的信道</h2><p>信道可以是 <em>带缓冲的</em>。将缓冲长度作为第二个参数提供给 <code>make</code>​ 来初始化一个带缓冲的信道：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ch := make(chan int, 100)</span><br></pre></td></tr></table></figure>\n\n<p>仅当信道的缓冲区填满后，向其发送数据时才会阻塞。当缓冲区为空时，接受方会阻塞。</p>\n<p>修改示例填满缓冲区，然后看看会发生什么。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">\tch &lt;- <span class=\"number\">1</span></span><br><span class=\"line\">\tch &lt;- <span class=\"number\">2</span></span><br><span class=\"line\">\tfmt.Println(&lt;-ch)</span><br><span class=\"line\">\tfmt.Println(&lt;-ch)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<h2 id=\"6-4-信道使用-range-和-close\"><a href=\"#6-4-信道使用-range-和-close\" class=\"headerlink\" title=\"6. 4 信道使用 range 和 close\"></a>6. 4 信道使用 range 和 close</h2><p>发送者可通过 <code>close</code>​ 关闭一个信道来表示没有需要发送的值了。接收者可以通过为接收表达式分配第二个参数来测试信道是否被关闭：若没有值可以接收且信道已被关闭，那么在执行完</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">v, ok := &lt;-ch</span><br></pre></td></tr></table></figure>\n\n<p>之后 <code>ok</code>​ 会被设置为 <code>false</code>​。</p>\n<p>循环 <code>for i := range c</code>​ 会不断从信道接收值，直到它被关闭。</p>\n<p><em>注意：</em> 只有发送者才能关闭信道，而接收者不能。向一个已经关闭的信道发送数据会引发程序恐慌（panic）。</p>\n<p><em>还要注意：</em> 信道与文件不同，通常情况下无需关闭它们。只有在必须告诉接收者不再有需要发送的值时才有必要关闭，例如终止一个 <code>range</code>​ 循环。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">fibonacci</span><span class=\"params\">(n <span class=\"type\">int</span>, c <span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span></span> &#123;</span><br><span class=\"line\">\tx, y := <span class=\"number\">0</span>, <span class=\"number\">1</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; n; i++ &#123;</span><br><span class=\"line\">\t\tc &lt;- x</span><br><span class=\"line\">\t\tx, y = y, x+y</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">close</span>(c)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tc := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>, <span class=\"number\">10</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> fibonacci(<span class=\"built_in\">cap</span>(c), c)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> c &#123;</span><br><span class=\"line\">\t\tfmt.Println(i)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">结果显示为：</span><br><span class=\"line\"><span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"number\">8</span></span><br><span class=\"line\"><span class=\"number\">13</span></span><br><span class=\"line\"><span class=\"number\">21</span></span><br><span class=\"line\"><span class=\"number\">34</span></span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<h2 id=\"6-5-Go-語言如何從-Channel-讀取資料\"><a href=\"#6-5-Go-語言如何從-Channel-讀取資料\" class=\"headerlink\" title=\"6.5 Go 語言如何從 Channel 讀取資料\"></a>6.5 Go 語言如何從 Channel 讀取資料</h2><blockquote>\n<p>参考文献：</p>\n<p><a href=\"https://blog.wu-boy.com/2022/05/read-data-from-channel-in-go/\">Chan的读取方式</a></p>\n</blockquote>\n<p>‍</p>\n<h2 id=\"6-6-select-语句\"><a href=\"#6-6-select-语句\" class=\"headerlink\" title=\"6.6 select 语句\"></a>6.6 select 语句</h2><p><code>select</code>​ 语句使一个 Go 程可以等待多个通信操作。</p>\n<p><code>select</code>​ 会阻塞到某个分支可以继续执行为止，这时就会执行该分支。当多个分支都准备好时会随机选择一个执行。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">fibonacci</span><span class=\"params\">(c, quit <span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span></span> &#123;</span><br><span class=\"line\">\tx, y := <span class=\"number\">0</span>, <span class=\"number\">1</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> c &lt;- x:</span><br><span class=\"line\">\t\t\tx, y = y, x+y</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> &lt;-quit:</span><br><span class=\"line\">\t\t\tfmt.Println(<span class=\"string\">&quot;quit&quot;</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tc := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\">\tquit := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++ &#123;</span><br><span class=\"line\">\t\t\tfmt.Println(&lt;-c)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tquit &lt;- <span class=\"number\">0</span></span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\">\tfibonacci(c, quit)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<h2 id=\"6-7-默认选择\"><a href=\"#6-7-默认选择\" class=\"headerlink\" title=\"6.7 默认选择\"></a>6.7 默认选择</h2><p>当 <code>select</code>​ 中的其它分支都没有准备好时，<code>default</code>​ 分支就会执行。</p>\n<p>为了在尝试发送或者接收时不发生阻塞，可使用 <code>default</code>​ 分支：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select &#123;</span><br><span class=\"line\">case i := &lt;-c:</span><br><span class=\"line\">    // 使用 i</span><br><span class=\"line\">default:</span><br><span class=\"line\">    // 从 c 中接收会阻塞时执行</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;time&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\ttick := time.Tick(<span class=\"number\">100</span> * time.Millisecond)</span><br><span class=\"line\">\tboom := time.After(<span class=\"number\">500</span> * time.Millisecond)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> i := &lt;-tick:</span><br><span class=\"line\">\t\t\tfmt.Println(i)</span><br><span class=\"line\">\t\t\tfmt.Println(<span class=\"string\">&quot;tick.&quot;</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> &lt;-boom:</span><br><span class=\"line\">\t\t\tfmt.Println(<span class=\"string\">&quot;BOOM!&quot;</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\t\tfmt.Println(<span class=\"string\">&quot;    .&quot;</span>)</span><br><span class=\"line\">\t\t\ttime.Sleep(<span class=\"number\">50</span> * time.Millisecond)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出为：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    .</span><br><span class=\"line\">    .</span><br><span class=\"line\"><span class=\"number\">2009</span><span class=\"number\">-11</span><span class=\"number\">-10</span> <span class=\"number\">23</span>:<span class=\"number\">00</span>:<span class=\"number\">00.1</span> +<span class=\"number\">0000</span> UTC m=+<span class=\"number\">0.100000001</span></span><br><span class=\"line\">tick.</span><br><span class=\"line\">    .</span><br><span class=\"line\">    .</span><br><span class=\"line\">    .</span><br><span class=\"line\"><span class=\"number\">2009</span><span class=\"number\">-11</span><span class=\"number\">-10</span> <span class=\"number\">23</span>:<span class=\"number\">00</span>:<span class=\"number\">00.2</span> +<span class=\"number\">0000</span> UTC m=+<span class=\"number\">0.200000001</span></span><br><span class=\"line\">tick.</span><br><span class=\"line\">    .</span><br><span class=\"line\"><span class=\"number\">2009</span><span class=\"number\">-11</span><span class=\"number\">-10</span> <span class=\"number\">23</span>:<span class=\"number\">00</span>:<span class=\"number\">00.3</span> +<span class=\"number\">0000</span> UTC m=+<span class=\"number\">0.300000001</span></span><br><span class=\"line\">tick.</span><br><span class=\"line\">    .</span><br><span class=\"line\">    .</span><br><span class=\"line\"><span class=\"number\">2009</span><span class=\"number\">-11</span><span class=\"number\">-10</span> <span class=\"number\">23</span>:<span class=\"number\">00</span>:<span class=\"number\">00.4</span> +<span class=\"number\">0000</span> UTC m=+<span class=\"number\">0.400000001</span></span><br><span class=\"line\">tick.</span><br><span class=\"line\">    .</span><br><span class=\"line\">    .</span><br><span class=\"line\">BOOM!</span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<h2 id=\"6-8-sync-Mutex\"><a href=\"#6-8-sync-Mutex\" class=\"headerlink\" title=\"6.8 sync.Mutex\"></a>6.8 sync.Mutex</h2><p>我们已经看到信道非常适合在各个 Go 程间进行通信。</p>\n<p>但是如果我们并不需要通信呢？比如说，若我们只是想保证每次只有一个 Go 程能够访问一个共享的变量，从而避免冲突？</p>\n<p>这里涉及的概念叫做 <em>互斥（mutual</em>exclusion）* ，我们通常使用 <em>互斥锁（Mutex）</em> 这一数据结构来提供这种机制。</p>\n<p>Go 标准库中提供了 <a href=\"https://go-zh.org/pkg/sync/#Mutex\">sync.Mutex</a>``​ 互斥锁类型及其两个方法：</p>\n<ul>\n<li><code>Lock</code>​</li>\n<li><code>Unlock</code>​</li>\n</ul>\n<p>我们可以通过在代码前调用 <code>Lock</code>​ 方法，在代码后调用 <code>Unlock</code>​ 方法来保证一段代码的互斥执行。参见 <code>Inc</code>​ 方法。</p>\n<p>我们也可以用 <code>defer</code>​ 语句来保证互斥锁一定会被解锁。参见 <code>Value</code>​ 方法。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;sync&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;time&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// SafeCounter 的并发使用是安全的。</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> SafeCounter <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tv   <span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"type\">int</span></span><br><span class=\"line\">\tmux sync.Mutex</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Inc 增加给定 key 的计数器的值。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *SafeCounter)</span></span> Inc(key <span class=\"type\">string</span>) &#123;</span><br><span class=\"line\">\tc.mux.Lock()</span><br><span class=\"line\">\t<span class=\"comment\">// Lock 之后同一时刻只有一个 goroutine 能访问 c.v</span></span><br><span class=\"line\">\tc.v[key]++</span><br><span class=\"line\">\tc.mux.Unlock()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Value 返回给定 key 的计数器的当前值。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *SafeCounter)</span></span> Value(key <span class=\"type\">string</span>) <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\tc.mux.Lock()</span><br><span class=\"line\">\t<span class=\"comment\">// Lock 之后同一时刻只有一个 goroutine 能访问 c.v</span></span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> c.mux.Unlock()</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> c.v[key]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tc := SafeCounter&#123;v: <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">string</span>]<span class=\"type\">int</span>)&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++ &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">go</span> c.Inc(<span class=\"string\">&quot;somekey&quot;</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\ttime.Sleep(time.Second)</span><br><span class=\"line\">\tfmt.Println(c.Value(<span class=\"string\">&quot;somekey&quot;</span>))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n<h1 id=\"练习题目（自己答案系列）\"><a href=\"#练习题目（自己答案系列）\" class=\"headerlink\" title=\"练习题目（自己答案系列）\"></a>练习题目（自己答案系列）</h1><h2 id=\"练习：Stringer\"><a href=\"#练习：Stringer\" class=\"headerlink\" title=\"练习：Stringer\"></a>练习：Stringer</h2><p>通过让 <code>IPAddr</code>​ 类型实现 <code>fmt.Stringer</code>​ 来打印点号分隔的地址。</p>\n<p>例如，<code>IPAddr&#123;1, 2, 3, 4&#125;</code>​ 应当打印为 <code>&quot;1.2.3.4&quot;</code>​。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> IPAddr [<span class=\"number\">4</span>]<span class=\"type\">byte</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// <span class=\"doctag\">TODO:</span> 给 IPAddr 添加一个 &quot;String() string&quot; 方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(ip *IPAddr)</span></span> String() <span class=\"type\">string</span>&#123;</span><br><span class=\"line\">\tipAddr:= fmt.Sprintf(<span class=\"string\">&quot;%d.%d.%d.%d&quot;</span>,ip[<span class=\"number\">0</span>],ip[<span class=\"number\">1</span>],ip[<span class=\"number\">2</span>],ip[<span class=\"number\">3</span>])</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"type\">string</span>(ipAddr)</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\thosts := <span class=\"keyword\">map</span>[<span class=\"type\">string</span>]IPAddr&#123;</span><br><span class=\"line\">\t\t<span class=\"string\">&quot;loopback&quot;</span>:  &#123;<span class=\"number\">127</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>&#125;,</span><br><span class=\"line\">\t\t<span class=\"string\">&quot;googleDNS&quot;</span>: &#123;<span class=\"number\">8</span>, <span class=\"number\">8</span>, <span class=\"number\">8</span>, <span class=\"number\">8</span>&#125;,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> name, ip := <span class=\"keyword\">range</span> hosts &#123;</span><br><span class=\"line\">\t\tfmt.Printf(<span class=\"string\">&quot;%v: %v\\n&quot;</span>, name, ip.String())</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loopback: <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span></span><br><span class=\"line\">googleDNS: <span class=\"number\">8.8</span><span class=\"number\">.8</span><span class=\"number\">.8</span></span><br></pre></td></tr></table></figure>\n\n<p>‍</p>\n"},{"title":"Go basic examples","catalog":true,"date":"2023-05-04T17:16:19.000Z","subtitle":null,"header-img":null,"_content":"\n> 记录 Golang  的基础使用例子\n\n## 输入输出例子\n\n> 输入输出也是处理的关键部分，包括从cmd 、文件、网络 等对象中读入，读入写入触发中断，会在意想不到的地方影响性能，尤其是acm形式下要注意\n\n### 从控制台读入数据\n\n一共有两种方法，一种是使用bufio中的newReader方法，一种是使用bufio中的NewScanner方法\n\n使用 NewReader() 方法，通过返回值err判断是否是io.EOF来判断控制台的输出是否已经结束。\n\n```go\n//处理流数据，NewReader读取到所有的命令行数据，但是，newReader解出来数据需要有split。\nreader := bufio.NewReader(os.stdout)\n\n//实时循环读取输出流中的一行内容\nfor {\n\tline, err := reader.ReadString('\\n') //使用换行符作为切割。\n\tif err != nil || io.EOF == err {\n        fmt.Println(\"err occured! err = \", err)\n\t\tbreak\n\t}\n\tfmt.Printf(line)\n}\n\n```\n\nNewScanner方法使用时，使用Scan()方法判断控制台的输出是否已经结束。使用Bytes()方法读取数据时不指定分隔符，但也可以使用其他读取函数使用分隔符进行分割。\n\n```go\nscanner := bufio.NewScanner(os.Stdin)\n\n//循环读取控制台数据\nfor scanner.Scan() {\n\tdata := scanner.Bytes()\n\tfmt.Println(string(data))\n}\n\n```\n\n针对 写入数据类型来做读入处理\n\n1. 用 fmt 包实现简单读取数字\n\n   * 知道每行输入的信息个数，但不知道有多少行\n\n     ```go\n     // 一直循环读取 cmd 输入的数据\n     for {\n         \t// n 记录的是成功读取每行的数字个数\n     \t\tn, _ := fmt.Scanln(&a, &b)  //也可以用 fmt.Scan\n         \t\n     \t}\n     ```\n\n   * 先输入行数，再输入信息\n\n     ``` go\n     fmt.Scanln(&t)\n     for i:=0 ; i<t ; i++{\n        fmt.Scanln(&a,&b)\n     }\n     ```\n\n     > fmt.Scanln 一次只能读取一行数据，而且得提前创建好对应的结构\n\n   * 读取一整行数据，但不确定行数和一行内的数据量\n\n     ``` go\n     inputs := bufio.NewScanner(os.Stdin)\n     for inputs.Scan() {  //每次读入一行\n         data := strings.Split(inputs.Text(), \" \")  //通过空格将他们分割，并存入一个字符串切片\n         for i := range data {// 遍历一行内的数据\n             val, _ := strconv.Atoi(data[i])   //将字符串转换为int 或者是根据实际要求转化\n         }\n     }\n     ```\n\n   * 读一行字符串\n\n     ```go\n     // 输入描述:\n     // 输入有两行，第一行n\n     // 第二行是n个字符串，字符串之间用空格隔开\n     in := bufio.NewScanner(os.Stdin)\n     for in.Scan(){\n         n := in.Text()\n     }\n     for in.Scan(){\n        str := in.Text()\n        s := strings.Split(str, \" \")\n        fmt.Println(strings.Join(s,\" \"))  //将切片连接成字符串\n     }\n     \n     ```\n\n   * 读多行字符串\n\n     ```go\n     input := bufio.NewScanner(os.Stdin)\n     for input.Scan(){\n        data := strings.Split(input.Text(),\" \")\n        fmt.Println(strings.Join(data, \" \"))\n     }\n     ```\n\n   * 一次性读入字符串数据\n\n     ```go\n     func scanT() {\n         scanner := bufio.NewScanner(os.Stdin)\n         for scanner.Scan() {\n             fmt.Println(scanner.Text())\n         }\n     }\n     ```\n\n依据不同的场景来选择不同的读入函数，一般考虑的时候主要是性能相关的，这部分还没有统一的一个套路，所以为了方便，整理出以下套路：\n\n* 先读入数据\n* 在将数据转化为需要的数据类型\n\n\n\n## 字符串处理例子\n\n### 字符数据据类型\n\n在 Go 中字符相关的类型一共三类：\n\n- ```go\n  byte // 一般用于强调数值是原始数据，代表ASCII码的一个字符（占一个字节）\n  ```\n\n  - byte是`uint8`的别名，在所有方面都等同于`uint8`\n\n  - 按惯例，它用于区分**字节值**和**8位无符号整数值**。\n\n    一般形式：是基础类型\n\n    ```go\n    //使用单引号 表示一个字符\n    var ch byte = 'A'\n    //在 ASCII 码表中，A 的值是 65,也可以这么定义\n    var ch byte = 65\n    //65使用十六进制表示是41，所以也可以这么定义 \\x 总是紧跟着长度为 2 的 16 进制数\n    var ch byte = '\\x41'\n    //65的八进制表示是101，所以使用八进制定义 \\后面紧跟着长度为 3 的八进制数\n    var ch byte = '\\101'\n    ```\n\n- ```\n  rune\n  ```\n\n  - `rune`是`int32`的别名，在所有方面都等同于`int32`， 用于标识Unicode字符，代表一个UTF-8字符\n\n    主要价值在于 非英文字符的计算和标识使用\n\n  - 按惯例，它用于区分**字符值**和**整数值**。\n\n    ```go\n    var ch rune = '\\u0041'\n    var ch1 int64 = '\\U00000041'\n    //格式化说明符%c用于表示字符，%v或%d会输出用于表示该字符的整数，%U输出格式为 U+hhhh 的字符串。\n    fmt.Printf(\"%c,%c,%U\",ch,ch1,ch)\n    ```\n\n- ```\n  string\n  ```\n\n  - string是所有**8位字节字符串**的集合，通常但不一定代表UTF-8编码的文本\n\n  - 字符串可能为空，但是不能为 `nil`\n\n  - 字符串类型的值是不可变的:  **本质是**只读的字符型数组\n\n    所以这行代码是不可以执行的：`str1[3] = 'l'`, 但是读取的操作是可以执行的： `fmt.Println(str1[3])`，这个也不是golang的独创，很多语言当中都有这个限制，因为会将字符串作为const类型存储在专门的区域。\n\n  string 类型详述：[Golang基础教程——字符串篇 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/143352497) [go底层系列-string底层实现原理与使用 - 掘金 (juejin.cn)](https://juejin.cn/post/7111953294469267493)\n\n  string 变量本质上是一个指向字符串首地址的指针加上字符串长度的量，二者均为8字节，所以使用SizoOf的时候所获得的大小一直为16，其源码对应的是：\n\n  ```go\n  type stringStruct struct {\n  \tstr unsafe.Pointer\t\t//字符串首地址，指向底层字节数组的指针\n  \tlen int\t\t\t\t\t//字符串长度\n  }\n  ```\n\n  说到这里关于字符串长度的统计有几处误区需要辨明：\n\n  1. 使用 len 来获取字符串长度时候计算的是 Byte 数量，这对于英文字符来说一个字母就对应一个Byte，len所获取的长度就是字符串的长度，还有 ` bytes.Count() ` 也是类似的\n\n     但对于中文等语言，使用utf-8编码，一个**汉字需要3个字节**编码，这个时候使用len 就会把一个中文字符计算为长度 3\n\n     ```go\n     // 获取长度\n     l := len(str)\n     // 如果是获取string 中的字符串数量\n     l1 := strings.Count(str,\"\") - 1\n     l2 := bytes.Count([]byte(str),nil) - 1 \n     // strings.Count函数和bytes.Count函数,这两个函数的用法是相同，只是一个作用在字符串上，一个作用在字节上\n     ```\n\n  2. 将 string 数组转化为 rune 数组之后来计算长度，常用的方法是：\n\n     ```go\n     // 将字符串转换为 []rune 后调用 len 函数进行统计\n     l := len([]rune(str))\n     // 使用 utf8.RuneCountInString() 统计\n     l := utf8.RuneCountInString(str)\n     ```\n\n  那么回顾总结，目前对于 string 量以下操作是明确的：\n\n\n\n### 1. string  初始化\n\n```go\n// 第一种形式最简洁，但只能用在函数内部，不能用在包变量。\n// 当函数传入 string 类型或者说，使用 cmd 或者 bufio 读取了数值时候在函数内需要进行微操的时候使用\ns := \"\"\n\n// 第二种形式依赖于字符串的默认初始化值，被初始化为\"\"。\nvar s string\n\n// 第三种形式用得很少，除非同时声明多个变量。\nvar s = \"\"\n\n// 第四种形式显式地标明变量的类型，当变量类型与初值类型相同时，类型冗余，但如果两者类型不同，变量类型就必须了。\nvar s string = \"\"\n```\n\n\n\n### 2. string 拼接操作\n\n仅对于 string 是可以用的， rune和byte操作的是一个值或者切片，相互之间需要转化\n\n```go\n// 简单的 + ，一共存在两种用法：\n// s = a + b 则 s 会被赋值为一个新的由ab组成的字符串\ns = a + b\n// s += a + b , += 连接原字符串和下个参数，产生新字符串, 并把它赋值给s(ab)\ns += a + b\n```\n\n这样的方式更新，s 原来的内容都将不再会使用，Go 会在适当的时机对他进行垃圾回收，这方面的机制将在 enhanced 文章当中提及\n\n为改进这方面的问题，一种简单且高效的解决方案是使用strings包的Join函数\n\n```go\n// 使用拼接函数\nstrings.Join([]string{a,b...}, \" \")\n```\n\n一个实例如下\n\n```go\nfunc main() {\n\ta := \"=this=is=\"\n\tb := \"=your=word=\"\n\tfmt.Printf(\"%s\\n\", a+b)\n\tvar d string\n\td += a + b\n\tfmt.Printf(\"%s\\n\", d)\n\tfmt.Printf(\"%s\\n\", strings.Join([]string{a, b}, \"\"))\n}\n// 结果是：\n=this=is==your=word=\n=this=is==your=word=\n=this=is==your=word=\n```\n\n\n\n### 3. string 求长度\n\n``` go\n// 英文字符用 len()  , 中文字符先转换为 []rune，再计算len()\n```\n\n以下为一个实例，计算长度时候是把空格也计算在内了\n\n```go\nfunc main() {\n\ta := \"this is a string\" // 16\n\tb := \"这是一个字符串\"      // 7\n\tc := \"this is a 字符串\"  // 13\n\td := \"this is 11 字符串 @@#\"  // 18\n\tfmt.Printf(\"%d\\n\", len(a))\n\tfmt.Printf(\"%d\\n\", len([]rune(b)))\n\tfmt.Printf(\"%d\\n\", len([]rune(c)))\n\tfmt.Printf(\"%d\\n\", len([]rune(d)))\n}\n// 输出结果为：\n16\n7 \n13\n18\n```\n\n\n\n大部分情况下，上述的操作已经满足了需求，但在面对输入输出的时候，还需要将字符串转化为有效的数据，比如读取 Docker 输出之后，需要将其中的数据转化为可以计算的其他数据，这个时候就涉及到类型转化。\n\n### 4. 以字符串为核心的类型转换\n\n#### 4.1 string To int and Reverse\n\n使用：\n\n* `strconv.ParseInt(a,10,64)`\n* `strconv.Atoi(a)`\n\n``` go\nfunc main() {\n\ta := \"1056\"\n\tb := \"1056\"\n\tvala, _ := strconv.ParseInt(a, 10, 64)\n\tvalb, _ := strconv.Atoi(b)\n\tfmt.Printf(\"ParseInt is : %d\\n\", vala)\n\tfmt.Printf(\"Atoi is :%d\\n\", valb)\n}\n// 结果是：\nParseInt is : 1056\nAtoi is :1056\n```\n\n二者在遍历字符串的时候，如果遇到了非数值型字符就会把整个数值置为零，但使用ParseInt对应16进制时候，a-f（A-F）会被识别为对应的进制数\n\n这里有一点是Atoi， Go 从str 转化为 int 类型读取时候只能默认是10进制的，也就是说上述进制转化的逻辑是：\n\nstring ---> 10进制 int ---> 其他进制 int\n\n反过来将Int类型转化为string时候使用 Format 函数\n\n```go\nstrconv.FormatInt(int64(num), 10)\nstrconv.Itoa(num)\n```\n\n传入的是一个64位的Int型数字，将其转化为10进制数（也可以将10换为8，16）\n\n#### 4.2 string to float\n\n`strconv.ParseFloat(a,64)`  对于浮点数来说就没有进制的区别了\n\n```go\nvalue, err := strconv.ParseFloat(\"1056.56\", 64)\n```\n\n浮点数的转化就有些麻烦，但依旧是使用FormatFloat来实现的\n\n```go\nnum := 23423134.323422\nfmt.Println(strconv.FormatFloat(float64(num), 'f', -1, 64))\nfmt.Println(strconv.FormatFloat(float64(num), 'b', -1, 64))\nfmt.Println(strconv.FormatFloat(float64(num), 'e', -1, 64))\nfmt.Println(strconv.FormatFloat(float64(num), 'E', -1, 64))\nfmt.Println(strconv.FormatFloat(float64(num), 'g', -1, 64))\nfmt.Println(strconv.FormatFloat(float64(num), 'G', -1, 64))\n// 结果是：\n23423134.323422\n6287599743057036p-28\n2.3423134323422e+07 \n2.3423134323422E+07 \n2.3423134323422e+07 \n2.3423134323422E+07 \n\n```\n\nFormatFloat接受4个参数，第一个参数就是待转换的浮点数，第二个参数表示我们希望转换之后得到的格式。一共有'f', 'b', 'e', 'E', 'g', 'G'这几种格式。\n\n* 'f' 表示普通模式：（-ddd.dddd）\n* 'b' 表示指数为二进制：（-ddddp±ddd）\n* 'e' 表示十进制指数，也就是科学记数法的模式：(-d.dddde±dd)\n* 'E' 和'e'一样，都是科学记数法的模式，只不过字母e大写：(-d.ddddE±dd)\n* 'g' 表示指数很大时用'e'模式，否则用‘f'模式\n* 'G' 表示指数很大时用’E'模式，否则用'f'模式\n\n#### 4.3 string to []byte and Revese\n\n使用强制转化就行\n\n``` go\ns := \"abc\"\nb := []byte(s)\ns2 := string(b)\n```\n\n\n#### 4.4 string to []rune and Reverse\n\n强制转化就行 \n\n```go\ns := \"你是谁\"\nr := []rune(s)\ns2 := string(r)\n```\n\n\n\n> 回顾： ASCII 码：\n>\n> 记住十进制表示中 1 --> 48, A --> 65, a --> 97\n>\n> ​\t\t\t\t\t\t\t  9 --> 57, Z --> 90, z --> 122\n\n> 数字部分：\n>\n> | [Binary](https://en.wikipedia.org/wiki/Binary_numeral_system) | [Oct](https://en.wikipedia.org/wiki/Octal) | [Dec](https://en.wikipedia.org/wiki/Decimal) | [Hex](https://en.wikipedia.org/wiki/Hexadecimal) | Glyph                                         |\n> | ------------------------------------------------------------ | ------------------------------------------ | -------------------------------------------- | ------------------------------------------------ | --------------------------------------------- |\n> | 011 0000                                                     | 060                                        | 48                                           | 30                                               | [0](https://en.wikipedia.org/wiki/0_(number)) |\n> | 011 0001                                                     | 061                                        | 49                                           | 31                                               | [1](https://en.wikipedia.org/wiki/1_(number)) |\n> | 011 0010                                                     | 062                                        | 50                                           | 32                                               | [2](https://en.wikipedia.org/wiki/2_(number)) |\n> | 011 0011                                                     | 063                                        | 51                                           | 33                                               | [3](https://en.wikipedia.org/wiki/3_(number)) |\n> | 011 0100                                                     | 064                                        | 52                                           | 34                                               | [4](https://en.wikipedia.org/wiki/4_(number)) |\n> | 011 0101                                                     | 065                                        | 53                                           | 35                                               | [5](https://en.wikipedia.org/wiki/5_(number)) |\n> | 011 0110                                                     | 066                                        | 54                                           | 36                                               | [6](https://en.wikipedia.org/wiki/6_(number)) |\n> | 011 0111                                                     | 067                                        | 55                                           | 37                                               | [7](https://en.wikipedia.org/wiki/7_(number)) |\n> | 011 1000                                                     | 070                                        | 56                                           | 38                                               | [8](https://en.wikipedia.org/wiki/8_(number)) |\n> | 011 1001                                                     | 071                                        | 57                                           | 39                                               | [9](https://en.wikipedia.org/wiki/9_(number)) |\n\n> 大写字母部分\n>\n> | [Binary](https://en.wikipedia.org/wiki/Binary_numeral_system) | [Oct](https://en.wikipedia.org/wiki/Octal) | [Dec](https://en.wikipedia.org/wiki/Decimal) | [Hex](https://en.wikipedia.org/wiki/Hexadecimal) | Glyph                                |\n> | ------------------------------------------------------------ | ------------------------------------------ | -------------------------------------------- | ------------------------------------------------ | ------------------------------------ |\n> | 100 0001                                                     | 101                                        | 65                                           | 41                                               | [A](https://en.wikipedia.org/wiki/A) |\n> | 100 0010                                                     | 102                                        | 66                                           | 42                                               | [B](https://en.wikipedia.org/wiki/B) |\n> | 100 0011                                                     | 103                                        | 67                                           | 43                                               | [C](https://en.wikipedia.org/wiki/C) |\n> | 100 0100                                                     | 104                                        | 68                                           | 44                                               | [D](https://en.wikipedia.org/wiki/D) |\n> | 100 0101                                                     | 105                                        | 69                                           | 45                                               | [E](https://en.wikipedia.org/wiki/E) |\n> | 100 0110                                                     | 106                                        | 70                                           | 46                                               | [F](https://en.wikipedia.org/wiki/F) |\n> | 100 0111                                                     | 107                                        | 71                                           | 47                                               | [G](https://en.wikipedia.org/wiki/G) |\n> | 100 1000                                                     | 110                                        | 72                                           | 48                                               | [H](https://en.wikipedia.org/wiki/H) |\n> | 100 1001                                                     | 111                                        | 73                                           | 49                                               | [I](https://en.wikipedia.org/wiki/I) |\n> | 100 1010                                                     | 112                                        | 74                                           | 4A                                               | [J](https://en.wikipedia.org/wiki/J) |\n> | 100 1011                                                     | 113                                        | 75                                           | 4B                                               | [K](https://en.wikipedia.org/wiki/K) |\n> | 100 1100                                                     | 114                                        | 76                                           | 4C                                               | [L](https://en.wikipedia.org/wiki/L) |\n> | 100 1101                                                     | 115                                        | 77                                           | 4D                                               | [M](https://en.wikipedia.org/wiki/M) |\n> | 100 1110                                                     | 116                                        | 78                                           | 4E                                               | [N](https://en.wikipedia.org/wiki/N) |\n> | 100 1111                                                     | 117                                        | 79                                           | 4F                                               | [O](https://en.wikipedia.org/wiki/O) |\n> | 101 0000                                                     | 120                                        | 80                                           | 50                                               | [P](https://en.wikipedia.org/wiki/P) |\n> | 101 0001                                                     | 121                                        | 81                                           | 51                                               | [Q](https://en.wikipedia.org/wiki/Q) |\n> | 101 0010                                                     | 122                                        | 82                                           | 52                                               | [R](https://en.wikipedia.org/wiki/R) |\n> | 101 0011                                                     | 123                                        | 83                                           | 53                                               | [S](https://en.wikipedia.org/wiki/S) |\n> | 101 0100                                                     | 124                                        | 84                                           | 54                                               | [T](https://en.wikipedia.org/wiki/T) |\n> | 101 0101                                                     | 125                                        | 85                                           | 55                                               | [U](https://en.wikipedia.org/wiki/U) |\n> | 101 0110                                                     | 126                                        | 86                                           | 56                                               | [V](https://en.wikipedia.org/wiki/V) |\n> | 101 0111                                                     | 127                                        | 87                                           | 57                                               | [W](https://en.wikipedia.org/wiki/W) |\n> | 101 1000                                                     | 130                                        | 88                                           | 58                                               | [X](https://en.wikipedia.org/wiki/X) |\n> | 101 1001                                                     | 131                                        | 89                                           | 59                                               | [Y](https://en.wikipedia.org/wiki/Y) |\n> | 101 1010                                                     | 132                                        | 90                                           | 5A                                               | [Z](https://en.wikipedia.org/wiki/Z) |\n\n> 小写字母部分：\n>\n> | [Binary](https://en.wikipedia.org/wiki/Binary_numeral_system) | [Oct](https://en.wikipedia.org/wiki/Octal) | [Dec](https://en.wikipedia.org/wiki/Decimal) | [Hex](https://en.wikipedia.org/wiki/Hexadecimal) | Glyph |                                      |\n> | ------------------------------------------------------------ | ------------------------------------------ | -------------------------------------------- | ------------------------------------------------ | ----- | ------------------------------------ |\n> | 110 0001                                                     | 141                                        | 97                                           | 61                                               |       | [a](https://en.wikipedia.org/wiki/A) |\n> | 110 0010                                                     | 142                                        | 98                                           | 62                                               |       | [b](https://en.wikipedia.org/wiki/B) |\n> | 110 0011                                                     | 143                                        | 99                                           | 63                                               |       | [c](https://en.wikipedia.org/wiki/C) |\n> | 110 0100                                                     | 144                                        | 100                                          | 64                                               |       | [d](https://en.wikipedia.org/wiki/D) |\n> | 110 0101                                                     | 145                                        | 101                                          | 65                                               |       | [e](https://en.wikipedia.org/wiki/E) |\n> | 110 0110                                                     | 146                                        | 102                                          | 66                                               |       | [f](https://en.wikipedia.org/wiki/F) |\n> | 110 0111                                                     | 147                                        | 103                                          | 67                                               |       | [g](https://en.wikipedia.org/wiki/G) |\n> | 110 1000                                                     | 150                                        | 104                                          | 68                                               |       | [h](https://en.wikipedia.org/wiki/H) |\n> | 110 1001                                                     | 151                                        | 105                                          | 69                                               |       | [i](https://en.wikipedia.org/wiki/I) |\n> | 110 1010                                                     | 152                                        | 106                                          | 6A                                               |       | [j](https://en.wikipedia.org/wiki/J) |\n> | 110 1011                                                     | 153                                        | 107                                          | 6B                                               |       | [k](https://en.wikipedia.org/wiki/K) |\n> | 110 1100                                                     | 154                                        | 108                                          | 6C                                               |       | [l](https://en.wikipedia.org/wiki/L) |\n> | 110 1101                                                     | 155                                        | 109                                          | 6D                                               |       | [m](https://en.wikipedia.org/wiki/M) |\n> | 110 1110                                                     | 156                                        | 110                                          | 6E                                               |       | [n](https://en.wikipedia.org/wiki/N) |\n> | 110 1111                                                     | 157                                        | 111                                          | 6F                                               |       | [o](https://en.wikipedia.org/wiki/O) |\n> | 111 0000                                                     | 160                                        | 112                                          | 70                                               |       | [p](https://en.wikipedia.org/wiki/P) |\n> | 111 0001                                                     | 161                                        | 113                                          | 71                                               |       | [q](https://en.wikipedia.org/wiki/Q) |\n> | 111 0010                                                     | 162                                        | 114                                          | 72                                               |       | [r](https://en.wikipedia.org/wiki/R) |\n> | 111 0011                                                     | 163                                        | 115                                          | 73                                               |       | [s](https://en.wikipedia.org/wiki/S) |\n> | 111 0100                                                     | 164                                        | 116                                          | 74                                               |       | [t](https://en.wikipedia.org/wiki/T) |\n> | 111 0101                                                     | 165                                        | 117                                          | 75                                               |       | [u](https://en.wikipedia.org/wiki/U) |\n> | 111 0110                                                     | 166                                        | 118                                          | 76                                               |       | [v](https://en.wikipedia.org/wiki/V) |\n> | 111 0111                                                     | 167                                        | 119                                          | 77                                               |       | [w](https://en.wikipedia.org/wiki/W) |\n> | 111 1000                                                     | 170                                        | 120                                          | 78                                               |       | [x](https://en.wikipedia.org/wiki/X) |\n> | 111 1001                                                     | 171                                        | 121                                          | 79                                               |       | [y](https://en.wikipedia.org/wiki/Y) |\n> | 111 1010                                                     | 172                                        | 122                                          | 7A                                               |       | [z](https://en.wikipedia.org/wiki/Z) |\n\n\n\n## 数字处理例子\n\n### 1.  高低位的处理\n\n> 核心是： \n>\n> * 取模得低位\n> * 除数/右移得高位集合，或者说是去除最低位\n\n以10进制数 x 为例子， x%10得到最低位的数字，如果想要得到高位的数字，可以 for 循环 x/10 然后再使用x%10，这个取位值的方式是通用的，10可以换成其他的进制数。\n\n典型场景：\n\n给你一个整数 `x` ，如果 `x` 是一个回文整数，返回 `true` ；否则，返回 `false` ，回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。\n\n> [9. 回文数 - 力扣（LeetCode）](https://leetcode.cn/problems/palindrome-number/)\n\n* 排除所有的负数和个位为0且不是0的数\n\n* 获取高低位数来进行比较\n\n  \n\n```go\n// 由于数字是整体具有大小的定义，不需要像是字符串那样需要按位比较，两数相同必定代表每一位的数字都相同，所以这个场景就可以换成取出整个数字的前半部分高位数和后半部分低位数，比较而这是否相同\nfront, back := x,0\n// 如果是要比较回文数，那么低位数字需要倒序，执行逻辑是： %10获取该位数字，在下一轮使用*10将这个位数往左移一位（变成高位）\nfor front > back{\n\t//先把当前地位数字向左移，然后在新的低位上加上新的数值\n\tback = back*10 + front%10\n    // 高位数字右移，直接丢弃最低位数字\n\tfront = front/10\n}\n// 要注意的是如果原数 x 有偶数位，那么循环后 back 和 front  的长度相同；如果x 是奇数位，那么循环后 back 会比 front 多一位，此时 back 的最低位是原数 x 的中间数，这个性质在求数位二分特征的时候可能有用\n```\n\n题目的解题代码为：\n\n``` golang\nfunc isPalindrome(x int) bool {\n    if x < 0 || ( x%10 == 0 && x != 0 ){\n        return false\n    }\n    front, back := x,0\n    for front > back{\n        back = back*10 + front%10\n        front = front/10\n    }\n    // 最后比较二者是否相同\n    return back == front || front == back/10\n}\n```\n\n\n\n### 2. 进制转化\n\n已有调用可以借助 strconv 转化为 string 然后进行操作(比如16进制本来也只能string表示)\n\n```go\n// 10进制转化为其他进制   \nvar v int64 = 12              //默认10进制\n   s2 := strconv.FormatInt(v, 2) //10 转2进制\n   fmt.Printf(\"%v\\n\", s2)\n //10 转8进制\n   s8 := strconv.FormatInt(v, 8)\n   fmt.Printf(\"%v\\n\", s8)\n \n   s10 := strconv.FormatInt(v, 10)\n   fmt.Printf(\"%v\\n\", s10)\n //10 转16进制\n   s16 := strconv.FormatInt(v, 16) //10 yo 16\n   fmt.Printf(\"%v\\n\", s16)\n \n// 其他进制转化为10进制\n   var sv = \"11\"\n   fmt.Println(strconv.ParseInt(sv, 16, 32)) // 16 to 10\n   fmt.Println(strconv.ParseInt(sv, 10, 32)) // 10 to 10\n   fmt.Println(strconv.ParseInt(sv, 8, 32))  // 8 to 10\n   fmt.Println(strconv.ParseInt(sv, 2, 32))  // 2 to 10\n\n```\n\n### 3. 数字表示转化\n\n> 本质是字符匹配然后拼接，问题就在于需要有一个可以匹配的字典以及对应的值\n>\n> 难点在于 []byte, int, string类型转化，数值计算与字符拆分拼接的等价关系，以及是否能够把组合类型元素全部枚举完毕\n\n一般常用的思路就是：\n\n* 从数字转字符 --> 数字做减法，字符做拼接\n\n* 从字符转数字 --> 数字做加法，字符做拆分\n\n一般根据各自的数特征来选择从高位还是低位开始，数值类型从低位加减，也就意味着字符从右到左遍历。\n\n比如将罗马数字转化位10进制整数，首先建立罗马数字与10进制数的对应关系map，然后从右到左遍历低位进行加数，期间注意罗马数字的特点：\"小数在大数左边表示减法\"\n\n> [13. 罗马数字转整数 - 力扣（LeetCode）](https://leetcode.cn/problems/roman-to-integer/)\n\n``` go\n// 匹配的关键在于生成一张 字符和数字对应的表\nm := map[byte]int {'I':1,'V':5,'X':10,'L':50,'C':100,'D':500,'M':1000}\n// 开始遍历罗马数字，并从表中找到它对应的数值，判断左右之后加在结果上\n// 注意点1 ： 初始赋值为最右边的罗马数，因为他不可能为零\nres := m[s[len(s)-1]]\nfor i := len(s)-2; i >= 0 ; i--{\n    // 注意点2 ： 大于等于条件，前后位罗马符号相同是加同一个值，不能漏了等号\n     if m[s[i]] >= m[s[i+1]] {\n        res = res + m[s[i]]\n     }\n     if m[s[i]] < m[s[i+1]] {\n        res = res - m[s[i]]\n     }\n}\nreturn res\n```\n\n反过来要将一个10进制整数转化位罗马数字，遍历的就是10进制数，然后找他对应的罗马数字；\n\n> [12. 整数转罗马数字 题解 - 力扣（LeetCode）](https://leetcode.cn/problems/integer-to-roman/solution/)\n\n但前一问运算简便是因为 10 进制加减覆盖了罗马数字的所有计算可排列组合，但是反过来的时候 10 进制数的每一位计算不一定都能找到罗马数字标识，比如 9 在罗马数字当中就存在非顺序的表达方式。由于这个特性就需要像是拼接组件一样去凑（说成贪心也可以）这个数字，也就是从左到右，先找大数再找小数，先从目标数字里面剪出所有的大数，然后找大数对应的罗马数字表示，逐个拼接。\n\n```go\nvar m = []int{1000,900,500,400,100,90,50,40,10,9,5,4,1}\nvar v = []string{\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"}\n// 从左到右来遍历先减去大数，加上罗马数字\nfunc intToRoman(num int) string {\n    var res string\n    for i := 0; i < len(v); i++{\n        for num >= m[i] {\n            num = num-m[i]\n            res = res + v[i]\n        }\n    }\n    return res\n}\n```\n\n这里唯一要注意的应该就是 Golang 当中字符串的拼接处理了，详情看\n\n同样的逻辑可以用到其他的转化情况，比如随意字符串转数字，一定先确认数字映射关系的字典，然后来做字符串的匹配，然后转化为数字的计算。\n\n","source":"_posts/Go/Go-basic-knowledge/Go-basic-usage.md","raw":"---\ntitle: Go basic examples\ncatalog: true\ndate: 2023-05-5 01:16:19\nsubtitle:\nheader-img:\ntags:\ncategories: \n\t- Basic\n---\n\n> 记录 Golang  的基础使用例子\n\n## 输入输出例子\n\n> 输入输出也是处理的关键部分，包括从cmd 、文件、网络 等对象中读入，读入写入触发中断，会在意想不到的地方影响性能，尤其是acm形式下要注意\n\n### 从控制台读入数据\n\n一共有两种方法，一种是使用bufio中的newReader方法，一种是使用bufio中的NewScanner方法\n\n使用 NewReader() 方法，通过返回值err判断是否是io.EOF来判断控制台的输出是否已经结束。\n\n```go\n//处理流数据，NewReader读取到所有的命令行数据，但是，newReader解出来数据需要有split。\nreader := bufio.NewReader(os.stdout)\n\n//实时循环读取输出流中的一行内容\nfor {\n\tline, err := reader.ReadString('\\n') //使用换行符作为切割。\n\tif err != nil || io.EOF == err {\n        fmt.Println(\"err occured! err = \", err)\n\t\tbreak\n\t}\n\tfmt.Printf(line)\n}\n\n```\n\nNewScanner方法使用时，使用Scan()方法判断控制台的输出是否已经结束。使用Bytes()方法读取数据时不指定分隔符，但也可以使用其他读取函数使用分隔符进行分割。\n\n```go\nscanner := bufio.NewScanner(os.Stdin)\n\n//循环读取控制台数据\nfor scanner.Scan() {\n\tdata := scanner.Bytes()\n\tfmt.Println(string(data))\n}\n\n```\n\n针对 写入数据类型来做读入处理\n\n1. 用 fmt 包实现简单读取数字\n\n   * 知道每行输入的信息个数，但不知道有多少行\n\n     ```go\n     // 一直循环读取 cmd 输入的数据\n     for {\n         \t// n 记录的是成功读取每行的数字个数\n     \t\tn, _ := fmt.Scanln(&a, &b)  //也可以用 fmt.Scan\n         \t\n     \t}\n     ```\n\n   * 先输入行数，再输入信息\n\n     ``` go\n     fmt.Scanln(&t)\n     for i:=0 ; i<t ; i++{\n        fmt.Scanln(&a,&b)\n     }\n     ```\n\n     > fmt.Scanln 一次只能读取一行数据，而且得提前创建好对应的结构\n\n   * 读取一整行数据，但不确定行数和一行内的数据量\n\n     ``` go\n     inputs := bufio.NewScanner(os.Stdin)\n     for inputs.Scan() {  //每次读入一行\n         data := strings.Split(inputs.Text(), \" \")  //通过空格将他们分割，并存入一个字符串切片\n         for i := range data {// 遍历一行内的数据\n             val, _ := strconv.Atoi(data[i])   //将字符串转换为int 或者是根据实际要求转化\n         }\n     }\n     ```\n\n   * 读一行字符串\n\n     ```go\n     // 输入描述:\n     // 输入有两行，第一行n\n     // 第二行是n个字符串，字符串之间用空格隔开\n     in := bufio.NewScanner(os.Stdin)\n     for in.Scan(){\n         n := in.Text()\n     }\n     for in.Scan(){\n        str := in.Text()\n        s := strings.Split(str, \" \")\n        fmt.Println(strings.Join(s,\" \"))  //将切片连接成字符串\n     }\n     \n     ```\n\n   * 读多行字符串\n\n     ```go\n     input := bufio.NewScanner(os.Stdin)\n     for input.Scan(){\n        data := strings.Split(input.Text(),\" \")\n        fmt.Println(strings.Join(data, \" \"))\n     }\n     ```\n\n   * 一次性读入字符串数据\n\n     ```go\n     func scanT() {\n         scanner := bufio.NewScanner(os.Stdin)\n         for scanner.Scan() {\n             fmt.Println(scanner.Text())\n         }\n     }\n     ```\n\n依据不同的场景来选择不同的读入函数，一般考虑的时候主要是性能相关的，这部分还没有统一的一个套路，所以为了方便，整理出以下套路：\n\n* 先读入数据\n* 在将数据转化为需要的数据类型\n\n\n\n## 字符串处理例子\n\n### 字符数据据类型\n\n在 Go 中字符相关的类型一共三类：\n\n- ```go\n  byte // 一般用于强调数值是原始数据，代表ASCII码的一个字符（占一个字节）\n  ```\n\n  - byte是`uint8`的别名，在所有方面都等同于`uint8`\n\n  - 按惯例，它用于区分**字节值**和**8位无符号整数值**。\n\n    一般形式：是基础类型\n\n    ```go\n    //使用单引号 表示一个字符\n    var ch byte = 'A'\n    //在 ASCII 码表中，A 的值是 65,也可以这么定义\n    var ch byte = 65\n    //65使用十六进制表示是41，所以也可以这么定义 \\x 总是紧跟着长度为 2 的 16 进制数\n    var ch byte = '\\x41'\n    //65的八进制表示是101，所以使用八进制定义 \\后面紧跟着长度为 3 的八进制数\n    var ch byte = '\\101'\n    ```\n\n- ```\n  rune\n  ```\n\n  - `rune`是`int32`的别名，在所有方面都等同于`int32`， 用于标识Unicode字符，代表一个UTF-8字符\n\n    主要价值在于 非英文字符的计算和标识使用\n\n  - 按惯例，它用于区分**字符值**和**整数值**。\n\n    ```go\n    var ch rune = '\\u0041'\n    var ch1 int64 = '\\U00000041'\n    //格式化说明符%c用于表示字符，%v或%d会输出用于表示该字符的整数，%U输出格式为 U+hhhh 的字符串。\n    fmt.Printf(\"%c,%c,%U\",ch,ch1,ch)\n    ```\n\n- ```\n  string\n  ```\n\n  - string是所有**8位字节字符串**的集合，通常但不一定代表UTF-8编码的文本\n\n  - 字符串可能为空，但是不能为 `nil`\n\n  - 字符串类型的值是不可变的:  **本质是**只读的字符型数组\n\n    所以这行代码是不可以执行的：`str1[3] = 'l'`, 但是读取的操作是可以执行的： `fmt.Println(str1[3])`，这个也不是golang的独创，很多语言当中都有这个限制，因为会将字符串作为const类型存储在专门的区域。\n\n  string 类型详述：[Golang基础教程——字符串篇 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/143352497) [go底层系列-string底层实现原理与使用 - 掘金 (juejin.cn)](https://juejin.cn/post/7111953294469267493)\n\n  string 变量本质上是一个指向字符串首地址的指针加上字符串长度的量，二者均为8字节，所以使用SizoOf的时候所获得的大小一直为16，其源码对应的是：\n\n  ```go\n  type stringStruct struct {\n  \tstr unsafe.Pointer\t\t//字符串首地址，指向底层字节数组的指针\n  \tlen int\t\t\t\t\t//字符串长度\n  }\n  ```\n\n  说到这里关于字符串长度的统计有几处误区需要辨明：\n\n  1. 使用 len 来获取字符串长度时候计算的是 Byte 数量，这对于英文字符来说一个字母就对应一个Byte，len所获取的长度就是字符串的长度，还有 ` bytes.Count() ` 也是类似的\n\n     但对于中文等语言，使用utf-8编码，一个**汉字需要3个字节**编码，这个时候使用len 就会把一个中文字符计算为长度 3\n\n     ```go\n     // 获取长度\n     l := len(str)\n     // 如果是获取string 中的字符串数量\n     l1 := strings.Count(str,\"\") - 1\n     l2 := bytes.Count([]byte(str),nil) - 1 \n     // strings.Count函数和bytes.Count函数,这两个函数的用法是相同，只是一个作用在字符串上，一个作用在字节上\n     ```\n\n  2. 将 string 数组转化为 rune 数组之后来计算长度，常用的方法是：\n\n     ```go\n     // 将字符串转换为 []rune 后调用 len 函数进行统计\n     l := len([]rune(str))\n     // 使用 utf8.RuneCountInString() 统计\n     l := utf8.RuneCountInString(str)\n     ```\n\n  那么回顾总结，目前对于 string 量以下操作是明确的：\n\n\n\n### 1. string  初始化\n\n```go\n// 第一种形式最简洁，但只能用在函数内部，不能用在包变量。\n// 当函数传入 string 类型或者说，使用 cmd 或者 bufio 读取了数值时候在函数内需要进行微操的时候使用\ns := \"\"\n\n// 第二种形式依赖于字符串的默认初始化值，被初始化为\"\"。\nvar s string\n\n// 第三种形式用得很少，除非同时声明多个变量。\nvar s = \"\"\n\n// 第四种形式显式地标明变量的类型，当变量类型与初值类型相同时，类型冗余，但如果两者类型不同，变量类型就必须了。\nvar s string = \"\"\n```\n\n\n\n### 2. string 拼接操作\n\n仅对于 string 是可以用的， rune和byte操作的是一个值或者切片，相互之间需要转化\n\n```go\n// 简单的 + ，一共存在两种用法：\n// s = a + b 则 s 会被赋值为一个新的由ab组成的字符串\ns = a + b\n// s += a + b , += 连接原字符串和下个参数，产生新字符串, 并把它赋值给s(ab)\ns += a + b\n```\n\n这样的方式更新，s 原来的内容都将不再会使用，Go 会在适当的时机对他进行垃圾回收，这方面的机制将在 enhanced 文章当中提及\n\n为改进这方面的问题，一种简单且高效的解决方案是使用strings包的Join函数\n\n```go\n// 使用拼接函数\nstrings.Join([]string{a,b...}, \" \")\n```\n\n一个实例如下\n\n```go\nfunc main() {\n\ta := \"=this=is=\"\n\tb := \"=your=word=\"\n\tfmt.Printf(\"%s\\n\", a+b)\n\tvar d string\n\td += a + b\n\tfmt.Printf(\"%s\\n\", d)\n\tfmt.Printf(\"%s\\n\", strings.Join([]string{a, b}, \"\"))\n}\n// 结果是：\n=this=is==your=word=\n=this=is==your=word=\n=this=is==your=word=\n```\n\n\n\n### 3. string 求长度\n\n``` go\n// 英文字符用 len()  , 中文字符先转换为 []rune，再计算len()\n```\n\n以下为一个实例，计算长度时候是把空格也计算在内了\n\n```go\nfunc main() {\n\ta := \"this is a string\" // 16\n\tb := \"这是一个字符串\"      // 7\n\tc := \"this is a 字符串\"  // 13\n\td := \"this is 11 字符串 @@#\"  // 18\n\tfmt.Printf(\"%d\\n\", len(a))\n\tfmt.Printf(\"%d\\n\", len([]rune(b)))\n\tfmt.Printf(\"%d\\n\", len([]rune(c)))\n\tfmt.Printf(\"%d\\n\", len([]rune(d)))\n}\n// 输出结果为：\n16\n7 \n13\n18\n```\n\n\n\n大部分情况下，上述的操作已经满足了需求，但在面对输入输出的时候，还需要将字符串转化为有效的数据，比如读取 Docker 输出之后，需要将其中的数据转化为可以计算的其他数据，这个时候就涉及到类型转化。\n\n### 4. 以字符串为核心的类型转换\n\n#### 4.1 string To int and Reverse\n\n使用：\n\n* `strconv.ParseInt(a,10,64)`\n* `strconv.Atoi(a)`\n\n``` go\nfunc main() {\n\ta := \"1056\"\n\tb := \"1056\"\n\tvala, _ := strconv.ParseInt(a, 10, 64)\n\tvalb, _ := strconv.Atoi(b)\n\tfmt.Printf(\"ParseInt is : %d\\n\", vala)\n\tfmt.Printf(\"Atoi is :%d\\n\", valb)\n}\n// 结果是：\nParseInt is : 1056\nAtoi is :1056\n```\n\n二者在遍历字符串的时候，如果遇到了非数值型字符就会把整个数值置为零，但使用ParseInt对应16进制时候，a-f（A-F）会被识别为对应的进制数\n\n这里有一点是Atoi， Go 从str 转化为 int 类型读取时候只能默认是10进制的，也就是说上述进制转化的逻辑是：\n\nstring ---> 10进制 int ---> 其他进制 int\n\n反过来将Int类型转化为string时候使用 Format 函数\n\n```go\nstrconv.FormatInt(int64(num), 10)\nstrconv.Itoa(num)\n```\n\n传入的是一个64位的Int型数字，将其转化为10进制数（也可以将10换为8，16）\n\n#### 4.2 string to float\n\n`strconv.ParseFloat(a,64)`  对于浮点数来说就没有进制的区别了\n\n```go\nvalue, err := strconv.ParseFloat(\"1056.56\", 64)\n```\n\n浮点数的转化就有些麻烦，但依旧是使用FormatFloat来实现的\n\n```go\nnum := 23423134.323422\nfmt.Println(strconv.FormatFloat(float64(num), 'f', -1, 64))\nfmt.Println(strconv.FormatFloat(float64(num), 'b', -1, 64))\nfmt.Println(strconv.FormatFloat(float64(num), 'e', -1, 64))\nfmt.Println(strconv.FormatFloat(float64(num), 'E', -1, 64))\nfmt.Println(strconv.FormatFloat(float64(num), 'g', -1, 64))\nfmt.Println(strconv.FormatFloat(float64(num), 'G', -1, 64))\n// 结果是：\n23423134.323422\n6287599743057036p-28\n2.3423134323422e+07 \n2.3423134323422E+07 \n2.3423134323422e+07 \n2.3423134323422E+07 \n\n```\n\nFormatFloat接受4个参数，第一个参数就是待转换的浮点数，第二个参数表示我们希望转换之后得到的格式。一共有'f', 'b', 'e', 'E', 'g', 'G'这几种格式。\n\n* 'f' 表示普通模式：（-ddd.dddd）\n* 'b' 表示指数为二进制：（-ddddp±ddd）\n* 'e' 表示十进制指数，也就是科学记数法的模式：(-d.dddde±dd)\n* 'E' 和'e'一样，都是科学记数法的模式，只不过字母e大写：(-d.ddddE±dd)\n* 'g' 表示指数很大时用'e'模式，否则用‘f'模式\n* 'G' 表示指数很大时用’E'模式，否则用'f'模式\n\n#### 4.3 string to []byte and Revese\n\n使用强制转化就行\n\n``` go\ns := \"abc\"\nb := []byte(s)\ns2 := string(b)\n```\n\n\n#### 4.4 string to []rune and Reverse\n\n强制转化就行 \n\n```go\ns := \"你是谁\"\nr := []rune(s)\ns2 := string(r)\n```\n\n\n\n> 回顾： ASCII 码：\n>\n> 记住十进制表示中 1 --> 48, A --> 65, a --> 97\n>\n> ​\t\t\t\t\t\t\t  9 --> 57, Z --> 90, z --> 122\n\n> 数字部分：\n>\n> | [Binary](https://en.wikipedia.org/wiki/Binary_numeral_system) | [Oct](https://en.wikipedia.org/wiki/Octal) | [Dec](https://en.wikipedia.org/wiki/Decimal) | [Hex](https://en.wikipedia.org/wiki/Hexadecimal) | Glyph                                         |\n> | ------------------------------------------------------------ | ------------------------------------------ | -------------------------------------------- | ------------------------------------------------ | --------------------------------------------- |\n> | 011 0000                                                     | 060                                        | 48                                           | 30                                               | [0](https://en.wikipedia.org/wiki/0_(number)) |\n> | 011 0001                                                     | 061                                        | 49                                           | 31                                               | [1](https://en.wikipedia.org/wiki/1_(number)) |\n> | 011 0010                                                     | 062                                        | 50                                           | 32                                               | [2](https://en.wikipedia.org/wiki/2_(number)) |\n> | 011 0011                                                     | 063                                        | 51                                           | 33                                               | [3](https://en.wikipedia.org/wiki/3_(number)) |\n> | 011 0100                                                     | 064                                        | 52                                           | 34                                               | [4](https://en.wikipedia.org/wiki/4_(number)) |\n> | 011 0101                                                     | 065                                        | 53                                           | 35                                               | [5](https://en.wikipedia.org/wiki/5_(number)) |\n> | 011 0110                                                     | 066                                        | 54                                           | 36                                               | [6](https://en.wikipedia.org/wiki/6_(number)) |\n> | 011 0111                                                     | 067                                        | 55                                           | 37                                               | [7](https://en.wikipedia.org/wiki/7_(number)) |\n> | 011 1000                                                     | 070                                        | 56                                           | 38                                               | [8](https://en.wikipedia.org/wiki/8_(number)) |\n> | 011 1001                                                     | 071                                        | 57                                           | 39                                               | [9](https://en.wikipedia.org/wiki/9_(number)) |\n\n> 大写字母部分\n>\n> | [Binary](https://en.wikipedia.org/wiki/Binary_numeral_system) | [Oct](https://en.wikipedia.org/wiki/Octal) | [Dec](https://en.wikipedia.org/wiki/Decimal) | [Hex](https://en.wikipedia.org/wiki/Hexadecimal) | Glyph                                |\n> | ------------------------------------------------------------ | ------------------------------------------ | -------------------------------------------- | ------------------------------------------------ | ------------------------------------ |\n> | 100 0001                                                     | 101                                        | 65                                           | 41                                               | [A](https://en.wikipedia.org/wiki/A) |\n> | 100 0010                                                     | 102                                        | 66                                           | 42                                               | [B](https://en.wikipedia.org/wiki/B) |\n> | 100 0011                                                     | 103                                        | 67                                           | 43                                               | [C](https://en.wikipedia.org/wiki/C) |\n> | 100 0100                                                     | 104                                        | 68                                           | 44                                               | [D](https://en.wikipedia.org/wiki/D) |\n> | 100 0101                                                     | 105                                        | 69                                           | 45                                               | [E](https://en.wikipedia.org/wiki/E) |\n> | 100 0110                                                     | 106                                        | 70                                           | 46                                               | [F](https://en.wikipedia.org/wiki/F) |\n> | 100 0111                                                     | 107                                        | 71                                           | 47                                               | [G](https://en.wikipedia.org/wiki/G) |\n> | 100 1000                                                     | 110                                        | 72                                           | 48                                               | [H](https://en.wikipedia.org/wiki/H) |\n> | 100 1001                                                     | 111                                        | 73                                           | 49                                               | [I](https://en.wikipedia.org/wiki/I) |\n> | 100 1010                                                     | 112                                        | 74                                           | 4A                                               | [J](https://en.wikipedia.org/wiki/J) |\n> | 100 1011                                                     | 113                                        | 75                                           | 4B                                               | [K](https://en.wikipedia.org/wiki/K) |\n> | 100 1100                                                     | 114                                        | 76                                           | 4C                                               | [L](https://en.wikipedia.org/wiki/L) |\n> | 100 1101                                                     | 115                                        | 77                                           | 4D                                               | [M](https://en.wikipedia.org/wiki/M) |\n> | 100 1110                                                     | 116                                        | 78                                           | 4E                                               | [N](https://en.wikipedia.org/wiki/N) |\n> | 100 1111                                                     | 117                                        | 79                                           | 4F                                               | [O](https://en.wikipedia.org/wiki/O) |\n> | 101 0000                                                     | 120                                        | 80                                           | 50                                               | [P](https://en.wikipedia.org/wiki/P) |\n> | 101 0001                                                     | 121                                        | 81                                           | 51                                               | [Q](https://en.wikipedia.org/wiki/Q) |\n> | 101 0010                                                     | 122                                        | 82                                           | 52                                               | [R](https://en.wikipedia.org/wiki/R) |\n> | 101 0011                                                     | 123                                        | 83                                           | 53                                               | [S](https://en.wikipedia.org/wiki/S) |\n> | 101 0100                                                     | 124                                        | 84                                           | 54                                               | [T](https://en.wikipedia.org/wiki/T) |\n> | 101 0101                                                     | 125                                        | 85                                           | 55                                               | [U](https://en.wikipedia.org/wiki/U) |\n> | 101 0110                                                     | 126                                        | 86                                           | 56                                               | [V](https://en.wikipedia.org/wiki/V) |\n> | 101 0111                                                     | 127                                        | 87                                           | 57                                               | [W](https://en.wikipedia.org/wiki/W) |\n> | 101 1000                                                     | 130                                        | 88                                           | 58                                               | [X](https://en.wikipedia.org/wiki/X) |\n> | 101 1001                                                     | 131                                        | 89                                           | 59                                               | [Y](https://en.wikipedia.org/wiki/Y) |\n> | 101 1010                                                     | 132                                        | 90                                           | 5A                                               | [Z](https://en.wikipedia.org/wiki/Z) |\n\n> 小写字母部分：\n>\n> | [Binary](https://en.wikipedia.org/wiki/Binary_numeral_system) | [Oct](https://en.wikipedia.org/wiki/Octal) | [Dec](https://en.wikipedia.org/wiki/Decimal) | [Hex](https://en.wikipedia.org/wiki/Hexadecimal) | Glyph |                                      |\n> | ------------------------------------------------------------ | ------------------------------------------ | -------------------------------------------- | ------------------------------------------------ | ----- | ------------------------------------ |\n> | 110 0001                                                     | 141                                        | 97                                           | 61                                               |       | [a](https://en.wikipedia.org/wiki/A) |\n> | 110 0010                                                     | 142                                        | 98                                           | 62                                               |       | [b](https://en.wikipedia.org/wiki/B) |\n> | 110 0011                                                     | 143                                        | 99                                           | 63                                               |       | [c](https://en.wikipedia.org/wiki/C) |\n> | 110 0100                                                     | 144                                        | 100                                          | 64                                               |       | [d](https://en.wikipedia.org/wiki/D) |\n> | 110 0101                                                     | 145                                        | 101                                          | 65                                               |       | [e](https://en.wikipedia.org/wiki/E) |\n> | 110 0110                                                     | 146                                        | 102                                          | 66                                               |       | [f](https://en.wikipedia.org/wiki/F) |\n> | 110 0111                                                     | 147                                        | 103                                          | 67                                               |       | [g](https://en.wikipedia.org/wiki/G) |\n> | 110 1000                                                     | 150                                        | 104                                          | 68                                               |       | [h](https://en.wikipedia.org/wiki/H) |\n> | 110 1001                                                     | 151                                        | 105                                          | 69                                               |       | [i](https://en.wikipedia.org/wiki/I) |\n> | 110 1010                                                     | 152                                        | 106                                          | 6A                                               |       | [j](https://en.wikipedia.org/wiki/J) |\n> | 110 1011                                                     | 153                                        | 107                                          | 6B                                               |       | [k](https://en.wikipedia.org/wiki/K) |\n> | 110 1100                                                     | 154                                        | 108                                          | 6C                                               |       | [l](https://en.wikipedia.org/wiki/L) |\n> | 110 1101                                                     | 155                                        | 109                                          | 6D                                               |       | [m](https://en.wikipedia.org/wiki/M) |\n> | 110 1110                                                     | 156                                        | 110                                          | 6E                                               |       | [n](https://en.wikipedia.org/wiki/N) |\n> | 110 1111                                                     | 157                                        | 111                                          | 6F                                               |       | [o](https://en.wikipedia.org/wiki/O) |\n> | 111 0000                                                     | 160                                        | 112                                          | 70                                               |       | [p](https://en.wikipedia.org/wiki/P) |\n> | 111 0001                                                     | 161                                        | 113                                          | 71                                               |       | [q](https://en.wikipedia.org/wiki/Q) |\n> | 111 0010                                                     | 162                                        | 114                                          | 72                                               |       | [r](https://en.wikipedia.org/wiki/R) |\n> | 111 0011                                                     | 163                                        | 115                                          | 73                                               |       | [s](https://en.wikipedia.org/wiki/S) |\n> | 111 0100                                                     | 164                                        | 116                                          | 74                                               |       | [t](https://en.wikipedia.org/wiki/T) |\n> | 111 0101                                                     | 165                                        | 117                                          | 75                                               |       | [u](https://en.wikipedia.org/wiki/U) |\n> | 111 0110                                                     | 166                                        | 118                                          | 76                                               |       | [v](https://en.wikipedia.org/wiki/V) |\n> | 111 0111                                                     | 167                                        | 119                                          | 77                                               |       | [w](https://en.wikipedia.org/wiki/W) |\n> | 111 1000                                                     | 170                                        | 120                                          | 78                                               |       | [x](https://en.wikipedia.org/wiki/X) |\n> | 111 1001                                                     | 171                                        | 121                                          | 79                                               |       | [y](https://en.wikipedia.org/wiki/Y) |\n> | 111 1010                                                     | 172                                        | 122                                          | 7A                                               |       | [z](https://en.wikipedia.org/wiki/Z) |\n\n\n\n## 数字处理例子\n\n### 1.  高低位的处理\n\n> 核心是： \n>\n> * 取模得低位\n> * 除数/右移得高位集合，或者说是去除最低位\n\n以10进制数 x 为例子， x%10得到最低位的数字，如果想要得到高位的数字，可以 for 循环 x/10 然后再使用x%10，这个取位值的方式是通用的，10可以换成其他的进制数。\n\n典型场景：\n\n给你一个整数 `x` ，如果 `x` 是一个回文整数，返回 `true` ；否则，返回 `false` ，回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。\n\n> [9. 回文数 - 力扣（LeetCode）](https://leetcode.cn/problems/palindrome-number/)\n\n* 排除所有的负数和个位为0且不是0的数\n\n* 获取高低位数来进行比较\n\n  \n\n```go\n// 由于数字是整体具有大小的定义，不需要像是字符串那样需要按位比较，两数相同必定代表每一位的数字都相同，所以这个场景就可以换成取出整个数字的前半部分高位数和后半部分低位数，比较而这是否相同\nfront, back := x,0\n// 如果是要比较回文数，那么低位数字需要倒序，执行逻辑是： %10获取该位数字，在下一轮使用*10将这个位数往左移一位（变成高位）\nfor front > back{\n\t//先把当前地位数字向左移，然后在新的低位上加上新的数值\n\tback = back*10 + front%10\n    // 高位数字右移，直接丢弃最低位数字\n\tfront = front/10\n}\n// 要注意的是如果原数 x 有偶数位，那么循环后 back 和 front  的长度相同；如果x 是奇数位，那么循环后 back 会比 front 多一位，此时 back 的最低位是原数 x 的中间数，这个性质在求数位二分特征的时候可能有用\n```\n\n题目的解题代码为：\n\n``` golang\nfunc isPalindrome(x int) bool {\n    if x < 0 || ( x%10 == 0 && x != 0 ){\n        return false\n    }\n    front, back := x,0\n    for front > back{\n        back = back*10 + front%10\n        front = front/10\n    }\n    // 最后比较二者是否相同\n    return back == front || front == back/10\n}\n```\n\n\n\n### 2. 进制转化\n\n已有调用可以借助 strconv 转化为 string 然后进行操作(比如16进制本来也只能string表示)\n\n```go\n// 10进制转化为其他进制   \nvar v int64 = 12              //默认10进制\n   s2 := strconv.FormatInt(v, 2) //10 转2进制\n   fmt.Printf(\"%v\\n\", s2)\n //10 转8进制\n   s8 := strconv.FormatInt(v, 8)\n   fmt.Printf(\"%v\\n\", s8)\n \n   s10 := strconv.FormatInt(v, 10)\n   fmt.Printf(\"%v\\n\", s10)\n //10 转16进制\n   s16 := strconv.FormatInt(v, 16) //10 yo 16\n   fmt.Printf(\"%v\\n\", s16)\n \n// 其他进制转化为10进制\n   var sv = \"11\"\n   fmt.Println(strconv.ParseInt(sv, 16, 32)) // 16 to 10\n   fmt.Println(strconv.ParseInt(sv, 10, 32)) // 10 to 10\n   fmt.Println(strconv.ParseInt(sv, 8, 32))  // 8 to 10\n   fmt.Println(strconv.ParseInt(sv, 2, 32))  // 2 to 10\n\n```\n\n### 3. 数字表示转化\n\n> 本质是字符匹配然后拼接，问题就在于需要有一个可以匹配的字典以及对应的值\n>\n> 难点在于 []byte, int, string类型转化，数值计算与字符拆分拼接的等价关系，以及是否能够把组合类型元素全部枚举完毕\n\n一般常用的思路就是：\n\n* 从数字转字符 --> 数字做减法，字符做拼接\n\n* 从字符转数字 --> 数字做加法，字符做拆分\n\n一般根据各自的数特征来选择从高位还是低位开始，数值类型从低位加减，也就意味着字符从右到左遍历。\n\n比如将罗马数字转化位10进制整数，首先建立罗马数字与10进制数的对应关系map，然后从右到左遍历低位进行加数，期间注意罗马数字的特点：\"小数在大数左边表示减法\"\n\n> [13. 罗马数字转整数 - 力扣（LeetCode）](https://leetcode.cn/problems/roman-to-integer/)\n\n``` go\n// 匹配的关键在于生成一张 字符和数字对应的表\nm := map[byte]int {'I':1,'V':5,'X':10,'L':50,'C':100,'D':500,'M':1000}\n// 开始遍历罗马数字，并从表中找到它对应的数值，判断左右之后加在结果上\n// 注意点1 ： 初始赋值为最右边的罗马数，因为他不可能为零\nres := m[s[len(s)-1]]\nfor i := len(s)-2; i >= 0 ; i--{\n    // 注意点2 ： 大于等于条件，前后位罗马符号相同是加同一个值，不能漏了等号\n     if m[s[i]] >= m[s[i+1]] {\n        res = res + m[s[i]]\n     }\n     if m[s[i]] < m[s[i+1]] {\n        res = res - m[s[i]]\n     }\n}\nreturn res\n```\n\n反过来要将一个10进制整数转化位罗马数字，遍历的就是10进制数，然后找他对应的罗马数字；\n\n> [12. 整数转罗马数字 题解 - 力扣（LeetCode）](https://leetcode.cn/problems/integer-to-roman/solution/)\n\n但前一问运算简便是因为 10 进制加减覆盖了罗马数字的所有计算可排列组合，但是反过来的时候 10 进制数的每一位计算不一定都能找到罗马数字标识，比如 9 在罗马数字当中就存在非顺序的表达方式。由于这个特性就需要像是拼接组件一样去凑（说成贪心也可以）这个数字，也就是从左到右，先找大数再找小数，先从目标数字里面剪出所有的大数，然后找大数对应的罗马数字表示，逐个拼接。\n\n```go\nvar m = []int{1000,900,500,400,100,90,50,40,10,9,5,4,1}\nvar v = []string{\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"}\n// 从左到右来遍历先减去大数，加上罗马数字\nfunc intToRoman(num int) string {\n    var res string\n    for i := 0; i < len(v); i++{\n        for num >= m[i] {\n            num = num-m[i]\n            res = res + v[i]\n        }\n    }\n    return res\n}\n```\n\n这里唯一要注意的应该就是 Golang 当中字符串的拼接处理了，详情看\n\n同样的逻辑可以用到其他的转化情况，比如随意字符串转数字，一定先确认数字映射关系的字典，然后来做字符串的匹配，然后转化为数字的计算。\n\n","slug":"Go/Go-basic-knowledge/Go-basic-usage","published":1,"updated":"2023-05-05T15:09:37.855Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli796r0v001dbyjx03z9h8dl","content":"<blockquote>\n<p>记录 Golang  的基础使用例子</p>\n</blockquote>\n<h2 id=\"输入输出例子\"><a href=\"#输入输出例子\" class=\"headerlink\" title=\"输入输出例子\"></a>输入输出例子</h2><blockquote>\n<p>输入输出也是处理的关键部分，包括从cmd 、文件、网络 等对象中读入，读入写入触发中断，会在意想不到的地方影响性能，尤其是acm形式下要注意</p>\n</blockquote>\n<h3 id=\"从控制台读入数据\"><a href=\"#从控制台读入数据\" class=\"headerlink\" title=\"从控制台读入数据\"></a>从控制台读入数据</h3><p>一共有两种方法，一种是使用bufio中的newReader方法，一种是使用bufio中的NewScanner方法</p>\n<p>使用 NewReader() 方法，通过返回值err判断是否是io.EOF来判断控制台的输出是否已经结束。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//处理流数据，NewReader读取到所有的命令行数据，但是，newReader解出来数据需要有split。</span></span><br><span class=\"line\">reader := bufio.NewReader(os.stdout)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//实时循环读取输出流中的一行内容</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\tline, err := reader.ReadString(<span class=\"string\">&#x27;\\n&#x27;</span>) <span class=\"comment\">//使用换行符作为切割。</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> || io.EOF == err &#123;</span><br><span class=\"line\">        fmt.Println(<span class=\"string\">&quot;err occured! err = &quot;</span>, err)</span><br><span class=\"line\">\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfmt.Printf(line)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>NewScanner方法使用时，使用Scan()方法判断控制台的输出是否已经结束。使用Bytes()方法读取数据时不指定分隔符，但也可以使用其他读取函数使用分隔符进行分割。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scanner := bufio.NewScanner(os.Stdin)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//循环读取控制台数据</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> scanner.Scan() &#123;</span><br><span class=\"line\">\tdata := scanner.Bytes()</span><br><span class=\"line\">\tfmt.Println(<span class=\"type\">string</span>(data))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>针对 写入数据类型来做读入处理</p>\n<ol>\n<li><p>用 fmt 包实现简单读取数字</p>\n<ul>\n<li><p>知道每行输入的信息个数，但不知道有多少行</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 一直循环读取 cmd 输入的数据</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// n 记录的是成功读取每行的数字个数</span></span><br><span class=\"line\">\t\tn, _ := fmt.Scanln(&amp;a, &amp;b)  <span class=\"comment\">//也可以用 fmt.Scan</span></span><br><span class=\"line\">    \t</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>先输入行数，再输入信息</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fmt.Scanln(&amp;t)</span><br><span class=\"line\"><span class=\"keyword\">for</span> i:=<span class=\"number\">0</span> ; i&lt;t ; i++&#123;</span><br><span class=\"line\">   fmt.Scanln(&amp;a,&amp;b)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>fmt.Scanln 一次只能读取一行数据，而且得提前创建好对应的结构</p>\n</blockquote>\n</li>\n<li><p>读取一整行数据，但不确定行数和一行内的数据量</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">inputs := bufio.NewScanner(os.Stdin)</span><br><span class=\"line\"><span class=\"keyword\">for</span> inputs.Scan() &#123;  <span class=\"comment\">//每次读入一行</span></span><br><span class=\"line\">    data := strings.Split(inputs.Text(), <span class=\"string\">&quot; &quot;</span>)  <span class=\"comment\">//通过空格将他们分割，并存入一个字符串切片</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> data &#123;<span class=\"comment\">// 遍历一行内的数据</span></span><br><span class=\"line\">        val, _ := strconv.Atoi(data[i])   <span class=\"comment\">//将字符串转换为int 或者是根据实际要求转化</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>读一行字符串</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 输入描述:</span></span><br><span class=\"line\"><span class=\"comment\">// 输入有两行，第一行n</span></span><br><span class=\"line\"><span class=\"comment\">// 第二行是n个字符串，字符串之间用空格隔开</span></span><br><span class=\"line\">in := bufio.NewScanner(os.Stdin)</span><br><span class=\"line\"><span class=\"keyword\">for</span> in.Scan()&#123;</span><br><span class=\"line\">    n := in.Text()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> in.Scan()&#123;</span><br><span class=\"line\">   str := in.Text()</span><br><span class=\"line\">   s := strings.Split(str, <span class=\"string\">&quot; &quot;</span>)</span><br><span class=\"line\">   fmt.Println(strings.Join(s,<span class=\"string\">&quot; &quot;</span>))  <span class=\"comment\">//将切片连接成字符串</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n<li><p>读多行字符串</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">input := bufio.NewScanner(os.Stdin)</span><br><span class=\"line\"><span class=\"keyword\">for</span> input.Scan()&#123;</span><br><span class=\"line\">   data := strings.Split(input.Text(),<span class=\"string\">&quot; &quot;</span>)</span><br><span class=\"line\">   fmt.Println(strings.Join(data, <span class=\"string\">&quot; &quot;</span>))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>一次性读入字符串数据</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">scanT</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    scanner := bufio.NewScanner(os.Stdin)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> scanner.Scan() &#123;</span><br><span class=\"line\">        fmt.Println(scanner.Text())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n<p>依据不同的场景来选择不同的读入函数，一般考虑的时候主要是性能相关的，这部分还没有统一的一个套路，所以为了方便，整理出以下套路：</p>\n<ul>\n<li>先读入数据</li>\n<li>在将数据转化为需要的数据类型</li>\n</ul>\n<h2 id=\"字符串处理例子\"><a href=\"#字符串处理例子\" class=\"headerlink\" title=\"字符串处理例子\"></a>字符串处理例子</h2><h3 id=\"字符数据据类型\"><a href=\"#字符数据据类型\" class=\"headerlink\" title=\"字符数据据类型\"></a>字符数据据类型</h3><p>在 Go 中字符相关的类型一共三类：</p>\n<ul>\n<li><p>```go<br>byte // 一般用于强调数值是原始数据，代表ASCII码的一个字符（占一个字节）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">- byte是`uint8`的别名，在所有方面都等同于`uint8`</span><br><span class=\"line\"></span><br><span class=\"line\">- 按惯例，它用于区分**字节值**和**8位无符号整数值**。</span><br><span class=\"line\"></span><br><span class=\"line\">  一般形式：是基础类型</span><br><span class=\"line\"></span><br><span class=\"line\">  ```go</span><br><span class=\"line\">  //使用单引号 表示一个字符</span><br><span class=\"line\">  var ch byte = &#x27;A&#x27;</span><br><span class=\"line\">  //在 ASCII 码表中，A 的值是 65,也可以这么定义</span><br><span class=\"line\">  var ch byte = 65</span><br><span class=\"line\">  //65使用十六进制表示是41，所以也可以这么定义 \\x 总是紧跟着长度为 2 的 16 进制数</span><br><span class=\"line\">  var ch byte = &#x27;\\x41&#x27;</span><br><span class=\"line\">  //65的八进制表示是101，所以使用八进制定义 \\后面紧跟着长度为 3 的八进制数</span><br><span class=\"line\">  var ch byte = &#x27;\\101&#x27;</span><br></pre></td></tr></table></figure></li>\n<li><p>```<br>rune</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">- `rune`是`int32`的别名，在所有方面都等同于`int32`， 用于标识Unicode字符，代表一个UTF-8字符</span><br><span class=\"line\"></span><br><span class=\"line\">  主要价值在于 非英文字符的计算和标识使用</span><br><span class=\"line\"></span><br><span class=\"line\">- 按惯例，它用于区分**字符值**和**整数值**。</span><br><span class=\"line\"></span><br><span class=\"line\">  ```go</span><br><span class=\"line\">  var ch rune = &#x27;\\u0041&#x27;</span><br><span class=\"line\">  var ch1 int64 = &#x27;\\U00000041&#x27;</span><br><span class=\"line\">  //格式化说明符%c用于表示字符，%v或%d会输出用于表示该字符的整数，%U输出格式为 U+hhhh 的字符串。</span><br><span class=\"line\">  fmt.Printf(&quot;%c,%c,%U&quot;,ch,ch1,ch)</span><br></pre></td></tr></table></figure></li>\n<li><p>```<br>string</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">- string是所有**8位字节字符串**的集合，通常但不一定代表UTF-8编码的文本</span><br><span class=\"line\"></span><br><span class=\"line\">- 字符串可能为空，但是不能为 `nil`</span><br><span class=\"line\"></span><br><span class=\"line\">- 字符串类型的值是不可变的:  **本质是**只读的字符型数组</span><br><span class=\"line\"></span><br><span class=\"line\">  所以这行代码是不可以执行的：`str1[3] = &#x27;l&#x27;`, 但是读取的操作是可以执行的： `fmt.Println(str1[3])`，这个也不是golang的独创，很多语言当中都有这个限制，因为会将字符串作为const类型存储在专门的区域。</span><br><span class=\"line\"></span><br><span class=\"line\">string 类型详述：[Golang基础教程——字符串篇 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/143352497) [go底层系列-string底层实现原理与使用 - 掘金 (juejin.cn)](https://juejin.cn/post/7111953294469267493)</span><br><span class=\"line\"></span><br><span class=\"line\">string 变量本质上是一个指向字符串首地址的指针加上字符串长度的量，二者均为8字节，所以使用SizoOf的时候所获得的大小一直为16，其源码对应的是：</span><br><span class=\"line\"></span><br><span class=\"line\">```go</span><br><span class=\"line\">type stringStruct struct &#123;</span><br><span class=\"line\">\tstr unsafe.Pointer\t\t//字符串首地址，指向底层字节数组的指针</span><br><span class=\"line\">\tlen int\t\t\t\t\t//字符串长度</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>说到这里关于字符串长度的统计有几处误区需要辨明：</p>\n<ol>\n<li><p>使用 len 来获取字符串长度时候计算的是 Byte 数量，这对于英文字符来说一个字母就对应一个Byte，len所获取的长度就是字符串的长度，还有 <code>bytes.Count()</code> 也是类似的</p>\n<p>但对于中文等语言，使用utf-8编码，一个<strong>汉字需要3个字节</strong>编码，这个时候使用len 就会把一个中文字符计算为长度 3</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取长度</span></span><br><span class=\"line\">l := <span class=\"built_in\">len</span>(str)</span><br><span class=\"line\"><span class=\"comment\">// 如果是获取string 中的字符串数量</span></span><br><span class=\"line\">l1 := strings.Count(str,<span class=\"string\">&quot;&quot;</span>) - <span class=\"number\">1</span></span><br><span class=\"line\">l2 := bytes.Count([]<span class=\"type\">byte</span>(str),<span class=\"literal\">nil</span>) - <span class=\"number\">1</span> </span><br><span class=\"line\"><span class=\"comment\">// strings.Count函数和bytes.Count函数,这两个函数的用法是相同，只是一个作用在字符串上，一个作用在字节上</span></span><br></pre></td></tr></table></figure></li>\n<li><p>将 string 数组转化为 rune 数组之后来计算长度，常用的方法是：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 将字符串转换为 []rune 后调用 len 函数进行统计</span></span><br><span class=\"line\">l := <span class=\"built_in\">len</span>([]<span class=\"type\">rune</span>(str))</span><br><span class=\"line\"><span class=\"comment\">// 使用 utf8.RuneCountInString() 统计</span></span><br><span class=\"line\">l := utf8.RuneCountInString(str)</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>那么回顾总结，目前对于 string 量以下操作是明确的：</p>\n</li>\n</ul>\n<h3 id=\"1-string-初始化\"><a href=\"#1-string-初始化\" class=\"headerlink\" title=\"1. string  初始化\"></a>1. string  初始化</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 第一种形式最简洁，但只能用在函数内部，不能用在包变量。</span></span><br><span class=\"line\"><span class=\"comment\">// 当函数传入 string 类型或者说，使用 cmd 或者 bufio 读取了数值时候在函数内需要进行微操的时候使用</span></span><br><span class=\"line\">s := <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第二种形式依赖于字符串的默认初始化值，被初始化为&quot;&quot;。</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> s <span class=\"type\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第三种形式用得很少，除非同时声明多个变量。</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第四种形式显式地标明变量的类型，当变量类型与初值类型相同时，类型冗余，但如果两者类型不同，变量类型就必须了。</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> s <span class=\"type\">string</span> = <span class=\"string\">&quot;&quot;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"2-string-拼接操作\"><a href=\"#2-string-拼接操作\" class=\"headerlink\" title=\"2. string 拼接操作\"></a>2. string 拼接操作</h3><p>仅对于 string 是可以用的， rune和byte操作的是一个值或者切片，相互之间需要转化</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 简单的 + ，一共存在两种用法：</span></span><br><span class=\"line\"><span class=\"comment\">// s = a + b 则 s 会被赋值为一个新的由ab组成的字符串</span></span><br><span class=\"line\">s = a + b</span><br><span class=\"line\"><span class=\"comment\">// s += a + b , += 连接原字符串和下个参数，产生新字符串, 并把它赋值给s(ab)</span></span><br><span class=\"line\">s += a + b</span><br></pre></td></tr></table></figure>\n\n<p>这样的方式更新，s 原来的内容都将不再会使用，Go 会在适当的时机对他进行垃圾回收，这方面的机制将在 enhanced 文章当中提及</p>\n<p>为改进这方面的问题，一种简单且高效的解决方案是使用strings包的Join函数</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用拼接函数</span></span><br><span class=\"line\">strings.Join([]<span class=\"type\">string</span>&#123;a,b...&#125;, <span class=\"string\">&quot; &quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>一个实例如下</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\ta := <span class=\"string\">&quot;=this=is=&quot;</span></span><br><span class=\"line\">\tb := <span class=\"string\">&quot;=your=word=&quot;</span></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;%s\\n&quot;</span>, a+b)</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> d <span class=\"type\">string</span></span><br><span class=\"line\">\td += a + b</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;%s\\n&quot;</span>, d)</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;%s\\n&quot;</span>, strings.Join([]<span class=\"type\">string</span>&#123;a, b&#125;, <span class=\"string\">&quot;&quot;</span>))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 结果是：</span></span><br><span class=\"line\">=this=is==your=word=</span><br><span class=\"line\">=this=is==your=word=</span><br><span class=\"line\">=this=is==your=word=</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"3-string-求长度\"><a href=\"#3-string-求长度\" class=\"headerlink\" title=\"3. string 求长度\"></a>3. string 求长度</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 英文字符用 len()  , 中文字符先转换为 []rune，再计算len()</span></span><br></pre></td></tr></table></figure>\n\n<p>以下为一个实例，计算长度时候是把空格也计算在内了</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\ta := <span class=\"string\">&quot;this is a string&quot;</span> <span class=\"comment\">// 16</span></span><br><span class=\"line\">\tb := <span class=\"string\">&quot;这是一个字符串&quot;</span>      <span class=\"comment\">// 7</span></span><br><span class=\"line\">\tc := <span class=\"string\">&quot;this is a 字符串&quot;</span>  <span class=\"comment\">// 13</span></span><br><span class=\"line\">\td := <span class=\"string\">&quot;this is 11 字符串 @@#&quot;</span>  <span class=\"comment\">// 18</span></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;%d\\n&quot;</span>, <span class=\"built_in\">len</span>(a))</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;%d\\n&quot;</span>, <span class=\"built_in\">len</span>([]<span class=\"type\">rune</span>(b)))</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;%d\\n&quot;</span>, <span class=\"built_in\">len</span>([]<span class=\"type\">rune</span>(c)))</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;%d\\n&quot;</span>, <span class=\"built_in\">len</span>([]<span class=\"type\">rune</span>(d)))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 输出结果为：</span></span><br><span class=\"line\"><span class=\"number\">16</span></span><br><span class=\"line\"><span class=\"number\">7</span> </span><br><span class=\"line\"><span class=\"number\">13</span></span><br><span class=\"line\"><span class=\"number\">18</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>大部分情况下，上述的操作已经满足了需求，但在面对输入输出的时候，还需要将字符串转化为有效的数据，比如读取 Docker 输出之后，需要将其中的数据转化为可以计算的其他数据，这个时候就涉及到类型转化。</p>\n<h3 id=\"4-以字符串为核心的类型转换\"><a href=\"#4-以字符串为核心的类型转换\" class=\"headerlink\" title=\"4. 以字符串为核心的类型转换\"></a>4. 以字符串为核心的类型转换</h3><h4 id=\"4-1-string-To-int-and-Reverse\"><a href=\"#4-1-string-To-int-and-Reverse\" class=\"headerlink\" title=\"4.1 string To int and Reverse\"></a>4.1 string To int and Reverse</h4><p>使用：</p>\n<ul>\n<li><code>strconv.ParseInt(a,10,64)</code></li>\n<li><code>strconv.Atoi(a)</code></li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\ta := <span class=\"string\">&quot;1056&quot;</span></span><br><span class=\"line\">\tb := <span class=\"string\">&quot;1056&quot;</span></span><br><span class=\"line\">\tvala, _ := strconv.ParseInt(a, <span class=\"number\">10</span>, <span class=\"number\">64</span>)</span><br><span class=\"line\">\tvalb, _ := strconv.Atoi(b)</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;ParseInt is : %d\\n&quot;</span>, vala)</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;Atoi is :%d\\n&quot;</span>, valb)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 结果是：</span></span><br><span class=\"line\">ParseInt is : <span class=\"number\">1056</span></span><br><span class=\"line\">Atoi is :<span class=\"number\">1056</span></span><br></pre></td></tr></table></figure>\n\n<p>二者在遍历字符串的时候，如果遇到了非数值型字符就会把整个数值置为零，但使用ParseInt对应16进制时候，a-f（A-F）会被识别为对应的进制数</p>\n<p>这里有一点是Atoi， Go 从str 转化为 int 类型读取时候只能默认是10进制的，也就是说上述进制转化的逻辑是：</p>\n<p>string —&gt; 10进制 int —&gt; 其他进制 int</p>\n<p>反过来将Int类型转化为string时候使用 Format 函数</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">strconv.FormatInt(<span class=\"type\">int64</span>(num), <span class=\"number\">10</span>)</span><br><span class=\"line\">strconv.Itoa(num)</span><br></pre></td></tr></table></figure>\n\n<p>传入的是一个64位的Int型数字，将其转化为10进制数（也可以将10换为8，16）</p>\n<h4 id=\"4-2-string-to-float\"><a href=\"#4-2-string-to-float\" class=\"headerlink\" title=\"4.2 string to float\"></a>4.2 string to float</h4><p><code>strconv.ParseFloat(a,64)</code>  对于浮点数来说就没有进制的区别了</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">value, err := strconv.ParseFloat(<span class=\"string\">&quot;1056.56&quot;</span>, <span class=\"number\">64</span>)</span><br></pre></td></tr></table></figure>\n\n<p>浮点数的转化就有些麻烦，但依旧是使用FormatFloat来实现的</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">num := <span class=\"number\">23423134.323422</span></span><br><span class=\"line\">fmt.Println(strconv.FormatFloat(<span class=\"type\">float64</span>(num), <span class=\"string\">&#x27;f&#x27;</span>, <span class=\"number\">-1</span>, <span class=\"number\">64</span>))</span><br><span class=\"line\">fmt.Println(strconv.FormatFloat(<span class=\"type\">float64</span>(num), <span class=\"string\">&#x27;b&#x27;</span>, <span class=\"number\">-1</span>, <span class=\"number\">64</span>))</span><br><span class=\"line\">fmt.Println(strconv.FormatFloat(<span class=\"type\">float64</span>(num), <span class=\"string\">&#x27;e&#x27;</span>, <span class=\"number\">-1</span>, <span class=\"number\">64</span>))</span><br><span class=\"line\">fmt.Println(strconv.FormatFloat(<span class=\"type\">float64</span>(num), <span class=\"string\">&#x27;E&#x27;</span>, <span class=\"number\">-1</span>, <span class=\"number\">64</span>))</span><br><span class=\"line\">fmt.Println(strconv.FormatFloat(<span class=\"type\">float64</span>(num), <span class=\"string\">&#x27;g&#x27;</span>, <span class=\"number\">-1</span>, <span class=\"number\">64</span>))</span><br><span class=\"line\">fmt.Println(strconv.FormatFloat(<span class=\"type\">float64</span>(num), <span class=\"string\">&#x27;G&#x27;</span>, <span class=\"number\">-1</span>, <span class=\"number\">64</span>))</span><br><span class=\"line\"><span class=\"comment\">// 结果是：</span></span><br><span class=\"line\"><span class=\"number\">23423134.323422</span></span><br><span class=\"line\"><span class=\"number\">6287599743057036</span>p<span class=\"number\">-28</span></span><br><span class=\"line\"><span class=\"number\">2.3423134323422e+07</span> </span><br><span class=\"line\"><span class=\"number\">2.3423134323422E+07</span> </span><br><span class=\"line\"><span class=\"number\">2.3423134323422e+07</span> </span><br><span class=\"line\"><span class=\"number\">2.3423134323422E+07</span> </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>FormatFloat接受4个参数，第一个参数就是待转换的浮点数，第二个参数表示我们希望转换之后得到的格式。一共有’f’, ‘b’, ‘e’, ‘E’, ‘g’, ‘G’这几种格式。</p>\n<ul>\n<li>‘f’ 表示普通模式：（-ddd.dddd）</li>\n<li>‘b’ 表示指数为二进制：（-ddddp±ddd）</li>\n<li>‘e’ 表示十进制指数，也就是科学记数法的模式：(-d.dddde±dd)</li>\n<li>‘E’ 和’e’一样，都是科学记数法的模式，只不过字母e大写：(-d.ddddE±dd)</li>\n<li>‘g’ 表示指数很大时用’e’模式，否则用‘f’模式</li>\n<li>‘G’ 表示指数很大时用’E’模式，否则用’f’模式</li>\n</ul>\n<h4 id=\"4-3-string-to-byte-and-Revese\"><a href=\"#4-3-string-to-byte-and-Revese\" class=\"headerlink\" title=\"4.3 string to []byte and Revese\"></a>4.3 string to []byte and Revese</h4><p>使用强制转化就行</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s := <span class=\"string\">&quot;abc&quot;</span></span><br><span class=\"line\">b := []<span class=\"type\">byte</span>(s)</span><br><span class=\"line\">s2 := <span class=\"type\">string</span>(b)</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"4-4-string-to-rune-and-Reverse\"><a href=\"#4-4-string-to-rune-and-Reverse\" class=\"headerlink\" title=\"4.4 string to []rune and Reverse\"></a>4.4 string to []rune and Reverse</h4><p>强制转化就行 </p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s := <span class=\"string\">&quot;你是谁&quot;</span></span><br><span class=\"line\">r := []<span class=\"type\">rune</span>(s)</span><br><span class=\"line\">s2 := <span class=\"type\">string</span>(r)</span><br></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<p>回顾： ASCII 码：</p>\n<p>记住十进制表示中 1 –&gt; 48, A –&gt; 65, a –&gt; 97</p>\n<p>​                              9 –&gt; 57, Z –&gt; 90, z –&gt; 122</p>\n</blockquote>\n<blockquote>\n<p>数字部分：</p>\n<table>\n<thead>\n<tr>\n<th><a href=\"https://en.wikipedia.org/wiki/Binary_numeral_system\">Binary</a></th>\n<th><a href=\"https://en.wikipedia.org/wiki/Octal\">Oct</a></th>\n<th><a href=\"https://en.wikipedia.org/wiki/Decimal\">Dec</a></th>\n<th><a href=\"https://en.wikipedia.org/wiki/Hexadecimal\">Hex</a></th>\n<th>Glyph</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>011 0000</td>\n<td>060</td>\n<td>48</td>\n<td>30</td>\n<td><a href=\"https://en.wikipedia.org/wiki/0_(number)\">0</a></td>\n</tr>\n<tr>\n<td>011 0001</td>\n<td>061</td>\n<td>49</td>\n<td>31</td>\n<td><a href=\"https://en.wikipedia.org/wiki/1_(number)\">1</a></td>\n</tr>\n<tr>\n<td>011 0010</td>\n<td>062</td>\n<td>50</td>\n<td>32</td>\n<td><a href=\"https://en.wikipedia.org/wiki/2_(number)\">2</a></td>\n</tr>\n<tr>\n<td>011 0011</td>\n<td>063</td>\n<td>51</td>\n<td>33</td>\n<td><a href=\"https://en.wikipedia.org/wiki/3_(number)\">3</a></td>\n</tr>\n<tr>\n<td>011 0100</td>\n<td>064</td>\n<td>52</td>\n<td>34</td>\n<td><a href=\"https://en.wikipedia.org/wiki/4_(number)\">4</a></td>\n</tr>\n<tr>\n<td>011 0101</td>\n<td>065</td>\n<td>53</td>\n<td>35</td>\n<td><a href=\"https://en.wikipedia.org/wiki/5_(number)\">5</a></td>\n</tr>\n<tr>\n<td>011 0110</td>\n<td>066</td>\n<td>54</td>\n<td>36</td>\n<td><a href=\"https://en.wikipedia.org/wiki/6_(number)\">6</a></td>\n</tr>\n<tr>\n<td>011 0111</td>\n<td>067</td>\n<td>55</td>\n<td>37</td>\n<td><a href=\"https://en.wikipedia.org/wiki/7_(number)\">7</a></td>\n</tr>\n<tr>\n<td>011 1000</td>\n<td>070</td>\n<td>56</td>\n<td>38</td>\n<td><a href=\"https://en.wikipedia.org/wiki/8_(number)\">8</a></td>\n</tr>\n<tr>\n<td>011 1001</td>\n<td>071</td>\n<td>57</td>\n<td>39</td>\n<td><a href=\"https://en.wikipedia.org/wiki/9_(number)\">9</a></td>\n</tr>\n</tbody></table>\n</blockquote>\n<blockquote>\n<p>大写字母部分</p>\n<table>\n<thead>\n<tr>\n<th><a href=\"https://en.wikipedia.org/wiki/Binary_numeral_system\">Binary</a></th>\n<th><a href=\"https://en.wikipedia.org/wiki/Octal\">Oct</a></th>\n<th><a href=\"https://en.wikipedia.org/wiki/Decimal\">Dec</a></th>\n<th><a href=\"https://en.wikipedia.org/wiki/Hexadecimal\">Hex</a></th>\n<th>Glyph</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>100 0001</td>\n<td>101</td>\n<td>65</td>\n<td>41</td>\n<td><a href=\"https://en.wikipedia.org/wiki/A\">A</a></td>\n</tr>\n<tr>\n<td>100 0010</td>\n<td>102</td>\n<td>66</td>\n<td>42</td>\n<td><a href=\"https://en.wikipedia.org/wiki/B\">B</a></td>\n</tr>\n<tr>\n<td>100 0011</td>\n<td>103</td>\n<td>67</td>\n<td>43</td>\n<td><a href=\"https://en.wikipedia.org/wiki/C\">C</a></td>\n</tr>\n<tr>\n<td>100 0100</td>\n<td>104</td>\n<td>68</td>\n<td>44</td>\n<td><a href=\"https://en.wikipedia.org/wiki/D\">D</a></td>\n</tr>\n<tr>\n<td>100 0101</td>\n<td>105</td>\n<td>69</td>\n<td>45</td>\n<td><a href=\"https://en.wikipedia.org/wiki/E\">E</a></td>\n</tr>\n<tr>\n<td>100 0110</td>\n<td>106</td>\n<td>70</td>\n<td>46</td>\n<td><a href=\"https://en.wikipedia.org/wiki/F\">F</a></td>\n</tr>\n<tr>\n<td>100 0111</td>\n<td>107</td>\n<td>71</td>\n<td>47</td>\n<td><a href=\"https://en.wikipedia.org/wiki/G\">G</a></td>\n</tr>\n<tr>\n<td>100 1000</td>\n<td>110</td>\n<td>72</td>\n<td>48</td>\n<td><a href=\"https://en.wikipedia.org/wiki/H\">H</a></td>\n</tr>\n<tr>\n<td>100 1001</td>\n<td>111</td>\n<td>73</td>\n<td>49</td>\n<td><a href=\"https://en.wikipedia.org/wiki/I\">I</a></td>\n</tr>\n<tr>\n<td>100 1010</td>\n<td>112</td>\n<td>74</td>\n<td>4A</td>\n<td><a href=\"https://en.wikipedia.org/wiki/J\">J</a></td>\n</tr>\n<tr>\n<td>100 1011</td>\n<td>113</td>\n<td>75</td>\n<td>4B</td>\n<td><a href=\"https://en.wikipedia.org/wiki/K\">K</a></td>\n</tr>\n<tr>\n<td>100 1100</td>\n<td>114</td>\n<td>76</td>\n<td>4C</td>\n<td><a href=\"https://en.wikipedia.org/wiki/L\">L</a></td>\n</tr>\n<tr>\n<td>100 1101</td>\n<td>115</td>\n<td>77</td>\n<td>4D</td>\n<td><a href=\"https://en.wikipedia.org/wiki/M\">M</a></td>\n</tr>\n<tr>\n<td>100 1110</td>\n<td>116</td>\n<td>78</td>\n<td>4E</td>\n<td><a href=\"https://en.wikipedia.org/wiki/N\">N</a></td>\n</tr>\n<tr>\n<td>100 1111</td>\n<td>117</td>\n<td>79</td>\n<td>4F</td>\n<td><a href=\"https://en.wikipedia.org/wiki/O\">O</a></td>\n</tr>\n<tr>\n<td>101 0000</td>\n<td>120</td>\n<td>80</td>\n<td>50</td>\n<td><a href=\"https://en.wikipedia.org/wiki/P\">P</a></td>\n</tr>\n<tr>\n<td>101 0001</td>\n<td>121</td>\n<td>81</td>\n<td>51</td>\n<td><a href=\"https://en.wikipedia.org/wiki/Q\">Q</a></td>\n</tr>\n<tr>\n<td>101 0010</td>\n<td>122</td>\n<td>82</td>\n<td>52</td>\n<td><a href=\"https://en.wikipedia.org/wiki/R\">R</a></td>\n</tr>\n<tr>\n<td>101 0011</td>\n<td>123</td>\n<td>83</td>\n<td>53</td>\n<td><a href=\"https://en.wikipedia.org/wiki/S\">S</a></td>\n</tr>\n<tr>\n<td>101 0100</td>\n<td>124</td>\n<td>84</td>\n<td>54</td>\n<td><a href=\"https://en.wikipedia.org/wiki/T\">T</a></td>\n</tr>\n<tr>\n<td>101 0101</td>\n<td>125</td>\n<td>85</td>\n<td>55</td>\n<td><a href=\"https://en.wikipedia.org/wiki/U\">U</a></td>\n</tr>\n<tr>\n<td>101 0110</td>\n<td>126</td>\n<td>86</td>\n<td>56</td>\n<td><a href=\"https://en.wikipedia.org/wiki/V\">V</a></td>\n</tr>\n<tr>\n<td>101 0111</td>\n<td>127</td>\n<td>87</td>\n<td>57</td>\n<td><a href=\"https://en.wikipedia.org/wiki/W\">W</a></td>\n</tr>\n<tr>\n<td>101 1000</td>\n<td>130</td>\n<td>88</td>\n<td>58</td>\n<td><a href=\"https://en.wikipedia.org/wiki/X\">X</a></td>\n</tr>\n<tr>\n<td>101 1001</td>\n<td>131</td>\n<td>89</td>\n<td>59</td>\n<td><a href=\"https://en.wikipedia.org/wiki/Y\">Y</a></td>\n</tr>\n<tr>\n<td>101 1010</td>\n<td>132</td>\n<td>90</td>\n<td>5A</td>\n<td><a href=\"https://en.wikipedia.org/wiki/Z\">Z</a></td>\n</tr>\n</tbody></table>\n</blockquote>\n<blockquote>\n<p>小写字母部分：</p>\n<table>\n<thead>\n<tr>\n<th><a href=\"https://en.wikipedia.org/wiki/Binary_numeral_system\">Binary</a></th>\n<th><a href=\"https://en.wikipedia.org/wiki/Octal\">Oct</a></th>\n<th><a href=\"https://en.wikipedia.org/wiki/Decimal\">Dec</a></th>\n<th><a href=\"https://en.wikipedia.org/wiki/Hexadecimal\">Hex</a></th>\n<th>Glyph</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>110 0001</td>\n<td>141</td>\n<td>97</td>\n<td>61</td>\n<td></td>\n<td><a href=\"https://en.wikipedia.org/wiki/A\">a</a></td>\n</tr>\n<tr>\n<td>110 0010</td>\n<td>142</td>\n<td>98</td>\n<td>62</td>\n<td></td>\n<td><a href=\"https://en.wikipedia.org/wiki/B\">b</a></td>\n</tr>\n<tr>\n<td>110 0011</td>\n<td>143</td>\n<td>99</td>\n<td>63</td>\n<td></td>\n<td><a href=\"https://en.wikipedia.org/wiki/C\">c</a></td>\n</tr>\n<tr>\n<td>110 0100</td>\n<td>144</td>\n<td>100</td>\n<td>64</td>\n<td></td>\n<td><a href=\"https://en.wikipedia.org/wiki/D\">d</a></td>\n</tr>\n<tr>\n<td>110 0101</td>\n<td>145</td>\n<td>101</td>\n<td>65</td>\n<td></td>\n<td><a href=\"https://en.wikipedia.org/wiki/E\">e</a></td>\n</tr>\n<tr>\n<td>110 0110</td>\n<td>146</td>\n<td>102</td>\n<td>66</td>\n<td></td>\n<td><a href=\"https://en.wikipedia.org/wiki/F\">f</a></td>\n</tr>\n<tr>\n<td>110 0111</td>\n<td>147</td>\n<td>103</td>\n<td>67</td>\n<td></td>\n<td><a href=\"https://en.wikipedia.org/wiki/G\">g</a></td>\n</tr>\n<tr>\n<td>110 1000</td>\n<td>150</td>\n<td>104</td>\n<td>68</td>\n<td></td>\n<td><a href=\"https://en.wikipedia.org/wiki/H\">h</a></td>\n</tr>\n<tr>\n<td>110 1001</td>\n<td>151</td>\n<td>105</td>\n<td>69</td>\n<td></td>\n<td><a href=\"https://en.wikipedia.org/wiki/I\">i</a></td>\n</tr>\n<tr>\n<td>110 1010</td>\n<td>152</td>\n<td>106</td>\n<td>6A</td>\n<td></td>\n<td><a href=\"https://en.wikipedia.org/wiki/J\">j</a></td>\n</tr>\n<tr>\n<td>110 1011</td>\n<td>153</td>\n<td>107</td>\n<td>6B</td>\n<td></td>\n<td><a href=\"https://en.wikipedia.org/wiki/K\">k</a></td>\n</tr>\n<tr>\n<td>110 1100</td>\n<td>154</td>\n<td>108</td>\n<td>6C</td>\n<td></td>\n<td><a href=\"https://en.wikipedia.org/wiki/L\">l</a></td>\n</tr>\n<tr>\n<td>110 1101</td>\n<td>155</td>\n<td>109</td>\n<td>6D</td>\n<td></td>\n<td><a href=\"https://en.wikipedia.org/wiki/M\">m</a></td>\n</tr>\n<tr>\n<td>110 1110</td>\n<td>156</td>\n<td>110</td>\n<td>6E</td>\n<td></td>\n<td><a href=\"https://en.wikipedia.org/wiki/N\">n</a></td>\n</tr>\n<tr>\n<td>110 1111</td>\n<td>157</td>\n<td>111</td>\n<td>6F</td>\n<td></td>\n<td><a href=\"https://en.wikipedia.org/wiki/O\">o</a></td>\n</tr>\n<tr>\n<td>111 0000</td>\n<td>160</td>\n<td>112</td>\n<td>70</td>\n<td></td>\n<td><a href=\"https://en.wikipedia.org/wiki/P\">p</a></td>\n</tr>\n<tr>\n<td>111 0001</td>\n<td>161</td>\n<td>113</td>\n<td>71</td>\n<td></td>\n<td><a href=\"https://en.wikipedia.org/wiki/Q\">q</a></td>\n</tr>\n<tr>\n<td>111 0010</td>\n<td>162</td>\n<td>114</td>\n<td>72</td>\n<td></td>\n<td><a href=\"https://en.wikipedia.org/wiki/R\">r</a></td>\n</tr>\n<tr>\n<td>111 0011</td>\n<td>163</td>\n<td>115</td>\n<td>73</td>\n<td></td>\n<td><a href=\"https://en.wikipedia.org/wiki/S\">s</a></td>\n</tr>\n<tr>\n<td>111 0100</td>\n<td>164</td>\n<td>116</td>\n<td>74</td>\n<td></td>\n<td><a href=\"https://en.wikipedia.org/wiki/T\">t</a></td>\n</tr>\n<tr>\n<td>111 0101</td>\n<td>165</td>\n<td>117</td>\n<td>75</td>\n<td></td>\n<td><a href=\"https://en.wikipedia.org/wiki/U\">u</a></td>\n</tr>\n<tr>\n<td>111 0110</td>\n<td>166</td>\n<td>118</td>\n<td>76</td>\n<td></td>\n<td><a href=\"https://en.wikipedia.org/wiki/V\">v</a></td>\n</tr>\n<tr>\n<td>111 0111</td>\n<td>167</td>\n<td>119</td>\n<td>77</td>\n<td></td>\n<td><a href=\"https://en.wikipedia.org/wiki/W\">w</a></td>\n</tr>\n<tr>\n<td>111 1000</td>\n<td>170</td>\n<td>120</td>\n<td>78</td>\n<td></td>\n<td><a href=\"https://en.wikipedia.org/wiki/X\">x</a></td>\n</tr>\n<tr>\n<td>111 1001</td>\n<td>171</td>\n<td>121</td>\n<td>79</td>\n<td></td>\n<td><a href=\"https://en.wikipedia.org/wiki/Y\">y</a></td>\n</tr>\n<tr>\n<td>111 1010</td>\n<td>172</td>\n<td>122</td>\n<td>7A</td>\n<td></td>\n<td><a href=\"https://en.wikipedia.org/wiki/Z\">z</a></td>\n</tr>\n</tbody></table>\n</blockquote>\n<h2 id=\"数字处理例子\"><a href=\"#数字处理例子\" class=\"headerlink\" title=\"数字处理例子\"></a>数字处理例子</h2><h3 id=\"1-高低位的处理\"><a href=\"#1-高低位的处理\" class=\"headerlink\" title=\"1.  高低位的处理\"></a>1.  高低位的处理</h3><blockquote>\n<p>核心是： </p>\n<ul>\n<li>取模得低位</li>\n<li>除数/右移得高位集合，或者说是去除最低位</li>\n</ul>\n</blockquote>\n<p>以10进制数 x 为例子， x%10得到最低位的数字，如果想要得到高位的数字，可以 for 循环 x/10 然后再使用x%10，这个取位值的方式是通用的，10可以换成其他的进制数。</p>\n<p>典型场景：</p>\n<p>给你一个整数 <code>x</code> ，如果 <code>x</code> 是一个回文整数，返回 <code>true</code> ；否则，返回 <code>false</code> ，回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p>\n<blockquote>\n<p><a href=\"https://leetcode.cn/problems/palindrome-number/\">9. 回文数 - 力扣（LeetCode）</a></p>\n</blockquote>\n<ul>\n<li><p>排除所有的负数和个位为0且不是0的数</p>\n</li>\n<li><p>获取高低位数来进行比较</p>\n</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 由于数字是整体具有大小的定义，不需要像是字符串那样需要按位比较，两数相同必定代表每一位的数字都相同，所以这个场景就可以换成取出整个数字的前半部分高位数和后半部分低位数，比较而这是否相同</span></span><br><span class=\"line\">front, back := x,<span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"comment\">// 如果是要比较回文数，那么低位数字需要倒序，执行逻辑是： %10获取该位数字，在下一轮使用*10将这个位数往左移一位（变成高位）</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> front &gt; back&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//先把当前地位数字向左移，然后在新的低位上加上新的数值</span></span><br><span class=\"line\">\tback = back*<span class=\"number\">10</span> + front%<span class=\"number\">10</span></span><br><span class=\"line\">    <span class=\"comment\">// 高位数字右移，直接丢弃最低位数字</span></span><br><span class=\"line\">\tfront = front/<span class=\"number\">10</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 要注意的是如果原数 x 有偶数位，那么循环后 back 和 front  的长度相同；如果x 是奇数位，那么循环后 back 会比 front 多一位，此时 back 的最低位是原数 x 的中间数，这个性质在求数位二分特征的时候可能有用</span></span><br></pre></td></tr></table></figure>\n\n<p>题目的解题代码为：</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">isPalindrome</span><span class=\"params\">(x <span class=\"type\">int</span>)</span></span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> x &lt; <span class=\"number\">0</span> || ( x%<span class=\"number\">10</span> == <span class=\"number\">0</span> &amp;&amp; x != <span class=\"number\">0</span> )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    front, back := x,<span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> front &gt; back&#123;</span><br><span class=\"line\">        back = back*<span class=\"number\">10</span> + front%<span class=\"number\">10</span></span><br><span class=\"line\">        front = front/<span class=\"number\">10</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 最后比较二者是否相同</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> back == front || front == back/<span class=\"number\">10</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"2-进制转化\"><a href=\"#2-进制转化\" class=\"headerlink\" title=\"2. 进制转化\"></a>2. 进制转化</h3><p>已有调用可以借助 strconv 转化为 string 然后进行操作(比如16进制本来也只能string表示)</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 10进制转化为其他进制   </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> v <span class=\"type\">int64</span> = <span class=\"number\">12</span>              <span class=\"comment\">//默认10进制</span></span><br><span class=\"line\">   s2 := strconv.FormatInt(v, <span class=\"number\">2</span>) <span class=\"comment\">//10 转2进制</span></span><br><span class=\"line\">   fmt.Printf(<span class=\"string\">&quot;%v\\n&quot;</span>, s2)</span><br><span class=\"line\"> <span class=\"comment\">//10 转8进制</span></span><br><span class=\"line\">   s8 := strconv.FormatInt(v, <span class=\"number\">8</span>)</span><br><span class=\"line\">   fmt.Printf(<span class=\"string\">&quot;%v\\n&quot;</span>, s8)</span><br><span class=\"line\"> </span><br><span class=\"line\">   s10 := strconv.FormatInt(v, <span class=\"number\">10</span>)</span><br><span class=\"line\">   fmt.Printf(<span class=\"string\">&quot;%v\\n&quot;</span>, s10)</span><br><span class=\"line\"> <span class=\"comment\">//10 转16进制</span></span><br><span class=\"line\">   s16 := strconv.FormatInt(v, <span class=\"number\">16</span>) <span class=\"comment\">//10 yo 16</span></span><br><span class=\"line\">   fmt.Printf(<span class=\"string\">&quot;%v\\n&quot;</span>, s16)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// 其他进制转化为10进制</span></span><br><span class=\"line\">   <span class=\"keyword\">var</span> sv = <span class=\"string\">&quot;11&quot;</span></span><br><span class=\"line\">   fmt.Println(strconv.ParseInt(sv, <span class=\"number\">16</span>, <span class=\"number\">32</span>)) <span class=\"comment\">// 16 to 10</span></span><br><span class=\"line\">   fmt.Println(strconv.ParseInt(sv, <span class=\"number\">10</span>, <span class=\"number\">32</span>)) <span class=\"comment\">// 10 to 10</span></span><br><span class=\"line\">   fmt.Println(strconv.ParseInt(sv, <span class=\"number\">8</span>, <span class=\"number\">32</span>))  <span class=\"comment\">// 8 to 10</span></span><br><span class=\"line\">   fmt.Println(strconv.ParseInt(sv, <span class=\"number\">2</span>, <span class=\"number\">32</span>))  <span class=\"comment\">// 2 to 10</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-数字表示转化\"><a href=\"#3-数字表示转化\" class=\"headerlink\" title=\"3. 数字表示转化\"></a>3. 数字表示转化</h3><blockquote>\n<p>本质是字符匹配然后拼接，问题就在于需要有一个可以匹配的字典以及对应的值</p>\n<p>难点在于 []byte, int, string类型转化，数值计算与字符拆分拼接的等价关系，以及是否能够把组合类型元素全部枚举完毕</p>\n</blockquote>\n<p>一般常用的思路就是：</p>\n<ul>\n<li><p>从数字转字符 –&gt; 数字做减法，字符做拼接</p>\n</li>\n<li><p>从字符转数字 –&gt; 数字做加法，字符做拆分</p>\n</li>\n</ul>\n<p>一般根据各自的数特征来选择从高位还是低位开始，数值类型从低位加减，也就意味着字符从右到左遍历。</p>\n<p>比如将罗马数字转化位10进制整数，首先建立罗马数字与10进制数的对应关系map，然后从右到左遍历低位进行加数，期间注意罗马数字的特点：”小数在大数左边表示减法”</p>\n<blockquote>\n<p><a href=\"https://leetcode.cn/problems/roman-to-integer/\">13. 罗马数字转整数 - 力扣（LeetCode）</a></p>\n</blockquote>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 匹配的关键在于生成一张 字符和数字对应的表</span></span><br><span class=\"line\">m := <span class=\"keyword\">map</span>[<span class=\"type\">byte</span>]<span class=\"type\">int</span> &#123;<span class=\"string\">&#x27;I&#x27;</span>:<span class=\"number\">1</span>,<span class=\"string\">&#x27;V&#x27;</span>:<span class=\"number\">5</span>,<span class=\"string\">&#x27;X&#x27;</span>:<span class=\"number\">10</span>,<span class=\"string\">&#x27;L&#x27;</span>:<span class=\"number\">50</span>,<span class=\"string\">&#x27;C&#x27;</span>:<span class=\"number\">100</span>,<span class=\"string\">&#x27;D&#x27;</span>:<span class=\"number\">500</span>,<span class=\"string\">&#x27;M&#x27;</span>:<span class=\"number\">1000</span>&#125;</span><br><span class=\"line\"><span class=\"comment\">// 开始遍历罗马数字，并从表中找到它对应的数值，判断左右之后加在结果上</span></span><br><span class=\"line\"><span class=\"comment\">// 注意点1 ： 初始赋值为最右边的罗马数，因为他不可能为零</span></span><br><span class=\"line\">res := m[s[<span class=\"built_in\">len</span>(s)<span class=\"number\">-1</span>]]</span><br><span class=\"line\"><span class=\"keyword\">for</span> i := <span class=\"built_in\">len</span>(s)<span class=\"number\">-2</span>; i &gt;= <span class=\"number\">0</span> ; i--&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 注意点2 ： 大于等于条件，前后位罗马符号相同是加同一个值，不能漏了等号</span></span><br><span class=\"line\">     <span class=\"keyword\">if</span> m[s[i]] &gt;= m[s[i+<span class=\"number\">1</span>]] &#123;</span><br><span class=\"line\">        res = res + m[s[i]]</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> m[s[i]] &lt; m[s[i+<span class=\"number\">1</span>]] &#123;</span><br><span class=\"line\">        res = res - m[s[i]]</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n\n<p>反过来要将一个10进制整数转化位罗马数字，遍历的就是10进制数，然后找他对应的罗马数字；</p>\n<blockquote>\n<p><a href=\"https://leetcode.cn/problems/integer-to-roman/solution/\">12. 整数转罗马数字 题解 - 力扣（LeetCode）</a></p>\n</blockquote>\n<p>但前一问运算简便是因为 10 进制加减覆盖了罗马数字的所有计算可排列组合，但是反过来的时候 10 进制数的每一位计算不一定都能找到罗马数字标识，比如 9 在罗马数字当中就存在非顺序的表达方式。由于这个特性就需要像是拼接组件一样去凑（说成贪心也可以）这个数字，也就是从左到右，先找大数再找小数，先从目标数字里面剪出所有的大数，然后找大数对应的罗马数字表示，逐个拼接。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> m = []<span class=\"type\">int</span>&#123;<span class=\"number\">1000</span>,<span class=\"number\">900</span>,<span class=\"number\">500</span>,<span class=\"number\">400</span>,<span class=\"number\">100</span>,<span class=\"number\">90</span>,<span class=\"number\">50</span>,<span class=\"number\">40</span>,<span class=\"number\">10</span>,<span class=\"number\">9</span>,<span class=\"number\">5</span>,<span class=\"number\">4</span>,<span class=\"number\">1</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> v = []<span class=\"type\">string</span>&#123;<span class=\"string\">&quot;M&quot;</span>,<span class=\"string\">&quot;CM&quot;</span>,<span class=\"string\">&quot;D&quot;</span>,<span class=\"string\">&quot;CD&quot;</span>,<span class=\"string\">&quot;C&quot;</span>,<span class=\"string\">&quot;XC&quot;</span>,<span class=\"string\">&quot;L&quot;</span>,<span class=\"string\">&quot;XL&quot;</span>,<span class=\"string\">&quot;X&quot;</span>,<span class=\"string\">&quot;IX&quot;</span>,<span class=\"string\">&quot;V&quot;</span>,<span class=\"string\">&quot;IV&quot;</span>,<span class=\"string\">&quot;I&quot;</span>&#125;</span><br><span class=\"line\"><span class=\"comment\">// 从左到右来遍历先减去大数，加上罗马数字</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">intToRoman</span><span class=\"params\">(num <span class=\"type\">int</span>)</span></span> <span class=\"type\">string</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> res <span class=\"type\">string</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(v); i++&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> num &gt;= m[i] &#123;</span><br><span class=\"line\">            num = num-m[i]</span><br><span class=\"line\">            res = res + v[i]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里唯一要注意的应该就是 Golang 当中字符串的拼接处理了，详情看</p>\n<p>同样的逻辑可以用到其他的转化情况，比如随意字符串转数字，一定先确认数字映射关系的字典，然后来做字符串的匹配，然后转化为数字的计算。</p>\n","site":{"data":{}},"cover":"/img/cover/sky.png","cover_type":"img","excerpt":"","more":"<blockquote>\n<p>记录 Golang  的基础使用例子</p>\n</blockquote>\n<h2 id=\"输入输出例子\"><a href=\"#输入输出例子\" class=\"headerlink\" title=\"输入输出例子\"></a>输入输出例子</h2><blockquote>\n<p>输入输出也是处理的关键部分，包括从cmd 、文件、网络 等对象中读入，读入写入触发中断，会在意想不到的地方影响性能，尤其是acm形式下要注意</p>\n</blockquote>\n<h3 id=\"从控制台读入数据\"><a href=\"#从控制台读入数据\" class=\"headerlink\" title=\"从控制台读入数据\"></a>从控制台读入数据</h3><p>一共有两种方法，一种是使用bufio中的newReader方法，一种是使用bufio中的NewScanner方法</p>\n<p>使用 NewReader() 方法，通过返回值err判断是否是io.EOF来判断控制台的输出是否已经结束。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//处理流数据，NewReader读取到所有的命令行数据，但是，newReader解出来数据需要有split。</span></span><br><span class=\"line\">reader := bufio.NewReader(os.stdout)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//实时循环读取输出流中的一行内容</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\tline, err := reader.ReadString(<span class=\"string\">&#x27;\\n&#x27;</span>) <span class=\"comment\">//使用换行符作为切割。</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> || io.EOF == err &#123;</span><br><span class=\"line\">        fmt.Println(<span class=\"string\">&quot;err occured! err = &quot;</span>, err)</span><br><span class=\"line\">\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfmt.Printf(line)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>NewScanner方法使用时，使用Scan()方法判断控制台的输出是否已经结束。使用Bytes()方法读取数据时不指定分隔符，但也可以使用其他读取函数使用分隔符进行分割。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scanner := bufio.NewScanner(os.Stdin)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//循环读取控制台数据</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> scanner.Scan() &#123;</span><br><span class=\"line\">\tdata := scanner.Bytes()</span><br><span class=\"line\">\tfmt.Println(<span class=\"type\">string</span>(data))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>针对 写入数据类型来做读入处理</p>\n<ol>\n<li><p>用 fmt 包实现简单读取数字</p>\n<ul>\n<li><p>知道每行输入的信息个数，但不知道有多少行</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 一直循环读取 cmd 输入的数据</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// n 记录的是成功读取每行的数字个数</span></span><br><span class=\"line\">\t\tn, _ := fmt.Scanln(&amp;a, &amp;b)  <span class=\"comment\">//也可以用 fmt.Scan</span></span><br><span class=\"line\">    \t</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>先输入行数，再输入信息</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fmt.Scanln(&amp;t)</span><br><span class=\"line\"><span class=\"keyword\">for</span> i:=<span class=\"number\">0</span> ; i&lt;t ; i++&#123;</span><br><span class=\"line\">   fmt.Scanln(&amp;a,&amp;b)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>fmt.Scanln 一次只能读取一行数据，而且得提前创建好对应的结构</p>\n</blockquote>\n</li>\n<li><p>读取一整行数据，但不确定行数和一行内的数据量</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">inputs := bufio.NewScanner(os.Stdin)</span><br><span class=\"line\"><span class=\"keyword\">for</span> inputs.Scan() &#123;  <span class=\"comment\">//每次读入一行</span></span><br><span class=\"line\">    data := strings.Split(inputs.Text(), <span class=\"string\">&quot; &quot;</span>)  <span class=\"comment\">//通过空格将他们分割，并存入一个字符串切片</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> data &#123;<span class=\"comment\">// 遍历一行内的数据</span></span><br><span class=\"line\">        val, _ := strconv.Atoi(data[i])   <span class=\"comment\">//将字符串转换为int 或者是根据实际要求转化</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>读一行字符串</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 输入描述:</span></span><br><span class=\"line\"><span class=\"comment\">// 输入有两行，第一行n</span></span><br><span class=\"line\"><span class=\"comment\">// 第二行是n个字符串，字符串之间用空格隔开</span></span><br><span class=\"line\">in := bufio.NewScanner(os.Stdin)</span><br><span class=\"line\"><span class=\"keyword\">for</span> in.Scan()&#123;</span><br><span class=\"line\">    n := in.Text()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> in.Scan()&#123;</span><br><span class=\"line\">   str := in.Text()</span><br><span class=\"line\">   s := strings.Split(str, <span class=\"string\">&quot; &quot;</span>)</span><br><span class=\"line\">   fmt.Println(strings.Join(s,<span class=\"string\">&quot; &quot;</span>))  <span class=\"comment\">//将切片连接成字符串</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n<li><p>读多行字符串</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">input := bufio.NewScanner(os.Stdin)</span><br><span class=\"line\"><span class=\"keyword\">for</span> input.Scan()&#123;</span><br><span class=\"line\">   data := strings.Split(input.Text(),<span class=\"string\">&quot; &quot;</span>)</span><br><span class=\"line\">   fmt.Println(strings.Join(data, <span class=\"string\">&quot; &quot;</span>))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>一次性读入字符串数据</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">scanT</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    scanner := bufio.NewScanner(os.Stdin)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> scanner.Scan() &#123;</span><br><span class=\"line\">        fmt.Println(scanner.Text())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n<p>依据不同的场景来选择不同的读入函数，一般考虑的时候主要是性能相关的，这部分还没有统一的一个套路，所以为了方便，整理出以下套路：</p>\n<ul>\n<li>先读入数据</li>\n<li>在将数据转化为需要的数据类型</li>\n</ul>\n<h2 id=\"字符串处理例子\"><a href=\"#字符串处理例子\" class=\"headerlink\" title=\"字符串处理例子\"></a>字符串处理例子</h2><h3 id=\"字符数据据类型\"><a href=\"#字符数据据类型\" class=\"headerlink\" title=\"字符数据据类型\"></a>字符数据据类型</h3><p>在 Go 中字符相关的类型一共三类：</p>\n<ul>\n<li><p>```go<br>byte // 一般用于强调数值是原始数据，代表ASCII码的一个字符（占一个字节）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">- byte是`uint8`的别名，在所有方面都等同于`uint8`</span><br><span class=\"line\"></span><br><span class=\"line\">- 按惯例，它用于区分**字节值**和**8位无符号整数值**。</span><br><span class=\"line\"></span><br><span class=\"line\">  一般形式：是基础类型</span><br><span class=\"line\"></span><br><span class=\"line\">  ```go</span><br><span class=\"line\">  //使用单引号 表示一个字符</span><br><span class=\"line\">  var ch byte = &#x27;A&#x27;</span><br><span class=\"line\">  //在 ASCII 码表中，A 的值是 65,也可以这么定义</span><br><span class=\"line\">  var ch byte = 65</span><br><span class=\"line\">  //65使用十六进制表示是41，所以也可以这么定义 \\x 总是紧跟着长度为 2 的 16 进制数</span><br><span class=\"line\">  var ch byte = &#x27;\\x41&#x27;</span><br><span class=\"line\">  //65的八进制表示是101，所以使用八进制定义 \\后面紧跟着长度为 3 的八进制数</span><br><span class=\"line\">  var ch byte = &#x27;\\101&#x27;</span><br></pre></td></tr></table></figure></li>\n<li><p>```<br>rune</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">- `rune`是`int32`的别名，在所有方面都等同于`int32`， 用于标识Unicode字符，代表一个UTF-8字符</span><br><span class=\"line\"></span><br><span class=\"line\">  主要价值在于 非英文字符的计算和标识使用</span><br><span class=\"line\"></span><br><span class=\"line\">- 按惯例，它用于区分**字符值**和**整数值**。</span><br><span class=\"line\"></span><br><span class=\"line\">  ```go</span><br><span class=\"line\">  var ch rune = &#x27;\\u0041&#x27;</span><br><span class=\"line\">  var ch1 int64 = &#x27;\\U00000041&#x27;</span><br><span class=\"line\">  //格式化说明符%c用于表示字符，%v或%d会输出用于表示该字符的整数，%U输出格式为 U+hhhh 的字符串。</span><br><span class=\"line\">  fmt.Printf(&quot;%c,%c,%U&quot;,ch,ch1,ch)</span><br></pre></td></tr></table></figure></li>\n<li><p>```<br>string</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">- string是所有**8位字节字符串**的集合，通常但不一定代表UTF-8编码的文本</span><br><span class=\"line\"></span><br><span class=\"line\">- 字符串可能为空，但是不能为 `nil`</span><br><span class=\"line\"></span><br><span class=\"line\">- 字符串类型的值是不可变的:  **本质是**只读的字符型数组</span><br><span class=\"line\"></span><br><span class=\"line\">  所以这行代码是不可以执行的：`str1[3] = &#x27;l&#x27;`, 但是读取的操作是可以执行的： `fmt.Println(str1[3])`，这个也不是golang的独创，很多语言当中都有这个限制，因为会将字符串作为const类型存储在专门的区域。</span><br><span class=\"line\"></span><br><span class=\"line\">string 类型详述：[Golang基础教程——字符串篇 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/143352497) [go底层系列-string底层实现原理与使用 - 掘金 (juejin.cn)](https://juejin.cn/post/7111953294469267493)</span><br><span class=\"line\"></span><br><span class=\"line\">string 变量本质上是一个指向字符串首地址的指针加上字符串长度的量，二者均为8字节，所以使用SizoOf的时候所获得的大小一直为16，其源码对应的是：</span><br><span class=\"line\"></span><br><span class=\"line\">```go</span><br><span class=\"line\">type stringStruct struct &#123;</span><br><span class=\"line\">\tstr unsafe.Pointer\t\t//字符串首地址，指向底层字节数组的指针</span><br><span class=\"line\">\tlen int\t\t\t\t\t//字符串长度</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>说到这里关于字符串长度的统计有几处误区需要辨明：</p>\n<ol>\n<li><p>使用 len 来获取字符串长度时候计算的是 Byte 数量，这对于英文字符来说一个字母就对应一个Byte，len所获取的长度就是字符串的长度，还有 <code>bytes.Count()</code> 也是类似的</p>\n<p>但对于中文等语言，使用utf-8编码，一个<strong>汉字需要3个字节</strong>编码，这个时候使用len 就会把一个中文字符计算为长度 3</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取长度</span></span><br><span class=\"line\">l := <span class=\"built_in\">len</span>(str)</span><br><span class=\"line\"><span class=\"comment\">// 如果是获取string 中的字符串数量</span></span><br><span class=\"line\">l1 := strings.Count(str,<span class=\"string\">&quot;&quot;</span>) - <span class=\"number\">1</span></span><br><span class=\"line\">l2 := bytes.Count([]<span class=\"type\">byte</span>(str),<span class=\"literal\">nil</span>) - <span class=\"number\">1</span> </span><br><span class=\"line\"><span class=\"comment\">// strings.Count函数和bytes.Count函数,这两个函数的用法是相同，只是一个作用在字符串上，一个作用在字节上</span></span><br></pre></td></tr></table></figure></li>\n<li><p>将 string 数组转化为 rune 数组之后来计算长度，常用的方法是：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 将字符串转换为 []rune 后调用 len 函数进行统计</span></span><br><span class=\"line\">l := <span class=\"built_in\">len</span>([]<span class=\"type\">rune</span>(str))</span><br><span class=\"line\"><span class=\"comment\">// 使用 utf8.RuneCountInString() 统计</span></span><br><span class=\"line\">l := utf8.RuneCountInString(str)</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>那么回顾总结，目前对于 string 量以下操作是明确的：</p>\n</li>\n</ul>\n<h3 id=\"1-string-初始化\"><a href=\"#1-string-初始化\" class=\"headerlink\" title=\"1. string  初始化\"></a>1. string  初始化</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 第一种形式最简洁，但只能用在函数内部，不能用在包变量。</span></span><br><span class=\"line\"><span class=\"comment\">// 当函数传入 string 类型或者说，使用 cmd 或者 bufio 读取了数值时候在函数内需要进行微操的时候使用</span></span><br><span class=\"line\">s := <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第二种形式依赖于字符串的默认初始化值，被初始化为&quot;&quot;。</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> s <span class=\"type\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第三种形式用得很少，除非同时声明多个变量。</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第四种形式显式地标明变量的类型，当变量类型与初值类型相同时，类型冗余，但如果两者类型不同，变量类型就必须了。</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> s <span class=\"type\">string</span> = <span class=\"string\">&quot;&quot;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"2-string-拼接操作\"><a href=\"#2-string-拼接操作\" class=\"headerlink\" title=\"2. string 拼接操作\"></a>2. string 拼接操作</h3><p>仅对于 string 是可以用的， rune和byte操作的是一个值或者切片，相互之间需要转化</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 简单的 + ，一共存在两种用法：</span></span><br><span class=\"line\"><span class=\"comment\">// s = a + b 则 s 会被赋值为一个新的由ab组成的字符串</span></span><br><span class=\"line\">s = a + b</span><br><span class=\"line\"><span class=\"comment\">// s += a + b , += 连接原字符串和下个参数，产生新字符串, 并把它赋值给s(ab)</span></span><br><span class=\"line\">s += a + b</span><br></pre></td></tr></table></figure>\n\n<p>这样的方式更新，s 原来的内容都将不再会使用，Go 会在适当的时机对他进行垃圾回收，这方面的机制将在 enhanced 文章当中提及</p>\n<p>为改进这方面的问题，一种简单且高效的解决方案是使用strings包的Join函数</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用拼接函数</span></span><br><span class=\"line\">strings.Join([]<span class=\"type\">string</span>&#123;a,b...&#125;, <span class=\"string\">&quot; &quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>一个实例如下</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\ta := <span class=\"string\">&quot;=this=is=&quot;</span></span><br><span class=\"line\">\tb := <span class=\"string\">&quot;=your=word=&quot;</span></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;%s\\n&quot;</span>, a+b)</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> d <span class=\"type\">string</span></span><br><span class=\"line\">\td += a + b</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;%s\\n&quot;</span>, d)</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;%s\\n&quot;</span>, strings.Join([]<span class=\"type\">string</span>&#123;a, b&#125;, <span class=\"string\">&quot;&quot;</span>))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 结果是：</span></span><br><span class=\"line\">=this=is==your=word=</span><br><span class=\"line\">=this=is==your=word=</span><br><span class=\"line\">=this=is==your=word=</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"3-string-求长度\"><a href=\"#3-string-求长度\" class=\"headerlink\" title=\"3. string 求长度\"></a>3. string 求长度</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 英文字符用 len()  , 中文字符先转换为 []rune，再计算len()</span></span><br></pre></td></tr></table></figure>\n\n<p>以下为一个实例，计算长度时候是把空格也计算在内了</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\ta := <span class=\"string\">&quot;this is a string&quot;</span> <span class=\"comment\">// 16</span></span><br><span class=\"line\">\tb := <span class=\"string\">&quot;这是一个字符串&quot;</span>      <span class=\"comment\">// 7</span></span><br><span class=\"line\">\tc := <span class=\"string\">&quot;this is a 字符串&quot;</span>  <span class=\"comment\">// 13</span></span><br><span class=\"line\">\td := <span class=\"string\">&quot;this is 11 字符串 @@#&quot;</span>  <span class=\"comment\">// 18</span></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;%d\\n&quot;</span>, <span class=\"built_in\">len</span>(a))</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;%d\\n&quot;</span>, <span class=\"built_in\">len</span>([]<span class=\"type\">rune</span>(b)))</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;%d\\n&quot;</span>, <span class=\"built_in\">len</span>([]<span class=\"type\">rune</span>(c)))</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;%d\\n&quot;</span>, <span class=\"built_in\">len</span>([]<span class=\"type\">rune</span>(d)))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 输出结果为：</span></span><br><span class=\"line\"><span class=\"number\">16</span></span><br><span class=\"line\"><span class=\"number\">7</span> </span><br><span class=\"line\"><span class=\"number\">13</span></span><br><span class=\"line\"><span class=\"number\">18</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>大部分情况下，上述的操作已经满足了需求，但在面对输入输出的时候，还需要将字符串转化为有效的数据，比如读取 Docker 输出之后，需要将其中的数据转化为可以计算的其他数据，这个时候就涉及到类型转化。</p>\n<h3 id=\"4-以字符串为核心的类型转换\"><a href=\"#4-以字符串为核心的类型转换\" class=\"headerlink\" title=\"4. 以字符串为核心的类型转换\"></a>4. 以字符串为核心的类型转换</h3><h4 id=\"4-1-string-To-int-and-Reverse\"><a href=\"#4-1-string-To-int-and-Reverse\" class=\"headerlink\" title=\"4.1 string To int and Reverse\"></a>4.1 string To int and Reverse</h4><p>使用：</p>\n<ul>\n<li><code>strconv.ParseInt(a,10,64)</code></li>\n<li><code>strconv.Atoi(a)</code></li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\ta := <span class=\"string\">&quot;1056&quot;</span></span><br><span class=\"line\">\tb := <span class=\"string\">&quot;1056&quot;</span></span><br><span class=\"line\">\tvala, _ := strconv.ParseInt(a, <span class=\"number\">10</span>, <span class=\"number\">64</span>)</span><br><span class=\"line\">\tvalb, _ := strconv.Atoi(b)</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;ParseInt is : %d\\n&quot;</span>, vala)</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;Atoi is :%d\\n&quot;</span>, valb)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 结果是：</span></span><br><span class=\"line\">ParseInt is : <span class=\"number\">1056</span></span><br><span class=\"line\">Atoi is :<span class=\"number\">1056</span></span><br></pre></td></tr></table></figure>\n\n<p>二者在遍历字符串的时候，如果遇到了非数值型字符就会把整个数值置为零，但使用ParseInt对应16进制时候，a-f（A-F）会被识别为对应的进制数</p>\n<p>这里有一点是Atoi， Go 从str 转化为 int 类型读取时候只能默认是10进制的，也就是说上述进制转化的逻辑是：</p>\n<p>string —&gt; 10进制 int —&gt; 其他进制 int</p>\n<p>反过来将Int类型转化为string时候使用 Format 函数</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">strconv.FormatInt(<span class=\"type\">int64</span>(num), <span class=\"number\">10</span>)</span><br><span class=\"line\">strconv.Itoa(num)</span><br></pre></td></tr></table></figure>\n\n<p>传入的是一个64位的Int型数字，将其转化为10进制数（也可以将10换为8，16）</p>\n<h4 id=\"4-2-string-to-float\"><a href=\"#4-2-string-to-float\" class=\"headerlink\" title=\"4.2 string to float\"></a>4.2 string to float</h4><p><code>strconv.ParseFloat(a,64)</code>  对于浮点数来说就没有进制的区别了</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">value, err := strconv.ParseFloat(<span class=\"string\">&quot;1056.56&quot;</span>, <span class=\"number\">64</span>)</span><br></pre></td></tr></table></figure>\n\n<p>浮点数的转化就有些麻烦，但依旧是使用FormatFloat来实现的</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">num := <span class=\"number\">23423134.323422</span></span><br><span class=\"line\">fmt.Println(strconv.FormatFloat(<span class=\"type\">float64</span>(num), <span class=\"string\">&#x27;f&#x27;</span>, <span class=\"number\">-1</span>, <span class=\"number\">64</span>))</span><br><span class=\"line\">fmt.Println(strconv.FormatFloat(<span class=\"type\">float64</span>(num), <span class=\"string\">&#x27;b&#x27;</span>, <span class=\"number\">-1</span>, <span class=\"number\">64</span>))</span><br><span class=\"line\">fmt.Println(strconv.FormatFloat(<span class=\"type\">float64</span>(num), <span class=\"string\">&#x27;e&#x27;</span>, <span class=\"number\">-1</span>, <span class=\"number\">64</span>))</span><br><span class=\"line\">fmt.Println(strconv.FormatFloat(<span class=\"type\">float64</span>(num), <span class=\"string\">&#x27;E&#x27;</span>, <span class=\"number\">-1</span>, <span class=\"number\">64</span>))</span><br><span class=\"line\">fmt.Println(strconv.FormatFloat(<span class=\"type\">float64</span>(num), <span class=\"string\">&#x27;g&#x27;</span>, <span class=\"number\">-1</span>, <span class=\"number\">64</span>))</span><br><span class=\"line\">fmt.Println(strconv.FormatFloat(<span class=\"type\">float64</span>(num), <span class=\"string\">&#x27;G&#x27;</span>, <span class=\"number\">-1</span>, <span class=\"number\">64</span>))</span><br><span class=\"line\"><span class=\"comment\">// 结果是：</span></span><br><span class=\"line\"><span class=\"number\">23423134.323422</span></span><br><span class=\"line\"><span class=\"number\">6287599743057036</span>p<span class=\"number\">-28</span></span><br><span class=\"line\"><span class=\"number\">2.3423134323422e+07</span> </span><br><span class=\"line\"><span class=\"number\">2.3423134323422E+07</span> </span><br><span class=\"line\"><span class=\"number\">2.3423134323422e+07</span> </span><br><span class=\"line\"><span class=\"number\">2.3423134323422E+07</span> </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>FormatFloat接受4个参数，第一个参数就是待转换的浮点数，第二个参数表示我们希望转换之后得到的格式。一共有’f’, ‘b’, ‘e’, ‘E’, ‘g’, ‘G’这几种格式。</p>\n<ul>\n<li>‘f’ 表示普通模式：（-ddd.dddd）</li>\n<li>‘b’ 表示指数为二进制：（-ddddp±ddd）</li>\n<li>‘e’ 表示十进制指数，也就是科学记数法的模式：(-d.dddde±dd)</li>\n<li>‘E’ 和’e’一样，都是科学记数法的模式，只不过字母e大写：(-d.ddddE±dd)</li>\n<li>‘g’ 表示指数很大时用’e’模式，否则用‘f’模式</li>\n<li>‘G’ 表示指数很大时用’E’模式，否则用’f’模式</li>\n</ul>\n<h4 id=\"4-3-string-to-byte-and-Revese\"><a href=\"#4-3-string-to-byte-and-Revese\" class=\"headerlink\" title=\"4.3 string to []byte and Revese\"></a>4.3 string to []byte and Revese</h4><p>使用强制转化就行</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s := <span class=\"string\">&quot;abc&quot;</span></span><br><span class=\"line\">b := []<span class=\"type\">byte</span>(s)</span><br><span class=\"line\">s2 := <span class=\"type\">string</span>(b)</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"4-4-string-to-rune-and-Reverse\"><a href=\"#4-4-string-to-rune-and-Reverse\" class=\"headerlink\" title=\"4.4 string to []rune and Reverse\"></a>4.4 string to []rune and Reverse</h4><p>强制转化就行 </p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s := <span class=\"string\">&quot;你是谁&quot;</span></span><br><span class=\"line\">r := []<span class=\"type\">rune</span>(s)</span><br><span class=\"line\">s2 := <span class=\"type\">string</span>(r)</span><br></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<p>回顾： ASCII 码：</p>\n<p>记住十进制表示中 1 –&gt; 48, A –&gt; 65, a –&gt; 97</p>\n<p>​                              9 –&gt; 57, Z –&gt; 90, z –&gt; 122</p>\n</blockquote>\n<blockquote>\n<p>数字部分：</p>\n<table>\n<thead>\n<tr>\n<th><a href=\"https://en.wikipedia.org/wiki/Binary_numeral_system\">Binary</a></th>\n<th><a href=\"https://en.wikipedia.org/wiki/Octal\">Oct</a></th>\n<th><a href=\"https://en.wikipedia.org/wiki/Decimal\">Dec</a></th>\n<th><a href=\"https://en.wikipedia.org/wiki/Hexadecimal\">Hex</a></th>\n<th>Glyph</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>011 0000</td>\n<td>060</td>\n<td>48</td>\n<td>30</td>\n<td><a href=\"https://en.wikipedia.org/wiki/0_(number)\">0</a></td>\n</tr>\n<tr>\n<td>011 0001</td>\n<td>061</td>\n<td>49</td>\n<td>31</td>\n<td><a href=\"https://en.wikipedia.org/wiki/1_(number)\">1</a></td>\n</tr>\n<tr>\n<td>011 0010</td>\n<td>062</td>\n<td>50</td>\n<td>32</td>\n<td><a href=\"https://en.wikipedia.org/wiki/2_(number)\">2</a></td>\n</tr>\n<tr>\n<td>011 0011</td>\n<td>063</td>\n<td>51</td>\n<td>33</td>\n<td><a href=\"https://en.wikipedia.org/wiki/3_(number)\">3</a></td>\n</tr>\n<tr>\n<td>011 0100</td>\n<td>064</td>\n<td>52</td>\n<td>34</td>\n<td><a href=\"https://en.wikipedia.org/wiki/4_(number)\">4</a></td>\n</tr>\n<tr>\n<td>011 0101</td>\n<td>065</td>\n<td>53</td>\n<td>35</td>\n<td><a href=\"https://en.wikipedia.org/wiki/5_(number)\">5</a></td>\n</tr>\n<tr>\n<td>011 0110</td>\n<td>066</td>\n<td>54</td>\n<td>36</td>\n<td><a href=\"https://en.wikipedia.org/wiki/6_(number)\">6</a></td>\n</tr>\n<tr>\n<td>011 0111</td>\n<td>067</td>\n<td>55</td>\n<td>37</td>\n<td><a href=\"https://en.wikipedia.org/wiki/7_(number)\">7</a></td>\n</tr>\n<tr>\n<td>011 1000</td>\n<td>070</td>\n<td>56</td>\n<td>38</td>\n<td><a href=\"https://en.wikipedia.org/wiki/8_(number)\">8</a></td>\n</tr>\n<tr>\n<td>011 1001</td>\n<td>071</td>\n<td>57</td>\n<td>39</td>\n<td><a href=\"https://en.wikipedia.org/wiki/9_(number)\">9</a></td>\n</tr>\n</tbody></table>\n</blockquote>\n<blockquote>\n<p>大写字母部分</p>\n<table>\n<thead>\n<tr>\n<th><a href=\"https://en.wikipedia.org/wiki/Binary_numeral_system\">Binary</a></th>\n<th><a href=\"https://en.wikipedia.org/wiki/Octal\">Oct</a></th>\n<th><a href=\"https://en.wikipedia.org/wiki/Decimal\">Dec</a></th>\n<th><a href=\"https://en.wikipedia.org/wiki/Hexadecimal\">Hex</a></th>\n<th>Glyph</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>100 0001</td>\n<td>101</td>\n<td>65</td>\n<td>41</td>\n<td><a href=\"https://en.wikipedia.org/wiki/A\">A</a></td>\n</tr>\n<tr>\n<td>100 0010</td>\n<td>102</td>\n<td>66</td>\n<td>42</td>\n<td><a href=\"https://en.wikipedia.org/wiki/B\">B</a></td>\n</tr>\n<tr>\n<td>100 0011</td>\n<td>103</td>\n<td>67</td>\n<td>43</td>\n<td><a href=\"https://en.wikipedia.org/wiki/C\">C</a></td>\n</tr>\n<tr>\n<td>100 0100</td>\n<td>104</td>\n<td>68</td>\n<td>44</td>\n<td><a href=\"https://en.wikipedia.org/wiki/D\">D</a></td>\n</tr>\n<tr>\n<td>100 0101</td>\n<td>105</td>\n<td>69</td>\n<td>45</td>\n<td><a href=\"https://en.wikipedia.org/wiki/E\">E</a></td>\n</tr>\n<tr>\n<td>100 0110</td>\n<td>106</td>\n<td>70</td>\n<td>46</td>\n<td><a href=\"https://en.wikipedia.org/wiki/F\">F</a></td>\n</tr>\n<tr>\n<td>100 0111</td>\n<td>107</td>\n<td>71</td>\n<td>47</td>\n<td><a href=\"https://en.wikipedia.org/wiki/G\">G</a></td>\n</tr>\n<tr>\n<td>100 1000</td>\n<td>110</td>\n<td>72</td>\n<td>48</td>\n<td><a href=\"https://en.wikipedia.org/wiki/H\">H</a></td>\n</tr>\n<tr>\n<td>100 1001</td>\n<td>111</td>\n<td>73</td>\n<td>49</td>\n<td><a href=\"https://en.wikipedia.org/wiki/I\">I</a></td>\n</tr>\n<tr>\n<td>100 1010</td>\n<td>112</td>\n<td>74</td>\n<td>4A</td>\n<td><a href=\"https://en.wikipedia.org/wiki/J\">J</a></td>\n</tr>\n<tr>\n<td>100 1011</td>\n<td>113</td>\n<td>75</td>\n<td>4B</td>\n<td><a href=\"https://en.wikipedia.org/wiki/K\">K</a></td>\n</tr>\n<tr>\n<td>100 1100</td>\n<td>114</td>\n<td>76</td>\n<td>4C</td>\n<td><a href=\"https://en.wikipedia.org/wiki/L\">L</a></td>\n</tr>\n<tr>\n<td>100 1101</td>\n<td>115</td>\n<td>77</td>\n<td>4D</td>\n<td><a href=\"https://en.wikipedia.org/wiki/M\">M</a></td>\n</tr>\n<tr>\n<td>100 1110</td>\n<td>116</td>\n<td>78</td>\n<td>4E</td>\n<td><a href=\"https://en.wikipedia.org/wiki/N\">N</a></td>\n</tr>\n<tr>\n<td>100 1111</td>\n<td>117</td>\n<td>79</td>\n<td>4F</td>\n<td><a href=\"https://en.wikipedia.org/wiki/O\">O</a></td>\n</tr>\n<tr>\n<td>101 0000</td>\n<td>120</td>\n<td>80</td>\n<td>50</td>\n<td><a href=\"https://en.wikipedia.org/wiki/P\">P</a></td>\n</tr>\n<tr>\n<td>101 0001</td>\n<td>121</td>\n<td>81</td>\n<td>51</td>\n<td><a href=\"https://en.wikipedia.org/wiki/Q\">Q</a></td>\n</tr>\n<tr>\n<td>101 0010</td>\n<td>122</td>\n<td>82</td>\n<td>52</td>\n<td><a href=\"https://en.wikipedia.org/wiki/R\">R</a></td>\n</tr>\n<tr>\n<td>101 0011</td>\n<td>123</td>\n<td>83</td>\n<td>53</td>\n<td><a href=\"https://en.wikipedia.org/wiki/S\">S</a></td>\n</tr>\n<tr>\n<td>101 0100</td>\n<td>124</td>\n<td>84</td>\n<td>54</td>\n<td><a href=\"https://en.wikipedia.org/wiki/T\">T</a></td>\n</tr>\n<tr>\n<td>101 0101</td>\n<td>125</td>\n<td>85</td>\n<td>55</td>\n<td><a href=\"https://en.wikipedia.org/wiki/U\">U</a></td>\n</tr>\n<tr>\n<td>101 0110</td>\n<td>126</td>\n<td>86</td>\n<td>56</td>\n<td><a href=\"https://en.wikipedia.org/wiki/V\">V</a></td>\n</tr>\n<tr>\n<td>101 0111</td>\n<td>127</td>\n<td>87</td>\n<td>57</td>\n<td><a href=\"https://en.wikipedia.org/wiki/W\">W</a></td>\n</tr>\n<tr>\n<td>101 1000</td>\n<td>130</td>\n<td>88</td>\n<td>58</td>\n<td><a href=\"https://en.wikipedia.org/wiki/X\">X</a></td>\n</tr>\n<tr>\n<td>101 1001</td>\n<td>131</td>\n<td>89</td>\n<td>59</td>\n<td><a href=\"https://en.wikipedia.org/wiki/Y\">Y</a></td>\n</tr>\n<tr>\n<td>101 1010</td>\n<td>132</td>\n<td>90</td>\n<td>5A</td>\n<td><a href=\"https://en.wikipedia.org/wiki/Z\">Z</a></td>\n</tr>\n</tbody></table>\n</blockquote>\n<blockquote>\n<p>小写字母部分：</p>\n<table>\n<thead>\n<tr>\n<th><a href=\"https://en.wikipedia.org/wiki/Binary_numeral_system\">Binary</a></th>\n<th><a href=\"https://en.wikipedia.org/wiki/Octal\">Oct</a></th>\n<th><a href=\"https://en.wikipedia.org/wiki/Decimal\">Dec</a></th>\n<th><a href=\"https://en.wikipedia.org/wiki/Hexadecimal\">Hex</a></th>\n<th>Glyph</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>110 0001</td>\n<td>141</td>\n<td>97</td>\n<td>61</td>\n<td></td>\n<td><a href=\"https://en.wikipedia.org/wiki/A\">a</a></td>\n</tr>\n<tr>\n<td>110 0010</td>\n<td>142</td>\n<td>98</td>\n<td>62</td>\n<td></td>\n<td><a href=\"https://en.wikipedia.org/wiki/B\">b</a></td>\n</tr>\n<tr>\n<td>110 0011</td>\n<td>143</td>\n<td>99</td>\n<td>63</td>\n<td></td>\n<td><a href=\"https://en.wikipedia.org/wiki/C\">c</a></td>\n</tr>\n<tr>\n<td>110 0100</td>\n<td>144</td>\n<td>100</td>\n<td>64</td>\n<td></td>\n<td><a href=\"https://en.wikipedia.org/wiki/D\">d</a></td>\n</tr>\n<tr>\n<td>110 0101</td>\n<td>145</td>\n<td>101</td>\n<td>65</td>\n<td></td>\n<td><a href=\"https://en.wikipedia.org/wiki/E\">e</a></td>\n</tr>\n<tr>\n<td>110 0110</td>\n<td>146</td>\n<td>102</td>\n<td>66</td>\n<td></td>\n<td><a href=\"https://en.wikipedia.org/wiki/F\">f</a></td>\n</tr>\n<tr>\n<td>110 0111</td>\n<td>147</td>\n<td>103</td>\n<td>67</td>\n<td></td>\n<td><a href=\"https://en.wikipedia.org/wiki/G\">g</a></td>\n</tr>\n<tr>\n<td>110 1000</td>\n<td>150</td>\n<td>104</td>\n<td>68</td>\n<td></td>\n<td><a href=\"https://en.wikipedia.org/wiki/H\">h</a></td>\n</tr>\n<tr>\n<td>110 1001</td>\n<td>151</td>\n<td>105</td>\n<td>69</td>\n<td></td>\n<td><a href=\"https://en.wikipedia.org/wiki/I\">i</a></td>\n</tr>\n<tr>\n<td>110 1010</td>\n<td>152</td>\n<td>106</td>\n<td>6A</td>\n<td></td>\n<td><a href=\"https://en.wikipedia.org/wiki/J\">j</a></td>\n</tr>\n<tr>\n<td>110 1011</td>\n<td>153</td>\n<td>107</td>\n<td>6B</td>\n<td></td>\n<td><a href=\"https://en.wikipedia.org/wiki/K\">k</a></td>\n</tr>\n<tr>\n<td>110 1100</td>\n<td>154</td>\n<td>108</td>\n<td>6C</td>\n<td></td>\n<td><a href=\"https://en.wikipedia.org/wiki/L\">l</a></td>\n</tr>\n<tr>\n<td>110 1101</td>\n<td>155</td>\n<td>109</td>\n<td>6D</td>\n<td></td>\n<td><a href=\"https://en.wikipedia.org/wiki/M\">m</a></td>\n</tr>\n<tr>\n<td>110 1110</td>\n<td>156</td>\n<td>110</td>\n<td>6E</td>\n<td></td>\n<td><a href=\"https://en.wikipedia.org/wiki/N\">n</a></td>\n</tr>\n<tr>\n<td>110 1111</td>\n<td>157</td>\n<td>111</td>\n<td>6F</td>\n<td></td>\n<td><a href=\"https://en.wikipedia.org/wiki/O\">o</a></td>\n</tr>\n<tr>\n<td>111 0000</td>\n<td>160</td>\n<td>112</td>\n<td>70</td>\n<td></td>\n<td><a href=\"https://en.wikipedia.org/wiki/P\">p</a></td>\n</tr>\n<tr>\n<td>111 0001</td>\n<td>161</td>\n<td>113</td>\n<td>71</td>\n<td></td>\n<td><a href=\"https://en.wikipedia.org/wiki/Q\">q</a></td>\n</tr>\n<tr>\n<td>111 0010</td>\n<td>162</td>\n<td>114</td>\n<td>72</td>\n<td></td>\n<td><a href=\"https://en.wikipedia.org/wiki/R\">r</a></td>\n</tr>\n<tr>\n<td>111 0011</td>\n<td>163</td>\n<td>115</td>\n<td>73</td>\n<td></td>\n<td><a href=\"https://en.wikipedia.org/wiki/S\">s</a></td>\n</tr>\n<tr>\n<td>111 0100</td>\n<td>164</td>\n<td>116</td>\n<td>74</td>\n<td></td>\n<td><a href=\"https://en.wikipedia.org/wiki/T\">t</a></td>\n</tr>\n<tr>\n<td>111 0101</td>\n<td>165</td>\n<td>117</td>\n<td>75</td>\n<td></td>\n<td><a href=\"https://en.wikipedia.org/wiki/U\">u</a></td>\n</tr>\n<tr>\n<td>111 0110</td>\n<td>166</td>\n<td>118</td>\n<td>76</td>\n<td></td>\n<td><a href=\"https://en.wikipedia.org/wiki/V\">v</a></td>\n</tr>\n<tr>\n<td>111 0111</td>\n<td>167</td>\n<td>119</td>\n<td>77</td>\n<td></td>\n<td><a href=\"https://en.wikipedia.org/wiki/W\">w</a></td>\n</tr>\n<tr>\n<td>111 1000</td>\n<td>170</td>\n<td>120</td>\n<td>78</td>\n<td></td>\n<td><a href=\"https://en.wikipedia.org/wiki/X\">x</a></td>\n</tr>\n<tr>\n<td>111 1001</td>\n<td>171</td>\n<td>121</td>\n<td>79</td>\n<td></td>\n<td><a href=\"https://en.wikipedia.org/wiki/Y\">y</a></td>\n</tr>\n<tr>\n<td>111 1010</td>\n<td>172</td>\n<td>122</td>\n<td>7A</td>\n<td></td>\n<td><a href=\"https://en.wikipedia.org/wiki/Z\">z</a></td>\n</tr>\n</tbody></table>\n</blockquote>\n<h2 id=\"数字处理例子\"><a href=\"#数字处理例子\" class=\"headerlink\" title=\"数字处理例子\"></a>数字处理例子</h2><h3 id=\"1-高低位的处理\"><a href=\"#1-高低位的处理\" class=\"headerlink\" title=\"1.  高低位的处理\"></a>1.  高低位的处理</h3><blockquote>\n<p>核心是： </p>\n<ul>\n<li>取模得低位</li>\n<li>除数/右移得高位集合，或者说是去除最低位</li>\n</ul>\n</blockquote>\n<p>以10进制数 x 为例子， x%10得到最低位的数字，如果想要得到高位的数字，可以 for 循环 x/10 然后再使用x%10，这个取位值的方式是通用的，10可以换成其他的进制数。</p>\n<p>典型场景：</p>\n<p>给你一个整数 <code>x</code> ，如果 <code>x</code> 是一个回文整数，返回 <code>true</code> ；否则，返回 <code>false</code> ，回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p>\n<blockquote>\n<p><a href=\"https://leetcode.cn/problems/palindrome-number/\">9. 回文数 - 力扣（LeetCode）</a></p>\n</blockquote>\n<ul>\n<li><p>排除所有的负数和个位为0且不是0的数</p>\n</li>\n<li><p>获取高低位数来进行比较</p>\n</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 由于数字是整体具有大小的定义，不需要像是字符串那样需要按位比较，两数相同必定代表每一位的数字都相同，所以这个场景就可以换成取出整个数字的前半部分高位数和后半部分低位数，比较而这是否相同</span></span><br><span class=\"line\">front, back := x,<span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"comment\">// 如果是要比较回文数，那么低位数字需要倒序，执行逻辑是： %10获取该位数字，在下一轮使用*10将这个位数往左移一位（变成高位）</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> front &gt; back&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//先把当前地位数字向左移，然后在新的低位上加上新的数值</span></span><br><span class=\"line\">\tback = back*<span class=\"number\">10</span> + front%<span class=\"number\">10</span></span><br><span class=\"line\">    <span class=\"comment\">// 高位数字右移，直接丢弃最低位数字</span></span><br><span class=\"line\">\tfront = front/<span class=\"number\">10</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 要注意的是如果原数 x 有偶数位，那么循环后 back 和 front  的长度相同；如果x 是奇数位，那么循环后 back 会比 front 多一位，此时 back 的最低位是原数 x 的中间数，这个性质在求数位二分特征的时候可能有用</span></span><br></pre></td></tr></table></figure>\n\n<p>题目的解题代码为：</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">isPalindrome</span><span class=\"params\">(x <span class=\"type\">int</span>)</span></span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> x &lt; <span class=\"number\">0</span> || ( x%<span class=\"number\">10</span> == <span class=\"number\">0</span> &amp;&amp; x != <span class=\"number\">0</span> )&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    front, back := x,<span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> front &gt; back&#123;</span><br><span class=\"line\">        back = back*<span class=\"number\">10</span> + front%<span class=\"number\">10</span></span><br><span class=\"line\">        front = front/<span class=\"number\">10</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 最后比较二者是否相同</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> back == front || front == back/<span class=\"number\">10</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"2-进制转化\"><a href=\"#2-进制转化\" class=\"headerlink\" title=\"2. 进制转化\"></a>2. 进制转化</h3><p>已有调用可以借助 strconv 转化为 string 然后进行操作(比如16进制本来也只能string表示)</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 10进制转化为其他进制   </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> v <span class=\"type\">int64</span> = <span class=\"number\">12</span>              <span class=\"comment\">//默认10进制</span></span><br><span class=\"line\">   s2 := strconv.FormatInt(v, <span class=\"number\">2</span>) <span class=\"comment\">//10 转2进制</span></span><br><span class=\"line\">   fmt.Printf(<span class=\"string\">&quot;%v\\n&quot;</span>, s2)</span><br><span class=\"line\"> <span class=\"comment\">//10 转8进制</span></span><br><span class=\"line\">   s8 := strconv.FormatInt(v, <span class=\"number\">8</span>)</span><br><span class=\"line\">   fmt.Printf(<span class=\"string\">&quot;%v\\n&quot;</span>, s8)</span><br><span class=\"line\"> </span><br><span class=\"line\">   s10 := strconv.FormatInt(v, <span class=\"number\">10</span>)</span><br><span class=\"line\">   fmt.Printf(<span class=\"string\">&quot;%v\\n&quot;</span>, s10)</span><br><span class=\"line\"> <span class=\"comment\">//10 转16进制</span></span><br><span class=\"line\">   s16 := strconv.FormatInt(v, <span class=\"number\">16</span>) <span class=\"comment\">//10 yo 16</span></span><br><span class=\"line\">   fmt.Printf(<span class=\"string\">&quot;%v\\n&quot;</span>, s16)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// 其他进制转化为10进制</span></span><br><span class=\"line\">   <span class=\"keyword\">var</span> sv = <span class=\"string\">&quot;11&quot;</span></span><br><span class=\"line\">   fmt.Println(strconv.ParseInt(sv, <span class=\"number\">16</span>, <span class=\"number\">32</span>)) <span class=\"comment\">// 16 to 10</span></span><br><span class=\"line\">   fmt.Println(strconv.ParseInt(sv, <span class=\"number\">10</span>, <span class=\"number\">32</span>)) <span class=\"comment\">// 10 to 10</span></span><br><span class=\"line\">   fmt.Println(strconv.ParseInt(sv, <span class=\"number\">8</span>, <span class=\"number\">32</span>))  <span class=\"comment\">// 8 to 10</span></span><br><span class=\"line\">   fmt.Println(strconv.ParseInt(sv, <span class=\"number\">2</span>, <span class=\"number\">32</span>))  <span class=\"comment\">// 2 to 10</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-数字表示转化\"><a href=\"#3-数字表示转化\" class=\"headerlink\" title=\"3. 数字表示转化\"></a>3. 数字表示转化</h3><blockquote>\n<p>本质是字符匹配然后拼接，问题就在于需要有一个可以匹配的字典以及对应的值</p>\n<p>难点在于 []byte, int, string类型转化，数值计算与字符拆分拼接的等价关系，以及是否能够把组合类型元素全部枚举完毕</p>\n</blockquote>\n<p>一般常用的思路就是：</p>\n<ul>\n<li><p>从数字转字符 –&gt; 数字做减法，字符做拼接</p>\n</li>\n<li><p>从字符转数字 –&gt; 数字做加法，字符做拆分</p>\n</li>\n</ul>\n<p>一般根据各自的数特征来选择从高位还是低位开始，数值类型从低位加减，也就意味着字符从右到左遍历。</p>\n<p>比如将罗马数字转化位10进制整数，首先建立罗马数字与10进制数的对应关系map，然后从右到左遍历低位进行加数，期间注意罗马数字的特点：”小数在大数左边表示减法”</p>\n<blockquote>\n<p><a href=\"https://leetcode.cn/problems/roman-to-integer/\">13. 罗马数字转整数 - 力扣（LeetCode）</a></p>\n</blockquote>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 匹配的关键在于生成一张 字符和数字对应的表</span></span><br><span class=\"line\">m := <span class=\"keyword\">map</span>[<span class=\"type\">byte</span>]<span class=\"type\">int</span> &#123;<span class=\"string\">&#x27;I&#x27;</span>:<span class=\"number\">1</span>,<span class=\"string\">&#x27;V&#x27;</span>:<span class=\"number\">5</span>,<span class=\"string\">&#x27;X&#x27;</span>:<span class=\"number\">10</span>,<span class=\"string\">&#x27;L&#x27;</span>:<span class=\"number\">50</span>,<span class=\"string\">&#x27;C&#x27;</span>:<span class=\"number\">100</span>,<span class=\"string\">&#x27;D&#x27;</span>:<span class=\"number\">500</span>,<span class=\"string\">&#x27;M&#x27;</span>:<span class=\"number\">1000</span>&#125;</span><br><span class=\"line\"><span class=\"comment\">// 开始遍历罗马数字，并从表中找到它对应的数值，判断左右之后加在结果上</span></span><br><span class=\"line\"><span class=\"comment\">// 注意点1 ： 初始赋值为最右边的罗马数，因为他不可能为零</span></span><br><span class=\"line\">res := m[s[<span class=\"built_in\">len</span>(s)<span class=\"number\">-1</span>]]</span><br><span class=\"line\"><span class=\"keyword\">for</span> i := <span class=\"built_in\">len</span>(s)<span class=\"number\">-2</span>; i &gt;= <span class=\"number\">0</span> ; i--&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 注意点2 ： 大于等于条件，前后位罗马符号相同是加同一个值，不能漏了等号</span></span><br><span class=\"line\">     <span class=\"keyword\">if</span> m[s[i]] &gt;= m[s[i+<span class=\"number\">1</span>]] &#123;</span><br><span class=\"line\">        res = res + m[s[i]]</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> m[s[i]] &lt; m[s[i+<span class=\"number\">1</span>]] &#123;</span><br><span class=\"line\">        res = res - m[s[i]]</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> res</span><br></pre></td></tr></table></figure>\n\n<p>反过来要将一个10进制整数转化位罗马数字，遍历的就是10进制数，然后找他对应的罗马数字；</p>\n<blockquote>\n<p><a href=\"https://leetcode.cn/problems/integer-to-roman/solution/\">12. 整数转罗马数字 题解 - 力扣（LeetCode）</a></p>\n</blockquote>\n<p>但前一问运算简便是因为 10 进制加减覆盖了罗马数字的所有计算可排列组合，但是反过来的时候 10 进制数的每一位计算不一定都能找到罗马数字标识，比如 9 在罗马数字当中就存在非顺序的表达方式。由于这个特性就需要像是拼接组件一样去凑（说成贪心也可以）这个数字，也就是从左到右，先找大数再找小数，先从目标数字里面剪出所有的大数，然后找大数对应的罗马数字表示，逐个拼接。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> m = []<span class=\"type\">int</span>&#123;<span class=\"number\">1000</span>,<span class=\"number\">900</span>,<span class=\"number\">500</span>,<span class=\"number\">400</span>,<span class=\"number\">100</span>,<span class=\"number\">90</span>,<span class=\"number\">50</span>,<span class=\"number\">40</span>,<span class=\"number\">10</span>,<span class=\"number\">9</span>,<span class=\"number\">5</span>,<span class=\"number\">4</span>,<span class=\"number\">1</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> v = []<span class=\"type\">string</span>&#123;<span class=\"string\">&quot;M&quot;</span>,<span class=\"string\">&quot;CM&quot;</span>,<span class=\"string\">&quot;D&quot;</span>,<span class=\"string\">&quot;CD&quot;</span>,<span class=\"string\">&quot;C&quot;</span>,<span class=\"string\">&quot;XC&quot;</span>,<span class=\"string\">&quot;L&quot;</span>,<span class=\"string\">&quot;XL&quot;</span>,<span class=\"string\">&quot;X&quot;</span>,<span class=\"string\">&quot;IX&quot;</span>,<span class=\"string\">&quot;V&quot;</span>,<span class=\"string\">&quot;IV&quot;</span>,<span class=\"string\">&quot;I&quot;</span>&#125;</span><br><span class=\"line\"><span class=\"comment\">// 从左到右来遍历先减去大数，加上罗马数字</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">intToRoman</span><span class=\"params\">(num <span class=\"type\">int</span>)</span></span> <span class=\"type\">string</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> res <span class=\"type\">string</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(v); i++&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> num &gt;= m[i] &#123;</span><br><span class=\"line\">            num = num-m[i]</span><br><span class=\"line\">            res = res + v[i]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里唯一要注意的应该就是 Golang 当中字符串的拼接处理了，详情看</p>\n<p>同样的逻辑可以用到其他的转化情况，比如随意字符串转数字，一定先确认数字映射关系的字典，然后来做字符串的匹配，然后转化为数字的计算。</p>\n"},{"title":"Go 系统知识汇总","catalog":true,"date":"2023-04-01T12:57:34.000Z","subtitle":null,"header-img":null,"_content":"- [Golang 系统知识回答收集](#golang-系统知识回答收集)\n  - [Golang 语法方面](#golang-语法方面)\n    - [Golang关键字有哪些](#golang关键字有哪些)\n    - [Golang 当中](#golang-当中)\n    - [range 函数的具体使用](#range-函数的具体使用)\n    - [Slice 扩容机制](#slice-扩容机制)\n    - [Slice 为什么不是线程安全的](#slice-为什么不是线程安全的)\n    - [map的底层原理](#map的底层原理)\n    - [map的扩容机制](#map的扩容机制)\n    - [map的遍历为什么无序](#map的遍历为什么无序)\n    - [map的底层存储不是连续的](#map的底层存储不是连续的)\n    - [map 为什么不是线程安全的](#map-为什么不是线程安全的)\n    - [Map如何查找](#map如何查找)\n    - [map 冲突解决的方式](#map-冲突解决的方式)\n    - [map 的负载因子为什么时6.5](#map-的负载因子为什么时65)\n    - [Map和 Sync.Map哪一个性能好](#map和-syncmap哪一个性能好)\n    - [channel 底层实现原理](#channel-底层实现原理)\n    - [channel 有什么特点](#channel-有什么特点)\n    - [Channel 的使用场景](#channel-的使用场景)\n    - [channel 为什么是线程安全的](#channel-为什么是线程安全的)\n    - [Channel 发送和接收什么情况下会死锁](#channel-发送和接收什么情况下会死锁)\n    - [互斥锁实现原理](#互斥锁实现原理)\n    - [悲观锁与乐观锁](#悲观锁与乐观锁)\n    - [原子操作和锁的区别](#原子操作和锁的区别)\n    - [互斥锁允许自旋的条件](#互斥锁允许自旋的条件)\n    - [读写锁的实现原理](#读写锁的实现原理)\n    - [\"原子操作\"有哪些](#原子操作有哪些)\n    - [Goroutine 的底层实现原理](#goroutine-的底层实现原理)\n    - [](#)\n    - [goroutine 和线程的区别](#goroutine-和线程的区别)\n    - [Go 线程模型（Go底层怎么实现高并发的）](#go-线程模型go底层怎么实现高并发的)\n    - [Golang assertion](#golang-assertion)\n  - [Golang调用方面](#golang调用方面)\n    - [len 统计长度](#len-统计长度)\n\n\n# Golang 系统知识回答收集\n\n## Golang 语法方面\n\n### Golang关键字有哪些\n\n### Golang 当中\n关键字是指被编程语言用作特定目的的保留单词，这些关键字在代码当中具有特殊的含义，不能被用作标识符（例如变量名，函数名，类型名等）。以下是Golang中关键字的列表\n\n```go\nfunc \ntype \n\ninterface \nstruct \nvar\n\nbreak continue \n\ndefault\n\ncase \nselect\ndefer\nswitch\nfor \nrange \ngoto\nelse\nif\n\nconst\nchan \nmap\n\nimport\npackage\n\ngo\nreturn \n\nfallthrough\n\n```\n\n### range 函数的具体使用\n\ngolang当中range 关键字可以用于迭代数组、切片、字符串、map和通道等数据类型\n\n```go\n//迭代数组和切片时候，返回当前元素的索引和值\narr := [3]int{1,2,3}\nfor key,num := range arr{\n\tfmt.Printf(\"now arr[%d] is %d\\n\", key,num)\n}\n\n// map 迭代字符串的时候，每次迭代返回当前字符的索引和Unicode码点\n\ns := \"hello world\"\nfor i, c := range s{\n\tfmt.Printf(\"index:%d, Unicode code ponit : %U\\n\",i,c)\n}\n\n//迭代map结构\nm := map[int]string{\n\t1: \"one\",\n\t2: \"two\",\n\t3: \"three\",\n}\nfor k,v := range m{\n\tfmt.Printf(\"key : %d, value : %s\",k,v)\n\n}\n\n//迭代通道使用range 迭代通道的时候，会不断地从通道当中接受元素，直到通道关闭为止\n\nch := make(chan int)\ngo func() {\n\tfor i := 0;i<5,i++{\n\tch <- i\n\t}\n\tclose(ch)\n}()\n\nfor v := range ch {\n\tfmt.Println(v)\n}\n```\n\n在迭代通道的时候，如果通道没有关闭，那么循环就会一直等待下去，知道程序死锁，因此必须要再写入完所有的数据之后关闭通道，或者使用'select'语句在接受通道数据的时候检查通道是否已经关闭\n\n\n### Slice 扩容机制\n\nGo 1.18 版本之后，当新切片需要的容量cap大于两倍扩容的容量时候，则直接按照新切片需要的容量进行扩容：\n\n* 当原 Slice 容量 < threshold 的时候，新 slice 容量变成原来的2 倍\n* 当原 Slice 容量 > threshold 的时候，进入一个循环，每次容量增加 （旧容量 + 3*threshold）/4\n\n\n### Slice 为什么不是线程安全的\n\n因为 Slice 内部使用了底层数组，数组在内存当中是连续存储的并没有加锁的机制，本身并不支持并发的读写\n\n当多个Goroutine并发访问同一个Slice的时候，可能存在某个Goroutine修改了Slice中的某个元素，其他Goroutine无法立即看到这个修改，也可能会造成竞争问题。可以通过使用((20230318150223-agvrll2 \"互斥锁\"))或者((20230318154221-miv3alf \"原子操作\"))来保证某个Goroutine访问的时候其他goroutine不能够同时访问，另外也可以使用通道来进行同步，通过将Slice的访问权限交给某个Goroutine，从而保障其他的Goroutine无法同时访问该Slice。\n\n\n\n### map的底层原理\n\nmap对象本身是一个指针，占用8个字节（64位计算机），指向`hmap`结构体，hmap包含多个bmap数组（桶）\n\n```go\ntype hmap struct{\n\tcount int // 元素个数，调用len(map)的时候直接返回\n\tflags uint8 // 标志当前map的状态，正在删除元素、添加元素、、、、\n\tB uint8 //单元(buckets)的对数 B=5表示能容纳32个元素  B随着map容量增大而变大\n\n\tnoverflow uint16  //单元(buckets)溢出数量，如果一个单元能存8个key，此时存储了9个，溢出了，就需要再增加一个单元\n\thash0 uint32 //哈希种子\n\tbuckets unsafe.Pointer //指向单元(buckets)数组,大小为2^B，可以为nil\n\toldbuckets unsafe.Pointer //扩容的时候，buckets长度会是oldbuckets的两倍\n\tnevacute uintptr  //指示扩容进度，小于此buckets迁移完成 \n\textra *mapextra //与gc相关 可选字段 \n}\n\ntype bmap struct{\n\ttophash [bucketCnt]uint8 \n}\n//实际上编译期间会生成一个新的数据结构  \ntype bmap struct { \n    topbits [8]uint8     //key hash值前8位 用于快速定位keys的位置\n    keys [8]keytype     //键\n    values [8]valuetype //值\n    pad uintptr \n    overflow uintptr     //指向溢出桶 无符号整形 优化GC\n}\n\n```\n\n\n### map的扩容机制\n\n扩容时机：向map里面插入新的key的时候，会进行条件检测，符合以下两个条件就会触发扩容操作：\n\n扩容条件：\n\n1. 超过负载 map元素个数 > 负载因子 * 桶个数\n2. 溢出桶太多\n\n负载因子是元素个数与桶的数量的比值\n\n当桶总数<2^15^时，如果溢出桶总数>=桶总数，则认为溢出桶过多\n\n当桶总数>2^15^时，如果溢出桶总数>=2^15^，则认为溢出桶过多\n\n\n扩容机制：\n\n* 双倍扩容：针对条件1，新建一个buckets数组，新的buckets大小是原来的2倍，然后旧buckets数据搬迁到新的buckets。\n* 等量扩容：针对条件2，并不扩大容量，buckets数量维持不变，重新做一遍类似双倍扩容的搬迁动作，把松散的键值对重新排列一次，使得同一个 bucket 中的 key 排列地更紧密，节省空间，提高 bucket 利用率，进而保证更快的存取。\n\n* 渐进式扩容： 插入修改删除key的时候，都会尝试进行搬迁桶的工作，每次都会检查oldbucket是否**nil**，如果不是**nil**则每次搬迁**2**个桶，蚂蚁搬家一样渐进式扩容\n\n\n### map的遍历为什么无序\n\nmap  每次遍历，都会从一个随机值序号的桶开始，再从其中随机的cell 开始遍历，并且扩容后，原来桶中的key会落到其他的桶中，本身就会造成失序。\n\n如果想要遍历map，先把key放到切片中排序，再按照key的顺序遍历map\n\n```go\n//请写一段代码验证\nm := map[int]string {\n\t1: \"one\",\n\t2: \"two\",\n\t3: \"three\",\n}\n\nfor key,value := range m{\n\tfmt.Printf(\"data is : %d ---> %S \\n\", key,value)\n}\n\n```\n\n\n### map的底层存储不是连续的\n\n具体来说map 内部存储的是一个桶（bucket）数组，桶数组中的每个元素有事一个指向链表头的指针，他存储的数据并不连续\n\n\n### map 为什么不是线程安全的\n\n多个协程同时对**map**进行并发读写**,**程序会**panic**\n\n想要线程安全，可以使用sync.RWLock锁\n\n在sync.map 这个包当中实现了锁，是线程安全的\n\n\n### Map如何查找\n\n1. 计算hash值\n    key经过哈希函数计算后,得到64bit(64位CPU)\n    10010111 | 101011101010110101010101101010101010 | 10010\n2. 找到hash对应的桶\n    上面64位后5(hmap的B值)位定位所存放的桶\n    如果当前正在扩容中,并且定位到旧桶数据还未完成迁移,则使用旧的桶\n3. 遍历桶查找\n    上面64位前8位用来在tophash数组查找快速判断key是否在当前的桶中,如果不在需要去溢出桶查找\n4. 返回key对应的指针\n\n\n\n### map 冲突解决的方式\n\nGo采用链式地址解决冲突，具体实现就是插入key到map中时，当key定位的桶填满8个元素，将会创建一个溢出桶并且将溢出桶插入到当前桶所在的链表尾部\n\nGolang当中采用链式哈希表（Cahined Hash Table）\n\n在Golang的哈希表实现当中，每一个桶就是一个链表的头指针，桶内每个元素都是哈希链表节点，节点包含了该元素的哈希值、键以及指向下一个节点的指针。\n\n在查找时候，先根据键的哈希值找到对应的桶，然后在该桶对应的链表中顺序查找，指导找到目标元素或者是链表遍历完毕。\n\n\n### map 的负载因子为什么时6.5\n\n> 负载因子 = 哈希表存储的元素个数 / 桶个数\n\nGo 官方发现：装载因子越大，填入的元素越多，空间利用率就越高，但发生哈希冲突的几率就变大。\n装载因子越小，填入的元素越少，冲突发生的几率减小，但空间浪费也会变得更多，而且还会提高扩容操作的次数\n\nGo 官方取了一个相对适中的值，把 Go 中的 map 的负载因子硬编码为 6.5，这就是 6.5 的选择缘由。\n\n这意味着在 Go 语言中，当 map存储的元素个数大于或等于 6.5 * 桶个数 时，就会触发扩容行为。\n\n\n### Map和 Sync.Map哪一个性能好\n\n对比原始map：\n\n和原始map+RWLock的实现并发的方式相比，减少了加锁对性能的影响。\n\n它做了一些优化：可以无锁访问read map，而且会优先操作read map，倘若只操作read map就可以满足要求，那就不用去操作write map(dirty)，所以在某些特定场景中它发生锁竞争的频率会远远小于map+RWLock的实现方式\n\n* 优点：\n  适合读多写少的场景\n* 缺点：\n  写多的场景，会导致 read map 缓存失效，需要加锁，冲突变多，性能急剧下降\n\n\n\n### channel 底层实现原理\n\n通过**var****声明或者是**​**make****函数创建的channel变量**是一个存储在函数栈帧上的指针，占用8个字节，指向堆上的hchan结构体\n\n```go\ntype hchan struct{\n\tclosed uint32 // channel 是否关闭的标志\n\telemtype *_type // channel 中的元素类型\n\n\tbuf unsafe.Pointer //指向底层循环数组的指针（环形缓存区）\n\tqcount uint // 循环数组中的元素数量\n\tdataqsiz uint //循环数组的长度\n\telemsize uint16 //元素的大小\n\tsendx uint // 下一次写下标的位置\n\trecvx uint // 下一次读下标的位置\n\t// 尝试读取channel 或者向channel 写入数据而被阻塞的goroutine\n    \trecvq    waitq  // 读等待队列\n    \tsendq    waitq  // 写等待队列\n    \tlock mutex //互斥锁，保证读写channel时不存在并发竞争问题\n}\n```\n\nchannel 分为无缓冲和有缓冲两种\n\n* 对于有缓冲的channel存储数据，使用了ring buffer(环形缓冲区) 来缓存写入的数据，本质是循环数组。\n\n  为啥是循环数组呢？普通数组不行吗，普通数组容量固定，更适合指定的空间，弹出元素的时候，普通数组需要全部前移。\n\n  `当下标超过数组容量后会回到第一个位置，所以需要有两个字段记录当前读和写的下标位置`\n\n* 对于无缓冲的channel 存储数据\n\n等待队列： \n\n双向链表，包含一个头结点和一个尾结点 每个节点是一个sudog结构体变量，记录哪个协程在等待，等待的是哪个channel，等待发送**/**接收的数据在哪里\n\n```go\ntype wait struct{\n\tfirst *sudog\n\tlast *sudog\n}\n\ntype sudog struct{\n\tg *g\n\tnext *sudog\n\tpre  *sudog\n\telem unsafe.Pointer\n\tc  *hchan\n\t...\n}\n```\n\n\n创建 channel 的时候：\n\n创建时会做一些检查**:** \n\n* 元素大小不能超过 **64**K\n* 元素的对齐大小不能超过 maxAlign 也就是 **8** 字节\n* 计算出来的内存是否超过限制\n\n创建时的策略:\n\n* 如果是无缓冲的channel，会直接给hchan 分配内存\n* 如果是有缓冲的channel，并且元素不包含指针，那么会为 hchan  和底层数组分配一段连续的地址\n\n* 如果是有缓冲的channel，元素包含指针，那么就会为了hchan 和底层数组分别分配地址\n\n发送时：\n\n* 如果 channel 的读队列存在着接收者 goroutine，将唤醒接收的goroutine，将数据**直接发送**给第一个等待的 goroutine\n\n* 如果channel 的读等待队列不存在接收者 goroutine\n\n  * 如果循环数组buffer未满，那么将会把数据发送到循环数组buffer的队尾\n  * 如果循环数组buffer已满，这个时候就会阻塞发送的流程，将当前goroutine加入写等待队列，**并挂起等待唤醒**\n\n接收时：\n\n* 如果 channel 的写等待队列存在发送者 goroutine\n\n  * 如果是无缓冲 channel ，**直接**从第一个发送者goroutine 那里 把数据拷贝给接受变量，**唤醒 发送的goroutine**\n  * 如果是有缓冲的 channel（已满），将循环数组的buffer的队首元素拷贝给接受变量，将第一个发送者goroutine的数据拷贝到buffer循环数组的队尾，**唤醒发送的goroutine**\n* 如果channel 的写等待队列不存在发送者goroutine\n\n  * 如果循环数组buffer非空，将循环数组buffer的队首元素拷贝给接受变量\n  * 如果循环数组buffer为空，这个时候就会阻塞接收的流程，将当前goroutine 加入读等待队列，并**挂起等待唤醒**\n\n\n### channel 有什么特点\n\nchannel是线程安全的\n\nchannel 有两种类型： 无缓冲、有缓冲\n\nchannel 有三种模式： 写操作模式（单向通道）、读操作模式（单向通道）、读写操作模式（双向通道）\n\n```go\n写操作模式    make(chan<- int)\n读操作模式    make(<-chan int)\n读写操作模式    make(chan int)\n```\n\nchannel 有 3 种状态：未初始化、正常、关闭\n\n| 操作 \\ 状态 | 未初始化         | 关闭                               | 正常             |\n| ------------- | ------------------ | ------------------------------------ | ------------------ |\n| 关闭        | panic            | panic                              | 正常             |\n| 发送        | 永远阻塞导致死锁 | panic                              | 阻塞或者成功发送 |\n| 接收        | 永远阻塞导致死锁 | 缓冲区为空则为零值，否则可以继续读 | 阻塞或者成功接收 |\n\n注意点：\n\n* 一个 channel不能多次关闭，会导致painc\n\n* 如果多个 goroutine 都监听同一个 channel，那么 channel 上的数据都可能随机被某一个 goroutine 取走进行消费\n* 如果多个 goroutine 监听同一个 channel，如果这个 channel 被关闭，则所有 goroutine 都能收到退出信号\n\n### Channel 的使用场景\n\n无缓冲 Channel 在并发编程中的具体业务使用场景很多，主要应用于 Go 语言中。以下是一些常见的无缓冲 Channel 的具体业务使用场景及例子：\n\n1. 并发控制：在并发程序中，通过无缓冲 Channel 可以实现多个 Goroutine 之间的**同步和控制**。例如，一个任务需要多个协程协作完成时，可以使用无缓冲 Channel 来传递任务数据和控制信号。\n2. 事件驱动：在事件驱动的编程中，可以使用无缓冲 Channel 来传递事件和执行结果。例如，当一个 HTTP 请求到达时，可以将请求交给一个协程处理，并使用无缓冲 Channel 返回处理结果。\n3. 分布式计算：在分布式计算中，可以使用无缓冲 Channel 来实现节点之间的通信和数据传递。例如，在 MapReduce 算法中，可以使用无缓冲 Channel 来传递 Map 阶段的输出结果并驱动 Reduce 阶段的计算。\n\n有缓冲 Channel 在并发编程中的具体业务使用场景也很多，主要应用于 Go 语言中。以下是一些常见的有缓冲 Channel 的具体业务使用场景及例子：\n\n1. 网络编程：在 TCP 或 UDP 数据处理中，可以使用有缓冲 Channel 缓存数据，**以避免因数据接收太慢而导致发送者被阻塞**。例如，在高并发的 Web 服务器中，可以使用有缓冲 Channel 缓存请求数据以提高吞吐量。\n2. IO 操作：在使用 IO 操作时，如文件读写、数据库访问等，可以使用有缓冲 Channel 缓存数据，以避免因数据处理速度不匹配而导致发送者或接收者被阻塞。例如，**在从数据库获取大量数据时，可以使用有缓冲 Channel 缓存数据，减少数据库连接次数。**\n3. 并发控制：在并发程序中，通过有缓冲 Channel 可以实现多个 Goroutine 之间的同步和控制。例如，一个任务需要多个协程协作完成时，可以使用有缓冲 Channel 来传递任务数据和控制信号，并根据缓冲区的剩余空间来控制协程的执行顺序。\n4. 事件驱动：在事件驱动的编程中，可以使用有缓冲 Channel 来缓存事件和执行结果，并根据缓冲区的剩余空间来控制事件的处理顺序。例如，当一个 HTTP 请求到达时，可以将请求交给一个协程处理，并使用有缓冲 Channel 缓存处理结果，避免处理速度过慢导致请求被阻塞。\n\n\n### channel 为什么是线程安全的\n\n不同协程通过channel进行通信，本身的使用场景就是多线程，为了保证数据的一致性，必须实现线程安全\n\n\nchannel的底层实现中，hchan结构体中采用Mutex锁来保证数据读写安全。在对循环数组buf中的数据进行入队和出队操作时，必须先获取互斥锁，才能操作channel数据\n\n\n### Channel 发送和接收什么情况下会死锁\n\n```go\nfunc deadlock1() {    //无缓冲channel只写不读\n    ch := make(chan int) \n    ch <- 3 //  这里会发生一直阻塞的情况，执行不到下面一句\n}\nfunc deadlock2() { //无缓冲channel读在写后面\n    ch := make(chan int)\n    ch <- 3  //  这里会发生一直阻塞的情况，执行不到下面一句\n    num := <-ch\n    fmt.Println(\"num=\", num)\n}\nfunc deadlock3() { //无缓冲channel读在写后面\n    ch := make(chan int)\n    ch <- 100 //  这里会发生一直阻塞的情况，执行不到下面一句\n    go func() {\n        num := <-ch\n        fmt.Println(\"num=\", num)\n    }()\n    time.Sleep(time.Second)\n}\nfunc deadlock3() {    //有缓冲channel写入超过缓冲区数量\n    ch := make(chan int, 3)\n    ch <- 3\n    ch <- 4\n    ch <- 5\n    ch <- 6  //  这里会发生一直阻塞的情况\n}\nfunc deadlock4() {    //空读\n    ch := make(chan int)\n    // ch := make(chan int, 1)\n    fmt.Println(<-ch)  //  这里会发生一直阻塞的情况\n}\nfunc deadlock5() {    //互相等对方造成死锁\n    ch1 := make(chan int)\n    ch2 := make(chan int)\n    go func() {\n        for {\n        select {\n        case num := <-ch1:\n            fmt.Println(\"num=\", num)\n            ch2 <- 100\n        }\n    }\n    }()\n    for {\n        select {\n        case num := <-ch2:\n            fmt.Println(\"num=\", num)\n            ch1 <- 300\n        }\n    }\n}\n```\n\n### 互斥锁实现原理\n\nGo sync包提供了两种锁类型：互斥锁sync.Mutex 和 读写互斥锁sync.RWMutex，都属于((20230402113517-ppcs0gj \"悲观锁\"))。\n[https://blog.csdn.net/baolingye/article/details/111357407](https://blog.csdn.net/baolingye/article/details/111357407)\n\n在正常模式下，**锁的等待者会按照先进先出的顺序获取锁**。但是刚被唤起的 Goroutine 与新创建的 Goroutine 竞争时，大概率会获取不到锁，在这种情况下，这个被唤醒的 Goroutine 会加入到等待队列的前面。 如果一个等待的 Goroutine 超过1ms 没有获取锁，那么它将会把锁转变为**饥饿模式**。\nGo在1.9中引入优化，目的保证互斥锁的公平性。在饥饿模式中，互斥锁会直接交给等待队列最前面的 Goroutine。新的 Goroutine 在该状态下不能获取锁、也不会进入自旋状态，它们只会在队列的末尾等待。如果一个 Goroutine 获得了互斥锁并且它在队列的末尾或者它等待的时间少于 1ms，那么当前的互斥锁就会切换回正常模式。\n\n\n### 悲观锁与乐观锁\n\n**悲观锁**是基于一种悲观的态度类来防止一切数据冲突，它是以一种预防的姿态在**修改数据之前把数据锁住，然后再对数据进行读写，在它释放锁之前任何人都不能对其数据进行操作，直到前面一个人把锁释放后下一个人数据加锁才可对数据进行加锁，**然后才可以对数据进行操作，一般数据库本身锁的机制都是基于悲观锁的机制实现的;\n\n特点：可以完全保证数据的独占性和正确性，因为每次请求都会先对数据进行加锁， 然后进行数据操作，最后再解锁，而加锁释放锁的过程会造成消耗，所以性能不高;\n\n\n**乐观锁**是对于数据冲突保持一种乐观态度，操作数据时不会对操作的数据进行加锁（这使得多个任务可以并行的对数据进行操作），只有到数据提交的时候才通过一种机制来验证数据是否存在冲突(一般实现方式是通过加版本号然后进行版本号的对比方式实现);\n\n特点：乐观锁是一种并发类型的锁，其本身不对数据进行加锁通而是通过业务实现锁的功能，不对数据进行加锁就意味着允许多个请求同时访问数据，同时也省掉了对数据加锁和解锁的过程，这种方式因为节省了悲观锁加锁的操作，所以可以一定程度的的提高操作的性能，不过在并发非常高的情况下，会导致大量的请求冲突，冲突导致大部分操作无功而返而浪费资源，所以在高并发的场景下，乐观锁的性能却反而不如悲观锁。\n\n\n\n### 原子操作和锁的区别\n\n在并发编程里，Go语言`sync`包里的同步原语`Mutex`是我们经常用来保证并发安全的，那么他跟`atomic`包里的这些操作有啥区别呢？在我看来他们在使用目的和底层实现上都不一样：\n\n* 使用目的：互斥锁是用来保护一段逻辑，原子操作用于对一个变量的更新保护。\n* 底层实现：`Mutex`由**操作系统**的调度器实现，而`atomic`包中的原子操作则由**底层硬件指令**直接提供支持，这些指令在执行的过程中是不允许中断的，因此原子操作可以在`lock-free`的情况下保证并发安全，并且它的性能也能做到随`CPU`个数的增多而线性扩展。\n\n\n\n\n### 互斥锁允许自旋的条件\n\n线程没有获取到锁时常见有2种处理方式：\n\n* 一种是没有获取到锁的线程就会循环等待判断该资源是否已经释放锁，这种锁也叫做自旋锁，它不用将线程阻塞起来， 适用于并发低且程序执行时间短的场景，缺点是cpu占用较高\n* 另外一种处理方式就是把自己阻塞起来，会释放CPU给其他线程，内核会将线程置为「睡眠」状态，等到锁被释放后，内核会在合适的时机唤醒该线程，适用于高并发场景，缺点是有线程上下文切换的开销\n  Go语言中的Mutex实现了自旋与阻塞两种场景，当满足不了自旋条件时，就会进入阻塞\n  **允许自旋的条件：**\n\n1. 锁已被占用，并且锁不处于饥饿模式。\n2. 积累的自旋次数小于最大自旋次数（active_spin=4）。\n3. cpu 核数大于 1。\n4. 有空闲的 P。\n5. 当前 goroutine 所挂载的 P 下，本地待运行队列为空。\n\n\n### 读写锁的实现原理\n\n读写锁的底层是基于互斥锁实现的。\n写锁需要阻塞写锁：一个协程拥有写锁时，其他协程写锁定需要阻塞；\n写锁需要阻塞读锁：一个协程拥有写锁时，其他协程读锁定需要阻塞；\n读锁需要阻塞写锁：一个协程拥有读锁时，其他协程写锁定需要阻塞；\n**读锁不能阻塞读锁：一个协程拥有读锁时，其他协程也可以拥有读锁。**\n\n\n### \"原子操作\"有哪些\n\nGo atomic包是最轻量级的锁（也称无锁结构），可以在不形成临界区和创建互斥量的情况下完成并发安全的值替换操作，不过这个包只支持int32/int64/uint32/uint64/uintptr这几种数据类型的一些基础操作（增减、交换、载入、存储等）\n当我们想要对**某个变量**并发安全的修改，除了使用官方提供的 `mutex`，还可以使用 sync/atomic 包的原子操作，它能够保证对变量的读取或修改期间不被其他的协程所影响。\natomic 包提供的原子操作能够确保任一时刻只有一个goroutine对变量进行操作，善用 atomic 能够避免程序中出现大量的锁操作。\n**常见操作：**\n\n* 增减Add     AddInt32 AddInt64 AddUint32 AddUint64 AddUintptr\n* 载入Load    LoadInt32 LoadInt64    LoadPointer    LoadUint32    LoadUint64    LoadUintptr\n* 比较并交换   CompareAndSwap    CompareAndSwapInt32...\n* 交换Swap    SwapInt32...\n* 存储Store    StoreInt32...\n\n\n### Goroutine 的底层实现原理\n\n```go\ng本质是一个数据结构,真正让 goroutine 运行起来的是调度器\ntype g struct { \n    goid int64  // 唯一的goroutine的ID \n    sched gobuf // goroutine切换时，用于保存g的上下文 \n    stack stack // 栈 \n    gopc // pc of go statement that created this goroutine \n    startpc uintptr  // pc of goroutine function ... \n} \ntype gobuf struct {     //运行时寄存器\n    sp uintptr  // 栈指针位置 \n    pc uintptr  // 运行到的程序位置 \n    g  guintptr // 指向 goroutine \n    ret uintptr // 保存系统调用的返回值 ... \n} \ntype stack struct {     //运行时栈\n    lo uintptr  // 栈的下界内存地址 \n    hi uintptr  // 栈的上界内存地址 \n}\n```\n\n### \n\n### goroutine 和线程的区别\n\n内存占用:\n创建一个 goroutine 的栈内存消耗为 2 KB，实际运行过程中，如果栈空间不够用，会自动进行扩容。创建一个 thread 则需要消耗 1 MB 栈内存。\n创建和销毀:\nThread 创建和销毀需要陷入内核,系统调用。而 goroutine 因为是由 Go runtime 负责管理的，创建和销毁的消耗非常小，是用户级。\n切换:\n当 threads 切换时，需要保存各种寄存器,而 goroutines 切换只需保存三个寄存器：Program Counter, Stack Pointer and BP。一般而言，线程切换会消耗 1000-1500 ns,Goroutine 的切换约为 200 ns,因此，goroutines 切换成本比 threads 要小得多。\n\n\n### Go 线程模型（Go底层怎么实现高并发的）\n\n> 线程协程，进程的区别：\n>\n> [https://zhuanlan.zhihu.com/p/337978321](https://zhuanlan.zhihu.com/p/337978321)\n>\n> [https://www.bilibili.com/read/cv9346691/](https://www.bilibili.com/read/cv9346691/)\n\nGolang的调度器是一个轻量级的协程调度器，主要负责管理和调度协程。Golang 中的调度器采用 **M:N 模型**，即 M 个用户级线程对应 N 个内核线程。\n\n调度器会将 Golang 中的协程（goroutine）调度到不同的线程上运行，以实现并发执行的效果。\n\nM个线程对应N个内核线程的优点：\n\n* 能够利用多核\n* 上下文切换成本低\n* 如果进程中的一个线程被阻塞，不会阻塞其他线程，是能够切换同一进程内的其他线程继续执行\n\n### Golang assertion \n\n## Golang调用方面\n\n### len 统计长度\n<font color = 'red'>len()计算的是字节的长度，和编码无关，对于英文和数组对象等，字节长度等效于实际长度</font>\n当需要计算中文字符长度的时候，就需要调用其他的函数方法：\n`utf8.RuneCountInString(\"中文\")`\n","source":"_posts/Go/Go-enhanced-knowledge/Go 系统知识汇总.md","raw":"---\ntitle: Go 系统知识汇总\ncatalog: true\ndate: 2023-04-01 20:57:34\nsubtitle:\nheader-img:\ntags:\ncategories: \n    - enhanced\n---\n- [Golang 系统知识回答收集](#golang-系统知识回答收集)\n  - [Golang 语法方面](#golang-语法方面)\n    - [Golang关键字有哪些](#golang关键字有哪些)\n    - [Golang 当中](#golang-当中)\n    - [range 函数的具体使用](#range-函数的具体使用)\n    - [Slice 扩容机制](#slice-扩容机制)\n    - [Slice 为什么不是线程安全的](#slice-为什么不是线程安全的)\n    - [map的底层原理](#map的底层原理)\n    - [map的扩容机制](#map的扩容机制)\n    - [map的遍历为什么无序](#map的遍历为什么无序)\n    - [map的底层存储不是连续的](#map的底层存储不是连续的)\n    - [map 为什么不是线程安全的](#map-为什么不是线程安全的)\n    - [Map如何查找](#map如何查找)\n    - [map 冲突解决的方式](#map-冲突解决的方式)\n    - [map 的负载因子为什么时6.5](#map-的负载因子为什么时65)\n    - [Map和 Sync.Map哪一个性能好](#map和-syncmap哪一个性能好)\n    - [channel 底层实现原理](#channel-底层实现原理)\n    - [channel 有什么特点](#channel-有什么特点)\n    - [Channel 的使用场景](#channel-的使用场景)\n    - [channel 为什么是线程安全的](#channel-为什么是线程安全的)\n    - [Channel 发送和接收什么情况下会死锁](#channel-发送和接收什么情况下会死锁)\n    - [互斥锁实现原理](#互斥锁实现原理)\n    - [悲观锁与乐观锁](#悲观锁与乐观锁)\n    - [原子操作和锁的区别](#原子操作和锁的区别)\n    - [互斥锁允许自旋的条件](#互斥锁允许自旋的条件)\n    - [读写锁的实现原理](#读写锁的实现原理)\n    - [\"原子操作\"有哪些](#原子操作有哪些)\n    - [Goroutine 的底层实现原理](#goroutine-的底层实现原理)\n    - [](#)\n    - [goroutine 和线程的区别](#goroutine-和线程的区别)\n    - [Go 线程模型（Go底层怎么实现高并发的）](#go-线程模型go底层怎么实现高并发的)\n    - [Golang assertion](#golang-assertion)\n  - [Golang调用方面](#golang调用方面)\n    - [len 统计长度](#len-统计长度)\n\n\n# Golang 系统知识回答收集\n\n## Golang 语法方面\n\n### Golang关键字有哪些\n\n### Golang 当中\n关键字是指被编程语言用作特定目的的保留单词，这些关键字在代码当中具有特殊的含义，不能被用作标识符（例如变量名，函数名，类型名等）。以下是Golang中关键字的列表\n\n```go\nfunc \ntype \n\ninterface \nstruct \nvar\n\nbreak continue \n\ndefault\n\ncase \nselect\ndefer\nswitch\nfor \nrange \ngoto\nelse\nif\n\nconst\nchan \nmap\n\nimport\npackage\n\ngo\nreturn \n\nfallthrough\n\n```\n\n### range 函数的具体使用\n\ngolang当中range 关键字可以用于迭代数组、切片、字符串、map和通道等数据类型\n\n```go\n//迭代数组和切片时候，返回当前元素的索引和值\narr := [3]int{1,2,3}\nfor key,num := range arr{\n\tfmt.Printf(\"now arr[%d] is %d\\n\", key,num)\n}\n\n// map 迭代字符串的时候，每次迭代返回当前字符的索引和Unicode码点\n\ns := \"hello world\"\nfor i, c := range s{\n\tfmt.Printf(\"index:%d, Unicode code ponit : %U\\n\",i,c)\n}\n\n//迭代map结构\nm := map[int]string{\n\t1: \"one\",\n\t2: \"two\",\n\t3: \"three\",\n}\nfor k,v := range m{\n\tfmt.Printf(\"key : %d, value : %s\",k,v)\n\n}\n\n//迭代通道使用range 迭代通道的时候，会不断地从通道当中接受元素，直到通道关闭为止\n\nch := make(chan int)\ngo func() {\n\tfor i := 0;i<5,i++{\n\tch <- i\n\t}\n\tclose(ch)\n}()\n\nfor v := range ch {\n\tfmt.Println(v)\n}\n```\n\n在迭代通道的时候，如果通道没有关闭，那么循环就会一直等待下去，知道程序死锁，因此必须要再写入完所有的数据之后关闭通道，或者使用'select'语句在接受通道数据的时候检查通道是否已经关闭\n\n\n### Slice 扩容机制\n\nGo 1.18 版本之后，当新切片需要的容量cap大于两倍扩容的容量时候，则直接按照新切片需要的容量进行扩容：\n\n* 当原 Slice 容量 < threshold 的时候，新 slice 容量变成原来的2 倍\n* 当原 Slice 容量 > threshold 的时候，进入一个循环，每次容量增加 （旧容量 + 3*threshold）/4\n\n\n### Slice 为什么不是线程安全的\n\n因为 Slice 内部使用了底层数组，数组在内存当中是连续存储的并没有加锁的机制，本身并不支持并发的读写\n\n当多个Goroutine并发访问同一个Slice的时候，可能存在某个Goroutine修改了Slice中的某个元素，其他Goroutine无法立即看到这个修改，也可能会造成竞争问题。可以通过使用((20230318150223-agvrll2 \"互斥锁\"))或者((20230318154221-miv3alf \"原子操作\"))来保证某个Goroutine访问的时候其他goroutine不能够同时访问，另外也可以使用通道来进行同步，通过将Slice的访问权限交给某个Goroutine，从而保障其他的Goroutine无法同时访问该Slice。\n\n\n\n### map的底层原理\n\nmap对象本身是一个指针，占用8个字节（64位计算机），指向`hmap`结构体，hmap包含多个bmap数组（桶）\n\n```go\ntype hmap struct{\n\tcount int // 元素个数，调用len(map)的时候直接返回\n\tflags uint8 // 标志当前map的状态，正在删除元素、添加元素、、、、\n\tB uint8 //单元(buckets)的对数 B=5表示能容纳32个元素  B随着map容量增大而变大\n\n\tnoverflow uint16  //单元(buckets)溢出数量，如果一个单元能存8个key，此时存储了9个，溢出了，就需要再增加一个单元\n\thash0 uint32 //哈希种子\n\tbuckets unsafe.Pointer //指向单元(buckets)数组,大小为2^B，可以为nil\n\toldbuckets unsafe.Pointer //扩容的时候，buckets长度会是oldbuckets的两倍\n\tnevacute uintptr  //指示扩容进度，小于此buckets迁移完成 \n\textra *mapextra //与gc相关 可选字段 \n}\n\ntype bmap struct{\n\ttophash [bucketCnt]uint8 \n}\n//实际上编译期间会生成一个新的数据结构  \ntype bmap struct { \n    topbits [8]uint8     //key hash值前8位 用于快速定位keys的位置\n    keys [8]keytype     //键\n    values [8]valuetype //值\n    pad uintptr \n    overflow uintptr     //指向溢出桶 无符号整形 优化GC\n}\n\n```\n\n\n### map的扩容机制\n\n扩容时机：向map里面插入新的key的时候，会进行条件检测，符合以下两个条件就会触发扩容操作：\n\n扩容条件：\n\n1. 超过负载 map元素个数 > 负载因子 * 桶个数\n2. 溢出桶太多\n\n负载因子是元素个数与桶的数量的比值\n\n当桶总数<2^15^时，如果溢出桶总数>=桶总数，则认为溢出桶过多\n\n当桶总数>2^15^时，如果溢出桶总数>=2^15^，则认为溢出桶过多\n\n\n扩容机制：\n\n* 双倍扩容：针对条件1，新建一个buckets数组，新的buckets大小是原来的2倍，然后旧buckets数据搬迁到新的buckets。\n* 等量扩容：针对条件2，并不扩大容量，buckets数量维持不变，重新做一遍类似双倍扩容的搬迁动作，把松散的键值对重新排列一次，使得同一个 bucket 中的 key 排列地更紧密，节省空间，提高 bucket 利用率，进而保证更快的存取。\n\n* 渐进式扩容： 插入修改删除key的时候，都会尝试进行搬迁桶的工作，每次都会检查oldbucket是否**nil**，如果不是**nil**则每次搬迁**2**个桶，蚂蚁搬家一样渐进式扩容\n\n\n### map的遍历为什么无序\n\nmap  每次遍历，都会从一个随机值序号的桶开始，再从其中随机的cell 开始遍历，并且扩容后，原来桶中的key会落到其他的桶中，本身就会造成失序。\n\n如果想要遍历map，先把key放到切片中排序，再按照key的顺序遍历map\n\n```go\n//请写一段代码验证\nm := map[int]string {\n\t1: \"one\",\n\t2: \"two\",\n\t3: \"three\",\n}\n\nfor key,value := range m{\n\tfmt.Printf(\"data is : %d ---> %S \\n\", key,value)\n}\n\n```\n\n\n### map的底层存储不是连续的\n\n具体来说map 内部存储的是一个桶（bucket）数组，桶数组中的每个元素有事一个指向链表头的指针，他存储的数据并不连续\n\n\n### map 为什么不是线程安全的\n\n多个协程同时对**map**进行并发读写**,**程序会**panic**\n\n想要线程安全，可以使用sync.RWLock锁\n\n在sync.map 这个包当中实现了锁，是线程安全的\n\n\n### Map如何查找\n\n1. 计算hash值\n    key经过哈希函数计算后,得到64bit(64位CPU)\n    10010111 | 101011101010110101010101101010101010 | 10010\n2. 找到hash对应的桶\n    上面64位后5(hmap的B值)位定位所存放的桶\n    如果当前正在扩容中,并且定位到旧桶数据还未完成迁移,则使用旧的桶\n3. 遍历桶查找\n    上面64位前8位用来在tophash数组查找快速判断key是否在当前的桶中,如果不在需要去溢出桶查找\n4. 返回key对应的指针\n\n\n\n### map 冲突解决的方式\n\nGo采用链式地址解决冲突，具体实现就是插入key到map中时，当key定位的桶填满8个元素，将会创建一个溢出桶并且将溢出桶插入到当前桶所在的链表尾部\n\nGolang当中采用链式哈希表（Cahined Hash Table）\n\n在Golang的哈希表实现当中，每一个桶就是一个链表的头指针，桶内每个元素都是哈希链表节点，节点包含了该元素的哈希值、键以及指向下一个节点的指针。\n\n在查找时候，先根据键的哈希值找到对应的桶，然后在该桶对应的链表中顺序查找，指导找到目标元素或者是链表遍历完毕。\n\n\n### map 的负载因子为什么时6.5\n\n> 负载因子 = 哈希表存储的元素个数 / 桶个数\n\nGo 官方发现：装载因子越大，填入的元素越多，空间利用率就越高，但发生哈希冲突的几率就变大。\n装载因子越小，填入的元素越少，冲突发生的几率减小，但空间浪费也会变得更多，而且还会提高扩容操作的次数\n\nGo 官方取了一个相对适中的值，把 Go 中的 map 的负载因子硬编码为 6.5，这就是 6.5 的选择缘由。\n\n这意味着在 Go 语言中，当 map存储的元素个数大于或等于 6.5 * 桶个数 时，就会触发扩容行为。\n\n\n### Map和 Sync.Map哪一个性能好\n\n对比原始map：\n\n和原始map+RWLock的实现并发的方式相比，减少了加锁对性能的影响。\n\n它做了一些优化：可以无锁访问read map，而且会优先操作read map，倘若只操作read map就可以满足要求，那就不用去操作write map(dirty)，所以在某些特定场景中它发生锁竞争的频率会远远小于map+RWLock的实现方式\n\n* 优点：\n  适合读多写少的场景\n* 缺点：\n  写多的场景，会导致 read map 缓存失效，需要加锁，冲突变多，性能急剧下降\n\n\n\n### channel 底层实现原理\n\n通过**var****声明或者是**​**make****函数创建的channel变量**是一个存储在函数栈帧上的指针，占用8个字节，指向堆上的hchan结构体\n\n```go\ntype hchan struct{\n\tclosed uint32 // channel 是否关闭的标志\n\telemtype *_type // channel 中的元素类型\n\n\tbuf unsafe.Pointer //指向底层循环数组的指针（环形缓存区）\n\tqcount uint // 循环数组中的元素数量\n\tdataqsiz uint //循环数组的长度\n\telemsize uint16 //元素的大小\n\tsendx uint // 下一次写下标的位置\n\trecvx uint // 下一次读下标的位置\n\t// 尝试读取channel 或者向channel 写入数据而被阻塞的goroutine\n    \trecvq    waitq  // 读等待队列\n    \tsendq    waitq  // 写等待队列\n    \tlock mutex //互斥锁，保证读写channel时不存在并发竞争问题\n}\n```\n\nchannel 分为无缓冲和有缓冲两种\n\n* 对于有缓冲的channel存储数据，使用了ring buffer(环形缓冲区) 来缓存写入的数据，本质是循环数组。\n\n  为啥是循环数组呢？普通数组不行吗，普通数组容量固定，更适合指定的空间，弹出元素的时候，普通数组需要全部前移。\n\n  `当下标超过数组容量后会回到第一个位置，所以需要有两个字段记录当前读和写的下标位置`\n\n* 对于无缓冲的channel 存储数据\n\n等待队列： \n\n双向链表，包含一个头结点和一个尾结点 每个节点是一个sudog结构体变量，记录哪个协程在等待，等待的是哪个channel，等待发送**/**接收的数据在哪里\n\n```go\ntype wait struct{\n\tfirst *sudog\n\tlast *sudog\n}\n\ntype sudog struct{\n\tg *g\n\tnext *sudog\n\tpre  *sudog\n\telem unsafe.Pointer\n\tc  *hchan\n\t...\n}\n```\n\n\n创建 channel 的时候：\n\n创建时会做一些检查**:** \n\n* 元素大小不能超过 **64**K\n* 元素的对齐大小不能超过 maxAlign 也就是 **8** 字节\n* 计算出来的内存是否超过限制\n\n创建时的策略:\n\n* 如果是无缓冲的channel，会直接给hchan 分配内存\n* 如果是有缓冲的channel，并且元素不包含指针，那么会为 hchan  和底层数组分配一段连续的地址\n\n* 如果是有缓冲的channel，元素包含指针，那么就会为了hchan 和底层数组分别分配地址\n\n发送时：\n\n* 如果 channel 的读队列存在着接收者 goroutine，将唤醒接收的goroutine，将数据**直接发送**给第一个等待的 goroutine\n\n* 如果channel 的读等待队列不存在接收者 goroutine\n\n  * 如果循环数组buffer未满，那么将会把数据发送到循环数组buffer的队尾\n  * 如果循环数组buffer已满，这个时候就会阻塞发送的流程，将当前goroutine加入写等待队列，**并挂起等待唤醒**\n\n接收时：\n\n* 如果 channel 的写等待队列存在发送者 goroutine\n\n  * 如果是无缓冲 channel ，**直接**从第一个发送者goroutine 那里 把数据拷贝给接受变量，**唤醒 发送的goroutine**\n  * 如果是有缓冲的 channel（已满），将循环数组的buffer的队首元素拷贝给接受变量，将第一个发送者goroutine的数据拷贝到buffer循环数组的队尾，**唤醒发送的goroutine**\n* 如果channel 的写等待队列不存在发送者goroutine\n\n  * 如果循环数组buffer非空，将循环数组buffer的队首元素拷贝给接受变量\n  * 如果循环数组buffer为空，这个时候就会阻塞接收的流程，将当前goroutine 加入读等待队列，并**挂起等待唤醒**\n\n\n### channel 有什么特点\n\nchannel是线程安全的\n\nchannel 有两种类型： 无缓冲、有缓冲\n\nchannel 有三种模式： 写操作模式（单向通道）、读操作模式（单向通道）、读写操作模式（双向通道）\n\n```go\n写操作模式    make(chan<- int)\n读操作模式    make(<-chan int)\n读写操作模式    make(chan int)\n```\n\nchannel 有 3 种状态：未初始化、正常、关闭\n\n| 操作 \\ 状态 | 未初始化         | 关闭                               | 正常             |\n| ------------- | ------------------ | ------------------------------------ | ------------------ |\n| 关闭        | panic            | panic                              | 正常             |\n| 发送        | 永远阻塞导致死锁 | panic                              | 阻塞或者成功发送 |\n| 接收        | 永远阻塞导致死锁 | 缓冲区为空则为零值，否则可以继续读 | 阻塞或者成功接收 |\n\n注意点：\n\n* 一个 channel不能多次关闭，会导致painc\n\n* 如果多个 goroutine 都监听同一个 channel，那么 channel 上的数据都可能随机被某一个 goroutine 取走进行消费\n* 如果多个 goroutine 监听同一个 channel，如果这个 channel 被关闭，则所有 goroutine 都能收到退出信号\n\n### Channel 的使用场景\n\n无缓冲 Channel 在并发编程中的具体业务使用场景很多，主要应用于 Go 语言中。以下是一些常见的无缓冲 Channel 的具体业务使用场景及例子：\n\n1. 并发控制：在并发程序中，通过无缓冲 Channel 可以实现多个 Goroutine 之间的**同步和控制**。例如，一个任务需要多个协程协作完成时，可以使用无缓冲 Channel 来传递任务数据和控制信号。\n2. 事件驱动：在事件驱动的编程中，可以使用无缓冲 Channel 来传递事件和执行结果。例如，当一个 HTTP 请求到达时，可以将请求交给一个协程处理，并使用无缓冲 Channel 返回处理结果。\n3. 分布式计算：在分布式计算中，可以使用无缓冲 Channel 来实现节点之间的通信和数据传递。例如，在 MapReduce 算法中，可以使用无缓冲 Channel 来传递 Map 阶段的输出结果并驱动 Reduce 阶段的计算。\n\n有缓冲 Channel 在并发编程中的具体业务使用场景也很多，主要应用于 Go 语言中。以下是一些常见的有缓冲 Channel 的具体业务使用场景及例子：\n\n1. 网络编程：在 TCP 或 UDP 数据处理中，可以使用有缓冲 Channel 缓存数据，**以避免因数据接收太慢而导致发送者被阻塞**。例如，在高并发的 Web 服务器中，可以使用有缓冲 Channel 缓存请求数据以提高吞吐量。\n2. IO 操作：在使用 IO 操作时，如文件读写、数据库访问等，可以使用有缓冲 Channel 缓存数据，以避免因数据处理速度不匹配而导致发送者或接收者被阻塞。例如，**在从数据库获取大量数据时，可以使用有缓冲 Channel 缓存数据，减少数据库连接次数。**\n3. 并发控制：在并发程序中，通过有缓冲 Channel 可以实现多个 Goroutine 之间的同步和控制。例如，一个任务需要多个协程协作完成时，可以使用有缓冲 Channel 来传递任务数据和控制信号，并根据缓冲区的剩余空间来控制协程的执行顺序。\n4. 事件驱动：在事件驱动的编程中，可以使用有缓冲 Channel 来缓存事件和执行结果，并根据缓冲区的剩余空间来控制事件的处理顺序。例如，当一个 HTTP 请求到达时，可以将请求交给一个协程处理，并使用有缓冲 Channel 缓存处理结果，避免处理速度过慢导致请求被阻塞。\n\n\n### channel 为什么是线程安全的\n\n不同协程通过channel进行通信，本身的使用场景就是多线程，为了保证数据的一致性，必须实现线程安全\n\n\nchannel的底层实现中，hchan结构体中采用Mutex锁来保证数据读写安全。在对循环数组buf中的数据进行入队和出队操作时，必须先获取互斥锁，才能操作channel数据\n\n\n### Channel 发送和接收什么情况下会死锁\n\n```go\nfunc deadlock1() {    //无缓冲channel只写不读\n    ch := make(chan int) \n    ch <- 3 //  这里会发生一直阻塞的情况，执行不到下面一句\n}\nfunc deadlock2() { //无缓冲channel读在写后面\n    ch := make(chan int)\n    ch <- 3  //  这里会发生一直阻塞的情况，执行不到下面一句\n    num := <-ch\n    fmt.Println(\"num=\", num)\n}\nfunc deadlock3() { //无缓冲channel读在写后面\n    ch := make(chan int)\n    ch <- 100 //  这里会发生一直阻塞的情况，执行不到下面一句\n    go func() {\n        num := <-ch\n        fmt.Println(\"num=\", num)\n    }()\n    time.Sleep(time.Second)\n}\nfunc deadlock3() {    //有缓冲channel写入超过缓冲区数量\n    ch := make(chan int, 3)\n    ch <- 3\n    ch <- 4\n    ch <- 5\n    ch <- 6  //  这里会发生一直阻塞的情况\n}\nfunc deadlock4() {    //空读\n    ch := make(chan int)\n    // ch := make(chan int, 1)\n    fmt.Println(<-ch)  //  这里会发生一直阻塞的情况\n}\nfunc deadlock5() {    //互相等对方造成死锁\n    ch1 := make(chan int)\n    ch2 := make(chan int)\n    go func() {\n        for {\n        select {\n        case num := <-ch1:\n            fmt.Println(\"num=\", num)\n            ch2 <- 100\n        }\n    }\n    }()\n    for {\n        select {\n        case num := <-ch2:\n            fmt.Println(\"num=\", num)\n            ch1 <- 300\n        }\n    }\n}\n```\n\n### 互斥锁实现原理\n\nGo sync包提供了两种锁类型：互斥锁sync.Mutex 和 读写互斥锁sync.RWMutex，都属于((20230402113517-ppcs0gj \"悲观锁\"))。\n[https://blog.csdn.net/baolingye/article/details/111357407](https://blog.csdn.net/baolingye/article/details/111357407)\n\n在正常模式下，**锁的等待者会按照先进先出的顺序获取锁**。但是刚被唤起的 Goroutine 与新创建的 Goroutine 竞争时，大概率会获取不到锁，在这种情况下，这个被唤醒的 Goroutine 会加入到等待队列的前面。 如果一个等待的 Goroutine 超过1ms 没有获取锁，那么它将会把锁转变为**饥饿模式**。\nGo在1.9中引入优化，目的保证互斥锁的公平性。在饥饿模式中，互斥锁会直接交给等待队列最前面的 Goroutine。新的 Goroutine 在该状态下不能获取锁、也不会进入自旋状态，它们只会在队列的末尾等待。如果一个 Goroutine 获得了互斥锁并且它在队列的末尾或者它等待的时间少于 1ms，那么当前的互斥锁就会切换回正常模式。\n\n\n### 悲观锁与乐观锁\n\n**悲观锁**是基于一种悲观的态度类来防止一切数据冲突，它是以一种预防的姿态在**修改数据之前把数据锁住，然后再对数据进行读写，在它释放锁之前任何人都不能对其数据进行操作，直到前面一个人把锁释放后下一个人数据加锁才可对数据进行加锁，**然后才可以对数据进行操作，一般数据库本身锁的机制都是基于悲观锁的机制实现的;\n\n特点：可以完全保证数据的独占性和正确性，因为每次请求都会先对数据进行加锁， 然后进行数据操作，最后再解锁，而加锁释放锁的过程会造成消耗，所以性能不高;\n\n\n**乐观锁**是对于数据冲突保持一种乐观态度，操作数据时不会对操作的数据进行加锁（这使得多个任务可以并行的对数据进行操作），只有到数据提交的时候才通过一种机制来验证数据是否存在冲突(一般实现方式是通过加版本号然后进行版本号的对比方式实现);\n\n特点：乐观锁是一种并发类型的锁，其本身不对数据进行加锁通而是通过业务实现锁的功能，不对数据进行加锁就意味着允许多个请求同时访问数据，同时也省掉了对数据加锁和解锁的过程，这种方式因为节省了悲观锁加锁的操作，所以可以一定程度的的提高操作的性能，不过在并发非常高的情况下，会导致大量的请求冲突，冲突导致大部分操作无功而返而浪费资源，所以在高并发的场景下，乐观锁的性能却反而不如悲观锁。\n\n\n\n### 原子操作和锁的区别\n\n在并发编程里，Go语言`sync`包里的同步原语`Mutex`是我们经常用来保证并发安全的，那么他跟`atomic`包里的这些操作有啥区别呢？在我看来他们在使用目的和底层实现上都不一样：\n\n* 使用目的：互斥锁是用来保护一段逻辑，原子操作用于对一个变量的更新保护。\n* 底层实现：`Mutex`由**操作系统**的调度器实现，而`atomic`包中的原子操作则由**底层硬件指令**直接提供支持，这些指令在执行的过程中是不允许中断的，因此原子操作可以在`lock-free`的情况下保证并发安全，并且它的性能也能做到随`CPU`个数的增多而线性扩展。\n\n\n\n\n### 互斥锁允许自旋的条件\n\n线程没有获取到锁时常见有2种处理方式：\n\n* 一种是没有获取到锁的线程就会循环等待判断该资源是否已经释放锁，这种锁也叫做自旋锁，它不用将线程阻塞起来， 适用于并发低且程序执行时间短的场景，缺点是cpu占用较高\n* 另外一种处理方式就是把自己阻塞起来，会释放CPU给其他线程，内核会将线程置为「睡眠」状态，等到锁被释放后，内核会在合适的时机唤醒该线程，适用于高并发场景，缺点是有线程上下文切换的开销\n  Go语言中的Mutex实现了自旋与阻塞两种场景，当满足不了自旋条件时，就会进入阻塞\n  **允许自旋的条件：**\n\n1. 锁已被占用，并且锁不处于饥饿模式。\n2. 积累的自旋次数小于最大自旋次数（active_spin=4）。\n3. cpu 核数大于 1。\n4. 有空闲的 P。\n5. 当前 goroutine 所挂载的 P 下，本地待运行队列为空。\n\n\n### 读写锁的实现原理\n\n读写锁的底层是基于互斥锁实现的。\n写锁需要阻塞写锁：一个协程拥有写锁时，其他协程写锁定需要阻塞；\n写锁需要阻塞读锁：一个协程拥有写锁时，其他协程读锁定需要阻塞；\n读锁需要阻塞写锁：一个协程拥有读锁时，其他协程写锁定需要阻塞；\n**读锁不能阻塞读锁：一个协程拥有读锁时，其他协程也可以拥有读锁。**\n\n\n### \"原子操作\"有哪些\n\nGo atomic包是最轻量级的锁（也称无锁结构），可以在不形成临界区和创建互斥量的情况下完成并发安全的值替换操作，不过这个包只支持int32/int64/uint32/uint64/uintptr这几种数据类型的一些基础操作（增减、交换、载入、存储等）\n当我们想要对**某个变量**并发安全的修改，除了使用官方提供的 `mutex`，还可以使用 sync/atomic 包的原子操作，它能够保证对变量的读取或修改期间不被其他的协程所影响。\natomic 包提供的原子操作能够确保任一时刻只有一个goroutine对变量进行操作，善用 atomic 能够避免程序中出现大量的锁操作。\n**常见操作：**\n\n* 增减Add     AddInt32 AddInt64 AddUint32 AddUint64 AddUintptr\n* 载入Load    LoadInt32 LoadInt64    LoadPointer    LoadUint32    LoadUint64    LoadUintptr\n* 比较并交换   CompareAndSwap    CompareAndSwapInt32...\n* 交换Swap    SwapInt32...\n* 存储Store    StoreInt32...\n\n\n### Goroutine 的底层实现原理\n\n```go\ng本质是一个数据结构,真正让 goroutine 运行起来的是调度器\ntype g struct { \n    goid int64  // 唯一的goroutine的ID \n    sched gobuf // goroutine切换时，用于保存g的上下文 \n    stack stack // 栈 \n    gopc // pc of go statement that created this goroutine \n    startpc uintptr  // pc of goroutine function ... \n} \ntype gobuf struct {     //运行时寄存器\n    sp uintptr  // 栈指针位置 \n    pc uintptr  // 运行到的程序位置 \n    g  guintptr // 指向 goroutine \n    ret uintptr // 保存系统调用的返回值 ... \n} \ntype stack struct {     //运行时栈\n    lo uintptr  // 栈的下界内存地址 \n    hi uintptr  // 栈的上界内存地址 \n}\n```\n\n### \n\n### goroutine 和线程的区别\n\n内存占用:\n创建一个 goroutine 的栈内存消耗为 2 KB，实际运行过程中，如果栈空间不够用，会自动进行扩容。创建一个 thread 则需要消耗 1 MB 栈内存。\n创建和销毀:\nThread 创建和销毀需要陷入内核,系统调用。而 goroutine 因为是由 Go runtime 负责管理的，创建和销毁的消耗非常小，是用户级。\n切换:\n当 threads 切换时，需要保存各种寄存器,而 goroutines 切换只需保存三个寄存器：Program Counter, Stack Pointer and BP。一般而言，线程切换会消耗 1000-1500 ns,Goroutine 的切换约为 200 ns,因此，goroutines 切换成本比 threads 要小得多。\n\n\n### Go 线程模型（Go底层怎么实现高并发的）\n\n> 线程协程，进程的区别：\n>\n> [https://zhuanlan.zhihu.com/p/337978321](https://zhuanlan.zhihu.com/p/337978321)\n>\n> [https://www.bilibili.com/read/cv9346691/](https://www.bilibili.com/read/cv9346691/)\n\nGolang的调度器是一个轻量级的协程调度器，主要负责管理和调度协程。Golang 中的调度器采用 **M:N 模型**，即 M 个用户级线程对应 N 个内核线程。\n\n调度器会将 Golang 中的协程（goroutine）调度到不同的线程上运行，以实现并发执行的效果。\n\nM个线程对应N个内核线程的优点：\n\n* 能够利用多核\n* 上下文切换成本低\n* 如果进程中的一个线程被阻塞，不会阻塞其他线程，是能够切换同一进程内的其他线程继续执行\n\n### Golang assertion \n\n## Golang调用方面\n\n### len 统计长度\n<font color = 'red'>len()计算的是字节的长度，和编码无关，对于英文和数组对象等，字节长度等效于实际长度</font>\n当需要计算中文字符长度的时候，就需要调用其他的函数方法：\n`utf8.RuneCountInString(\"中文\")`\n","slug":"Go/Go-enhanced-knowledge/Go 系统知识汇总","published":1,"updated":"2023-05-03T01:59:23.972Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli796r0w001hbyjx3t5pf7gl","content":"<ul>\n<li><a href=\"#golang-%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E5%9B%9E%E7%AD%94%E6%94%B6%E9%9B%86\">Golang 系统知识回答收集</a><ul>\n<li><a href=\"#golang-%E8%AF%AD%E6%B3%95%E6%96%B9%E9%9D%A2\">Golang 语法方面</a><ul>\n<li><a href=\"#golang%E5%85%B3%E9%94%AE%E5%AD%97%E6%9C%89%E5%93%AA%E4%BA%9B\">Golang关键字有哪些</a></li>\n<li><a href=\"#golang-%E5%BD%93%E4%B8%AD\">Golang 当中</a></li>\n<li><a href=\"#range-%E5%87%BD%E6%95%B0%E7%9A%84%E5%85%B7%E4%BD%93%E4%BD%BF%E7%94%A8\">range 函数的具体使用</a></li>\n<li><a href=\"#slice-%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6\">Slice 扩容机制</a></li>\n<li><a href=\"#slice-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84\">Slice 为什么不是线程安全的</a></li>\n<li><a href=\"#map%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86\">map的底层原理</a></li>\n<li><a href=\"#map%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6\">map的扩容机制</a></li>\n<li><a href=\"#map%E7%9A%84%E9%81%8D%E5%8E%86%E4%B8%BA%E4%BB%80%E4%B9%88%E6%97%A0%E5%BA%8F\">map的遍历为什么无序</a></li>\n<li><a href=\"#map%E7%9A%84%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E4%B8%8D%E6%98%AF%E8%BF%9E%E7%BB%AD%E7%9A%84\">map的底层存储不是连续的</a></li>\n<li><a href=\"#map-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84\">map 为什么不是线程安全的</a></li>\n<li><a href=\"#map%E5%A6%82%E4%BD%95%E6%9F%A5%E6%89%BE\">Map如何查找</a></li>\n<li><a href=\"#map-%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E7%9A%84%E6%96%B9%E5%BC%8F\">map 冲突解决的方式</a></li>\n<li><a href=\"#map-%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9B%A0%E5%AD%90%E4%B8%BA%E4%BB%80%E4%B9%88%E6%97%B665\">map 的负载因子为什么时6.5</a></li>\n<li><a href=\"#map%E5%92%8C-syncmap%E5%93%AA%E4%B8%80%E4%B8%AA%E6%80%A7%E8%83%BD%E5%A5%BD\">Map和 Sync.Map哪一个性能好</a></li>\n<li><a href=\"#channel-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\">channel 底层实现原理</a></li>\n<li><a href=\"#channel-%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9\">channel 有什么特点</a></li>\n<li><a href=\"#channel-%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF\">Channel 的使用场景</a></li>\n<li><a href=\"#channel-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84\">channel 为什么是线程安全的</a></li>\n<li><a href=\"#channel-%E5%8F%91%E9%80%81%E5%92%8C%E6%8E%A5%E6%94%B6%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E6%AD%BB%E9%94%81\">Channel 发送和接收什么情况下会死锁</a></li>\n<li><a href=\"#%E4%BA%92%E6%96%A5%E9%94%81%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\">互斥锁实现原理</a></li>\n<li><a href=\"#%E6%82%B2%E8%A7%82%E9%94%81%E4%B8%8E%E4%B9%90%E8%A7%82%E9%94%81\">悲观锁与乐观锁</a></li>\n<li><a href=\"#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E5%92%8C%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB\">原子操作和锁的区别</a></li>\n<li><a href=\"#%E4%BA%92%E6%96%A5%E9%94%81%E5%85%81%E8%AE%B8%E8%87%AA%E6%97%8B%E7%9A%84%E6%9D%A1%E4%BB%B6\">互斥锁允许自旋的条件</a></li>\n<li><a href=\"#%E8%AF%BB%E5%86%99%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\">读写锁的实现原理</a></li>\n<li><a href=\"#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E6%9C%89%E5%93%AA%E4%BA%9B\">“原子操作”有哪些</a></li>\n<li><a href=\"#goroutine-%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\">Goroutine 的底层实现原理</a></li>\n<li><a href=\"#\"></a></li>\n<li><a href=\"#goroutine-%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB\">goroutine 和线程的区别</a></li>\n<li><a href=\"#go-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8Bgo%E5%BA%95%E5%B1%82%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%B9%B6%E5%8F%91%E7%9A%84\">Go 线程模型（Go底层怎么实现高并发的）</a></li>\n<li><a href=\"#golang-assertion\">Golang assertion</a></li>\n</ul>\n</li>\n<li><a href=\"#golang%E8%B0%83%E7%94%A8%E6%96%B9%E9%9D%A2\">Golang调用方面</a><ul>\n<li><a href=\"#len-%E7%BB%9F%E8%AE%A1%E9%95%BF%E5%BA%A6\">len 统计长度</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"Golang-系统知识回答收集\"><a href=\"#Golang-系统知识回答收集\" class=\"headerlink\" title=\"Golang 系统知识回答收集\"></a>Golang 系统知识回答收集</h1><h2 id=\"Golang-语法方面\"><a href=\"#Golang-语法方面\" class=\"headerlink\" title=\"Golang 语法方面\"></a>Golang 语法方面</h2><h3 id=\"Golang关键字有哪些\"><a href=\"#Golang关键字有哪些\" class=\"headerlink\" title=\"Golang关键字有哪些\"></a>Golang关键字有哪些</h3><h3 id=\"Golang-当中\"><a href=\"#Golang-当中\" class=\"headerlink\" title=\"Golang 当中\"></a>Golang 当中</h3><p>关键字是指被编程语言用作特定目的的保留单词，这些关键字在代码当中具有特殊的含义，不能被用作标识符（例如变量名，函数名，类型名等）。以下是Golang中关键字的列表</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span></span> </span><br><span class=\"line\"><span class=\"keyword\">type</span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> </span><br><span class=\"line\"><span class=\"keyword\">struct</span> </span><br><span class=\"line\"><span class=\"keyword\">var</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">break</span> <span class=\"keyword\">continue</span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">default</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">case</span> </span><br><span class=\"line\"><span class=\"keyword\">select</span></span><br><span class=\"line\"><span class=\"keyword\">defer</span></span><br><span class=\"line\"><span class=\"keyword\">switch</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> </span><br><span class=\"line\"><span class=\"keyword\">range</span> </span><br><span class=\"line\"><span class=\"keyword\">goto</span></span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\"><span class=\"keyword\">if</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span></span><br><span class=\"line\"><span class=\"keyword\">chan</span> </span><br><span class=\"line\"><span class=\"keyword\">map</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span></span><br><span class=\"line\"><span class=\"keyword\">package</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">go</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fallthrough</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"range-函数的具体使用\"><a href=\"#range-函数的具体使用\" class=\"headerlink\" title=\"range 函数的具体使用\"></a>range 函数的具体使用</h3><p>golang当中range 关键字可以用于迭代数组、切片、字符串、map和通道等数据类型</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//迭代数组和切片时候，返回当前元素的索引和值</span></span><br><span class=\"line\">arr := [<span class=\"number\">3</span>]<span class=\"type\">int</span>&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> key,num := <span class=\"keyword\">range</span> arr&#123;</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;now arr[%d] is %d\\n&quot;</span>, key,num)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// map 迭代字符串的时候，每次迭代返回当前字符的索引和Unicode码点</span></span><br><span class=\"line\"></span><br><span class=\"line\">s := <span class=\"string\">&quot;hello world&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i, c := <span class=\"keyword\">range</span> s&#123;</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;index:%d, Unicode code ponit : %U\\n&quot;</span>,i,c)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//迭代map结构</span></span><br><span class=\"line\">m := <span class=\"keyword\">map</span>[<span class=\"type\">int</span>]<span class=\"type\">string</span>&#123;</span><br><span class=\"line\">\t<span class=\"number\">1</span>: <span class=\"string\">&quot;one&quot;</span>,</span><br><span class=\"line\">\t<span class=\"number\">2</span>: <span class=\"string\">&quot;two&quot;</span>,</span><br><span class=\"line\">\t<span class=\"number\">3</span>: <span class=\"string\">&quot;three&quot;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> k,v := <span class=\"keyword\">range</span> m&#123;</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;key : %d, value : %s&quot;</span>,k,v)</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//迭代通道使用range 迭代通道的时候，会不断地从通道当中接受元素，直到通道关闭为止</span></span><br><span class=\"line\"></span><br><span class=\"line\">ch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\"><span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>;i&lt;<span class=\"number\">5</span>,i++&#123;</span><br><span class=\"line\">\tch &lt;- i</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">close</span>(ch)</span><br><span class=\"line\">&#125;()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> v := <span class=\"keyword\">range</span> ch &#123;</span><br><span class=\"line\">\tfmt.Println(v)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在迭代通道的时候，如果通道没有关闭，那么循环就会一直等待下去，知道程序死锁，因此必须要再写入完所有的数据之后关闭通道，或者使用’select’语句在接受通道数据的时候检查通道是否已经关闭</p>\n<h3 id=\"Slice-扩容机制\"><a href=\"#Slice-扩容机制\" class=\"headerlink\" title=\"Slice 扩容机制\"></a>Slice 扩容机制</h3><p>Go 1.18 版本之后，当新切片需要的容量cap大于两倍扩容的容量时候，则直接按照新切片需要的容量进行扩容：</p>\n<ul>\n<li>当原 Slice 容量 &lt; threshold 的时候，新 slice 容量变成原来的2 倍</li>\n<li>当原 Slice 容量 &gt; threshold 的时候，进入一个循环，每次容量增加 （旧容量 + 3*threshold）/4</li>\n</ul>\n<h3 id=\"Slice-为什么不是线程安全的\"><a href=\"#Slice-为什么不是线程安全的\" class=\"headerlink\" title=\"Slice 为什么不是线程安全的\"></a>Slice 为什么不是线程安全的</h3><p>因为 Slice 内部使用了底层数组，数组在内存当中是连续存储的并没有加锁的机制，本身并不支持并发的读写</p>\n<p>当多个Goroutine并发访问同一个Slice的时候，可能存在某个Goroutine修改了Slice中的某个元素，其他Goroutine无法立即看到这个修改，也可能会造成竞争问题。可以通过使用((20230318150223-agvrll2 “互斥锁”))或者((20230318154221-miv3alf “原子操作”))来保证某个Goroutine访问的时候其他goroutine不能够同时访问，另外也可以使用通道来进行同步，通过将Slice的访问权限交给某个Goroutine，从而保障其他的Goroutine无法同时访问该Slice。</p>\n<h3 id=\"map的底层原理\"><a href=\"#map的底层原理\" class=\"headerlink\" title=\"map的底层原理\"></a>map的底层原理</h3><p>map对象本身是一个指针，占用8个字节（64位计算机），指向<code>hmap</code>结构体，hmap包含多个bmap数组（桶）</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> hmap <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">\tcount <span class=\"type\">int</span> <span class=\"comment\">// 元素个数，调用len(map)的时候直接返回</span></span><br><span class=\"line\">\tflags <span class=\"type\">uint8</span> <span class=\"comment\">// 标志当前map的状态，正在删除元素、添加元素、、、、</span></span><br><span class=\"line\">\tB <span class=\"type\">uint8</span> <span class=\"comment\">//单元(buckets)的对数 B=5表示能容纳32个元素  B随着map容量增大而变大</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tnoverflow <span class=\"type\">uint16</span>  <span class=\"comment\">//单元(buckets)溢出数量，如果一个单元能存8个key，此时存储了9个，溢出了，就需要再增加一个单元</span></span><br><span class=\"line\">\thash0 <span class=\"type\">uint32</span> <span class=\"comment\">//哈希种子</span></span><br><span class=\"line\">\tbuckets unsafe.Pointer <span class=\"comment\">//指向单元(buckets)数组,大小为2^B，可以为nil</span></span><br><span class=\"line\">\toldbuckets unsafe.Pointer <span class=\"comment\">//扩容的时候，buckets长度会是oldbuckets的两倍</span></span><br><span class=\"line\">\tnevacute <span class=\"type\">uintptr</span>  <span class=\"comment\">//指示扩容进度，小于此buckets迁移完成 </span></span><br><span class=\"line\">\textra *mapextra <span class=\"comment\">//与gc相关 可选字段 </span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> bmap <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">\ttophash [bucketCnt]<span class=\"type\">uint8</span> </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//实际上编译期间会生成一个新的数据结构  </span></span><br><span class=\"line\"><span class=\"keyword\">type</span> bmap <span class=\"keyword\">struct</span> &#123; </span><br><span class=\"line\">    topbits [<span class=\"number\">8</span>]<span class=\"type\">uint8</span>     <span class=\"comment\">//key hash值前8位 用于快速定位keys的位置</span></span><br><span class=\"line\">    keys [<span class=\"number\">8</span>]keytype     <span class=\"comment\">//键</span></span><br><span class=\"line\">    values [<span class=\"number\">8</span>]valuetype <span class=\"comment\">//值</span></span><br><span class=\"line\">    pad <span class=\"type\">uintptr</span> </span><br><span class=\"line\">    overflow <span class=\"type\">uintptr</span>     <span class=\"comment\">//指向溢出桶 无符号整形 优化GC</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"map的扩容机制\"><a href=\"#map的扩容机制\" class=\"headerlink\" title=\"map的扩容机制\"></a>map的扩容机制</h3><p>扩容时机：向map里面插入新的key的时候，会进行条件检测，符合以下两个条件就会触发扩容操作：</p>\n<p>扩容条件：</p>\n<ol>\n<li>超过负载 map元素个数 &gt; 负载因子 * 桶个数</li>\n<li>溢出桶太多</li>\n</ol>\n<p>负载因子是元素个数与桶的数量的比值</p>\n<p>当桶总数&lt;2^15^时，如果溢出桶总数&gt;=桶总数，则认为溢出桶过多</p>\n<p>当桶总数&gt;2^15^时，如果溢出桶总数&gt;=2^15^，则认为溢出桶过多</p>\n<p>扩容机制：</p>\n<ul>\n<li><p>双倍扩容：针对条件1，新建一个buckets数组，新的buckets大小是原来的2倍，然后旧buckets数据搬迁到新的buckets。</p>\n</li>\n<li><p>等量扩容：针对条件2，并不扩大容量，buckets数量维持不变，重新做一遍类似双倍扩容的搬迁动作，把松散的键值对重新排列一次，使得同一个 bucket 中的 key 排列地更紧密，节省空间，提高 bucket 利用率，进而保证更快的存取。</p>\n</li>\n<li><p>渐进式扩容： 插入修改删除key的时候，都会尝试进行搬迁桶的工作，每次都会检查oldbucket是否<strong>nil</strong>，如果不是<strong>nil</strong>则每次搬迁<strong>2</strong>个桶，蚂蚁搬家一样渐进式扩容</p>\n</li>\n</ul>\n<h3 id=\"map的遍历为什么无序\"><a href=\"#map的遍历为什么无序\" class=\"headerlink\" title=\"map的遍历为什么无序\"></a>map的遍历为什么无序</h3><p>map  每次遍历，都会从一个随机值序号的桶开始，再从其中随机的cell 开始遍历，并且扩容后，原来桶中的key会落到其他的桶中，本身就会造成失序。</p>\n<p>如果想要遍历map，先把key放到切片中排序，再按照key的顺序遍历map</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//请写一段代码验证</span></span><br><span class=\"line\">m := <span class=\"keyword\">map</span>[<span class=\"type\">int</span>]<span class=\"type\">string</span> &#123;</span><br><span class=\"line\">\t<span class=\"number\">1</span>: <span class=\"string\">&quot;one&quot;</span>,</span><br><span class=\"line\">\t<span class=\"number\">2</span>: <span class=\"string\">&quot;two&quot;</span>,</span><br><span class=\"line\">\t<span class=\"number\">3</span>: <span class=\"string\">&quot;three&quot;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> key,value := <span class=\"keyword\">range</span> m&#123;</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;data is : %d ---&gt; %S \\n&quot;</span>, key,value)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"map的底层存储不是连续的\"><a href=\"#map的底层存储不是连续的\" class=\"headerlink\" title=\"map的底层存储不是连续的\"></a>map的底层存储不是连续的</h3><p>具体来说map 内部存储的是一个桶（bucket）数组，桶数组中的每个元素有事一个指向链表头的指针，他存储的数据并不连续</p>\n<h3 id=\"map-为什么不是线程安全的\"><a href=\"#map-为什么不是线程安全的\" class=\"headerlink\" title=\"map 为什么不是线程安全的\"></a>map 为什么不是线程安全的</h3><p>多个协程同时对<strong>map</strong>进行并发读写**,<strong>程序会</strong>panic**</p>\n<p>想要线程安全，可以使用sync.RWLock锁</p>\n<p>在sync.map 这个包当中实现了锁，是线程安全的</p>\n<h3 id=\"Map如何查找\"><a href=\"#Map如何查找\" class=\"headerlink\" title=\"Map如何查找\"></a>Map如何查找</h3><ol>\n<li>计算hash值<br> key经过哈希函数计算后,得到64bit(64位CPU)<br> 10010111 | 101011101010110101010101101010101010 | 10010</li>\n<li>找到hash对应的桶<br> 上面64位后5(hmap的B值)位定位所存放的桶<br> 如果当前正在扩容中,并且定位到旧桶数据还未完成迁移,则使用旧的桶</li>\n<li>遍历桶查找<br> 上面64位前8位用来在tophash数组查找快速判断key是否在当前的桶中,如果不在需要去溢出桶查找</li>\n<li>返回key对应的指针</li>\n</ol>\n<h3 id=\"map-冲突解决的方式\"><a href=\"#map-冲突解决的方式\" class=\"headerlink\" title=\"map 冲突解决的方式\"></a>map 冲突解决的方式</h3><p>Go采用链式地址解决冲突，具体实现就是插入key到map中时，当key定位的桶填满8个元素，将会创建一个溢出桶并且将溢出桶插入到当前桶所在的链表尾部</p>\n<p>Golang当中采用链式哈希表（Cahined Hash Table）</p>\n<p>在Golang的哈希表实现当中，每一个桶就是一个链表的头指针，桶内每个元素都是哈希链表节点，节点包含了该元素的哈希值、键以及指向下一个节点的指针。</p>\n<p>在查找时候，先根据键的哈希值找到对应的桶，然后在该桶对应的链表中顺序查找，指导找到目标元素或者是链表遍历完毕。</p>\n<h3 id=\"map-的负载因子为什么时6-5\"><a href=\"#map-的负载因子为什么时6-5\" class=\"headerlink\" title=\"map 的负载因子为什么时6.5\"></a>map 的负载因子为什么时6.5</h3><blockquote>\n<p>负载因子 = 哈希表存储的元素个数 / 桶个数</p>\n</blockquote>\n<p>Go 官方发现：装载因子越大，填入的元素越多，空间利用率就越高，但发生哈希冲突的几率就变大。<br>装载因子越小，填入的元素越少，冲突发生的几率减小，但空间浪费也会变得更多，而且还会提高扩容操作的次数</p>\n<p>Go 官方取了一个相对适中的值，把 Go 中的 map 的负载因子硬编码为 6.5，这就是 6.5 的选择缘由。</p>\n<p>这意味着在 Go 语言中，当 map存储的元素个数大于或等于 6.5 * 桶个数 时，就会触发扩容行为。</p>\n<h3 id=\"Map和-Sync-Map哪一个性能好\"><a href=\"#Map和-Sync-Map哪一个性能好\" class=\"headerlink\" title=\"Map和 Sync.Map哪一个性能好\"></a>Map和 Sync.Map哪一个性能好</h3><p>对比原始map：</p>\n<p>和原始map+RWLock的实现并发的方式相比，减少了加锁对性能的影响。</p>\n<p>它做了一些优化：可以无锁访问read map，而且会优先操作read map，倘若只操作read map就可以满足要求，那就不用去操作write map(dirty)，所以在某些特定场景中它发生锁竞争的频率会远远小于map+RWLock的实现方式</p>\n<ul>\n<li>优点：<br>适合读多写少的场景</li>\n<li>缺点：<br>写多的场景，会导致 read map 缓存失效，需要加锁，冲突变多，性能急剧下降</li>\n</ul>\n<h3 id=\"channel-底层实现原理\"><a href=\"#channel-底层实现原理\" class=\"headerlink\" title=\"channel 底层实现原理\"></a>channel 底层实现原理</h3><p>通过<strong>var****声明或者是</strong>​<strong>make****函数创建的channel变量</strong>是一个存储在函数栈帧上的指针，占用8个字节，指向堆上的hchan结构体</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> hchan <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">\tclosed <span class=\"type\">uint32</span> <span class=\"comment\">// channel 是否关闭的标志</span></span><br><span class=\"line\">\telemtype *_type <span class=\"comment\">// channel 中的元素类型</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tbuf unsafe.Pointer <span class=\"comment\">//指向底层循环数组的指针（环形缓存区）</span></span><br><span class=\"line\">\tqcount <span class=\"type\">uint</span> <span class=\"comment\">// 循环数组中的元素数量</span></span><br><span class=\"line\">\tdataqsiz <span class=\"type\">uint</span> <span class=\"comment\">//循环数组的长度</span></span><br><span class=\"line\">\telemsize <span class=\"type\">uint16</span> <span class=\"comment\">//元素的大小</span></span><br><span class=\"line\">\tsendx <span class=\"type\">uint</span> <span class=\"comment\">// 下一次写下标的位置</span></span><br><span class=\"line\">\trecvx <span class=\"type\">uint</span> <span class=\"comment\">// 下一次读下标的位置</span></span><br><span class=\"line\">\t<span class=\"comment\">// 尝试读取channel 或者向channel 写入数据而被阻塞的goroutine</span></span><br><span class=\"line\">    \trecvq    waitq  <span class=\"comment\">// 读等待队列</span></span><br><span class=\"line\">    \tsendq    waitq  <span class=\"comment\">// 写等待队列</span></span><br><span class=\"line\">    \tlock mutex <span class=\"comment\">//互斥锁，保证读写channel时不存在并发竞争问题</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>channel 分为无缓冲和有缓冲两种</p>\n<ul>\n<li><p>对于有缓冲的channel存储数据，使用了ring buffer(环形缓冲区) 来缓存写入的数据，本质是循环数组。</p>\n<p>为啥是循环数组呢？普通数组不行吗，普通数组容量固定，更适合指定的空间，弹出元素的时候，普通数组需要全部前移。</p>\n<p><code>当下标超过数组容量后会回到第一个位置，所以需要有两个字段记录当前读和写的下标位置</code></p>\n</li>\n<li><p>对于无缓冲的channel 存储数据</p>\n</li>\n</ul>\n<p>等待队列： </p>\n<p>双向链表，包含一个头结点和一个尾结点 每个节点是一个sudog结构体变量，记录哪个协程在等待，等待的是哪个channel，等待发送**/**接收的数据在哪里</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> wait <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">\tfirst *sudog</span><br><span class=\"line\">\tlast *sudog</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> sudog <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">\tg *g</span><br><span class=\"line\">\tnext *sudog</span><br><span class=\"line\">\tpre  *sudog</span><br><span class=\"line\">\telem unsafe.Pointer</span><br><span class=\"line\">\tc  *hchan</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>创建 channel 的时候：</p>\n<p>创建时会做一些检查**:** </p>\n<ul>\n<li>元素大小不能超过 <strong>64</strong>K</li>\n<li>元素的对齐大小不能超过 maxAlign 也就是 <strong>8</strong> 字节</li>\n<li>计算出来的内存是否超过限制</li>\n</ul>\n<p>创建时的策略:</p>\n<ul>\n<li><p>如果是无缓冲的channel，会直接给hchan 分配内存</p>\n</li>\n<li><p>如果是有缓冲的channel，并且元素不包含指针，那么会为 hchan  和底层数组分配一段连续的地址</p>\n</li>\n<li><p>如果是有缓冲的channel，元素包含指针，那么就会为了hchan 和底层数组分别分配地址</p>\n</li>\n</ul>\n<p>发送时：</p>\n<ul>\n<li><p>如果 channel 的读队列存在着接收者 goroutine，将唤醒接收的goroutine，将数据<strong>直接发送</strong>给第一个等待的 goroutine</p>\n</li>\n<li><p>如果channel 的读等待队列不存在接收者 goroutine</p>\n<ul>\n<li>如果循环数组buffer未满，那么将会把数据发送到循环数组buffer的队尾</li>\n<li>如果循环数组buffer已满，这个时候就会阻塞发送的流程，将当前goroutine加入写等待队列，<strong>并挂起等待唤醒</strong></li>\n</ul>\n</li>\n</ul>\n<p>接收时：</p>\n<ul>\n<li><p>如果 channel 的写等待队列存在发送者 goroutine</p>\n<ul>\n<li>如果是无缓冲 channel ，<strong>直接</strong>从第一个发送者goroutine 那里 把数据拷贝给接受变量，<strong>唤醒 发送的goroutine</strong></li>\n<li>如果是有缓冲的 channel（已满），将循环数组的buffer的队首元素拷贝给接受变量，将第一个发送者goroutine的数据拷贝到buffer循环数组的队尾，<strong>唤醒发送的goroutine</strong></li>\n</ul>\n</li>\n<li><p>如果channel 的写等待队列不存在发送者goroutine</p>\n<ul>\n<li>如果循环数组buffer非空，将循环数组buffer的队首元素拷贝给接受变量</li>\n<li>如果循环数组buffer为空，这个时候就会阻塞接收的流程，将当前goroutine 加入读等待队列，并<strong>挂起等待唤醒</strong></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"channel-有什么特点\"><a href=\"#channel-有什么特点\" class=\"headerlink\" title=\"channel 有什么特点\"></a>channel 有什么特点</h3><p>channel是线程安全的</p>\n<p>channel 有两种类型： 无缓冲、有缓冲</p>\n<p>channel 有三种模式： 写操作模式（单向通道）、读操作模式（单向通道）、读写操作模式（双向通道）</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">写操作模式    <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span>&lt;- <span class=\"type\">int</span>)</span><br><span class=\"line\">读操作模式    <span class=\"built_in\">make</span>(&lt;-<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\">读写操作模式    <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br></pre></td></tr></table></figure>\n\n<p>channel 有 3 种状态：未初始化、正常、关闭</p>\n<table>\n<thead>\n<tr>\n<th>操作 \\ 状态</th>\n<th>未初始化</th>\n<th>关闭</th>\n<th>正常</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>关闭</td>\n<td>panic</td>\n<td>panic</td>\n<td>正常</td>\n</tr>\n<tr>\n<td>发送</td>\n<td>永远阻塞导致死锁</td>\n<td>panic</td>\n<td>阻塞或者成功发送</td>\n</tr>\n<tr>\n<td>接收</td>\n<td>永远阻塞导致死锁</td>\n<td>缓冲区为空则为零值，否则可以继续读</td>\n<td>阻塞或者成功接收</td>\n</tr>\n</tbody></table>\n<p>注意点：</p>\n<ul>\n<li><p>一个 channel不能多次关闭，会导致painc</p>\n</li>\n<li><p>如果多个 goroutine 都监听同一个 channel，那么 channel 上的数据都可能随机被某一个 goroutine 取走进行消费</p>\n</li>\n<li><p>如果多个 goroutine 监听同一个 channel，如果这个 channel 被关闭，则所有 goroutine 都能收到退出信号</p>\n</li>\n</ul>\n<h3 id=\"Channel-的使用场景\"><a href=\"#Channel-的使用场景\" class=\"headerlink\" title=\"Channel 的使用场景\"></a>Channel 的使用场景</h3><p>无缓冲 Channel 在并发编程中的具体业务使用场景很多，主要应用于 Go 语言中。以下是一些常见的无缓冲 Channel 的具体业务使用场景及例子：</p>\n<ol>\n<li>并发控制：在并发程序中，通过无缓冲 Channel 可以实现多个 Goroutine 之间的<strong>同步和控制</strong>。例如，一个任务需要多个协程协作完成时，可以使用无缓冲 Channel 来传递任务数据和控制信号。</li>\n<li>事件驱动：在事件驱动的编程中，可以使用无缓冲 Channel 来传递事件和执行结果。例如，当一个 HTTP 请求到达时，可以将请求交给一个协程处理，并使用无缓冲 Channel 返回处理结果。</li>\n<li>分布式计算：在分布式计算中，可以使用无缓冲 Channel 来实现节点之间的通信和数据传递。例如，在 MapReduce 算法中，可以使用无缓冲 Channel 来传递 Map 阶段的输出结果并驱动 Reduce 阶段的计算。</li>\n</ol>\n<p>有缓冲 Channel 在并发编程中的具体业务使用场景也很多，主要应用于 Go 语言中。以下是一些常见的有缓冲 Channel 的具体业务使用场景及例子：</p>\n<ol>\n<li>网络编程：在 TCP 或 UDP 数据处理中，可以使用有缓冲 Channel 缓存数据，<strong>以避免因数据接收太慢而导致发送者被阻塞</strong>。例如，在高并发的 Web 服务器中，可以使用有缓冲 Channel 缓存请求数据以提高吞吐量。</li>\n<li>IO 操作：在使用 IO 操作时，如文件读写、数据库访问等，可以使用有缓冲 Channel 缓存数据，以避免因数据处理速度不匹配而导致发送者或接收者被阻塞。例如，<strong>在从数据库获取大量数据时，可以使用有缓冲 Channel 缓存数据，减少数据库连接次数。</strong></li>\n<li>并发控制：在并发程序中，通过有缓冲 Channel 可以实现多个 Goroutine 之间的同步和控制。例如，一个任务需要多个协程协作完成时，可以使用有缓冲 Channel 来传递任务数据和控制信号，并根据缓冲区的剩余空间来控制协程的执行顺序。</li>\n<li>事件驱动：在事件驱动的编程中，可以使用有缓冲 Channel 来缓存事件和执行结果，并根据缓冲区的剩余空间来控制事件的处理顺序。例如，当一个 HTTP 请求到达时，可以将请求交给一个协程处理，并使用有缓冲 Channel 缓存处理结果，避免处理速度过慢导致请求被阻塞。</li>\n</ol>\n<h3 id=\"channel-为什么是线程安全的\"><a href=\"#channel-为什么是线程安全的\" class=\"headerlink\" title=\"channel 为什么是线程安全的\"></a>channel 为什么是线程安全的</h3><p>不同协程通过channel进行通信，本身的使用场景就是多线程，为了保证数据的一致性，必须实现线程安全</p>\n<p>channel的底层实现中，hchan结构体中采用Mutex锁来保证数据读写安全。在对循环数组buf中的数据进行入队和出队操作时，必须先获取互斥锁，才能操作channel数据</p>\n<h3 id=\"Channel-发送和接收什么情况下会死锁\"><a href=\"#Channel-发送和接收什么情况下会死锁\" class=\"headerlink\" title=\"Channel 发送和接收什么情况下会死锁\"></a>Channel 发送和接收什么情况下会死锁</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">deadlock1</span><span class=\"params\">()</span></span> &#123;    <span class=\"comment\">//无缓冲channel只写不读</span></span><br><span class=\"line\">    ch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>) </span><br><span class=\"line\">    ch &lt;- <span class=\"number\">3</span> <span class=\"comment\">//  这里会发生一直阻塞的情况，执行不到下面一句</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">deadlock2</span><span class=\"params\">()</span></span> &#123; <span class=\"comment\">//无缓冲channel读在写后面</span></span><br><span class=\"line\">    ch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\">    ch &lt;- <span class=\"number\">3</span>  <span class=\"comment\">//  这里会发生一直阻塞的情况，执行不到下面一句</span></span><br><span class=\"line\">    num := &lt;-ch</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;num=&quot;</span>, num)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">deadlock3</span><span class=\"params\">()</span></span> &#123; <span class=\"comment\">//无缓冲channel读在写后面</span></span><br><span class=\"line\">    ch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\">    ch &lt;- <span class=\"number\">100</span> <span class=\"comment\">//  这里会发生一直阻塞的情况，执行不到下面一句</span></span><br><span class=\"line\">    <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        num := &lt;-ch</span><br><span class=\"line\">        fmt.Println(<span class=\"string\">&quot;num=&quot;</span>, num)</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">    time.Sleep(time.Second)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">deadlock3</span><span class=\"params\">()</span></span> &#123;    <span class=\"comment\">//有缓冲channel写入超过缓冲区数量</span></span><br><span class=\"line\">    ch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\">    ch &lt;- <span class=\"number\">3</span></span><br><span class=\"line\">    ch &lt;- <span class=\"number\">4</span></span><br><span class=\"line\">    ch &lt;- <span class=\"number\">5</span></span><br><span class=\"line\">    ch &lt;- <span class=\"number\">6</span>  <span class=\"comment\">//  这里会发生一直阻塞的情况</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">deadlock4</span><span class=\"params\">()</span></span> &#123;    <span class=\"comment\">//空读</span></span><br><span class=\"line\">    ch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\">    <span class=\"comment\">// ch := make(chan int, 1)</span></span><br><span class=\"line\">    fmt.Println(&lt;-ch)  <span class=\"comment\">//  这里会发生一直阻塞的情况</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">deadlock5</span><span class=\"params\">()</span></span> &#123;    <span class=\"comment\">//互相等对方造成死锁</span></span><br><span class=\"line\">    ch1 := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\">    ch2 := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\">    <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> num := &lt;-ch1:</span><br><span class=\"line\">            fmt.Println(<span class=\"string\">&quot;num=&quot;</span>, num)</span><br><span class=\"line\">            ch2 &lt;- <span class=\"number\">100</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> num := &lt;-ch2:</span><br><span class=\"line\">            fmt.Println(<span class=\"string\">&quot;num=&quot;</span>, num)</span><br><span class=\"line\">            ch1 &lt;- <span class=\"number\">300</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"互斥锁实现原理\"><a href=\"#互斥锁实现原理\" class=\"headerlink\" title=\"互斥锁实现原理\"></a>互斥锁实现原理</h3><p>Go sync包提供了两种锁类型：互斥锁sync.Mutex 和 读写互斥锁sync.RWMutex，都属于((20230402113517-ppcs0gj “悲观锁”))。<br><a href=\"https://blog.csdn.net/baolingye/article/details/111357407\">https://blog.csdn.net/baolingye/article/details/111357407</a></p>\n<p>在正常模式下，<strong>锁的等待者会按照先进先出的顺序获取锁</strong>。但是刚被唤起的 Goroutine 与新创建的 Goroutine 竞争时，大概率会获取不到锁，在这种情况下，这个被唤醒的 Goroutine 会加入到等待队列的前面。 如果一个等待的 Goroutine 超过1ms 没有获取锁，那么它将会把锁转变为<strong>饥饿模式</strong>。<br>Go在1.9中引入优化，目的保证互斥锁的公平性。在饥饿模式中，互斥锁会直接交给等待队列最前面的 Goroutine。新的 Goroutine 在该状态下不能获取锁、也不会进入自旋状态，它们只会在队列的末尾等待。如果一个 Goroutine 获得了互斥锁并且它在队列的末尾或者它等待的时间少于 1ms，那么当前的互斥锁就会切换回正常模式。</p>\n<h3 id=\"悲观锁与乐观锁\"><a href=\"#悲观锁与乐观锁\" class=\"headerlink\" title=\"悲观锁与乐观锁\"></a>悲观锁与乐观锁</h3><p><strong>悲观锁</strong>是基于一种悲观的态度类来防止一切数据冲突，它是以一种预防的姿态在<strong>修改数据之前把数据锁住，然后再对数据进行读写，在它释放锁之前任何人都不能对其数据进行操作，直到前面一个人把锁释放后下一个人数据加锁才可对数据进行加锁，</strong>然后才可以对数据进行操作，一般数据库本身锁的机制都是基于悲观锁的机制实现的;</p>\n<p>特点：可以完全保证数据的独占性和正确性，因为每次请求都会先对数据进行加锁， 然后进行数据操作，最后再解锁，而加锁释放锁的过程会造成消耗，所以性能不高;</p>\n<p><strong>乐观锁</strong>是对于数据冲突保持一种乐观态度，操作数据时不会对操作的数据进行加锁（这使得多个任务可以并行的对数据进行操作），只有到数据提交的时候才通过一种机制来验证数据是否存在冲突(一般实现方式是通过加版本号然后进行版本号的对比方式实现);</p>\n<p>特点：乐观锁是一种并发类型的锁，其本身不对数据进行加锁通而是通过业务实现锁的功能，不对数据进行加锁就意味着允许多个请求同时访问数据，同时也省掉了对数据加锁和解锁的过程，这种方式因为节省了悲观锁加锁的操作，所以可以一定程度的的提高操作的性能，不过在并发非常高的情况下，会导致大量的请求冲突，冲突导致大部分操作无功而返而浪费资源，所以在高并发的场景下，乐观锁的性能却反而不如悲观锁。</p>\n<h3 id=\"原子操作和锁的区别\"><a href=\"#原子操作和锁的区别\" class=\"headerlink\" title=\"原子操作和锁的区别\"></a>原子操作和锁的区别</h3><p>在并发编程里，Go语言<code>sync</code>包里的同步原语<code>Mutex</code>是我们经常用来保证并发安全的，那么他跟<code>atomic</code>包里的这些操作有啥区别呢？在我看来他们在使用目的和底层实现上都不一样：</p>\n<ul>\n<li>使用目的：互斥锁是用来保护一段逻辑，原子操作用于对一个变量的更新保护。</li>\n<li>底层实现：<code>Mutex</code>由<strong>操作系统</strong>的调度器实现，而<code>atomic</code>包中的原子操作则由<strong>底层硬件指令</strong>直接提供支持，这些指令在执行的过程中是不允许中断的，因此原子操作可以在<code>lock-free</code>的情况下保证并发安全，并且它的性能也能做到随<code>CPU</code>个数的增多而线性扩展。</li>\n</ul>\n<h3 id=\"互斥锁允许自旋的条件\"><a href=\"#互斥锁允许自旋的条件\" class=\"headerlink\" title=\"互斥锁允许自旋的条件\"></a>互斥锁允许自旋的条件</h3><p>线程没有获取到锁时常见有2种处理方式：</p>\n<ul>\n<li>一种是没有获取到锁的线程就会循环等待判断该资源是否已经释放锁，这种锁也叫做自旋锁，它不用将线程阻塞起来， 适用于并发低且程序执行时间短的场景，缺点是cpu占用较高</li>\n<li>另外一种处理方式就是把自己阻塞起来，会释放CPU给其他线程，内核会将线程置为「睡眠」状态，等到锁被释放后，内核会在合适的时机唤醒该线程，适用于高并发场景，缺点是有线程上下文切换的开销<br>Go语言中的Mutex实现了自旋与阻塞两种场景，当满足不了自旋条件时，就会进入阻塞<br><strong>允许自旋的条件：</strong></li>\n</ul>\n<ol>\n<li>锁已被占用，并且锁不处于饥饿模式。</li>\n<li>积累的自旋次数小于最大自旋次数（active_spin=4）。</li>\n<li>cpu 核数大于 1。</li>\n<li>有空闲的 P。</li>\n<li>当前 goroutine 所挂载的 P 下，本地待运行队列为空。</li>\n</ol>\n<h3 id=\"读写锁的实现原理\"><a href=\"#读写锁的实现原理\" class=\"headerlink\" title=\"读写锁的实现原理\"></a>读写锁的实现原理</h3><p>读写锁的底层是基于互斥锁实现的。<br>写锁需要阻塞写锁：一个协程拥有写锁时，其他协程写锁定需要阻塞；<br>写锁需要阻塞读锁：一个协程拥有写锁时，其他协程读锁定需要阻塞；<br>读锁需要阻塞写锁：一个协程拥有读锁时，其他协程写锁定需要阻塞；<br><strong>读锁不能阻塞读锁：一个协程拥有读锁时，其他协程也可以拥有读锁。</strong></p>\n<h3 id=\"“原子操作”有哪些\"><a href=\"#“原子操作”有哪些\" class=\"headerlink\" title=\"“原子操作”有哪些\"></a>“原子操作”有哪些</h3><p>Go atomic包是最轻量级的锁（也称无锁结构），可以在不形成临界区和创建互斥量的情况下完成并发安全的值替换操作，不过这个包只支持int32/int64/uint32/uint64/uintptr这几种数据类型的一些基础操作（增减、交换、载入、存储等）<br>当我们想要对<strong>某个变量</strong>并发安全的修改，除了使用官方提供的 <code>mutex</code>，还可以使用 sync/atomic 包的原子操作，它能够保证对变量的读取或修改期间不被其他的协程所影响。<br>atomic 包提供的原子操作能够确保任一时刻只有一个goroutine对变量进行操作，善用 atomic 能够避免程序中出现大量的锁操作。<br><strong>常见操作：</strong></p>\n<ul>\n<li>增减Add     AddInt32 AddInt64 AddUint32 AddUint64 AddUintptr</li>\n<li>载入Load    LoadInt32 LoadInt64    LoadPointer    LoadUint32    LoadUint64    LoadUintptr</li>\n<li>比较并交换   CompareAndSwap    CompareAndSwapInt32…</li>\n<li>交换Swap    SwapInt32…</li>\n<li>存储Store    StoreInt32…</li>\n</ul>\n<h3 id=\"Goroutine-的底层实现原理\"><a href=\"#Goroutine-的底层实现原理\" class=\"headerlink\" title=\"Goroutine 的底层实现原理\"></a>Goroutine 的底层实现原理</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">g本质是一个数据结构,真正让 goroutine 运行起来的是调度器</span><br><span class=\"line\"><span class=\"keyword\">type</span> g <span class=\"keyword\">struct</span> &#123; </span><br><span class=\"line\">    goid <span class=\"type\">int64</span>  <span class=\"comment\">// 唯一的goroutine的ID </span></span><br><span class=\"line\">    sched gobuf <span class=\"comment\">// goroutine切换时，用于保存g的上下文 </span></span><br><span class=\"line\">    stack stack <span class=\"comment\">// 栈 </span></span><br><span class=\"line\">    gopc <span class=\"comment\">// pc of go statement that created this goroutine </span></span><br><span class=\"line\">    startpc <span class=\"type\">uintptr</span>  <span class=\"comment\">// pc of goroutine function ... </span></span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"keyword\">type</span> gobuf <span class=\"keyword\">struct</span> &#123;     <span class=\"comment\">//运行时寄存器</span></span><br><span class=\"line\">    sp <span class=\"type\">uintptr</span>  <span class=\"comment\">// 栈指针位置 </span></span><br><span class=\"line\">    pc <span class=\"type\">uintptr</span>  <span class=\"comment\">// 运行到的程序位置 </span></span><br><span class=\"line\">    g  guintptr <span class=\"comment\">// 指向 goroutine </span></span><br><span class=\"line\">    ret <span class=\"type\">uintptr</span> <span class=\"comment\">// 保存系统调用的返回值 ... </span></span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"keyword\">type</span> stack <span class=\"keyword\">struct</span> &#123;     <span class=\"comment\">//运行时栈</span></span><br><span class=\"line\">    lo <span class=\"type\">uintptr</span>  <span class=\"comment\">// 栈的下界内存地址 </span></span><br><span class=\"line\">    hi <span class=\"type\">uintptr</span>  <span class=\"comment\">// 栈的上界内存地址 </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><h3 id=\"goroutine-和线程的区别\"><a href=\"#goroutine-和线程的区别\" class=\"headerlink\" title=\"goroutine 和线程的区别\"></a>goroutine 和线程的区别</h3><p>内存占用:<br>创建一个 goroutine 的栈内存消耗为 2 KB，实际运行过程中，如果栈空间不够用，会自动进行扩容。创建一个 thread 则需要消耗 1 MB 栈内存。<br>创建和销毀:<br>Thread 创建和销毀需要陷入内核,系统调用。而 goroutine 因为是由 Go runtime 负责管理的，创建和销毁的消耗非常小，是用户级。<br>切换:<br>当 threads 切换时，需要保存各种寄存器,而 goroutines 切换只需保存三个寄存器：Program Counter, Stack Pointer and BP。一般而言，线程切换会消耗 1000-1500 ns,Goroutine 的切换约为 200 ns,因此，goroutines 切换成本比 threads 要小得多。</p>\n<h3 id=\"Go-线程模型（Go底层怎么实现高并发的）\"><a href=\"#Go-线程模型（Go底层怎么实现高并发的）\" class=\"headerlink\" title=\"Go 线程模型（Go底层怎么实现高并发的）\"></a>Go 线程模型（Go底层怎么实现高并发的）</h3><blockquote>\n<p>线程协程，进程的区别：</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/337978321\">https://zhuanlan.zhihu.com/p/337978321</a></p>\n<p><a href=\"https://www.bilibili.com/read/cv9346691/\">https://www.bilibili.com/read/cv9346691/</a></p>\n</blockquote>\n<p>Golang的调度器是一个轻量级的协程调度器，主要负责管理和调度协程。Golang 中的调度器采用 <strong>M:N 模型</strong>，即 M 个用户级线程对应 N 个内核线程。</p>\n<p>调度器会将 Golang 中的协程（goroutine）调度到不同的线程上运行，以实现并发执行的效果。</p>\n<p>M个线程对应N个内核线程的优点：</p>\n<ul>\n<li>能够利用多核</li>\n<li>上下文切换成本低</li>\n<li>如果进程中的一个线程被阻塞，不会阻塞其他线程，是能够切换同一进程内的其他线程继续执行</li>\n</ul>\n<h3 id=\"Golang-assertion\"><a href=\"#Golang-assertion\" class=\"headerlink\" title=\"Golang assertion\"></a>Golang assertion</h3><h2 id=\"Golang调用方面\"><a href=\"#Golang调用方面\" class=\"headerlink\" title=\"Golang调用方面\"></a>Golang调用方面</h2><h3 id=\"len-统计长度\"><a href=\"#len-统计长度\" class=\"headerlink\" title=\"len 统计长度\"></a>len 统计长度</h3><p><font color = 'red'>len()计算的是字节的长度，和编码无关，对于英文和数组对象等，字节长度等效于实际长度</font><br>当需要计算中文字符长度的时候，就需要调用其他的函数方法：<br><code>utf8.RuneCountInString(&quot;中文&quot;)</code></p>\n","site":{"data":{}},"cover":"/img/cover/sky2.png","cover_type":"img","excerpt":"","more":"<ul>\n<li><a href=\"#golang-%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E5%9B%9E%E7%AD%94%E6%94%B6%E9%9B%86\">Golang 系统知识回答收集</a><ul>\n<li><a href=\"#golang-%E8%AF%AD%E6%B3%95%E6%96%B9%E9%9D%A2\">Golang 语法方面</a><ul>\n<li><a href=\"#golang%E5%85%B3%E9%94%AE%E5%AD%97%E6%9C%89%E5%93%AA%E4%BA%9B\">Golang关键字有哪些</a></li>\n<li><a href=\"#golang-%E5%BD%93%E4%B8%AD\">Golang 当中</a></li>\n<li><a href=\"#range-%E5%87%BD%E6%95%B0%E7%9A%84%E5%85%B7%E4%BD%93%E4%BD%BF%E7%94%A8\">range 函数的具体使用</a></li>\n<li><a href=\"#slice-%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6\">Slice 扩容机制</a></li>\n<li><a href=\"#slice-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84\">Slice 为什么不是线程安全的</a></li>\n<li><a href=\"#map%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86\">map的底层原理</a></li>\n<li><a href=\"#map%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6\">map的扩容机制</a></li>\n<li><a href=\"#map%E7%9A%84%E9%81%8D%E5%8E%86%E4%B8%BA%E4%BB%80%E4%B9%88%E6%97%A0%E5%BA%8F\">map的遍历为什么无序</a></li>\n<li><a href=\"#map%E7%9A%84%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E4%B8%8D%E6%98%AF%E8%BF%9E%E7%BB%AD%E7%9A%84\">map的底层存储不是连续的</a></li>\n<li><a href=\"#map-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84\">map 为什么不是线程安全的</a></li>\n<li><a href=\"#map%E5%A6%82%E4%BD%95%E6%9F%A5%E6%89%BE\">Map如何查找</a></li>\n<li><a href=\"#map-%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E7%9A%84%E6%96%B9%E5%BC%8F\">map 冲突解决的方式</a></li>\n<li><a href=\"#map-%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9B%A0%E5%AD%90%E4%B8%BA%E4%BB%80%E4%B9%88%E6%97%B665\">map 的负载因子为什么时6.5</a></li>\n<li><a href=\"#map%E5%92%8C-syncmap%E5%93%AA%E4%B8%80%E4%B8%AA%E6%80%A7%E8%83%BD%E5%A5%BD\">Map和 Sync.Map哪一个性能好</a></li>\n<li><a href=\"#channel-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\">channel 底层实现原理</a></li>\n<li><a href=\"#channel-%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9\">channel 有什么特点</a></li>\n<li><a href=\"#channel-%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF\">Channel 的使用场景</a></li>\n<li><a href=\"#channel-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84\">channel 为什么是线程安全的</a></li>\n<li><a href=\"#channel-%E5%8F%91%E9%80%81%E5%92%8C%E6%8E%A5%E6%94%B6%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E6%AD%BB%E9%94%81\">Channel 发送和接收什么情况下会死锁</a></li>\n<li><a href=\"#%E4%BA%92%E6%96%A5%E9%94%81%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\">互斥锁实现原理</a></li>\n<li><a href=\"#%E6%82%B2%E8%A7%82%E9%94%81%E4%B8%8E%E4%B9%90%E8%A7%82%E9%94%81\">悲观锁与乐观锁</a></li>\n<li><a href=\"#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E5%92%8C%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB\">原子操作和锁的区别</a></li>\n<li><a href=\"#%E4%BA%92%E6%96%A5%E9%94%81%E5%85%81%E8%AE%B8%E8%87%AA%E6%97%8B%E7%9A%84%E6%9D%A1%E4%BB%B6\">互斥锁允许自旋的条件</a></li>\n<li><a href=\"#%E8%AF%BB%E5%86%99%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\">读写锁的实现原理</a></li>\n<li><a href=\"#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E6%9C%89%E5%93%AA%E4%BA%9B\">“原子操作”有哪些</a></li>\n<li><a href=\"#goroutine-%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\">Goroutine 的底层实现原理</a></li>\n<li><a href=\"#\"></a></li>\n<li><a href=\"#goroutine-%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB\">goroutine 和线程的区别</a></li>\n<li><a href=\"#go-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8Bgo%E5%BA%95%E5%B1%82%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%B9%B6%E5%8F%91%E7%9A%84\">Go 线程模型（Go底层怎么实现高并发的）</a></li>\n<li><a href=\"#golang-assertion\">Golang assertion</a></li>\n</ul>\n</li>\n<li><a href=\"#golang%E8%B0%83%E7%94%A8%E6%96%B9%E9%9D%A2\">Golang调用方面</a><ul>\n<li><a href=\"#len-%E7%BB%9F%E8%AE%A1%E9%95%BF%E5%BA%A6\">len 统计长度</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"Golang-系统知识回答收集\"><a href=\"#Golang-系统知识回答收集\" class=\"headerlink\" title=\"Golang 系统知识回答收集\"></a>Golang 系统知识回答收集</h1><h2 id=\"Golang-语法方面\"><a href=\"#Golang-语法方面\" class=\"headerlink\" title=\"Golang 语法方面\"></a>Golang 语法方面</h2><h3 id=\"Golang关键字有哪些\"><a href=\"#Golang关键字有哪些\" class=\"headerlink\" title=\"Golang关键字有哪些\"></a>Golang关键字有哪些</h3><h3 id=\"Golang-当中\"><a href=\"#Golang-当中\" class=\"headerlink\" title=\"Golang 当中\"></a>Golang 当中</h3><p>关键字是指被编程语言用作特定目的的保留单词，这些关键字在代码当中具有特殊的含义，不能被用作标识符（例如变量名，函数名，类型名等）。以下是Golang中关键字的列表</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span></span> </span><br><span class=\"line\"><span class=\"keyword\">type</span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> </span><br><span class=\"line\"><span class=\"keyword\">struct</span> </span><br><span class=\"line\"><span class=\"keyword\">var</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">break</span> <span class=\"keyword\">continue</span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">default</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">case</span> </span><br><span class=\"line\"><span class=\"keyword\">select</span></span><br><span class=\"line\"><span class=\"keyword\">defer</span></span><br><span class=\"line\"><span class=\"keyword\">switch</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> </span><br><span class=\"line\"><span class=\"keyword\">range</span> </span><br><span class=\"line\"><span class=\"keyword\">goto</span></span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\"><span class=\"keyword\">if</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span></span><br><span class=\"line\"><span class=\"keyword\">chan</span> </span><br><span class=\"line\"><span class=\"keyword\">map</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span></span><br><span class=\"line\"><span class=\"keyword\">package</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">go</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fallthrough</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"range-函数的具体使用\"><a href=\"#range-函数的具体使用\" class=\"headerlink\" title=\"range 函数的具体使用\"></a>range 函数的具体使用</h3><p>golang当中range 关键字可以用于迭代数组、切片、字符串、map和通道等数据类型</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//迭代数组和切片时候，返回当前元素的索引和值</span></span><br><span class=\"line\">arr := [<span class=\"number\">3</span>]<span class=\"type\">int</span>&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> key,num := <span class=\"keyword\">range</span> arr&#123;</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;now arr[%d] is %d\\n&quot;</span>, key,num)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// map 迭代字符串的时候，每次迭代返回当前字符的索引和Unicode码点</span></span><br><span class=\"line\"></span><br><span class=\"line\">s := <span class=\"string\">&quot;hello world&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i, c := <span class=\"keyword\">range</span> s&#123;</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;index:%d, Unicode code ponit : %U\\n&quot;</span>,i,c)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//迭代map结构</span></span><br><span class=\"line\">m := <span class=\"keyword\">map</span>[<span class=\"type\">int</span>]<span class=\"type\">string</span>&#123;</span><br><span class=\"line\">\t<span class=\"number\">1</span>: <span class=\"string\">&quot;one&quot;</span>,</span><br><span class=\"line\">\t<span class=\"number\">2</span>: <span class=\"string\">&quot;two&quot;</span>,</span><br><span class=\"line\">\t<span class=\"number\">3</span>: <span class=\"string\">&quot;three&quot;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> k,v := <span class=\"keyword\">range</span> m&#123;</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;key : %d, value : %s&quot;</span>,k,v)</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//迭代通道使用range 迭代通道的时候，会不断地从通道当中接受元素，直到通道关闭为止</span></span><br><span class=\"line\"></span><br><span class=\"line\">ch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\"><span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>;i&lt;<span class=\"number\">5</span>,i++&#123;</span><br><span class=\"line\">\tch &lt;- i</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">close</span>(ch)</span><br><span class=\"line\">&#125;()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> v := <span class=\"keyword\">range</span> ch &#123;</span><br><span class=\"line\">\tfmt.Println(v)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在迭代通道的时候，如果通道没有关闭，那么循环就会一直等待下去，知道程序死锁，因此必须要再写入完所有的数据之后关闭通道，或者使用’select’语句在接受通道数据的时候检查通道是否已经关闭</p>\n<h3 id=\"Slice-扩容机制\"><a href=\"#Slice-扩容机制\" class=\"headerlink\" title=\"Slice 扩容机制\"></a>Slice 扩容机制</h3><p>Go 1.18 版本之后，当新切片需要的容量cap大于两倍扩容的容量时候，则直接按照新切片需要的容量进行扩容：</p>\n<ul>\n<li>当原 Slice 容量 &lt; threshold 的时候，新 slice 容量变成原来的2 倍</li>\n<li>当原 Slice 容量 &gt; threshold 的时候，进入一个循环，每次容量增加 （旧容量 + 3*threshold）/4</li>\n</ul>\n<h3 id=\"Slice-为什么不是线程安全的\"><a href=\"#Slice-为什么不是线程安全的\" class=\"headerlink\" title=\"Slice 为什么不是线程安全的\"></a>Slice 为什么不是线程安全的</h3><p>因为 Slice 内部使用了底层数组，数组在内存当中是连续存储的并没有加锁的机制，本身并不支持并发的读写</p>\n<p>当多个Goroutine并发访问同一个Slice的时候，可能存在某个Goroutine修改了Slice中的某个元素，其他Goroutine无法立即看到这个修改，也可能会造成竞争问题。可以通过使用((20230318150223-agvrll2 “互斥锁”))或者((20230318154221-miv3alf “原子操作”))来保证某个Goroutine访问的时候其他goroutine不能够同时访问，另外也可以使用通道来进行同步，通过将Slice的访问权限交给某个Goroutine，从而保障其他的Goroutine无法同时访问该Slice。</p>\n<h3 id=\"map的底层原理\"><a href=\"#map的底层原理\" class=\"headerlink\" title=\"map的底层原理\"></a>map的底层原理</h3><p>map对象本身是一个指针，占用8个字节（64位计算机），指向<code>hmap</code>结构体，hmap包含多个bmap数组（桶）</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> hmap <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">\tcount <span class=\"type\">int</span> <span class=\"comment\">// 元素个数，调用len(map)的时候直接返回</span></span><br><span class=\"line\">\tflags <span class=\"type\">uint8</span> <span class=\"comment\">// 标志当前map的状态，正在删除元素、添加元素、、、、</span></span><br><span class=\"line\">\tB <span class=\"type\">uint8</span> <span class=\"comment\">//单元(buckets)的对数 B=5表示能容纳32个元素  B随着map容量增大而变大</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tnoverflow <span class=\"type\">uint16</span>  <span class=\"comment\">//单元(buckets)溢出数量，如果一个单元能存8个key，此时存储了9个，溢出了，就需要再增加一个单元</span></span><br><span class=\"line\">\thash0 <span class=\"type\">uint32</span> <span class=\"comment\">//哈希种子</span></span><br><span class=\"line\">\tbuckets unsafe.Pointer <span class=\"comment\">//指向单元(buckets)数组,大小为2^B，可以为nil</span></span><br><span class=\"line\">\toldbuckets unsafe.Pointer <span class=\"comment\">//扩容的时候，buckets长度会是oldbuckets的两倍</span></span><br><span class=\"line\">\tnevacute <span class=\"type\">uintptr</span>  <span class=\"comment\">//指示扩容进度，小于此buckets迁移完成 </span></span><br><span class=\"line\">\textra *mapextra <span class=\"comment\">//与gc相关 可选字段 </span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> bmap <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">\ttophash [bucketCnt]<span class=\"type\">uint8</span> </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//实际上编译期间会生成一个新的数据结构  </span></span><br><span class=\"line\"><span class=\"keyword\">type</span> bmap <span class=\"keyword\">struct</span> &#123; </span><br><span class=\"line\">    topbits [<span class=\"number\">8</span>]<span class=\"type\">uint8</span>     <span class=\"comment\">//key hash值前8位 用于快速定位keys的位置</span></span><br><span class=\"line\">    keys [<span class=\"number\">8</span>]keytype     <span class=\"comment\">//键</span></span><br><span class=\"line\">    values [<span class=\"number\">8</span>]valuetype <span class=\"comment\">//值</span></span><br><span class=\"line\">    pad <span class=\"type\">uintptr</span> </span><br><span class=\"line\">    overflow <span class=\"type\">uintptr</span>     <span class=\"comment\">//指向溢出桶 无符号整形 优化GC</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"map的扩容机制\"><a href=\"#map的扩容机制\" class=\"headerlink\" title=\"map的扩容机制\"></a>map的扩容机制</h3><p>扩容时机：向map里面插入新的key的时候，会进行条件检测，符合以下两个条件就会触发扩容操作：</p>\n<p>扩容条件：</p>\n<ol>\n<li>超过负载 map元素个数 &gt; 负载因子 * 桶个数</li>\n<li>溢出桶太多</li>\n</ol>\n<p>负载因子是元素个数与桶的数量的比值</p>\n<p>当桶总数&lt;2^15^时，如果溢出桶总数&gt;=桶总数，则认为溢出桶过多</p>\n<p>当桶总数&gt;2^15^时，如果溢出桶总数&gt;=2^15^，则认为溢出桶过多</p>\n<p>扩容机制：</p>\n<ul>\n<li><p>双倍扩容：针对条件1，新建一个buckets数组，新的buckets大小是原来的2倍，然后旧buckets数据搬迁到新的buckets。</p>\n</li>\n<li><p>等量扩容：针对条件2，并不扩大容量，buckets数量维持不变，重新做一遍类似双倍扩容的搬迁动作，把松散的键值对重新排列一次，使得同一个 bucket 中的 key 排列地更紧密，节省空间，提高 bucket 利用率，进而保证更快的存取。</p>\n</li>\n<li><p>渐进式扩容： 插入修改删除key的时候，都会尝试进行搬迁桶的工作，每次都会检查oldbucket是否<strong>nil</strong>，如果不是<strong>nil</strong>则每次搬迁<strong>2</strong>个桶，蚂蚁搬家一样渐进式扩容</p>\n</li>\n</ul>\n<h3 id=\"map的遍历为什么无序\"><a href=\"#map的遍历为什么无序\" class=\"headerlink\" title=\"map的遍历为什么无序\"></a>map的遍历为什么无序</h3><p>map  每次遍历，都会从一个随机值序号的桶开始，再从其中随机的cell 开始遍历，并且扩容后，原来桶中的key会落到其他的桶中，本身就会造成失序。</p>\n<p>如果想要遍历map，先把key放到切片中排序，再按照key的顺序遍历map</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//请写一段代码验证</span></span><br><span class=\"line\">m := <span class=\"keyword\">map</span>[<span class=\"type\">int</span>]<span class=\"type\">string</span> &#123;</span><br><span class=\"line\">\t<span class=\"number\">1</span>: <span class=\"string\">&quot;one&quot;</span>,</span><br><span class=\"line\">\t<span class=\"number\">2</span>: <span class=\"string\">&quot;two&quot;</span>,</span><br><span class=\"line\">\t<span class=\"number\">3</span>: <span class=\"string\">&quot;three&quot;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> key,value := <span class=\"keyword\">range</span> m&#123;</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;data is : %d ---&gt; %S \\n&quot;</span>, key,value)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"map的底层存储不是连续的\"><a href=\"#map的底层存储不是连续的\" class=\"headerlink\" title=\"map的底层存储不是连续的\"></a>map的底层存储不是连续的</h3><p>具体来说map 内部存储的是一个桶（bucket）数组，桶数组中的每个元素有事一个指向链表头的指针，他存储的数据并不连续</p>\n<h3 id=\"map-为什么不是线程安全的\"><a href=\"#map-为什么不是线程安全的\" class=\"headerlink\" title=\"map 为什么不是线程安全的\"></a>map 为什么不是线程安全的</h3><p>多个协程同时对<strong>map</strong>进行并发读写**,<strong>程序会</strong>panic**</p>\n<p>想要线程安全，可以使用sync.RWLock锁</p>\n<p>在sync.map 这个包当中实现了锁，是线程安全的</p>\n<h3 id=\"Map如何查找\"><a href=\"#Map如何查找\" class=\"headerlink\" title=\"Map如何查找\"></a>Map如何查找</h3><ol>\n<li>计算hash值<br> key经过哈希函数计算后,得到64bit(64位CPU)<br> 10010111 | 101011101010110101010101101010101010 | 10010</li>\n<li>找到hash对应的桶<br> 上面64位后5(hmap的B值)位定位所存放的桶<br> 如果当前正在扩容中,并且定位到旧桶数据还未完成迁移,则使用旧的桶</li>\n<li>遍历桶查找<br> 上面64位前8位用来在tophash数组查找快速判断key是否在当前的桶中,如果不在需要去溢出桶查找</li>\n<li>返回key对应的指针</li>\n</ol>\n<h3 id=\"map-冲突解决的方式\"><a href=\"#map-冲突解决的方式\" class=\"headerlink\" title=\"map 冲突解决的方式\"></a>map 冲突解决的方式</h3><p>Go采用链式地址解决冲突，具体实现就是插入key到map中时，当key定位的桶填满8个元素，将会创建一个溢出桶并且将溢出桶插入到当前桶所在的链表尾部</p>\n<p>Golang当中采用链式哈希表（Cahined Hash Table）</p>\n<p>在Golang的哈希表实现当中，每一个桶就是一个链表的头指针，桶内每个元素都是哈希链表节点，节点包含了该元素的哈希值、键以及指向下一个节点的指针。</p>\n<p>在查找时候，先根据键的哈希值找到对应的桶，然后在该桶对应的链表中顺序查找，指导找到目标元素或者是链表遍历完毕。</p>\n<h3 id=\"map-的负载因子为什么时6-5\"><a href=\"#map-的负载因子为什么时6-5\" class=\"headerlink\" title=\"map 的负载因子为什么时6.5\"></a>map 的负载因子为什么时6.5</h3><blockquote>\n<p>负载因子 = 哈希表存储的元素个数 / 桶个数</p>\n</blockquote>\n<p>Go 官方发现：装载因子越大，填入的元素越多，空间利用率就越高，但发生哈希冲突的几率就变大。<br>装载因子越小，填入的元素越少，冲突发生的几率减小，但空间浪费也会变得更多，而且还会提高扩容操作的次数</p>\n<p>Go 官方取了一个相对适中的值，把 Go 中的 map 的负载因子硬编码为 6.5，这就是 6.5 的选择缘由。</p>\n<p>这意味着在 Go 语言中，当 map存储的元素个数大于或等于 6.5 * 桶个数 时，就会触发扩容行为。</p>\n<h3 id=\"Map和-Sync-Map哪一个性能好\"><a href=\"#Map和-Sync-Map哪一个性能好\" class=\"headerlink\" title=\"Map和 Sync.Map哪一个性能好\"></a>Map和 Sync.Map哪一个性能好</h3><p>对比原始map：</p>\n<p>和原始map+RWLock的实现并发的方式相比，减少了加锁对性能的影响。</p>\n<p>它做了一些优化：可以无锁访问read map，而且会优先操作read map，倘若只操作read map就可以满足要求，那就不用去操作write map(dirty)，所以在某些特定场景中它发生锁竞争的频率会远远小于map+RWLock的实现方式</p>\n<ul>\n<li>优点：<br>适合读多写少的场景</li>\n<li>缺点：<br>写多的场景，会导致 read map 缓存失效，需要加锁，冲突变多，性能急剧下降</li>\n</ul>\n<h3 id=\"channel-底层实现原理\"><a href=\"#channel-底层实现原理\" class=\"headerlink\" title=\"channel 底层实现原理\"></a>channel 底层实现原理</h3><p>通过<strong>var****声明或者是</strong>​<strong>make****函数创建的channel变量</strong>是一个存储在函数栈帧上的指针，占用8个字节，指向堆上的hchan结构体</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> hchan <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">\tclosed <span class=\"type\">uint32</span> <span class=\"comment\">// channel 是否关闭的标志</span></span><br><span class=\"line\">\telemtype *_type <span class=\"comment\">// channel 中的元素类型</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tbuf unsafe.Pointer <span class=\"comment\">//指向底层循环数组的指针（环形缓存区）</span></span><br><span class=\"line\">\tqcount <span class=\"type\">uint</span> <span class=\"comment\">// 循环数组中的元素数量</span></span><br><span class=\"line\">\tdataqsiz <span class=\"type\">uint</span> <span class=\"comment\">//循环数组的长度</span></span><br><span class=\"line\">\telemsize <span class=\"type\">uint16</span> <span class=\"comment\">//元素的大小</span></span><br><span class=\"line\">\tsendx <span class=\"type\">uint</span> <span class=\"comment\">// 下一次写下标的位置</span></span><br><span class=\"line\">\trecvx <span class=\"type\">uint</span> <span class=\"comment\">// 下一次读下标的位置</span></span><br><span class=\"line\">\t<span class=\"comment\">// 尝试读取channel 或者向channel 写入数据而被阻塞的goroutine</span></span><br><span class=\"line\">    \trecvq    waitq  <span class=\"comment\">// 读等待队列</span></span><br><span class=\"line\">    \tsendq    waitq  <span class=\"comment\">// 写等待队列</span></span><br><span class=\"line\">    \tlock mutex <span class=\"comment\">//互斥锁，保证读写channel时不存在并发竞争问题</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>channel 分为无缓冲和有缓冲两种</p>\n<ul>\n<li><p>对于有缓冲的channel存储数据，使用了ring buffer(环形缓冲区) 来缓存写入的数据，本质是循环数组。</p>\n<p>为啥是循环数组呢？普通数组不行吗，普通数组容量固定，更适合指定的空间，弹出元素的时候，普通数组需要全部前移。</p>\n<p><code>当下标超过数组容量后会回到第一个位置，所以需要有两个字段记录当前读和写的下标位置</code></p>\n</li>\n<li><p>对于无缓冲的channel 存储数据</p>\n</li>\n</ul>\n<p>等待队列： </p>\n<p>双向链表，包含一个头结点和一个尾结点 每个节点是一个sudog结构体变量，记录哪个协程在等待，等待的是哪个channel，等待发送**/**接收的数据在哪里</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> wait <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">\tfirst *sudog</span><br><span class=\"line\">\tlast *sudog</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> sudog <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">\tg *g</span><br><span class=\"line\">\tnext *sudog</span><br><span class=\"line\">\tpre  *sudog</span><br><span class=\"line\">\telem unsafe.Pointer</span><br><span class=\"line\">\tc  *hchan</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>创建 channel 的时候：</p>\n<p>创建时会做一些检查**:** </p>\n<ul>\n<li>元素大小不能超过 <strong>64</strong>K</li>\n<li>元素的对齐大小不能超过 maxAlign 也就是 <strong>8</strong> 字节</li>\n<li>计算出来的内存是否超过限制</li>\n</ul>\n<p>创建时的策略:</p>\n<ul>\n<li><p>如果是无缓冲的channel，会直接给hchan 分配内存</p>\n</li>\n<li><p>如果是有缓冲的channel，并且元素不包含指针，那么会为 hchan  和底层数组分配一段连续的地址</p>\n</li>\n<li><p>如果是有缓冲的channel，元素包含指针，那么就会为了hchan 和底层数组分别分配地址</p>\n</li>\n</ul>\n<p>发送时：</p>\n<ul>\n<li><p>如果 channel 的读队列存在着接收者 goroutine，将唤醒接收的goroutine，将数据<strong>直接发送</strong>给第一个等待的 goroutine</p>\n</li>\n<li><p>如果channel 的读等待队列不存在接收者 goroutine</p>\n<ul>\n<li>如果循环数组buffer未满，那么将会把数据发送到循环数组buffer的队尾</li>\n<li>如果循环数组buffer已满，这个时候就会阻塞发送的流程，将当前goroutine加入写等待队列，<strong>并挂起等待唤醒</strong></li>\n</ul>\n</li>\n</ul>\n<p>接收时：</p>\n<ul>\n<li><p>如果 channel 的写等待队列存在发送者 goroutine</p>\n<ul>\n<li>如果是无缓冲 channel ，<strong>直接</strong>从第一个发送者goroutine 那里 把数据拷贝给接受变量，<strong>唤醒 发送的goroutine</strong></li>\n<li>如果是有缓冲的 channel（已满），将循环数组的buffer的队首元素拷贝给接受变量，将第一个发送者goroutine的数据拷贝到buffer循环数组的队尾，<strong>唤醒发送的goroutine</strong></li>\n</ul>\n</li>\n<li><p>如果channel 的写等待队列不存在发送者goroutine</p>\n<ul>\n<li>如果循环数组buffer非空，将循环数组buffer的队首元素拷贝给接受变量</li>\n<li>如果循环数组buffer为空，这个时候就会阻塞接收的流程，将当前goroutine 加入读等待队列，并<strong>挂起等待唤醒</strong></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"channel-有什么特点\"><a href=\"#channel-有什么特点\" class=\"headerlink\" title=\"channel 有什么特点\"></a>channel 有什么特点</h3><p>channel是线程安全的</p>\n<p>channel 有两种类型： 无缓冲、有缓冲</p>\n<p>channel 有三种模式： 写操作模式（单向通道）、读操作模式（单向通道）、读写操作模式（双向通道）</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">写操作模式    <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span>&lt;- <span class=\"type\">int</span>)</span><br><span class=\"line\">读操作模式    <span class=\"built_in\">make</span>(&lt;-<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\">读写操作模式    <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br></pre></td></tr></table></figure>\n\n<p>channel 有 3 种状态：未初始化、正常、关闭</p>\n<table>\n<thead>\n<tr>\n<th>操作 \\ 状态</th>\n<th>未初始化</th>\n<th>关闭</th>\n<th>正常</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>关闭</td>\n<td>panic</td>\n<td>panic</td>\n<td>正常</td>\n</tr>\n<tr>\n<td>发送</td>\n<td>永远阻塞导致死锁</td>\n<td>panic</td>\n<td>阻塞或者成功发送</td>\n</tr>\n<tr>\n<td>接收</td>\n<td>永远阻塞导致死锁</td>\n<td>缓冲区为空则为零值，否则可以继续读</td>\n<td>阻塞或者成功接收</td>\n</tr>\n</tbody></table>\n<p>注意点：</p>\n<ul>\n<li><p>一个 channel不能多次关闭，会导致painc</p>\n</li>\n<li><p>如果多个 goroutine 都监听同一个 channel，那么 channel 上的数据都可能随机被某一个 goroutine 取走进行消费</p>\n</li>\n<li><p>如果多个 goroutine 监听同一个 channel，如果这个 channel 被关闭，则所有 goroutine 都能收到退出信号</p>\n</li>\n</ul>\n<h3 id=\"Channel-的使用场景\"><a href=\"#Channel-的使用场景\" class=\"headerlink\" title=\"Channel 的使用场景\"></a>Channel 的使用场景</h3><p>无缓冲 Channel 在并发编程中的具体业务使用场景很多，主要应用于 Go 语言中。以下是一些常见的无缓冲 Channel 的具体业务使用场景及例子：</p>\n<ol>\n<li>并发控制：在并发程序中，通过无缓冲 Channel 可以实现多个 Goroutine 之间的<strong>同步和控制</strong>。例如，一个任务需要多个协程协作完成时，可以使用无缓冲 Channel 来传递任务数据和控制信号。</li>\n<li>事件驱动：在事件驱动的编程中，可以使用无缓冲 Channel 来传递事件和执行结果。例如，当一个 HTTP 请求到达时，可以将请求交给一个协程处理，并使用无缓冲 Channel 返回处理结果。</li>\n<li>分布式计算：在分布式计算中，可以使用无缓冲 Channel 来实现节点之间的通信和数据传递。例如，在 MapReduce 算法中，可以使用无缓冲 Channel 来传递 Map 阶段的输出结果并驱动 Reduce 阶段的计算。</li>\n</ol>\n<p>有缓冲 Channel 在并发编程中的具体业务使用场景也很多，主要应用于 Go 语言中。以下是一些常见的有缓冲 Channel 的具体业务使用场景及例子：</p>\n<ol>\n<li>网络编程：在 TCP 或 UDP 数据处理中，可以使用有缓冲 Channel 缓存数据，<strong>以避免因数据接收太慢而导致发送者被阻塞</strong>。例如，在高并发的 Web 服务器中，可以使用有缓冲 Channel 缓存请求数据以提高吞吐量。</li>\n<li>IO 操作：在使用 IO 操作时，如文件读写、数据库访问等，可以使用有缓冲 Channel 缓存数据，以避免因数据处理速度不匹配而导致发送者或接收者被阻塞。例如，<strong>在从数据库获取大量数据时，可以使用有缓冲 Channel 缓存数据，减少数据库连接次数。</strong></li>\n<li>并发控制：在并发程序中，通过有缓冲 Channel 可以实现多个 Goroutine 之间的同步和控制。例如，一个任务需要多个协程协作完成时，可以使用有缓冲 Channel 来传递任务数据和控制信号，并根据缓冲区的剩余空间来控制协程的执行顺序。</li>\n<li>事件驱动：在事件驱动的编程中，可以使用有缓冲 Channel 来缓存事件和执行结果，并根据缓冲区的剩余空间来控制事件的处理顺序。例如，当一个 HTTP 请求到达时，可以将请求交给一个协程处理，并使用有缓冲 Channel 缓存处理结果，避免处理速度过慢导致请求被阻塞。</li>\n</ol>\n<h3 id=\"channel-为什么是线程安全的\"><a href=\"#channel-为什么是线程安全的\" class=\"headerlink\" title=\"channel 为什么是线程安全的\"></a>channel 为什么是线程安全的</h3><p>不同协程通过channel进行通信，本身的使用场景就是多线程，为了保证数据的一致性，必须实现线程安全</p>\n<p>channel的底层实现中，hchan结构体中采用Mutex锁来保证数据读写安全。在对循环数组buf中的数据进行入队和出队操作时，必须先获取互斥锁，才能操作channel数据</p>\n<h3 id=\"Channel-发送和接收什么情况下会死锁\"><a href=\"#Channel-发送和接收什么情况下会死锁\" class=\"headerlink\" title=\"Channel 发送和接收什么情况下会死锁\"></a>Channel 发送和接收什么情况下会死锁</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">deadlock1</span><span class=\"params\">()</span></span> &#123;    <span class=\"comment\">//无缓冲channel只写不读</span></span><br><span class=\"line\">    ch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>) </span><br><span class=\"line\">    ch &lt;- <span class=\"number\">3</span> <span class=\"comment\">//  这里会发生一直阻塞的情况，执行不到下面一句</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">deadlock2</span><span class=\"params\">()</span></span> &#123; <span class=\"comment\">//无缓冲channel读在写后面</span></span><br><span class=\"line\">    ch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\">    ch &lt;- <span class=\"number\">3</span>  <span class=\"comment\">//  这里会发生一直阻塞的情况，执行不到下面一句</span></span><br><span class=\"line\">    num := &lt;-ch</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;num=&quot;</span>, num)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">deadlock3</span><span class=\"params\">()</span></span> &#123; <span class=\"comment\">//无缓冲channel读在写后面</span></span><br><span class=\"line\">    ch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\">    ch &lt;- <span class=\"number\">100</span> <span class=\"comment\">//  这里会发生一直阻塞的情况，执行不到下面一句</span></span><br><span class=\"line\">    <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        num := &lt;-ch</span><br><span class=\"line\">        fmt.Println(<span class=\"string\">&quot;num=&quot;</span>, num)</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">    time.Sleep(time.Second)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">deadlock3</span><span class=\"params\">()</span></span> &#123;    <span class=\"comment\">//有缓冲channel写入超过缓冲区数量</span></span><br><span class=\"line\">    ch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\">    ch &lt;- <span class=\"number\">3</span></span><br><span class=\"line\">    ch &lt;- <span class=\"number\">4</span></span><br><span class=\"line\">    ch &lt;- <span class=\"number\">5</span></span><br><span class=\"line\">    ch &lt;- <span class=\"number\">6</span>  <span class=\"comment\">//  这里会发生一直阻塞的情况</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">deadlock4</span><span class=\"params\">()</span></span> &#123;    <span class=\"comment\">//空读</span></span><br><span class=\"line\">    ch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\">    <span class=\"comment\">// ch := make(chan int, 1)</span></span><br><span class=\"line\">    fmt.Println(&lt;-ch)  <span class=\"comment\">//  这里会发生一直阻塞的情况</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">deadlock5</span><span class=\"params\">()</span></span> &#123;    <span class=\"comment\">//互相等对方造成死锁</span></span><br><span class=\"line\">    ch1 := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\">    ch2 := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\">    <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> num := &lt;-ch1:</span><br><span class=\"line\">            fmt.Println(<span class=\"string\">&quot;num=&quot;</span>, num)</span><br><span class=\"line\">            ch2 &lt;- <span class=\"number\">100</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> num := &lt;-ch2:</span><br><span class=\"line\">            fmt.Println(<span class=\"string\">&quot;num=&quot;</span>, num)</span><br><span class=\"line\">            ch1 &lt;- <span class=\"number\">300</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"互斥锁实现原理\"><a href=\"#互斥锁实现原理\" class=\"headerlink\" title=\"互斥锁实现原理\"></a>互斥锁实现原理</h3><p>Go sync包提供了两种锁类型：互斥锁sync.Mutex 和 读写互斥锁sync.RWMutex，都属于((20230402113517-ppcs0gj “悲观锁”))。<br><a href=\"https://blog.csdn.net/baolingye/article/details/111357407\">https://blog.csdn.net/baolingye/article/details/111357407</a></p>\n<p>在正常模式下，<strong>锁的等待者会按照先进先出的顺序获取锁</strong>。但是刚被唤起的 Goroutine 与新创建的 Goroutine 竞争时，大概率会获取不到锁，在这种情况下，这个被唤醒的 Goroutine 会加入到等待队列的前面。 如果一个等待的 Goroutine 超过1ms 没有获取锁，那么它将会把锁转变为<strong>饥饿模式</strong>。<br>Go在1.9中引入优化，目的保证互斥锁的公平性。在饥饿模式中，互斥锁会直接交给等待队列最前面的 Goroutine。新的 Goroutine 在该状态下不能获取锁、也不会进入自旋状态，它们只会在队列的末尾等待。如果一个 Goroutine 获得了互斥锁并且它在队列的末尾或者它等待的时间少于 1ms，那么当前的互斥锁就会切换回正常模式。</p>\n<h3 id=\"悲观锁与乐观锁\"><a href=\"#悲观锁与乐观锁\" class=\"headerlink\" title=\"悲观锁与乐观锁\"></a>悲观锁与乐观锁</h3><p><strong>悲观锁</strong>是基于一种悲观的态度类来防止一切数据冲突，它是以一种预防的姿态在<strong>修改数据之前把数据锁住，然后再对数据进行读写，在它释放锁之前任何人都不能对其数据进行操作，直到前面一个人把锁释放后下一个人数据加锁才可对数据进行加锁，</strong>然后才可以对数据进行操作，一般数据库本身锁的机制都是基于悲观锁的机制实现的;</p>\n<p>特点：可以完全保证数据的独占性和正确性，因为每次请求都会先对数据进行加锁， 然后进行数据操作，最后再解锁，而加锁释放锁的过程会造成消耗，所以性能不高;</p>\n<p><strong>乐观锁</strong>是对于数据冲突保持一种乐观态度，操作数据时不会对操作的数据进行加锁（这使得多个任务可以并行的对数据进行操作），只有到数据提交的时候才通过一种机制来验证数据是否存在冲突(一般实现方式是通过加版本号然后进行版本号的对比方式实现);</p>\n<p>特点：乐观锁是一种并发类型的锁，其本身不对数据进行加锁通而是通过业务实现锁的功能，不对数据进行加锁就意味着允许多个请求同时访问数据，同时也省掉了对数据加锁和解锁的过程，这种方式因为节省了悲观锁加锁的操作，所以可以一定程度的的提高操作的性能，不过在并发非常高的情况下，会导致大量的请求冲突，冲突导致大部分操作无功而返而浪费资源，所以在高并发的场景下，乐观锁的性能却反而不如悲观锁。</p>\n<h3 id=\"原子操作和锁的区别\"><a href=\"#原子操作和锁的区别\" class=\"headerlink\" title=\"原子操作和锁的区别\"></a>原子操作和锁的区别</h3><p>在并发编程里，Go语言<code>sync</code>包里的同步原语<code>Mutex</code>是我们经常用来保证并发安全的，那么他跟<code>atomic</code>包里的这些操作有啥区别呢？在我看来他们在使用目的和底层实现上都不一样：</p>\n<ul>\n<li>使用目的：互斥锁是用来保护一段逻辑，原子操作用于对一个变量的更新保护。</li>\n<li>底层实现：<code>Mutex</code>由<strong>操作系统</strong>的调度器实现，而<code>atomic</code>包中的原子操作则由<strong>底层硬件指令</strong>直接提供支持，这些指令在执行的过程中是不允许中断的，因此原子操作可以在<code>lock-free</code>的情况下保证并发安全，并且它的性能也能做到随<code>CPU</code>个数的增多而线性扩展。</li>\n</ul>\n<h3 id=\"互斥锁允许自旋的条件\"><a href=\"#互斥锁允许自旋的条件\" class=\"headerlink\" title=\"互斥锁允许自旋的条件\"></a>互斥锁允许自旋的条件</h3><p>线程没有获取到锁时常见有2种处理方式：</p>\n<ul>\n<li>一种是没有获取到锁的线程就会循环等待判断该资源是否已经释放锁，这种锁也叫做自旋锁，它不用将线程阻塞起来， 适用于并发低且程序执行时间短的场景，缺点是cpu占用较高</li>\n<li>另外一种处理方式就是把自己阻塞起来，会释放CPU给其他线程，内核会将线程置为「睡眠」状态，等到锁被释放后，内核会在合适的时机唤醒该线程，适用于高并发场景，缺点是有线程上下文切换的开销<br>Go语言中的Mutex实现了自旋与阻塞两种场景，当满足不了自旋条件时，就会进入阻塞<br><strong>允许自旋的条件：</strong></li>\n</ul>\n<ol>\n<li>锁已被占用，并且锁不处于饥饿模式。</li>\n<li>积累的自旋次数小于最大自旋次数（active_spin=4）。</li>\n<li>cpu 核数大于 1。</li>\n<li>有空闲的 P。</li>\n<li>当前 goroutine 所挂载的 P 下，本地待运行队列为空。</li>\n</ol>\n<h3 id=\"读写锁的实现原理\"><a href=\"#读写锁的实现原理\" class=\"headerlink\" title=\"读写锁的实现原理\"></a>读写锁的实现原理</h3><p>读写锁的底层是基于互斥锁实现的。<br>写锁需要阻塞写锁：一个协程拥有写锁时，其他协程写锁定需要阻塞；<br>写锁需要阻塞读锁：一个协程拥有写锁时，其他协程读锁定需要阻塞；<br>读锁需要阻塞写锁：一个协程拥有读锁时，其他协程写锁定需要阻塞；<br><strong>读锁不能阻塞读锁：一个协程拥有读锁时，其他协程也可以拥有读锁。</strong></p>\n<h3 id=\"“原子操作”有哪些\"><a href=\"#“原子操作”有哪些\" class=\"headerlink\" title=\"“原子操作”有哪些\"></a>“原子操作”有哪些</h3><p>Go atomic包是最轻量级的锁（也称无锁结构），可以在不形成临界区和创建互斥量的情况下完成并发安全的值替换操作，不过这个包只支持int32/int64/uint32/uint64/uintptr这几种数据类型的一些基础操作（增减、交换、载入、存储等）<br>当我们想要对<strong>某个变量</strong>并发安全的修改，除了使用官方提供的 <code>mutex</code>，还可以使用 sync/atomic 包的原子操作，它能够保证对变量的读取或修改期间不被其他的协程所影响。<br>atomic 包提供的原子操作能够确保任一时刻只有一个goroutine对变量进行操作，善用 atomic 能够避免程序中出现大量的锁操作。<br><strong>常见操作：</strong></p>\n<ul>\n<li>增减Add     AddInt32 AddInt64 AddUint32 AddUint64 AddUintptr</li>\n<li>载入Load    LoadInt32 LoadInt64    LoadPointer    LoadUint32    LoadUint64    LoadUintptr</li>\n<li>比较并交换   CompareAndSwap    CompareAndSwapInt32…</li>\n<li>交换Swap    SwapInt32…</li>\n<li>存储Store    StoreInt32…</li>\n</ul>\n<h3 id=\"Goroutine-的底层实现原理\"><a href=\"#Goroutine-的底层实现原理\" class=\"headerlink\" title=\"Goroutine 的底层实现原理\"></a>Goroutine 的底层实现原理</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">g本质是一个数据结构,真正让 goroutine 运行起来的是调度器</span><br><span class=\"line\"><span class=\"keyword\">type</span> g <span class=\"keyword\">struct</span> &#123; </span><br><span class=\"line\">    goid <span class=\"type\">int64</span>  <span class=\"comment\">// 唯一的goroutine的ID </span></span><br><span class=\"line\">    sched gobuf <span class=\"comment\">// goroutine切换时，用于保存g的上下文 </span></span><br><span class=\"line\">    stack stack <span class=\"comment\">// 栈 </span></span><br><span class=\"line\">    gopc <span class=\"comment\">// pc of go statement that created this goroutine </span></span><br><span class=\"line\">    startpc <span class=\"type\">uintptr</span>  <span class=\"comment\">// pc of goroutine function ... </span></span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"keyword\">type</span> gobuf <span class=\"keyword\">struct</span> &#123;     <span class=\"comment\">//运行时寄存器</span></span><br><span class=\"line\">    sp <span class=\"type\">uintptr</span>  <span class=\"comment\">// 栈指针位置 </span></span><br><span class=\"line\">    pc <span class=\"type\">uintptr</span>  <span class=\"comment\">// 运行到的程序位置 </span></span><br><span class=\"line\">    g  guintptr <span class=\"comment\">// 指向 goroutine </span></span><br><span class=\"line\">    ret <span class=\"type\">uintptr</span> <span class=\"comment\">// 保存系统调用的返回值 ... </span></span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"keyword\">type</span> stack <span class=\"keyword\">struct</span> &#123;     <span class=\"comment\">//运行时栈</span></span><br><span class=\"line\">    lo <span class=\"type\">uintptr</span>  <span class=\"comment\">// 栈的下界内存地址 </span></span><br><span class=\"line\">    hi <span class=\"type\">uintptr</span>  <span class=\"comment\">// 栈的上界内存地址 </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><h3 id=\"goroutine-和线程的区别\"><a href=\"#goroutine-和线程的区别\" class=\"headerlink\" title=\"goroutine 和线程的区别\"></a>goroutine 和线程的区别</h3><p>内存占用:<br>创建一个 goroutine 的栈内存消耗为 2 KB，实际运行过程中，如果栈空间不够用，会自动进行扩容。创建一个 thread 则需要消耗 1 MB 栈内存。<br>创建和销毀:<br>Thread 创建和销毀需要陷入内核,系统调用。而 goroutine 因为是由 Go runtime 负责管理的，创建和销毁的消耗非常小，是用户级。<br>切换:<br>当 threads 切换时，需要保存各种寄存器,而 goroutines 切换只需保存三个寄存器：Program Counter, Stack Pointer and BP。一般而言，线程切换会消耗 1000-1500 ns,Goroutine 的切换约为 200 ns,因此，goroutines 切换成本比 threads 要小得多。</p>\n<h3 id=\"Go-线程模型（Go底层怎么实现高并发的）\"><a href=\"#Go-线程模型（Go底层怎么实现高并发的）\" class=\"headerlink\" title=\"Go 线程模型（Go底层怎么实现高并发的）\"></a>Go 线程模型（Go底层怎么实现高并发的）</h3><blockquote>\n<p>线程协程，进程的区别：</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/337978321\">https://zhuanlan.zhihu.com/p/337978321</a></p>\n<p><a href=\"https://www.bilibili.com/read/cv9346691/\">https://www.bilibili.com/read/cv9346691/</a></p>\n</blockquote>\n<p>Golang的调度器是一个轻量级的协程调度器，主要负责管理和调度协程。Golang 中的调度器采用 <strong>M:N 模型</strong>，即 M 个用户级线程对应 N 个内核线程。</p>\n<p>调度器会将 Golang 中的协程（goroutine）调度到不同的线程上运行，以实现并发执行的效果。</p>\n<p>M个线程对应N个内核线程的优点：</p>\n<ul>\n<li>能够利用多核</li>\n<li>上下文切换成本低</li>\n<li>如果进程中的一个线程被阻塞，不会阻塞其他线程，是能够切换同一进程内的其他线程继续执行</li>\n</ul>\n<h3 id=\"Golang-assertion\"><a href=\"#Golang-assertion\" class=\"headerlink\" title=\"Golang assertion\"></a>Golang assertion</h3><h2 id=\"Golang调用方面\"><a href=\"#Golang调用方面\" class=\"headerlink\" title=\"Golang调用方面\"></a>Golang调用方面</h2><h3 id=\"len-统计长度\"><a href=\"#len-统计长度\" class=\"headerlink\" title=\"len 统计长度\"></a>len 统计长度</h3><p><font color = 'red'>len()计算的是字节的长度，和编码无关，对于英文和数组对象等，字节长度等效于实际长度</font><br>当需要计算中文字符长度的时候，就需要调用其他的函数方法：<br><code>utf8.RuneCountInString(&quot;中文&quot;)</code></p>\n"},{"title":"Go-Routine","catalog":true,"date":"2023-04-11T18:36:14.000Z","subtitle":null,"header-img":null,"published":0,"_content":"","source":"_posts/Go/Go-enhanced-knowledge/Go-Goroutine.md","raw":"---\ntitle: Go-Routine\ncatalog: true\ndate: 2023-04-12 02:36:14\nsubtitle:\nheader-img:\ntags:\ncategories:\npublished: false\n---","slug":"Go/Go-enhanced-knowledge/Go-Goroutine","updated":"2023-04-22T13:24:02.216Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli796r0w001jbyjx957q4yig","content":"","site":{"data":{}},"cover":"/img/cover/sky4.png","cover_type":"img","excerpt":"","more":""},{"title":"Go-enhanced-knowledge","catalog":true,"date":"2023-03-11T19:36:14.000Z","subtitle":null,"header-img":null,"published":0,"_content":"","source":"_posts/Go/Go-enhanced-knowledge/Go-enhanced-knowledge.md","raw":"---\ntitle: Go-enhanced-knowledge\ncatalog: true\ndate: 2023-03-12 02:36:14\nsubtitle:\nheader-img:\ntags:\ncategories:\npublished: false\n---\n","slug":"Go/Go-enhanced-knowledge/Go-enhanced-knowledge","updated":"2023-04-24T11:58:10.979Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli796r0x001mbyjxgokh0mxp","content":"","site":{"data":{}},"cover":"/img/cover/sky2.png","cover_type":"img","excerpt":"","more":""},{"title":"Golang Common Knowledege","catalog":true,"date":"2023-04-09T11:24:25.000Z","subtitle":null,"header-img":null,"published":0,"_content":"\n# Golang 常用量\n\n\n\n# Golang 常用函数调用\n\n","source":"_posts/Go/Golang-Common-Knowledege/Golang-Common-Knowledege.md","raw":"---\ntitle: Golang Common Knowledege\ncatalog: true\ndate: 2023-04-09 19:24:25\nsubtitle:\nheader-img:\ntags:\ncategories: Golang\npublished: false\n---\n\n# Golang 常用量\n\n\n\n# Golang 常用函数调用\n\n","slug":"Go/Golang-Common-Knowledege/Golang-Common-Knowledege","updated":"2023-04-22T13:24:02.216Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli796r0y001obyjxdy6eccpj","content":"<h1 id=\"Golang-常用量\"><a href=\"#Golang-常用量\" class=\"headerlink\" title=\"Golang 常用量\"></a>Golang 常用量</h1><h1 id=\"Golang-常用函数调用\"><a href=\"#Golang-常用函数调用\" class=\"headerlink\" title=\"Golang 常用函数调用\"></a>Golang 常用函数调用</h1>","site":{"data":{}},"cover":"/img/cover/sky4.png","cover_type":"img","excerpt":"","more":"<h1 id=\"Golang-常用量\"><a href=\"#Golang-常用量\" class=\"headerlink\" title=\"Golang 常用量\"></a>Golang 常用量</h1><h1 id=\"Golang-常用函数调用\"><a href=\"#Golang-常用函数调用\" class=\"headerlink\" title=\"Golang 常用函数调用\"></a>Golang 常用函数调用</h1>"},{"title":"Kubernetes 网络插件（CNI）性能测试","catalog":true,"date":"2023-03-26T17:03:57.000Z","subtitle":null,"header-img":null,"published":0,"_content":"","source":"_posts/Kubernetes/Kubernetes-网络插件（CNI）性能测试/Kubernetes-网络插件（CNI）性能测试.md","raw":"---\ntitle: Kubernetes 网络插件（CNI）性能测试\ncatalog: true\ndate: 2023-03-27 01:03:57\nsubtitle:\nheader-img:\ntags:\ncategories:\npublished: false\n---\n","slug":"Kubernetes/Kubernetes-网络插件（CNI）性能测试/Kubernetes-网络插件（CNI）性能测试","updated":"2023-04-22T13:24:02.236Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli796r0z001rbyjxaiqjezlb","content":"","site":{"data":{}},"cover":"/img/cover/sky.png","cover_type":"img","excerpt":"","more":""},{"title":"cpolar 使用","catalog":true,"date":"2023-04-18T21:02:23.000Z","subtitle":null,"header-img":null,"published":0,"_content":"\n\n\n使用软件： Cpolar, Nps\n\n[无公网IP，SSH远程连接Linux CentOS【内网穿透】 - cpolar 极点云](https://www.cpolar.com/blog/ssh-remote-linux-centos?channel=0&invite=4M3O)\n\n[cpolar - secure introspectable tunnels to localhost](https://dashboard.cpolar.com/reserved)\n\n","source":"_posts/P2P/cpolar/cpolar 使用.md","raw":"---\ntitle: cpolar 使用\ncatalog: true\ndate: 2023-04-19 05:02:23\nsubtitle:\nheader-img:\ntags: p2p,cpolar\ncategories: p2p\npublished: false\n---\n\n\n\n使用软件： Cpolar, Nps\n\n[无公网IP，SSH远程连接Linux CentOS【内网穿透】 - cpolar 极点云](https://www.cpolar.com/blog/ssh-remote-linux-centos?channel=0&invite=4M3O)\n\n[cpolar - secure introspectable tunnels to localhost](https://dashboard.cpolar.com/reserved)\n\n","slug":"P2P/cpolar/cpolar 使用","updated":"2023-04-23T14:16:40.107Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli796r10001sbyjxaa8r48r1","content":"<p>使用软件： Cpolar, Nps</p>\n<p><a href=\"https://www.cpolar.com/blog/ssh-remote-linux-centos?channel=0&invite=4M3O\">无公网IP，SSH远程连接Linux CentOS【内网穿透】 - cpolar 极点云</a></p>\n<p><a href=\"https://dashboard.cpolar.com/reserved\">cpolar - secure introspectable tunnels to localhost</a></p>\n","site":{"data":{}},"cover":"/img/cover/sky4.png","cover_type":"img","excerpt":"","more":"<p>使用软件： Cpolar, Nps</p>\n<p><a href=\"https://www.cpolar.com/blog/ssh-remote-linux-centos?channel=0&invite=4M3O\">无公网IP，SSH远程连接Linux CentOS【内网穿透】 - cpolar 极点云</a></p>\n<p><a href=\"https://dashboard.cpolar.com/reserved\">cpolar - secure introspectable tunnels to localhost</a></p>\n"},{"title":"【RPC】Golang 实现简单 RPC","catalog":true,"date":"2023-03-23T18:59:34.000Z","subtitle":null,"header-img":null,"published":0,"_content":"\n# [RPC] Goalng 实现简单的 RPC\n\n## 什么是 RPC \n\n### RPC 定义\nRPC(Remote Procedure Call，远程过程调用)是一种**计算机通信协议**，允许**调用不同进程空间的程序**。RPC 的客户端和服务器可以在一台机器上，也可以在不同的机器上。程序员使用时，就像调用本地程序一样，无需关注内部的实现细节。\n\n### RPC 需要解决的问题\n> core: 为进程运行提供 “overlay” 服务，使得不同团队的进程，不同进程的调用，可以在不同时间、机器、不同规则上实现一体化服务的提供，这对于分布式环境下多个类型公司主体处理同一份数据并给统一团体客户提供多样服务有着重要作用\n>\n> \n\n\n### 设计的简单RPC 需要实现的功能(RoadMap)\n\n参考 (GeeRpc)[https://geektutu.com/post/geerpc.html] 作为基础 rpc 实现\n\n\n\n## 实现服务端和消息编码\n> 目标是：\n> * 使用encoding/gob 实现消息的解编码（序列化和反序列化）\n> * 实现简易的服务端，仅接受消息不处理\n\n\n\n\n---\n\n## 问题集锦\n\n### encode/gob 与 Protobuf\n\n二者都是完成信息做序列化的工作，但是 encode/gob 仅仅是提供了对于Golang语言的支持，要想在不同的平台应用得使用Protobuf\n\n### 什么是工厂模式\n\n\n### Golang 包名字的统一\n\n\n### var _ Codec = (*GobCodec)(nil) 的作用\n> 参考文章：[https://cloud.tencent.com/developer/article/2025793]\n在 Golang 中，var _ 可以用作声明变量但不使用它的占位符。在 var _ Codec = (*GobCodec)(nil) 中，_ 的作用是占位符。它们结合在一起可以起到两个作用：\n\n防止编译器报错：当一个接口类型被定义后，需要确保该接口类型被所有实现都正确实现。编译器可以通过检查是否所有实现都满足该接口的方法来验证这一点。在接口类型和实现之间声明 var _ InterfaceType = (*ImplementType)(nil) 可以防止编译器发出“实现不完整”的警告。\n\n检验类型之间的兼容性：在 var _ Codec = (*GobCodec)(nil) 中，则是要检验 GobCodec 是否实现了 Codec 接口。如果 GobCodec 没有实现 Codec 接口中的所有方法，则编译时将无法通过，从而起到检验类型之间的兼容性的作用。\n\n总之，var _ Codec = (*GobCodec)(nil) 的目的是检验 GobCodec 是否实现了 Codec 接口、避免编译器报错并判断类型之间的兼容性。它通常用于接口类型和实现之间的声明，对于保证代码质量和类型安全是很有帮助的。\n\n","source":"_posts/RPC/【RPC】Golang-实现简单-RPC/【RPC】Golang-实现简单-RPC.md","raw":"---\ntitle: 【RPC】Golang 实现简单 RPC\ncatalog: true\ndate: 2023-03-24 02:59:34\nsubtitle:\nheader-img:\ntags:\ncategories:\npublished: false\n---\n\n# [RPC] Goalng 实现简单的 RPC\n\n## 什么是 RPC \n\n### RPC 定义\nRPC(Remote Procedure Call，远程过程调用)是一种**计算机通信协议**，允许**调用不同进程空间的程序**。RPC 的客户端和服务器可以在一台机器上，也可以在不同的机器上。程序员使用时，就像调用本地程序一样，无需关注内部的实现细节。\n\n### RPC 需要解决的问题\n> core: 为进程运行提供 “overlay” 服务，使得不同团队的进程，不同进程的调用，可以在不同时间、机器、不同规则上实现一体化服务的提供，这对于分布式环境下多个类型公司主体处理同一份数据并给统一团体客户提供多样服务有着重要作用\n>\n> \n\n\n### 设计的简单RPC 需要实现的功能(RoadMap)\n\n参考 (GeeRpc)[https://geektutu.com/post/geerpc.html] 作为基础 rpc 实现\n\n\n\n## 实现服务端和消息编码\n> 目标是：\n> * 使用encoding/gob 实现消息的解编码（序列化和反序列化）\n> * 实现简易的服务端，仅接受消息不处理\n\n\n\n\n---\n\n## 问题集锦\n\n### encode/gob 与 Protobuf\n\n二者都是完成信息做序列化的工作，但是 encode/gob 仅仅是提供了对于Golang语言的支持，要想在不同的平台应用得使用Protobuf\n\n### 什么是工厂模式\n\n\n### Golang 包名字的统一\n\n\n### var _ Codec = (*GobCodec)(nil) 的作用\n> 参考文章：[https://cloud.tencent.com/developer/article/2025793]\n在 Golang 中，var _ 可以用作声明变量但不使用它的占位符。在 var _ Codec = (*GobCodec)(nil) 中，_ 的作用是占位符。它们结合在一起可以起到两个作用：\n\n防止编译器报错：当一个接口类型被定义后，需要确保该接口类型被所有实现都正确实现。编译器可以通过检查是否所有实现都满足该接口的方法来验证这一点。在接口类型和实现之间声明 var _ InterfaceType = (*ImplementType)(nil) 可以防止编译器发出“实现不完整”的警告。\n\n检验类型之间的兼容性：在 var _ Codec = (*GobCodec)(nil) 中，则是要检验 GobCodec 是否实现了 Codec 接口。如果 GobCodec 没有实现 Codec 接口中的所有方法，则编译时将无法通过，从而起到检验类型之间的兼容性的作用。\n\n总之，var _ Codec = (*GobCodec)(nil) 的目的是检验 GobCodec 是否实现了 Codec 接口、避免编译器报错并判断类型之间的兼容性。它通常用于接口类型和实现之间的声明，对于保证代码质量和类型安全是很有帮助的。\n\n","slug":"RPC/【RPC】Golang-实现简单-RPC/【RPC】Golang-实现简单-RPC","updated":"2023-04-24T11:58:37.635Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli796r10001vbyjxdiu38f2g","content":"<h1 id=\"RPC-Goalng-实现简单的-RPC\"><a href=\"#RPC-Goalng-实现简单的-RPC\" class=\"headerlink\" title=\"[RPC] Goalng 实现简单的 RPC\"></a>[RPC] Goalng 实现简单的 RPC</h1><h2 id=\"什么是-RPC\"><a href=\"#什么是-RPC\" class=\"headerlink\" title=\"什么是 RPC\"></a>什么是 RPC</h2><h3 id=\"RPC-定义\"><a href=\"#RPC-定义\" class=\"headerlink\" title=\"RPC 定义\"></a>RPC 定义</h3><p>RPC(Remote Procedure Call，远程过程调用)是一种<strong>计算机通信协议</strong>，允许<strong>调用不同进程空间的程序</strong>。RPC 的客户端和服务器可以在一台机器上，也可以在不同的机器上。程序员使用时，就像调用本地程序一样，无需关注内部的实现细节。</p>\n<h3 id=\"RPC-需要解决的问题\"><a href=\"#RPC-需要解决的问题\" class=\"headerlink\" title=\"RPC 需要解决的问题\"></a>RPC 需要解决的问题</h3><blockquote>\n<p>core: 为进程运行提供 “overlay” 服务，使得不同团队的进程，不同进程的调用，可以在不同时间、机器、不同规则上实现一体化服务的提供，这对于分布式环境下多个类型公司主体处理同一份数据并给统一团体客户提供多样服务有着重要作用</p>\n</blockquote>\n<h3 id=\"设计的简单RPC-需要实现的功能-RoadMap\"><a href=\"#设计的简单RPC-需要实现的功能-RoadMap\" class=\"headerlink\" title=\"设计的简单RPC 需要实现的功能(RoadMap)\"></a>设计的简单RPC 需要实现的功能(RoadMap)</h3><p>参考 (GeeRpc)[<a href=\"https://geektutu.com/post/geerpc.html]\">https://geektutu.com/post/geerpc.html]</a> 作为基础 rpc 实现</p>\n<h2 id=\"实现服务端和消息编码\"><a href=\"#实现服务端和消息编码\" class=\"headerlink\" title=\"实现服务端和消息编码\"></a>实现服务端和消息编码</h2><blockquote>\n<p>目标是：</p>\n<ul>\n<li>使用encoding/gob 实现消息的解编码（序列化和反序列化）</li>\n<li>实现简易的服务端，仅接受消息不处理</li>\n</ul>\n</blockquote>\n<hr>\n<h2 id=\"问题集锦\"><a href=\"#问题集锦\" class=\"headerlink\" title=\"问题集锦\"></a>问题集锦</h2><h3 id=\"encode-gob-与-Protobuf\"><a href=\"#encode-gob-与-Protobuf\" class=\"headerlink\" title=\"encode/gob 与 Protobuf\"></a>encode/gob 与 Protobuf</h3><p>二者都是完成信息做序列化的工作，但是 encode/gob 仅仅是提供了对于Golang语言的支持，要想在不同的平台应用得使用Protobuf</p>\n<h3 id=\"什么是工厂模式\"><a href=\"#什么是工厂模式\" class=\"headerlink\" title=\"什么是工厂模式\"></a>什么是工厂模式</h3><h3 id=\"Golang-包名字的统一\"><a href=\"#Golang-包名字的统一\" class=\"headerlink\" title=\"Golang 包名字的统一\"></a>Golang 包名字的统一</h3><h3 id=\"var-Codec-GobCodec-nil-的作用\"><a href=\"#var-Codec-GobCodec-nil-的作用\" class=\"headerlink\" title=\"var _ Codec = (*GobCodec)(nil) 的作用\"></a>var _ Codec = (*GobCodec)(nil) 的作用</h3><blockquote>\n<p>参考文章：[<a href=\"https://cloud.tencent.com/developer/article/2025793]\">https://cloud.tencent.com/developer/article/2025793]</a><br>在 Golang 中，var _ 可以用作声明变量但不使用它的占位符。在 var _ Codec = (*GobCodec)(nil) 中，_ 的作用是占位符。它们结合在一起可以起到两个作用：</p>\n</blockquote>\n<p>防止编译器报错：当一个接口类型被定义后，需要确保该接口类型被所有实现都正确实现。编译器可以通过检查是否所有实现都满足该接口的方法来验证这一点。在接口类型和实现之间声明 var _ InterfaceType = (*ImplementType)(nil) 可以防止编译器发出“实现不完整”的警告。</p>\n<p>检验类型之间的兼容性：在 var _ Codec = (*GobCodec)(nil) 中，则是要检验 GobCodec 是否实现了 Codec 接口。如果 GobCodec 没有实现 Codec 接口中的所有方法，则编译时将无法通过，从而起到检验类型之间的兼容性的作用。</p>\n<p>总之，var _ Codec = (*GobCodec)(nil) 的目的是检验 GobCodec 是否实现了 Codec 接口、避免编译器报错并判断类型之间的兼容性。它通常用于接口类型和实现之间的声明，对于保证代码质量和类型安全是很有帮助的。</p>\n","site":{"data":{}},"cover":"/img/cover/sky2.png","cover_type":"img","excerpt":"","more":"<h1 id=\"RPC-Goalng-实现简单的-RPC\"><a href=\"#RPC-Goalng-实现简单的-RPC\" class=\"headerlink\" title=\"[RPC] Goalng 实现简单的 RPC\"></a>[RPC] Goalng 实现简单的 RPC</h1><h2 id=\"什么是-RPC\"><a href=\"#什么是-RPC\" class=\"headerlink\" title=\"什么是 RPC\"></a>什么是 RPC</h2><h3 id=\"RPC-定义\"><a href=\"#RPC-定义\" class=\"headerlink\" title=\"RPC 定义\"></a>RPC 定义</h3><p>RPC(Remote Procedure Call，远程过程调用)是一种<strong>计算机通信协议</strong>，允许<strong>调用不同进程空间的程序</strong>。RPC 的客户端和服务器可以在一台机器上，也可以在不同的机器上。程序员使用时，就像调用本地程序一样，无需关注内部的实现细节。</p>\n<h3 id=\"RPC-需要解决的问题\"><a href=\"#RPC-需要解决的问题\" class=\"headerlink\" title=\"RPC 需要解决的问题\"></a>RPC 需要解决的问题</h3><blockquote>\n<p>core: 为进程运行提供 “overlay” 服务，使得不同团队的进程，不同进程的调用，可以在不同时间、机器、不同规则上实现一体化服务的提供，这对于分布式环境下多个类型公司主体处理同一份数据并给统一团体客户提供多样服务有着重要作用</p>\n</blockquote>\n<h3 id=\"设计的简单RPC-需要实现的功能-RoadMap\"><a href=\"#设计的简单RPC-需要实现的功能-RoadMap\" class=\"headerlink\" title=\"设计的简单RPC 需要实现的功能(RoadMap)\"></a>设计的简单RPC 需要实现的功能(RoadMap)</h3><p>参考 (GeeRpc)[<a href=\"https://geektutu.com/post/geerpc.html]\">https://geektutu.com/post/geerpc.html]</a> 作为基础 rpc 实现</p>\n<h2 id=\"实现服务端和消息编码\"><a href=\"#实现服务端和消息编码\" class=\"headerlink\" title=\"实现服务端和消息编码\"></a>实现服务端和消息编码</h2><blockquote>\n<p>目标是：</p>\n<ul>\n<li>使用encoding/gob 实现消息的解编码（序列化和反序列化）</li>\n<li>实现简易的服务端，仅接受消息不处理</li>\n</ul>\n</blockquote>\n<hr>\n<h2 id=\"问题集锦\"><a href=\"#问题集锦\" class=\"headerlink\" title=\"问题集锦\"></a>问题集锦</h2><h3 id=\"encode-gob-与-Protobuf\"><a href=\"#encode-gob-与-Protobuf\" class=\"headerlink\" title=\"encode/gob 与 Protobuf\"></a>encode/gob 与 Protobuf</h3><p>二者都是完成信息做序列化的工作，但是 encode/gob 仅仅是提供了对于Golang语言的支持，要想在不同的平台应用得使用Protobuf</p>\n<h3 id=\"什么是工厂模式\"><a href=\"#什么是工厂模式\" class=\"headerlink\" title=\"什么是工厂模式\"></a>什么是工厂模式</h3><h3 id=\"Golang-包名字的统一\"><a href=\"#Golang-包名字的统一\" class=\"headerlink\" title=\"Golang 包名字的统一\"></a>Golang 包名字的统一</h3><h3 id=\"var-Codec-GobCodec-nil-的作用\"><a href=\"#var-Codec-GobCodec-nil-的作用\" class=\"headerlink\" title=\"var _ Codec = (*GobCodec)(nil) 的作用\"></a>var _ Codec = (*GobCodec)(nil) 的作用</h3><blockquote>\n<p>参考文章：[<a href=\"https://cloud.tencent.com/developer/article/2025793]\">https://cloud.tencent.com/developer/article/2025793]</a><br>在 Golang 中，var _ 可以用作声明变量但不使用它的占位符。在 var _ Codec = (*GobCodec)(nil) 中，_ 的作用是占位符。它们结合在一起可以起到两个作用：</p>\n</blockquote>\n<p>防止编译器报错：当一个接口类型被定义后，需要确保该接口类型被所有实现都正确实现。编译器可以通过检查是否所有实现都满足该接口的方法来验证这一点。在接口类型和实现之间声明 var _ InterfaceType = (*ImplementType)(nil) 可以防止编译器发出“实现不完整”的警告。</p>\n<p>检验类型之间的兼容性：在 var _ Codec = (*GobCodec)(nil) 中，则是要检验 GobCodec 是否实现了 Codec 接口。如果 GobCodec 没有实现 Codec 接口中的所有方法，则编译时将无法通过，从而起到检验类型之间的兼容性的作用。</p>\n<p>总之，var _ Codec = (*GobCodec)(nil) 的目的是检验 GobCodec 是否实现了 Codec 接口、避免编译器报错并判断类型之间的兼容性。它通常用于接口类型和实现之间的声明，对于保证代码质量和类型安全是很有帮助的。</p>\n"},{"title":"Golang 算法课程--算法","catalog":true,"date":"2023-04-01T16:46:21.000Z","subtitle":null,"header-img":null,"published":0,"_content":"\n# 算法思想篇\n> 个人学习算法经验：\n> 1. 深入了解和使用一门语言 ---> Golang\n> 2. 深入理解基础的数据结构和算法基础 ---> 数学理论\n> 3. 知识需要依据模块和分区来做体系的整理和学习 \n\n# **1** &ensp; 二分搜索： 为什么说有序皆可用二分\n> 本章节的学习目标：\n> * 二分搜索的两个标准模板\n> * 二分搜索的提问破解法\n> * 二分搜索的切分法\n\n## **1.1** &ensp; 二分搜索的关键考点\n\n1. 开闭原则\n   一定要注意，在写二分搜索时候，每一个区间的表示都是严格按照开闭原则进行的\n   开闭原则 --> 左闭右开 --> 左边指针指向起点，右边指针指向尾部元素的后面一个空位 \n\n2. 区间的变化计算\n\n3. 代码的流畅度\n   * ==是否深度理解了二分搜索的原则在该题目当中的体现== --> <font color='red'> 所有算法题目的代码流畅度检验思考一</font>\n   * ==是否真的记住了代码的模板== --> <font color='red'> 所有算法题目的代码流畅度检验思考二</font>\n   * ==所有代码编写流畅度问题的根源都是在于不熟练--> 用的不多 --> 不会转化为已知的问题 --> 是否理解了运用的原理== --> <font color='red'> 代码熟练度尤其关注 </font>\n\n``` mermaid\ngraph TD\nA[联系] --> B(开闭原则)\nB --> D[二分搜索]\nB --> E[快速排序-三路切分]\nB --> F[归并排序-切分为两个区间]\nA --> C(扔掉一半)\nC --> G[二叉搜索树]\nG --> H[查找]\nG --> I[删除]\nG --> N[插入]\nC --> J(三路切分)\nJ --> K[第k小的数]\nJ --> L[唯一出现的数]   \n```\n<br />\n\n\n## **1.2** &ensp; 提问破解法解决二分问题\n\n### 要什么，什么就是x \n\n1. 将目标元素设置为 x --> 去除掉题目当中所给的最小最长最大最短等限制条件，得到一个点描述\n2. 得到目标 x 的区间范围: --> 决定左开右闭的规则\n   \n### 满足约束条件的f(x)=0\n\n### 不满足约束条件的f(x)设置为-1或者是1\n\n构造出一个单调变化的 f(x)，以上两步的关键在于确定（构造）f(x)是否有序，需要观察数组元素和题目要求的内容变化\n\n### 使用lowbound 还是 upbound\n最优解 0 在 f(x)=0 结果区间的最左边还是最右边，决定使用lowbound 还是 upbound \n\n### 有序数组中最左边的元素\n> 模板题目\n\n### 给定有序数组和target ，返回起始和终止位置\n> 模板题目\n\n\n### 寻找山峰\n\n\n\n### 最小长度的连续子数组\n求取的中间数组[-1,-1,0,0,1,1] 中元素代表的是子数组的长度，-1表示小于target,0 表示等于target\n<!-- // 209. 长度最小的子数组\n\n// 给定一个含有 n 个正整数的数组和一个正整数 target 。\n\n// 找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。\n\n//  \n\n// 示例 1：\n\n// 输入：target = 7, nums = [2,3,1,2,4,3]\n// 输出：2\n// 解释：子数组 [4,3] 是该条件下的长度最小的子数组。\n// 示例 2：\n\n// 输入：target = 4, nums = [1,4,4]\n// 输出：1\n// 示例 3：\n\n// 输入：target = 11, nums = [1,1,1,1,1,1,1,1]\n// 输出：0\n//  \n\n// 提示：\n\n// 1 <= target <= 109\n// 1 <= nums.length <= 105\n// 1 <= nums[i] <= 105\n\n// 求和数组 -->\n``` golang\nfunc isTarget(nums []int,l int,target int)int{\n    sum := 0\n    for i := 0 ; i < len(nums) ; i++ {\n        sum += nums[i]\n        if i < l-1 {\n            continue\n        }\n        if sum >= target{\n            return 0\n        } \n        sum = sum - nums[i-(l-1)]\n    } \n    return -1\n}\n\n\nfunc minSubArrayLen(target int, nums []int) int {\n    left, right := 1,len(nums)+1\n\n    for left < right{\n        m := left + (right-left)/2\n        now := isTarget(nums,m,target)\n        if now < 0 {\n            left = m + 1\n        }else{\n            right = m\n        }\n    }\n    if left > len(nums){\n        return 0\n    }\n    return left\n}\n```\n\n### 最大平均值\n但限制了数组长度为k的时候，可以直接使用滑动窗口来解决这个问题\n``` golang \n/**\n * @param nums: an array\n * @param k: an integer\n * @return: the maximum average value\n */\nfunc FindMaxAverage(nums []int, k int) float64 {\n\t// Write your code here\n\tmax := -10001\n\tsum := 0\n\tfor i := 0; i < len(nums); i++ {\n\t\tsum = sum + nums[i]\n\t\tif i < k-1 {\n\t\t\tcontinue\n\t\t}\n\t\tif sum > max {\n\t\t\tmax = sum\n\t\t}\n\t\tif i >= k-1 {\n\t\t\tsum = sum - nums[i-(k-1)]\n\t\t}\n\t}\n\treturn float64(max) / float64(k)\n}\n```\n### 连续子数组的最大和问题\n在上述两个问题的基础之上，衍生出来同类型的问题：\n1. 如果子数组的长度无限制： 采用落差发或者是双指针，DP来解决这个问题\n2. 子数组长度等于K 时候采用滑动窗口\n3. 长度>=K,采用滑动窗口和落差法来解决\n4. 如果限制长度必须要<=k的连续子数组最大和，可以分别求1-k的最大值，然后再选一个最大值\n\n\n## **3**三步切分法\n\n1. 找出一个分界元素\n2. 将有序的搜索空间分为两半（复杂度为O（1））\n   扔掉不需要的那一半\n3. 在剩下的空间中递归使用切分法\n\n切分法不需要有序性，但是二分搜索必须要求有序性\n### 求旋转数组当中的某个元素\n以下是未重复的题目：\n```\n33. 搜索旋转排序数组\n整数数组 nums 按升序排列，数组中的值 互不相同 。\n\n在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。\n\n给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。\n\n你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。\n\n示例 1：\n\n输入：nums = [4,5,6,7,0,1,2], target = 0\n输出：4\n示例 2：\n\n输入：nums = [4,5,6,7,0,1,2], target = 3\n输出：-1\n示例 3：\n\n输入：nums = [1], target = 0\n输出：-1\n \n\n提示：\n\n1 <= nums.length <= 5000\n-104 <= nums[i] <= 104\nnums 中的每个值都 独一无二\n题目数据保证 nums 在预先未知的某个下标上进行了旋转\n-104 <= target <= 104\n```\n\n如果增加一个重复的元素，题目变成：\n```\n81. 搜索旋转排序数组 II\n已知存在一个按非降序排列的整数数组 nums ，数组中的值不必互不相同。\n\n在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转 ，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,4,4,5,6,6,7] 在下标 5 处经旋转后可能变为 [4,5,6,6,7,0,1,2,4,4] 。\n\n给你 旋转后 的数组 nums 和一个整数 target ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 nums 中存在这个目标值 target ，则返回 true ，否则返回 false 。\n\n你必须尽可能减少整个操作步骤。\n```\n增加了重复的元素，那么只需要判断重复的元素是否是目标元素，如果不是那么就直接删除重复的元素，使得问题便会原本不重复元素的形式\n\n```golang\nfunc search(nums []int, target int)bool {\n    n := len(nums)\n    left,right := 0 , n\n\n    for left < right {\n        m := left + (right-left)/2\n\n        if nums[left] == target || nums[m] == target || nums[right-1] == target{\n            return true\n        }\n        if nums[m] > nums[left] {\n            if target > nums[left] && target < nums[m]{\n                right = m\n            }else{\n                left = m + 1\n            }\n        }else if nums[m] < nums[left]{\n            if target > nums[m] && target < nums[right-1]{\n                left = m + 1\n            }else{\n                right = m\n            }\n        }else{\n            for left < right && nums[m] == nums[left]{\n                left++\n            }\n        }\n    }\n    return false\n}\n```\n\n","source":"_posts/Algorithm/Alg_Basic/Golang-基础算法/Golang-算法课程--算法.md","raw":"---\ntitle: Golang 算法课程--算法\ncatalog: true\ndate: 2023-04-02 00:46:21\nsubtitle:\nheader-img:\ntags: working, 算法\ncategories: 算法，Golang\npublished: false\n---\n\n# 算法思想篇\n> 个人学习算法经验：\n> 1. 深入了解和使用一门语言 ---> Golang\n> 2. 深入理解基础的数据结构和算法基础 ---> 数学理论\n> 3. 知识需要依据模块和分区来做体系的整理和学习 \n\n# **1** &ensp; 二分搜索： 为什么说有序皆可用二分\n> 本章节的学习目标：\n> * 二分搜索的两个标准模板\n> * 二分搜索的提问破解法\n> * 二分搜索的切分法\n\n## **1.1** &ensp; 二分搜索的关键考点\n\n1. 开闭原则\n   一定要注意，在写二分搜索时候，每一个区间的表示都是严格按照开闭原则进行的\n   开闭原则 --> 左闭右开 --> 左边指针指向起点，右边指针指向尾部元素的后面一个空位 \n\n2. 区间的变化计算\n\n3. 代码的流畅度\n   * ==是否深度理解了二分搜索的原则在该题目当中的体现== --> <font color='red'> 所有算法题目的代码流畅度检验思考一</font>\n   * ==是否真的记住了代码的模板== --> <font color='red'> 所有算法题目的代码流畅度检验思考二</font>\n   * ==所有代码编写流畅度问题的根源都是在于不熟练--> 用的不多 --> 不会转化为已知的问题 --> 是否理解了运用的原理== --> <font color='red'> 代码熟练度尤其关注 </font>\n\n``` mermaid\ngraph TD\nA[联系] --> B(开闭原则)\nB --> D[二分搜索]\nB --> E[快速排序-三路切分]\nB --> F[归并排序-切分为两个区间]\nA --> C(扔掉一半)\nC --> G[二叉搜索树]\nG --> H[查找]\nG --> I[删除]\nG --> N[插入]\nC --> J(三路切分)\nJ --> K[第k小的数]\nJ --> L[唯一出现的数]   \n```\n<br />\n\n\n## **1.2** &ensp; 提问破解法解决二分问题\n\n### 要什么，什么就是x \n\n1. 将目标元素设置为 x --> 去除掉题目当中所给的最小最长最大最短等限制条件，得到一个点描述\n2. 得到目标 x 的区间范围: --> 决定左开右闭的规则\n   \n### 满足约束条件的f(x)=0\n\n### 不满足约束条件的f(x)设置为-1或者是1\n\n构造出一个单调变化的 f(x)，以上两步的关键在于确定（构造）f(x)是否有序，需要观察数组元素和题目要求的内容变化\n\n### 使用lowbound 还是 upbound\n最优解 0 在 f(x)=0 结果区间的最左边还是最右边，决定使用lowbound 还是 upbound \n\n### 有序数组中最左边的元素\n> 模板题目\n\n### 给定有序数组和target ，返回起始和终止位置\n> 模板题目\n\n\n### 寻找山峰\n\n\n\n### 最小长度的连续子数组\n求取的中间数组[-1,-1,0,0,1,1] 中元素代表的是子数组的长度，-1表示小于target,0 表示等于target\n<!-- // 209. 长度最小的子数组\n\n// 给定一个含有 n 个正整数的数组和一个正整数 target 。\n\n// 找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。\n\n//  \n\n// 示例 1：\n\n// 输入：target = 7, nums = [2,3,1,2,4,3]\n// 输出：2\n// 解释：子数组 [4,3] 是该条件下的长度最小的子数组。\n// 示例 2：\n\n// 输入：target = 4, nums = [1,4,4]\n// 输出：1\n// 示例 3：\n\n// 输入：target = 11, nums = [1,1,1,1,1,1,1,1]\n// 输出：0\n//  \n\n// 提示：\n\n// 1 <= target <= 109\n// 1 <= nums.length <= 105\n// 1 <= nums[i] <= 105\n\n// 求和数组 -->\n``` golang\nfunc isTarget(nums []int,l int,target int)int{\n    sum := 0\n    for i := 0 ; i < len(nums) ; i++ {\n        sum += nums[i]\n        if i < l-1 {\n            continue\n        }\n        if sum >= target{\n            return 0\n        } \n        sum = sum - nums[i-(l-1)]\n    } \n    return -1\n}\n\n\nfunc minSubArrayLen(target int, nums []int) int {\n    left, right := 1,len(nums)+1\n\n    for left < right{\n        m := left + (right-left)/2\n        now := isTarget(nums,m,target)\n        if now < 0 {\n            left = m + 1\n        }else{\n            right = m\n        }\n    }\n    if left > len(nums){\n        return 0\n    }\n    return left\n}\n```\n\n### 最大平均值\n但限制了数组长度为k的时候，可以直接使用滑动窗口来解决这个问题\n``` golang \n/**\n * @param nums: an array\n * @param k: an integer\n * @return: the maximum average value\n */\nfunc FindMaxAverage(nums []int, k int) float64 {\n\t// Write your code here\n\tmax := -10001\n\tsum := 0\n\tfor i := 0; i < len(nums); i++ {\n\t\tsum = sum + nums[i]\n\t\tif i < k-1 {\n\t\t\tcontinue\n\t\t}\n\t\tif sum > max {\n\t\t\tmax = sum\n\t\t}\n\t\tif i >= k-1 {\n\t\t\tsum = sum - nums[i-(k-1)]\n\t\t}\n\t}\n\treturn float64(max) / float64(k)\n}\n```\n### 连续子数组的最大和问题\n在上述两个问题的基础之上，衍生出来同类型的问题：\n1. 如果子数组的长度无限制： 采用落差发或者是双指针，DP来解决这个问题\n2. 子数组长度等于K 时候采用滑动窗口\n3. 长度>=K,采用滑动窗口和落差法来解决\n4. 如果限制长度必须要<=k的连续子数组最大和，可以分别求1-k的最大值，然后再选一个最大值\n\n\n## **3**三步切分法\n\n1. 找出一个分界元素\n2. 将有序的搜索空间分为两半（复杂度为O（1））\n   扔掉不需要的那一半\n3. 在剩下的空间中递归使用切分法\n\n切分法不需要有序性，但是二分搜索必须要求有序性\n### 求旋转数组当中的某个元素\n以下是未重复的题目：\n```\n33. 搜索旋转排序数组\n整数数组 nums 按升序排列，数组中的值 互不相同 。\n\n在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。\n\n给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。\n\n你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。\n\n示例 1：\n\n输入：nums = [4,5,6,7,0,1,2], target = 0\n输出：4\n示例 2：\n\n输入：nums = [4,5,6,7,0,1,2], target = 3\n输出：-1\n示例 3：\n\n输入：nums = [1], target = 0\n输出：-1\n \n\n提示：\n\n1 <= nums.length <= 5000\n-104 <= nums[i] <= 104\nnums 中的每个值都 独一无二\n题目数据保证 nums 在预先未知的某个下标上进行了旋转\n-104 <= target <= 104\n```\n\n如果增加一个重复的元素，题目变成：\n```\n81. 搜索旋转排序数组 II\n已知存在一个按非降序排列的整数数组 nums ，数组中的值不必互不相同。\n\n在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转 ，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,4,4,5,6,6,7] 在下标 5 处经旋转后可能变为 [4,5,6,6,7,0,1,2,4,4] 。\n\n给你 旋转后 的数组 nums 和一个整数 target ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 nums 中存在这个目标值 target ，则返回 true ，否则返回 false 。\n\n你必须尽可能减少整个操作步骤。\n```\n增加了重复的元素，那么只需要判断重复的元素是否是目标元素，如果不是那么就直接删除重复的元素，使得问题便会原本不重复元素的形式\n\n```golang\nfunc search(nums []int, target int)bool {\n    n := len(nums)\n    left,right := 0 , n\n\n    for left < right {\n        m := left + (right-left)/2\n\n        if nums[left] == target || nums[m] == target || nums[right-1] == target{\n            return true\n        }\n        if nums[m] > nums[left] {\n            if target > nums[left] && target < nums[m]{\n                right = m\n            }else{\n                left = m + 1\n            }\n        }else if nums[m] < nums[left]{\n            if target > nums[m] && target < nums[right-1]{\n                left = m + 1\n            }else{\n                right = m\n            }\n        }else{\n            for left < right && nums[m] == nums[left]{\n                left++\n            }\n        }\n    }\n    return false\n}\n```\n\n","slug":"Algorithm/Alg_Basic/Golang-基础算法/Golang-算法课程--算法","updated":"2023-04-22T13:24:02.176Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli796r11001xbyjx99e63h31","content":"<h1 id=\"算法思想篇\"><a href=\"#算法思想篇\" class=\"headerlink\" title=\"算法思想篇\"></a>算法思想篇</h1><blockquote>\n<p>个人学习算法经验：</p>\n<ol>\n<li>深入了解和使用一门语言 —&gt; Golang</li>\n<li>深入理解基础的数据结构和算法基础 —&gt; 数学理论</li>\n<li>知识需要依据模块和分区来做体系的整理和学习 </li>\n</ol>\n</blockquote>\n<h1 id=\"1-ensp-二分搜索：-为什么说有序皆可用二分\"><a href=\"#1-ensp-二分搜索：-为什么说有序皆可用二分\" class=\"headerlink\" title=\"1 &ensp; 二分搜索： 为什么说有序皆可用二分\"></a><strong>1</strong> &ensp; 二分搜索： 为什么说有序皆可用二分</h1><blockquote>\n<p>本章节的学习目标：</p>\n<ul>\n<li>二分搜索的两个标准模板</li>\n<li>二分搜索的提问破解法</li>\n<li>二分搜索的切分法</li>\n</ul>\n</blockquote>\n<h2 id=\"1-1-ensp-二分搜索的关键考点\"><a href=\"#1-1-ensp-二分搜索的关键考点\" class=\"headerlink\" title=\"1.1 &ensp; 二分搜索的关键考点\"></a><strong>1.1</strong> &ensp; 二分搜索的关键考点</h2><ol>\n<li><p>开闭原则<br>一定要注意，在写二分搜索时候，每一个区间的表示都是严格按照开闭原则进行的<br>开闭原则 –&gt; 左闭右开 –&gt; 左边指针指向起点，右边指针指向尾部元素的后面一个空位 </p>\n</li>\n<li><p>区间的变化计算</p>\n</li>\n<li><p>代码的流畅度</p>\n<ul>\n<li>==是否深度理解了二分搜索的原则在该题目当中的体现== –&gt; <font color='red'> 所有算法题目的代码流畅度检验思考一</font></li>\n<li>==是否真的记住了代码的模板== –&gt; <font color='red'> 所有算法题目的代码流畅度检验思考二</font></li>\n<li>==所有代码编写流畅度问题的根源都是在于不熟练–&gt; 用的不多 –&gt; 不会转化为已知的问题 –&gt; 是否理解了运用的原理== –&gt; <font color='red'> 代码熟练度尤其关注 </font></li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph TD</span><br><span class=\"line\">A[联系] --&gt; B(开闭原则)</span><br><span class=\"line\">B --&gt; D[二分搜索]</span><br><span class=\"line\">B --&gt; E[快速排序-三路切分]</span><br><span class=\"line\">B --&gt; F[归并排序-切分为两个区间]</span><br><span class=\"line\">A --&gt; C(扔掉一半)</span><br><span class=\"line\">C --&gt; G[二叉搜索树]</span><br><span class=\"line\">G --&gt; H[查找]</span><br><span class=\"line\">G --&gt; I[删除]</span><br><span class=\"line\">G --&gt; N[插入]</span><br><span class=\"line\">C --&gt; J(三路切分)</span><br><span class=\"line\">J --&gt; K[第k小的数]</span><br><span class=\"line\">J --&gt; L[唯一出现的数]   </span><br></pre></td></tr></table></figure>\n<br />\n\n\n<h2 id=\"1-2-ensp-提问破解法解决二分问题\"><a href=\"#1-2-ensp-提问破解法解决二分问题\" class=\"headerlink\" title=\"1.2 &ensp; 提问破解法解决二分问题\"></a><strong>1.2</strong> &ensp; 提问破解法解决二分问题</h2><h3 id=\"要什么，什么就是x\"><a href=\"#要什么，什么就是x\" class=\"headerlink\" title=\"要什么，什么就是x\"></a>要什么，什么就是x</h3><ol>\n<li>将目标元素设置为 x –&gt; 去除掉题目当中所给的最小最长最大最短等限制条件，得到一个点描述</li>\n<li>得到目标 x 的区间范围: –&gt; 决定左开右闭的规则</li>\n</ol>\n<h3 id=\"满足约束条件的f-x-0\"><a href=\"#满足约束条件的f-x-0\" class=\"headerlink\" title=\"满足约束条件的f(x)=0\"></a>满足约束条件的f(x)=0</h3><h3 id=\"不满足约束条件的f-x-设置为-1或者是1\"><a href=\"#不满足约束条件的f-x-设置为-1或者是1\" class=\"headerlink\" title=\"不满足约束条件的f(x)设置为-1或者是1\"></a>不满足约束条件的f(x)设置为-1或者是1</h3><p>构造出一个单调变化的 f(x)，以上两步的关键在于确定（构造）f(x)是否有序，需要观察数组元素和题目要求的内容变化</p>\n<h3 id=\"使用lowbound-还是-upbound\"><a href=\"#使用lowbound-还是-upbound\" class=\"headerlink\" title=\"使用lowbound 还是 upbound\"></a>使用lowbound 还是 upbound</h3><p>最优解 0 在 f(x)=0 结果区间的最左边还是最右边，决定使用lowbound 还是 upbound </p>\n<h3 id=\"有序数组中最左边的元素\"><a href=\"#有序数组中最左边的元素\" class=\"headerlink\" title=\"有序数组中最左边的元素\"></a>有序数组中最左边的元素</h3><blockquote>\n<p>模板题目</p>\n</blockquote>\n<h3 id=\"给定有序数组和target-，返回起始和终止位置\"><a href=\"#给定有序数组和target-，返回起始和终止位置\" class=\"headerlink\" title=\"给定有序数组和target ，返回起始和终止位置\"></a>给定有序数组和target ，返回起始和终止位置</h3><blockquote>\n<p>模板题目</p>\n</blockquote>\n<h3 id=\"寻找山峰\"><a href=\"#寻找山峰\" class=\"headerlink\" title=\"寻找山峰\"></a>寻找山峰</h3><h3 id=\"最小长度的连续子数组\"><a href=\"#最小长度的连续子数组\" class=\"headerlink\" title=\"最小长度的连续子数组\"></a>最小长度的连续子数组</h3><p>求取的中间数组[-1,-1,0,0,1,1] 中元素代表的是子数组的长度，-1表示小于target,0 表示等于target</p>\n<!-- // 209. 长度最小的子数组\n\n// 给定一个含有 n 个正整数的数组和一个正整数 target 。\n\n// 找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。\n\n//  \n\n// 示例 1：\n\n// 输入：target = 7, nums = [2,3,1,2,4,3]\n// 输出：2\n// 解释：子数组 [4,3] 是该条件下的长度最小的子数组。\n// 示例 2：\n\n// 输入：target = 4, nums = [1,4,4]\n// 输出：1\n// 示例 3：\n\n// 输入：target = 11, nums = [1,1,1,1,1,1,1,1]\n// 输出：0\n//  \n\n// 提示：\n\n// 1 <= target <= 109\n// 1 <= nums.length <= 105\n// 1 <= nums[i] <= 105\n\n// 求和数组 -->\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">isTarget</span><span class=\"params\">(nums []<span class=\"type\">int</span>,l <span class=\"type\">int</span>,target <span class=\"type\">int</span>)</span></span><span class=\"type\">int</span>&#123;</span><br><span class=\"line\">    sum := <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span> ; i &lt; <span class=\"built_in\">len</span>(nums) ; i++ &#123;</span><br><span class=\"line\">        sum += nums[i]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i &lt; l<span class=\"number\">-1</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> sum &gt;= target&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        sum = sum - nums[i-(l<span class=\"number\">-1</span>)]</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">minSubArrayLen</span><span class=\"params\">(target <span class=\"type\">int</span>, nums []<span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    left, right := <span class=\"number\">1</span>,<span class=\"built_in\">len</span>(nums)+<span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> left &lt; right&#123;</span><br><span class=\"line\">        m := left + (right-left)/<span class=\"number\">2</span></span><br><span class=\"line\">        now := isTarget(nums,m,target)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> now &lt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">            left = m + <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            right = m</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> left &gt; <span class=\"built_in\">len</span>(nums)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> left</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"最大平均值\"><a href=\"#最大平均值\" class=\"headerlink\" title=\"最大平均值\"></a>最大平均值</h3><p>但限制了数组长度为k的时候，可以直接使用滑动窗口来解决这个问题</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @param nums: an array</span></span><br><span class=\"line\"><span class=\"comment\"> * @param k: an integer</span></span><br><span class=\"line\"><span class=\"comment\"> * @return: the maximum average value</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">FindMaxAverage</span><span class=\"params\">(nums []<span class=\"type\">int</span>, k <span class=\"type\">int</span>)</span></span> <span class=\"type\">float64</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// Write your code here</span></span><br><span class=\"line\">\tmax := <span class=\"number\">-10001</span></span><br><span class=\"line\">\tsum := <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(nums); i++ &#123;</span><br><span class=\"line\">\t\tsum = sum + nums[i]</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> i &lt; k<span class=\"number\">-1</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> sum &gt; max &#123;</span><br><span class=\"line\">\t\t\tmax = sum</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> i &gt;= k<span class=\"number\">-1</span> &#123;</span><br><span class=\"line\">\t\t\tsum = sum - nums[i-(k<span class=\"number\">-1</span>)]</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"type\">float64</span>(max) / <span class=\"type\">float64</span>(k)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"连续子数组的最大和问题\"><a href=\"#连续子数组的最大和问题\" class=\"headerlink\" title=\"连续子数组的最大和问题\"></a>连续子数组的最大和问题</h3><p>在上述两个问题的基础之上，衍生出来同类型的问题：</p>\n<ol>\n<li>如果子数组的长度无限制： 采用落差发或者是双指针，DP来解决这个问题</li>\n<li>子数组长度等于K 时候采用滑动窗口</li>\n<li>长度&gt;=K,采用滑动窗口和落差法来解决</li>\n<li>如果限制长度必须要&lt;=k的连续子数组最大和，可以分别求1-k的最大值，然后再选一个最大值</li>\n</ol>\n<h2 id=\"3三步切分法\"><a href=\"#3三步切分法\" class=\"headerlink\" title=\"3三步切分法\"></a><strong>3</strong>三步切分法</h2><ol>\n<li>找出一个分界元素</li>\n<li>将有序的搜索空间分为两半（复杂度为O（1））<br>扔掉不需要的那一半</li>\n<li>在剩下的空间中递归使用切分法</li>\n</ol>\n<p>切分法不需要有序性，但是二分搜索必须要求有序性</p>\n<h3 id=\"求旋转数组当中的某个元素\"><a href=\"#求旋转数组当中的某个元素\" class=\"headerlink\" title=\"求旋转数组当中的某个元素\"></a>求旋转数组当中的某个元素</h3><p>以下是未重复的题目：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">33. 搜索旋转排序数组</span><br><span class=\"line\">整数数组 nums 按升序排列，数组中的值 互不相同 。</span><br><span class=\"line\"></span><br><span class=\"line\">在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。</span><br><span class=\"line\"></span><br><span class=\"line\">给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。</span><br><span class=\"line\"></span><br><span class=\"line\">你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。</span><br><span class=\"line\"></span><br><span class=\"line\">示例 1：</span><br><span class=\"line\"></span><br><span class=\"line\">输入：nums = [4,5,6,7,0,1,2], target = 0</span><br><span class=\"line\">输出：4</span><br><span class=\"line\">示例 2：</span><br><span class=\"line\"></span><br><span class=\"line\">输入：nums = [4,5,6,7,0,1,2], target = 3</span><br><span class=\"line\">输出：-1</span><br><span class=\"line\">示例 3：</span><br><span class=\"line\"></span><br><span class=\"line\">输入：nums = [1], target = 0</span><br><span class=\"line\">输出：-1</span><br><span class=\"line\"> </span><br><span class=\"line\"></span><br><span class=\"line\">提示：</span><br><span class=\"line\"></span><br><span class=\"line\">1 &lt;= nums.length &lt;= 5000</span><br><span class=\"line\">-104 &lt;= nums[i] &lt;= 104</span><br><span class=\"line\">nums 中的每个值都 独一无二</span><br><span class=\"line\">题目数据保证 nums 在预先未知的某个下标上进行了旋转</span><br><span class=\"line\">-104 &lt;= target &lt;= 104</span><br></pre></td></tr></table></figure>\n\n<p>如果增加一个重复的元素，题目变成：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">81. 搜索旋转排序数组 II</span><br><span class=\"line\">已知存在一个按非降序排列的整数数组 nums ，数组中的值不必互不相同。</span><br><span class=\"line\"></span><br><span class=\"line\">在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转 ，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,4,4,5,6,6,7] 在下标 5 处经旋转后可能变为 [4,5,6,6,7,0,1,2,4,4] 。</span><br><span class=\"line\"></span><br><span class=\"line\">给你 旋转后 的数组 nums 和一个整数 target ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 nums 中存在这个目标值 target ，则返回 true ，否则返回 false 。</span><br><span class=\"line\"></span><br><span class=\"line\">你必须尽可能减少整个操作步骤。</span><br></pre></td></tr></table></figure>\n<p>增加了重复的元素，那么只需要判断重复的元素是否是目标元素，如果不是那么就直接删除重复的元素，使得问题便会原本不重复元素的形式</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">search</span><span class=\"params\">(nums []<span class=\"type\">int</span>, target <span class=\"type\">int</span>)</span></span><span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    n := <span class=\"built_in\">len</span>(nums)</span><br><span class=\"line\">    left,right := <span class=\"number\">0</span> , n</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> left &lt; right &#123;</span><br><span class=\"line\">        m := left + (right-left)/<span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> nums[left] == target || nums[m] == target || nums[right<span class=\"number\">-1</span>] == target&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> nums[m] &gt; nums[left] &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> target &gt; nums[left] &amp;&amp; target &lt; nums[m]&#123;</span><br><span class=\"line\">                right = m</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                left = m + <span class=\"number\">1</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> nums[m] &lt; nums[left]&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> target &gt; nums[m] &amp;&amp; target &lt; nums[right<span class=\"number\">-1</span>]&#123;</span><br><span class=\"line\">                left = m + <span class=\"number\">1</span></span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                right = m</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> left &lt; right &amp;&amp; nums[m] == nums[left]&#123;</span><br><span class=\"line\">                left++</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"cover":"/img/cover/sky3.png","cover_type":"img","excerpt":"","more":"<h1 id=\"算法思想篇\"><a href=\"#算法思想篇\" class=\"headerlink\" title=\"算法思想篇\"></a>算法思想篇</h1><blockquote>\n<p>个人学习算法经验：</p>\n<ol>\n<li>深入了解和使用一门语言 —&gt; Golang</li>\n<li>深入理解基础的数据结构和算法基础 —&gt; 数学理论</li>\n<li>知识需要依据模块和分区来做体系的整理和学习 </li>\n</ol>\n</blockquote>\n<h1 id=\"1-ensp-二分搜索：-为什么说有序皆可用二分\"><a href=\"#1-ensp-二分搜索：-为什么说有序皆可用二分\" class=\"headerlink\" title=\"1 &ensp; 二分搜索： 为什么说有序皆可用二分\"></a><strong>1</strong> &ensp; 二分搜索： 为什么说有序皆可用二分</h1><blockquote>\n<p>本章节的学习目标：</p>\n<ul>\n<li>二分搜索的两个标准模板</li>\n<li>二分搜索的提问破解法</li>\n<li>二分搜索的切分法</li>\n</ul>\n</blockquote>\n<h2 id=\"1-1-ensp-二分搜索的关键考点\"><a href=\"#1-1-ensp-二分搜索的关键考点\" class=\"headerlink\" title=\"1.1 &ensp; 二分搜索的关键考点\"></a><strong>1.1</strong> &ensp; 二分搜索的关键考点</h2><ol>\n<li><p>开闭原则<br>一定要注意，在写二分搜索时候，每一个区间的表示都是严格按照开闭原则进行的<br>开闭原则 –&gt; 左闭右开 –&gt; 左边指针指向起点，右边指针指向尾部元素的后面一个空位 </p>\n</li>\n<li><p>区间的变化计算</p>\n</li>\n<li><p>代码的流畅度</p>\n<ul>\n<li>==是否深度理解了二分搜索的原则在该题目当中的体现== –&gt; <font color='red'> 所有算法题目的代码流畅度检验思考一</font></li>\n<li>==是否真的记住了代码的模板== –&gt; <font color='red'> 所有算法题目的代码流畅度检验思考二</font></li>\n<li>==所有代码编写流畅度问题的根源都是在于不熟练–&gt; 用的不多 –&gt; 不会转化为已知的问题 –&gt; 是否理解了运用的原理== –&gt; <font color='red'> 代码熟练度尤其关注 </font></li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph TD</span><br><span class=\"line\">A[联系] --&gt; B(开闭原则)</span><br><span class=\"line\">B --&gt; D[二分搜索]</span><br><span class=\"line\">B --&gt; E[快速排序-三路切分]</span><br><span class=\"line\">B --&gt; F[归并排序-切分为两个区间]</span><br><span class=\"line\">A --&gt; C(扔掉一半)</span><br><span class=\"line\">C --&gt; G[二叉搜索树]</span><br><span class=\"line\">G --&gt; H[查找]</span><br><span class=\"line\">G --&gt; I[删除]</span><br><span class=\"line\">G --&gt; N[插入]</span><br><span class=\"line\">C --&gt; J(三路切分)</span><br><span class=\"line\">J --&gt; K[第k小的数]</span><br><span class=\"line\">J --&gt; L[唯一出现的数]   </span><br></pre></td></tr></table></figure>\n<br />\n\n\n<h2 id=\"1-2-ensp-提问破解法解决二分问题\"><a href=\"#1-2-ensp-提问破解法解决二分问题\" class=\"headerlink\" title=\"1.2 &ensp; 提问破解法解决二分问题\"></a><strong>1.2</strong> &ensp; 提问破解法解决二分问题</h2><h3 id=\"要什么，什么就是x\"><a href=\"#要什么，什么就是x\" class=\"headerlink\" title=\"要什么，什么就是x\"></a>要什么，什么就是x</h3><ol>\n<li>将目标元素设置为 x –&gt; 去除掉题目当中所给的最小最长最大最短等限制条件，得到一个点描述</li>\n<li>得到目标 x 的区间范围: –&gt; 决定左开右闭的规则</li>\n</ol>\n<h3 id=\"满足约束条件的f-x-0\"><a href=\"#满足约束条件的f-x-0\" class=\"headerlink\" title=\"满足约束条件的f(x)=0\"></a>满足约束条件的f(x)=0</h3><h3 id=\"不满足约束条件的f-x-设置为-1或者是1\"><a href=\"#不满足约束条件的f-x-设置为-1或者是1\" class=\"headerlink\" title=\"不满足约束条件的f(x)设置为-1或者是1\"></a>不满足约束条件的f(x)设置为-1或者是1</h3><p>构造出一个单调变化的 f(x)，以上两步的关键在于确定（构造）f(x)是否有序，需要观察数组元素和题目要求的内容变化</p>\n<h3 id=\"使用lowbound-还是-upbound\"><a href=\"#使用lowbound-还是-upbound\" class=\"headerlink\" title=\"使用lowbound 还是 upbound\"></a>使用lowbound 还是 upbound</h3><p>最优解 0 在 f(x)=0 结果区间的最左边还是最右边，决定使用lowbound 还是 upbound </p>\n<h3 id=\"有序数组中最左边的元素\"><a href=\"#有序数组中最左边的元素\" class=\"headerlink\" title=\"有序数组中最左边的元素\"></a>有序数组中最左边的元素</h3><blockquote>\n<p>模板题目</p>\n</blockquote>\n<h3 id=\"给定有序数组和target-，返回起始和终止位置\"><a href=\"#给定有序数组和target-，返回起始和终止位置\" class=\"headerlink\" title=\"给定有序数组和target ，返回起始和终止位置\"></a>给定有序数组和target ，返回起始和终止位置</h3><blockquote>\n<p>模板题目</p>\n</blockquote>\n<h3 id=\"寻找山峰\"><a href=\"#寻找山峰\" class=\"headerlink\" title=\"寻找山峰\"></a>寻找山峰</h3><h3 id=\"最小长度的连续子数组\"><a href=\"#最小长度的连续子数组\" class=\"headerlink\" title=\"最小长度的连续子数组\"></a>最小长度的连续子数组</h3><p>求取的中间数组[-1,-1,0,0,1,1] 中元素代表的是子数组的长度，-1表示小于target,0 表示等于target</p>\n<!-- // 209. 长度最小的子数组\n\n// 给定一个含有 n 个正整数的数组和一个正整数 target 。\n\n// 找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。\n\n//  \n\n// 示例 1：\n\n// 输入：target = 7, nums = [2,3,1,2,4,3]\n// 输出：2\n// 解释：子数组 [4,3] 是该条件下的长度最小的子数组。\n// 示例 2：\n\n// 输入：target = 4, nums = [1,4,4]\n// 输出：1\n// 示例 3：\n\n// 输入：target = 11, nums = [1,1,1,1,1,1,1,1]\n// 输出：0\n//  \n\n// 提示：\n\n// 1 <= target <= 109\n// 1 <= nums.length <= 105\n// 1 <= nums[i] <= 105\n\n// 求和数组 -->\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">isTarget</span><span class=\"params\">(nums []<span class=\"type\">int</span>,l <span class=\"type\">int</span>,target <span class=\"type\">int</span>)</span></span><span class=\"type\">int</span>&#123;</span><br><span class=\"line\">    sum := <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span> ; i &lt; <span class=\"built_in\">len</span>(nums) ; i++ &#123;</span><br><span class=\"line\">        sum += nums[i]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i &lt; l<span class=\"number\">-1</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> sum &gt;= target&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        sum = sum - nums[i-(l<span class=\"number\">-1</span>)]</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">minSubArrayLen</span><span class=\"params\">(target <span class=\"type\">int</span>, nums []<span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    left, right := <span class=\"number\">1</span>,<span class=\"built_in\">len</span>(nums)+<span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> left &lt; right&#123;</span><br><span class=\"line\">        m := left + (right-left)/<span class=\"number\">2</span></span><br><span class=\"line\">        now := isTarget(nums,m,target)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> now &lt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">            left = m + <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            right = m</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> left &gt; <span class=\"built_in\">len</span>(nums)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> left</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"最大平均值\"><a href=\"#最大平均值\" class=\"headerlink\" title=\"最大平均值\"></a>最大平均值</h3><p>但限制了数组长度为k的时候，可以直接使用滑动窗口来解决这个问题</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @param nums: an array</span></span><br><span class=\"line\"><span class=\"comment\"> * @param k: an integer</span></span><br><span class=\"line\"><span class=\"comment\"> * @return: the maximum average value</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">FindMaxAverage</span><span class=\"params\">(nums []<span class=\"type\">int</span>, k <span class=\"type\">int</span>)</span></span> <span class=\"type\">float64</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// Write your code here</span></span><br><span class=\"line\">\tmax := <span class=\"number\">-10001</span></span><br><span class=\"line\">\tsum := <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(nums); i++ &#123;</span><br><span class=\"line\">\t\tsum = sum + nums[i]</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> i &lt; k<span class=\"number\">-1</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> sum &gt; max &#123;</span><br><span class=\"line\">\t\t\tmax = sum</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> i &gt;= k<span class=\"number\">-1</span> &#123;</span><br><span class=\"line\">\t\t\tsum = sum - nums[i-(k<span class=\"number\">-1</span>)]</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"type\">float64</span>(max) / <span class=\"type\">float64</span>(k)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"连续子数组的最大和问题\"><a href=\"#连续子数组的最大和问题\" class=\"headerlink\" title=\"连续子数组的最大和问题\"></a>连续子数组的最大和问题</h3><p>在上述两个问题的基础之上，衍生出来同类型的问题：</p>\n<ol>\n<li>如果子数组的长度无限制： 采用落差发或者是双指针，DP来解决这个问题</li>\n<li>子数组长度等于K 时候采用滑动窗口</li>\n<li>长度&gt;=K,采用滑动窗口和落差法来解决</li>\n<li>如果限制长度必须要&lt;=k的连续子数组最大和，可以分别求1-k的最大值，然后再选一个最大值</li>\n</ol>\n<h2 id=\"3三步切分法\"><a href=\"#3三步切分法\" class=\"headerlink\" title=\"3三步切分法\"></a><strong>3</strong>三步切分法</h2><ol>\n<li>找出一个分界元素</li>\n<li>将有序的搜索空间分为两半（复杂度为O（1））<br>扔掉不需要的那一半</li>\n<li>在剩下的空间中递归使用切分法</li>\n</ol>\n<p>切分法不需要有序性，但是二分搜索必须要求有序性</p>\n<h3 id=\"求旋转数组当中的某个元素\"><a href=\"#求旋转数组当中的某个元素\" class=\"headerlink\" title=\"求旋转数组当中的某个元素\"></a>求旋转数组当中的某个元素</h3><p>以下是未重复的题目：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">33. 搜索旋转排序数组</span><br><span class=\"line\">整数数组 nums 按升序排列，数组中的值 互不相同 。</span><br><span class=\"line\"></span><br><span class=\"line\">在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。</span><br><span class=\"line\"></span><br><span class=\"line\">给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。</span><br><span class=\"line\"></span><br><span class=\"line\">你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。</span><br><span class=\"line\"></span><br><span class=\"line\">示例 1：</span><br><span class=\"line\"></span><br><span class=\"line\">输入：nums = [4,5,6,7,0,1,2], target = 0</span><br><span class=\"line\">输出：4</span><br><span class=\"line\">示例 2：</span><br><span class=\"line\"></span><br><span class=\"line\">输入：nums = [4,5,6,7,0,1,2], target = 3</span><br><span class=\"line\">输出：-1</span><br><span class=\"line\">示例 3：</span><br><span class=\"line\"></span><br><span class=\"line\">输入：nums = [1], target = 0</span><br><span class=\"line\">输出：-1</span><br><span class=\"line\"> </span><br><span class=\"line\"></span><br><span class=\"line\">提示：</span><br><span class=\"line\"></span><br><span class=\"line\">1 &lt;= nums.length &lt;= 5000</span><br><span class=\"line\">-104 &lt;= nums[i] &lt;= 104</span><br><span class=\"line\">nums 中的每个值都 独一无二</span><br><span class=\"line\">题目数据保证 nums 在预先未知的某个下标上进行了旋转</span><br><span class=\"line\">-104 &lt;= target &lt;= 104</span><br></pre></td></tr></table></figure>\n\n<p>如果增加一个重复的元素，题目变成：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">81. 搜索旋转排序数组 II</span><br><span class=\"line\">已知存在一个按非降序排列的整数数组 nums ，数组中的值不必互不相同。</span><br><span class=\"line\"></span><br><span class=\"line\">在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转 ，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,4,4,5,6,6,7] 在下标 5 处经旋转后可能变为 [4,5,6,6,7,0,1,2,4,4] 。</span><br><span class=\"line\"></span><br><span class=\"line\">给你 旋转后 的数组 nums 和一个整数 target ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 nums 中存在这个目标值 target ，则返回 true ，否则返回 false 。</span><br><span class=\"line\"></span><br><span class=\"line\">你必须尽可能减少整个操作步骤。</span><br></pre></td></tr></table></figure>\n<p>增加了重复的元素，那么只需要判断重复的元素是否是目标元素，如果不是那么就直接删除重复的元素，使得问题便会原本不重复元素的形式</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">search</span><span class=\"params\">(nums []<span class=\"type\">int</span>, target <span class=\"type\">int</span>)</span></span><span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    n := <span class=\"built_in\">len</span>(nums)</span><br><span class=\"line\">    left,right := <span class=\"number\">0</span> , n</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> left &lt; right &#123;</span><br><span class=\"line\">        m := left + (right-left)/<span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> nums[left] == target || nums[m] == target || nums[right<span class=\"number\">-1</span>] == target&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> nums[m] &gt; nums[left] &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> target &gt; nums[left] &amp;&amp; target &lt; nums[m]&#123;</span><br><span class=\"line\">                right = m</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                left = m + <span class=\"number\">1</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> nums[m] &lt; nums[left]&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> target &gt; nums[m] &amp;&amp; target &lt; nums[right<span class=\"number\">-1</span>]&#123;</span><br><span class=\"line\">                left = m + <span class=\"number\">1</span></span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                right = m</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> left &lt; right &amp;&amp; nums[m] == nums[left]&#123;</span><br><span class=\"line\">                left++</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"ACM 模式输入输出总结","catalog":true,"date":"2023-03-25T19:38:52.000Z","subtitle":"解决牛客网输入输出问题","header-img":null,"published":0,"_content":"\n# 输入格式归纳记录\n\n由于牛客网采用的是 acm 形式编写代码，所以需要在做题时候需要自行处理输入输出的数据格式，以 Golang 作为主要例子归纳如下：\n\n\n## 读取多行数据，每一行数据是多个空格隔开的元素\n``` golang\npackage main\nimport(\n    \"bufio\"\n    \"fmt\"\n    \"strings\"\n    \"strconv\"\n    \"os\"\n)\n\nfunc main(){\n    scanner := bufio.NewScanner(os.Stdin)\n    scanner.Split(bufio.ScanLines)\n    var sum int\n    for scanner.Scan(){\n        line := scanner.Text()\n        fields := strings.Fields(line)\n        for _, field := range fields{\n            num, err := strconv.Atoi(field)\n            if err == nil{\n                sum += num\n            }\n        }\n        fmt.Println(sum)\n        sum = 0\n    }\n}\n```\n\n\n\n# 输入数值的进制转换\n\n## 十进制数字转换为其他进制数字\n\n```golang\n    i := 255\n    // 将int类型的i转化为二进制字符串并输出\n    s := strconv.FormatInt(int64(i), 2)\n    fmt.Println(s) // \"11111111\"\n    // 将int类型的i转化为八进制字符串并输出\n    s = strconv.FormatInt(int64(i), 8)\n    fmt.Println(s) // \"377\"\n    // 将int类型的i转化为十六进制字符串并输出\n    s = strconv.FormatInt(int64(i), 16)\n    fmt.Println(s) // \"ff\"\n```\n\n## 其他进制转换为10进制\n\n```golang\n    s := \"377\"\n    i, err := strconv.ParseInt(s, 8, 0)\n    if err != nil {\n        fmt.Println(err)\n    } else {\n        fmt.Println(i) // 255\n    }\n```\n","source":"_posts/Algorithm/script/ACM-模式输入输出总结/ACM-模式输入输出总结.md","raw":"---\ntitle: ACM 模式输入输出总结\ncatalog: true\ndate: 2023-03-26 03:38:52\nsubtitle: 解决牛客网输入输出问题\nheader-img:\ntags: Golang\ncategories:\npublished: false\n---\n\n# 输入格式归纳记录\n\n由于牛客网采用的是 acm 形式编写代码，所以需要在做题时候需要自行处理输入输出的数据格式，以 Golang 作为主要例子归纳如下：\n\n\n## 读取多行数据，每一行数据是多个空格隔开的元素\n``` golang\npackage main\nimport(\n    \"bufio\"\n    \"fmt\"\n    \"strings\"\n    \"strconv\"\n    \"os\"\n)\n\nfunc main(){\n    scanner := bufio.NewScanner(os.Stdin)\n    scanner.Split(bufio.ScanLines)\n    var sum int\n    for scanner.Scan(){\n        line := scanner.Text()\n        fields := strings.Fields(line)\n        for _, field := range fields{\n            num, err := strconv.Atoi(field)\n            if err == nil{\n                sum += num\n            }\n        }\n        fmt.Println(sum)\n        sum = 0\n    }\n}\n```\n\n\n\n# 输入数值的进制转换\n\n## 十进制数字转换为其他进制数字\n\n```golang\n    i := 255\n    // 将int类型的i转化为二进制字符串并输出\n    s := strconv.FormatInt(int64(i), 2)\n    fmt.Println(s) // \"11111111\"\n    // 将int类型的i转化为八进制字符串并输出\n    s = strconv.FormatInt(int64(i), 8)\n    fmt.Println(s) // \"377\"\n    // 将int类型的i转化为十六进制字符串并输出\n    s = strconv.FormatInt(int64(i), 16)\n    fmt.Println(s) // \"ff\"\n```\n\n## 其他进制转换为10进制\n\n```golang\n    s := \"377\"\n    i, err := strconv.ParseInt(s, 8, 0)\n    if err != nil {\n        fmt.Println(err)\n    } else {\n        fmt.Println(i) // 255\n    }\n```\n","slug":"Algorithm/script/ACM-模式输入输出总结/ACM-模式输入输出总结","updated":"2023-05-03T01:57:14.323Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli796r120020byjx50tqalwm","content":"<h1 id=\"输入格式归纳记录\"><a href=\"#输入格式归纳记录\" class=\"headerlink\" title=\"输入格式归纳记录\"></a>输入格式归纳记录</h1><p>由于牛客网采用的是 acm 形式编写代码，所以需要在做题时候需要自行处理输入输出的数据格式，以 Golang 作为主要例子归纳如下：</p>\n<h2 id=\"读取多行数据，每一行数据是多个空格隔开的元素\"><a href=\"#读取多行数据，每一行数据是多个空格隔开的元素\" class=\"headerlink\" title=\"读取多行数据，每一行数据是多个空格隔开的元素\"></a>读取多行数据，每一行数据是多个空格隔开的元素</h2><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"><span class=\"keyword\">import</span>(</span><br><span class=\"line\">    <span class=\"string\">&quot;bufio&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;strings&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;strconv&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;os&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    scanner := bufio.NewScanner(os.Stdin)</span><br><span class=\"line\">    scanner.Split(bufio.ScanLines)</span><br><span class=\"line\">    <span class=\"keyword\">var</span> sum <span class=\"type\">int</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> scanner.Scan()&#123;</span><br><span class=\"line\">        line := scanner.Text()</span><br><span class=\"line\">        fields := strings.Fields(line)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> _, field := <span class=\"keyword\">range</span> fields&#123;</span><br><span class=\"line\">            num, err := strconv.Atoi(field)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> err == <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">                sum += num</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        fmt.Println(sum)</span><br><span class=\"line\">        sum = <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"输入数值的进制转换\"><a href=\"#输入数值的进制转换\" class=\"headerlink\" title=\"输入数值的进制转换\"></a>输入数值的进制转换</h1><h2 id=\"十进制数字转换为其他进制数字\"><a href=\"#十进制数字转换为其他进制数字\" class=\"headerlink\" title=\"十进制数字转换为其他进制数字\"></a>十进制数字转换为其他进制数字</h2><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i := <span class=\"number\">255</span></span><br><span class=\"line\"><span class=\"comment\">// 将int类型的i转化为二进制字符串并输出</span></span><br><span class=\"line\">s := strconv.FormatInt(<span class=\"type\">int64</span>(i), <span class=\"number\">2</span>)</span><br><span class=\"line\">fmt.Println(s) <span class=\"comment\">// &quot;11111111&quot;</span></span><br><span class=\"line\"><span class=\"comment\">// 将int类型的i转化为八进制字符串并输出</span></span><br><span class=\"line\">s = strconv.FormatInt(<span class=\"type\">int64</span>(i), <span class=\"number\">8</span>)</span><br><span class=\"line\">fmt.Println(s) <span class=\"comment\">// &quot;377&quot;</span></span><br><span class=\"line\"><span class=\"comment\">// 将int类型的i转化为十六进制字符串并输出</span></span><br><span class=\"line\">s = strconv.FormatInt(<span class=\"type\">int64</span>(i), <span class=\"number\">16</span>)</span><br><span class=\"line\">fmt.Println(s) <span class=\"comment\">// &quot;ff&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"其他进制转换为10进制\"><a href=\"#其他进制转换为10进制\" class=\"headerlink\" title=\"其他进制转换为10进制\"></a>其他进制转换为10进制</h2><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s := <span class=\"string\">&quot;377&quot;</span></span><br><span class=\"line\">i, err := strconv.ParseInt(s, <span class=\"number\">8</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    fmt.Println(err)</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    fmt.Println(i) <span class=\"comment\">// 255</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":"/img/cover/sky.png","cover_type":"img","excerpt":"","more":"<h1 id=\"输入格式归纳记录\"><a href=\"#输入格式归纳记录\" class=\"headerlink\" title=\"输入格式归纳记录\"></a>输入格式归纳记录</h1><p>由于牛客网采用的是 acm 形式编写代码，所以需要在做题时候需要自行处理输入输出的数据格式，以 Golang 作为主要例子归纳如下：</p>\n<h2 id=\"读取多行数据，每一行数据是多个空格隔开的元素\"><a href=\"#读取多行数据，每一行数据是多个空格隔开的元素\" class=\"headerlink\" title=\"读取多行数据，每一行数据是多个空格隔开的元素\"></a>读取多行数据，每一行数据是多个空格隔开的元素</h2><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"><span class=\"keyword\">import</span>(</span><br><span class=\"line\">    <span class=\"string\">&quot;bufio&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;strings&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;strconv&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;os&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    scanner := bufio.NewScanner(os.Stdin)</span><br><span class=\"line\">    scanner.Split(bufio.ScanLines)</span><br><span class=\"line\">    <span class=\"keyword\">var</span> sum <span class=\"type\">int</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> scanner.Scan()&#123;</span><br><span class=\"line\">        line := scanner.Text()</span><br><span class=\"line\">        fields := strings.Fields(line)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> _, field := <span class=\"keyword\">range</span> fields&#123;</span><br><span class=\"line\">            num, err := strconv.Atoi(field)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> err == <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">                sum += num</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        fmt.Println(sum)</span><br><span class=\"line\">        sum = <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"输入数值的进制转换\"><a href=\"#输入数值的进制转换\" class=\"headerlink\" title=\"输入数值的进制转换\"></a>输入数值的进制转换</h1><h2 id=\"十进制数字转换为其他进制数字\"><a href=\"#十进制数字转换为其他进制数字\" class=\"headerlink\" title=\"十进制数字转换为其他进制数字\"></a>十进制数字转换为其他进制数字</h2><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i := <span class=\"number\">255</span></span><br><span class=\"line\"><span class=\"comment\">// 将int类型的i转化为二进制字符串并输出</span></span><br><span class=\"line\">s := strconv.FormatInt(<span class=\"type\">int64</span>(i), <span class=\"number\">2</span>)</span><br><span class=\"line\">fmt.Println(s) <span class=\"comment\">// &quot;11111111&quot;</span></span><br><span class=\"line\"><span class=\"comment\">// 将int类型的i转化为八进制字符串并输出</span></span><br><span class=\"line\">s = strconv.FormatInt(<span class=\"type\">int64</span>(i), <span class=\"number\">8</span>)</span><br><span class=\"line\">fmt.Println(s) <span class=\"comment\">// &quot;377&quot;</span></span><br><span class=\"line\"><span class=\"comment\">// 将int类型的i转化为十六进制字符串并输出</span></span><br><span class=\"line\">s = strconv.FormatInt(<span class=\"type\">int64</span>(i), <span class=\"number\">16</span>)</span><br><span class=\"line\">fmt.Println(s) <span class=\"comment\">// &quot;ff&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"其他进制转换为10进制\"><a href=\"#其他进制转换为10进制\" class=\"headerlink\" title=\"其他进制转换为10进制\"></a>其他进制转换为10进制</h2><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s := <span class=\"string\">&quot;377&quot;</span></span><br><span class=\"line\">i, err := strconv.ParseInt(s, <span class=\"number\">8</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    fmt.Println(err)</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    fmt.Println(i) <span class=\"comment\">// 255</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Golang-非算法题目","catalog":true,"date":"2023-04-03T11:45:36.000Z","subtitle":null,"header-img":null,"published":0,"_content":"","source":"_posts/Algorithm/script/Golang-非算法题目/Golang-非算法题目.md","raw":"---\ntitle: Golang-非算法题目\ncatalog: true\ndate: 2023-04-03 19:45:36\nsubtitle:\nheader-img:\ntags:\ncategories:\npublished: false\n---\n","slug":"Algorithm/script/Golang-非算法题目/Golang-非算法题目","updated":"2023-04-22T13:24:02.176Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli796r130021byjxd8uqg3uw","content":"","site":{"data":{}},"cover":"/img/cover/elderring.png","cover_type":"img","excerpt":"","more":""},{"title":"Golang 算法课程--数据结构","catalog":true,"date":"2023-04-01T16:46:21.000Z","subtitle":null,"header-img":null,"_content":"\n# 告别盲目刷题，击破算法面试\n> 学习拉钩教育算法课程记录加个人感悟记录\n> 如果有版权问题，请联系 2374087322@qq.com 删除课程部分的内容\n> \n> 算法能力的高度，决定了个人能够解决的实战问题复杂度的上限\n>\n> 数学基础决定了算法能力的高低\n\n## ==解题流程==：\n\n### ==四部分析法==\n\n* **==模拟==** ： 模拟题目的运行\n  使用简单且有一定量的小例子，将自己当作计算机来执行这个流程\n  *一般使用题目给的较长的那个例子就可以*\n  \n  这部分也是读题和理解输入输出内容的部分，理解题意的部分\n  \n  这个时候一定不能够着急，不要害怕或者是觉得麻烦，一定要耐下性子，把简单的一个逻辑过程给跑清楚，理解这段程序或者是业务需要咱们处理什么样的问题。\n  \n  跑的过程，不要完全先入为主，应当以题目的要求来推进演示。\n  \n  不要想着在这一步就把所有的问题都给解决，一步步推进就可以. \n  \n* **==规律==** ： 尝试总结出题目的一般规律和特点\n  \n  数学规律和特性一般来说很难直接从零归纳出来，但我们可以依赖所学习的高数、线性代数、离散数学、测度论等高等数学理论当中所见到的数学计算模型来匹配，这也是这部分最重要的基础\n\n  先总结一些考题可能会用到的观察特点：\n  * 形式相关：比如 括号匹配、从1加到100，\n  * 数量变化：数量变化与取模相关，数量变化呈现递推公式\n  * \n\n\n* **==匹配==** ： 找到符合这些特点的数据结构和算法\n  * 关注数据的输入类型：对输入数据进行分类，哪一些数据进行怎样的操作\n\n  * **==怎样匹配呢？==**：\n    * 题目模拟的时候（这部分一般使用栈、队列、二叉树）来理解题目要求的数字变化\n    * 观察结果集合，或者是原本中间的变化集合，当期符合某种数据结构的变化特征的时候，就可以选用这个数据结构\n\n\n* **==考虑边界条件==**： 考虑特殊情况\n  特殊情况：\n  * 字符串为空，字符串只有一个，两个、\n  * 数组为空，数字为0或者是其他不符合规律的特殊情况\n\n\n* **==深度思考==** ： 平时练习当中的流程，用于提高算法模型的积累\n  * 深度： 这种解法还可以怎么优化\n  * 广度： 这种解法的具有普适性吗？可以推广吗？问题的限定条件变多的话，这个模型是否还可以适合。\n  * 数学模式扩散： 这样特点的问题是否有对应的数学模型或者是理论描述过\n\n\n\n# 栈： 从简单栈到单调栈，让栈问题不再困难\n\n## 结构特征\n\n先进后出\n\n对栈的操作：\n* **==pop==** 弹出栈顶元素，一般来说栈中可操作的元素就是栈顶元素，其他元素也都是先pop出其上面的元素，变成栈顶元素之后再进行操作。\n*  **==peek==** 获取栈顶元素，只是读取操作，但并没有弹出栈顶元素\n*  **==push==** 将元素压入栈中\n\n### Golang 栈的使用\n\n在 Go 中并没有直接提供Stack的方法结构，但可以使用切片非常简单地表示和使用栈、队列结构。\n\n 先进后出的数据结构，使用**==切片==**表示，压入栈的操作就是往切片中添加元素，弹出栈的操作就是输出末尾元素，并将切片缩小为：`[:len(stack)-1]`\n\n以下为栈的代码模板实现：\n```golang\ntype Stack struct{\n    Stack []interface{}\n}\n\nfunc (s *Stack)push(x interface{}){\n    s = append(s,x)\n}\n\nfunc (s *Stack)pop(){\n    s = s[:len(s)-1]\n}\n\nfunc (s *Stack)peek()(x interface{}){\n    return s[len(s)-1]\n}\n```\n\n关键在于记住：\n* 栈顶元素 ---> 切片末尾元素\n* 切片是左闭右开，所以pop操作是 s = s[:len(s)-1], 但如果是队列pop出第一个元素就需要往后再移动一位 s = s[1:] 而不是 s = s[0:]\n\n## 典型题目\n\n### 判断字符串是否合法\n题目：https://leetcode.cn/problems/valid-parentheses/\n\n#### 正确解法和流程\nhttps://leetcode.cn/link/?target=https://www.bilibili.com/video/BV1AF411w78g\n```golang\nfunc isValid(s string) bool {\n    n := len(s)\n    if n % 2 == 1 {\n        return false\n    }\n    pairs := map[byte]byte{\n        ')': '(',\n        ']': '[',\n        '}': '{',\n    }\n    stack := []byte{}\n    for i := 0; i < n; i++ {\n        if pairs[s[i]] > 0 {\n            if len(stack) == 0 || stack[len(stack)-1] != pairs[s[i]] {\n                return false\n            }\n            stack = stack[:len(stack)-1]\n        } else {\n            stack = append(stack, s[i])\n        }\n    }\n    return len(stack) == 0\n}\n```\n\n#### 个人解法和流程\n\n> 问题集中体现在数据特性处理判断太过分散，属实是缝缝补补有一年\n> 对输入数据进行分类，哪一些数据进行怎样的操作\n> * 输入的是左括号应该入栈\n> * 输入的是右括号应该做判断\n<br />\n\n我的代码是：\n```golang\n    func isValid(s string) bool {\n    \n    l := len(s)\n    if l%2 != 0{\n        return false\n    }\n    stack := make([]rune, 0)\n\n    m := map[rune]rune{\n        ']':'[',\n        ')':'(',\n        '}':'{',\n    }\n    for _,v := range s{\n        if v == '[' ||v == '{' ||v == '('{\n            stack = append(stack,v)\n            continue\n        }\n        if len(stack) == 0{\n            return false\n        }\n        if stack[len(stack)-1] == m[v]{\n            stack = stack[:len(stack)-1]\n            continue\n        }\n\n        if m[v] != 0 {return false}\n    }\n\n    if len(stack) == 0{return true}\n\n    return false\n}\n```\n上述在判断栈顶元素的时候逻辑不够清晰，所以加了很多的if来补足条件，我们看例子当中所给的逻辑顺序：\n```golang\n        pairs := map[byte]byte{\n        ')': '(',\n        ']': '[',\n        '}': '{',\n    }\n    stack := []byte{}\n    for i := 0; i < n; i++ {\n        if pairs[s[i]] > 0 {\n            if len(stack) == 0 || stack[len(stack)-1] != pairs[s[i]] {\n                return false\n            }\n            stack = stack[:len(stack)-1]\n        } else {\n            stack = append(stack, s[i])\n        }\n    }\n    return len(stack) == 0\n```\n\n关键差距就在于这一句话：`pairs[s[i]] > 0 `, 这个判断对输入的数据做了一次分类，依据上面的map结构可知，这句话 < 0 时候标识map当中没有存储对应的对象，而map中存储的是所有的左括号，所以这个判断的作用是**当输入是右括号的时候进入函数**，然后逻辑体依据输入是右括号判断，如果当前栈里面没有元素或者是栈顶元素与右括号不匹配那么就返回false\n\\\n实际上我写的函数最后夜市做了类似的判断，但显然没有考虑数据分类的情况。\n\n\n### 判断大鱼吃小鱼最后留下的鱼\n题目：\n\n近似题目：https://www.nowcoder.com/questionTerminal/3fdfc63015df42c6a78fdae46709fa69?f=discussion\n\n<br />\n\n#### 正确解法和流程\n``` c++\nclass Solution {\npublic:\n    /**\n     * \n     * @param N int整型 N条鱼\n     * @param A int整型vector 每条鱼的体积为Ai\n     * @return int整型\n     */\n    struct P{\n        int x, t;\n    };\n    int solve(int N, vector<int>& A) {\n        stack<P> S;\n        int cnt = 0;\n        for(int i=N-1;i>=0;i--){\n            int t = 0;\n            while(!S.empty() && A[i]>S.top().x){\n                t = max(S.top().t, t+1);\n                S.pop();\n            }\n            S.push({A[i], t});\n            cnt = max(cnt, t);\n        }\n        return cnt;\n    }\n};\n```\n\n\n#### 个人解法和流程\n由于找不到相同的题目，就找了类似的题目，但是解题的思路不太一样\n图片上的大鱼吃小鱼，只需要每次比较栈顶元素和新进来的元素大小即可，当大于的时候，就不做操作，当栈顶元素小于输入元素的时候，pop出栈顶元素并push进入这个最大值，最后栈中元素就是结果。这个过程当中几处需要重视的地方是：\n* 当鱼的方向一致时候，大鱼并不会把同方向的小鱼给吃了【可能不论大小鱼的速度相同（bushi）】，而如果小鱼在左，大鱼在右，方向不同，则也不会吃\n\n\n牛客网的题目则加了非常多的条件和限制，是对栈问题的一个较大的变化\n\n> 对比上述两个题目可以观察到：\n> <font color ='blue'> 1. 消除的行为不同</font>\n>   括号匹配中，消除行为是配对的两者都会消除，也就是栈顶元素和输入元素一起被消除\n>   大鱼吃小鱼中，消除行为是配对的两者中会有一个被消除\n> --> 是否入栈和出栈的判断\n> <font color ='blue'> 2. 栈中的内容不同</font>\n>   括号匹配当中，栈中存放的就是内容本身\n>   大鱼吃小鱼当中，栈里存放的是内容的索引，可以通过索引找到内容\n> <font color ='blue'> 3. 弹栈的方式也不相同</font>\n>   括号匹配只需要每次弹出一个元素就可以\n>   大鱼则需要用while语句一直弹出到满足某个条件才停止\n\n\n## 栈问题的特征和解决流程\n\n### pop 行为不同\npop【弹栈的操作不一样】\n常见的就是每次循环都判断栈顶元素的特点而pop或者push或者不操作，但这样必须得是连续性的元素才有这样的特征\n\n**==在弹栈的时候，是否一定要满足某个条件才停止弹栈==**\n也就是说当输入元素之后需要将其和站内其他的元素进行比较，在使用的时候尤其要注意迭代过程\n\n### 栈中存储内容不相同\n是否栈中存储数据、还是存储索引、还是存储一个自建的新的结构\n\n### 栈顶元素的含义不相同\n\n\n## 单调栈\n\n单调栈是指栈中元素必须按照升序排列的栈或者是降序排列的栈\n\n单调栈分为：\n* 递增栈：\n    栈中元素从左到右遵守从小到大的顺序\n    入栈时候，当**入栈元素小于栈顶元素**就会pop出栈顶元素，直到入栈元素大于栈顶元素\n    特点是：\n    入栈小数会消除栈内大数\n\n* 递减栈\n    栈中元素从左到右遵守从大到小的顺序\n    入栈时候，当**入栈元素大于栈顶元素**就会pop出栈顶元素，直到入栈元素小于栈顶元素\n    特点是：\n    入栈大数会消除栈内小数\n\n\n### 典型代码：\n```golang\nstack := make([]int,0)\n/**递增栈的入栈\n* 用for 循环出栈，直到栈顶元素满足递增栈的要求\n*/\nfor len(stack)> 0 && A[i] > stack[len(stack)-1]{\n    // pop出栈内比 A[i]小但却在前面的元素\n    stack = stack[:len(stack)-1]\n}\nstack = append(stack,A[i])\n\n```\n### 找到当前数字右边最小的对应数字\n### 取k个字符，求字典序最小的组合\n> 字典序：\n> * 对单个元素按照ascii 表中大小顺序排列\n> * 多个元素时，按照从左到右顺序，先从高位字典排序，然后在相同高位中按照地位再字典排序\n### 给定一个数组，数组中元素代表模板的高度，请你求出相邻木板能剪出的最大矩形面积\n> 和求最大容积是一个题目\n\n<br />\n\n## leetcode 题目汇总\n\n> 以leetcode 题目为例子\n\n相关栈的题目汇总：\n[1][https://leetcode.cn/problem-list/xb9nqhhg/?topicSlugs=stack&page=1]\n[2][https://leetcode.cn/problem-list/e8X3pBZi/?page=1&topicSlugs=heap-priority-queue]\n[3][https://leetcode.cn/problem-list/2cktkvj/?page=1&topicSlugs=stack]\n\n\n# 队列：FIFO 队列与单调队列的深挖与扩展\n\n先进先出，是共同特征\n\n类别上可以分出：\n* FIFO队列\n* 单调队列\n\n## FIFO队列\n\n**==Push 元素时候， 总是将放在元素放在队列尾部，也就是操作 fifo[len(fifo)-1]==**\n**==Pop 元素时候，总是将队列首部的元素扔掉 ，也就是操作 fifo = fifo[1:]==**\n\n###  二叉树的层次遍历（两种方法）\n\n* 规律： \n  广度遍历（层次遍历）：由于二叉树的特点，当拿到第N层的结点A之后，可以通过 A 的left，right指针拿到下一层的节点\n  **但是与A在同一层的节点还有其他吗，这个时候就需要按层来存储节点，不能直接使用递归**\n\n    <br />\n    顺序输出：每层输出时，排在左边的节点，它的子节点同样排在下一层的最左边\n\n--> **==题目具备广度遍历（分层遍历）的特点 和 顺序输出的特点 ，应该想到应用FIFO队列==**\n\n* 边界\n  特殊判断： 如果发现是一棵空二叉树，就直接返回空结果\n  ==制定一个规则==： 不要让空指针进入到FIFO队列（一些编程的亮点）\n\n<font color = 'red'> 非常重要的概念： QSize 表示当前层数 </font>\n\n#### 层次遍历二叉树\n题目链接：https://leetcode.cn/problems/binary-tree-level-order-traversal/submissions/\n\n##### 解题思路1\n关键思路在于将每一层的节点都存在FIFO队列里面，在每次遍历的时候从左到右pop出该层的节点，同时在队尾加入他的左右孩子\n\n队首pop出当层节点，队尾append下一层的孩子节点\nQSize 记录当层的节点数量\n\n时间复杂度是O(n), 空间复杂度由QSize决定O(K),K表示QSize最大，也就是存储的一层节点数量最多的时候\n\n##### 代码\n```golang\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc levelOrder(root *TreeNode) [][]int {\n    // 创建FIFO 队列来存储遍历的过程\n    fifo := make([]*TreeNode,0)\n    // QSize 表示当前遍历的层\n    QSize := 1\n    // 初始化最终结果\n    result := make([][]int,0)\n    if root == nil{\n        return result\n    }\n    //将根节点入栈\n    fifo = append(fifo,root)\n    // 开始层序遍历，只要当前队列不为空\n    for len(fifo) > 0 {\n        // 创建结果数组用于存储当层pop出的元素值\n        tmp := make([]int, 0)\n        // 当层元素QSize全部遍历以此，这里不能用len(fifo)，因为fifo的长度是在变化的\n        for i := QSize;i > 0;i--{\n            // 拿出队列头元素\n            node := fifo[0]\n            // 判断他的左孩子是否为空\n            if node.Left!= nil{\n                fifo = append(fifo,node.Left)\n            }\n            // 判断他的右孩子是否为空\n            if node.Right != nil{\n                fifo = append(fifo,node.Right)\n            }\n            // 将该节点的值存入结果\n            tmp = append(tmp,node.Val)\n            // 推出队首元素\n            fifo = fifo[1:]\n        }\n        // 将结果 tmp 存入到结果数组当中\n        result = append(result,tmp)\n        // 重新计算当前层的节点数量\n        QSize = len(fifo)\n    }\n    return result\n}\n```\n##### 官方题解\n```golang\nfunc levelOrder(root *TreeNode) [][]int {\n    ret := [][]int{}\n    if root == nil {\n        return ret\n    }\n    q := []*TreeNode{root}\n    for i := 0; len(q) > 0; i++ {\n        ret = append(ret, []int{})\n        p := []*TreeNode{}\n        for j := 0; j < len(q); j++ {\n            node := q[j]\n            ret[i] = append(ret[i], node.Val)\n            if node.Left != nil {\n                p = append(p, node.Left)\n            }\n            if node.Right != nil {\n                p = append(p, node.Right)\n            }\n        }\n        q = p\n    }\n    return ret\n}\n\n```\n\n##### 解题思路2\n\n使用链表来解决问题\n\n#### 锯齿状层次遍历\n题目链接：https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/\n\n##### 解题思路\n层次遍历的基础上加一个qs，表示当前层是从左到右还是从右到左\n\n**==本题当中所犯的错误：==**：\n* 每一轮都需要重新计算qsize,一定不要忘了这一点\n* tmp 接收的时候还是按照栈的pop逻辑，所以顺序上还需要再反一次\n* 题目样例当中root是按照从左到右遍历过一次来计算的\n\n##### 代码\n\n```golang\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc zigzagLevelOrder(root *TreeNode) [][]int {\n    //结果数组\n    result := make([][]int,0)\n    //全局的fifo队列\n    fifo := make([]*TreeNode,0)\n    // Qsize 表示当前层的节点数，qs 表示该层的遍历顺序，0表示从左到右，1表示从右到左\n    Qsize ,qs := 1 , 1\n    // 如果树中没有节点则直接返回\n    if root == nil{\n        return result\n    }\n    // 将 root 放入队列\n    fifo = append(fifo,root)\n    //遍历整棵树\n    for len(fifo) > 0 {\n        tmp := make([]int,0)\n        for i:= 1; Qsize >= i && qs == 0 ;i++{\n            node := fifo[Qsize-i]\n            if node.Right != nil {\n                fifo = append(fifo,node.Right)\n            }\n            if node.Left != nil{\n                fifo = append(fifo,node.Left)\n            }\n            tmp = append(tmp,node.Val)                \n        }\n        for i:= 1; Qsize >= i && qs == 1 ;i++{\n            node := fifo[Qsize-i]\n            if node.Left != nil{\n                fifo = append(fifo,node.Left)\n            }\n            if node.Right != nil{\n                fifo = append(fifo,node.Right)\n            }\n            tmp = append(tmp,node.Val)                \n        }\n        fifo = fifo[Qsize:]\n        Qsize = len(fifo)\n        result = append(result,tmp)\n        if qs == 1{\n            qs = 0\n        }else{\n            qs = 1\n        }\n    }\n    return result\n}\n```\n\n\n\n#### 倒序层次遍历\n题目链接：https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/\n\n##### 解题思路\n从题目要求当中可以读出，是在之前的层序遍历基础上把结果倒过来输出，那么会比较自然想到可以在使用一个栈用来存储中间结果\n\n##### 代码\n\n```golang\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc levelOrderBottom(root *TreeNode) [][]int {\n    // 构造全局fifo队列\n    fifo := make([]*TreeNode,0)\n    // 构造结果栈\n    stack := make([][]int,0)\n    result := make([][]int,0)\n    //表示当前层的节点数量\n    Qsize := 1\n    fifo = append(fifo,root)\n    if root == nil{\n        return result\n    }\n    for len(fifo) > 0{\n        tmp := make([]int,0)\n        for Qsize > 0{\n            node:= fifo[0]\n            if node.Left != nil{\n                fifo =append(fifo,node.Left)\n            }\n            if node.Right != nil{\n                fifo = append(fifo,node.Right)\n            }\n            Qsize--\n            fifo = fifo[1:]\n            tmp = append(tmp,node.Val)\n        }\n        stack = append(stack,tmp)\n        Qsize = len(fifo)\n    }\n\n    // 将栈中元素pop 到结果当中\n    for len(stack) > 0{\n        result = append(result,stack[len(stack)-1])\n        stack = stack[:len(stack)-1]\n    }\n    return result\n}\n```\n\n## 循环队列\n\n设计一个可以容纳 k 个元素的循环队列，需要实现以下接口：\n\n```golang\ntype ringQueue interface{\n    //构造函数，参数k表示这个循环队列最多容纳k个元素\n    CircularQueue(int)\n    //将value放到队列中，成功返回true\n    EnQueue(int) bool\n    // 删除队首元素，成功返回true\n    DeQueue() bool\n    // 得到队首元素，如果队列为空，返回-1\n    Front() int\n    // 得到队尾元素，如果队列为空，返回-1\n    Rear() int\n    // 查看循环队列是否为空\n    isEmpty() bool\n    // 查看队列是否已经放满k个元素\n    isFull() bool\n}\n```\n\n* **==循环队列的重点在于==: <font color = 'red'>循环使用固定空间</font>**\n* **==难点在于==： <font color='red'>控制好 Front/Rear两个首位指示器</font>**\n\n### 表示方法1\n使用 `used`、`front`、`rear` 三个变量来控制，其中`used, front`都代表的是数组的下标\n\n注意以下几点：\n* index = i 的后一个是i+1，前一个是i+1\n* index = k-1 的后一个就是index=0\n* index = 0 的前一个是 index = k-1\n**==可以使用取模的方式统一处理==:**\n<font color='red'> index = i 的后一个元素下标是（i+1）% k</font>\n<font color='red'> index = i 的前一个元素下标是（i-1+k）% k</font>\n<font color='blue'>所有的循环数组下标的处理都需要按照这个取模的方式</font>\n\n参考的实例代码如下：\n```golang\ntype MyCircularQueue struct {\n    queue  []int\n    rear   int\n    front  int\n    used   int\n    length int\n}\n\nfunc CircularQueue(k int) ringQueue {\n    return &MyCircularQueue{\n        queue:  make([]int, k),\n        rear:   0,\n        front:  0,\n        used:   0,\n        length: k,\n    }\n}\n\nfunc (q *MyCircularQueue) EnQueue(value int) bool {\n    if q.isFull() {\n        return false \n    }\n    q.queue[q.rear] = value\n    q.rear = (q.rear + 1) % q.length\n    q.used++\n    return true\n}\n\nfunc (q *MyCircularQueue) DeQueue() bool {\n    if q.isEmpty() {\n        return false\n    }\n    q.front = (q.front + 1) % q.length\n    q.used--\n    return true\n}\n\nfunc (q *MyCircularQueue) Front() int {\n    if q.used == 0 {\n        return -1\n    }\n    return q.queue[q.front]\n}\n\nfunc (q *MyCircularQueue) Rear() int {\n    if q.used == 0 {\n        return -1\n    }\n    return q.queue[(q.rear-1+q.length)%q.length]\n}\n\nfunc (q *MyCircularQueue) isEmpty() bool {\n    return q.used == 0\n}\n\nfunc (q *MyCircularQueue) isFull() bool {\n    return q.used == q.length\n}\n```\n备注：\n在 `DeQueue()` 方法中，删除队首元素时并不会真的删除该元素，而是通过移动 `front` 指针来达到删除的效果。\n\n循环队列是一个环状的数据结构，可以想象成沿着环形路径移动指针。在实现循环队列时，每当删除队首元素时，我们需要将 `front` 指针向前移一位，指向队列中的下一个元素，这样队列中原来的第二个元素就成为了新的头部元素。这里使用 \"指向队列中的下一个元素\" 实际上是模运算的作用，如 `(i+1) % n` 将会得到指向 `i` 在循环数组中下一个元素的索引值。\n\n而在这个移动指针的过程中，由于队列的前面已经没有元素，所以我们不需要将队首元素真正地删除。相反，仅需要更新 `front` 指针，让它指向目前第一个元素，后面再添加新的元素，也会覆盖掉先前的元素，实现对队列的循环利用。\n\n### 表示方法2\n```golang\ntype MyCircularQueue struct {\n    // 使用 k + 1 ，也就是多余一个空格的循环队列来设计\n    queue []int\n    front int\n    rear int\n    capacity int\n}\n\n\nfunc Constructor(k int) MyCircularQueue {\n    return MyCircularQueue{\n        queue: make([]int,k+1),\n        front: 0,\n        rear: 0,\n        capacity: k+1,\n    }\n}\n\n\nfunc (this *MyCircularQueue) EnQueue(value int) bool {\n    if this.IsFull(){\n        return false\n    }\n    this.queue[this.rear] = value\n    this.rear = (this.rear + 1)%this.capacity\n    return true\n}\n\n\nfunc (this *MyCircularQueue) DeQueue() bool {\n    if this.IsEmpty(){\n        return false\n    }\n    this.front = (this.front+1)%this.capacity\n    return true\n}\n\n\nfunc (this *MyCircularQueue) Front() int {\n    if this.IsEmpty() {\n        return -1\n    }\n    return this.queue[this.front]\n}\n\n\nfunc (this *MyCircularQueue) Rear() int {\n    if this.IsEmpty(){\n        return -1\n    }\n    rearPosition := (this.rear-1+this.capacity)%this.capacity\n    return this.queue[rearPosition]\n}\n\n\nfunc (this *MyCircularQueue) IsEmpty() bool {\n    return this.rear ==this.front\n}\n\n\nfunc (this *MyCircularQueue) IsFull() bool {\n    return (this.rear+1)%this.capacity == this.front\n}\n\n/**\n * Your MyCircularQueue object will be instantiated and called as such:\n * obj := Constructor(k);\n * param_1 := obj.EnQueue(value);\n * param_2 := obj.DeQueue();\n * param_3 := obj.Front();\n * param_4 := obj.Rear();\n * param_5 := obj.IsEmpty();\n * param_6 := obj.IsFull();\n */\n```\n\n### 循环双向队列\n\n#### 解题思路\n\n\n**==犯错的地方：==**\n<font color='red'> InsertFront的时候，需要先移动front向前一位，然后再把值插进去</font>\n最开始想的，直接让front和rear都指向一个空白的空间，那么就需要在插入的时候先将front向前移动两位，但这样的话就会浪费一个数值的空间，因为多余一个位就完全可以满足要求\n\n使用k+1的情况，如果是在LRU缓存或者是Ringbuffer当中还需要考虑，将队尾[或者是队中]的元素插入到队首，也就是将最近使用的元素放到前面\n\n#### 代码\n\n```golang\ntype MyCircularDeque struct {\n    queue []int\n    front int\n    rear int \n    capacity int\n}\n\n\nfunc Constructor(k int) MyCircularDeque {\n    return MyCircularDeque{\n        queue: make([]int,k+1),\n        front: 0,\n        rear: 0,\n        capacity: k+1,\n    }\n}\n\n\nfunc (this *MyCircularDeque) InsertFront(value int) bool {\n    if this.IsFull(){\n        return false\n    }\n    this.front = (this.front-1 + this.capacity)%this.capacity\n    this.queue[this.front] = value\n    return true\n}\n\n\nfunc (this *MyCircularDeque) InsertLast(value int) bool {\n    if this.IsFull(){\n        return false\n    }\n    this.queue[this.rear] = value\n    this.rear = (this.rear+1)%this.capacity\n    return true\n}\n\n\nfunc (this *MyCircularDeque) DeleteFront() bool {\n    if this.IsEmpty(){\n        return false\n    }\n    this.front = (this.front+1)%this.capacity\n    return true\n}\n\n\nfunc (this *MyCircularDeque) DeleteLast() bool {\n    if this.IsEmpty(){\n        return false\n    }\n    this.rear = (this.rear-1+this.capacity)%this.capacity\n    return true\n}\n\n\nfunc (this *MyCircularDeque) GetFront() int {\n    if this.IsEmpty(){\n        return -1\n    }\n    return this.queue[this.front]\n}\n\n\nfunc (this *MyCircularDeque) GetRear() int {\n    if this.IsEmpty(){\n        return -1\n    }\n    return this.queue[(this.rear-1+this.capacity)%this.capacity]\n}\n\n\nfunc (this *MyCircularDeque) IsEmpty() bool {\n    return this.front == this.rear\n}\n\n\nfunc (this *MyCircularDeque) IsFull() bool {\n    return this.front == (this.rear+1)%this.capacity\n}\n\n\n/**\n * Your MyCircularDeque object will be instantiated and called as such:\n * obj := Constructor(k);\n * param_1 := obj.InsertFront(value);\n * param_2 := obj.InsertLast(value);\n * param_3 := obj.DeleteFront();\n * param_4 := obj.DeleteLast();\n * param_5 := obj.GetFront();\n * param_6 := obj.GetRear();\n * param_7 := obj.IsEmpty();\n * param_8 := obj.IsFull();\n */\n```\n\n相似点：\n* 都使用了取模的方式\n\n## 单调队列\n单调队列属于双端队列的一种\n\n要求队列中的元素必须满足单调性\n\n单调队列如对时候的要求：入队前后，单调性完整\n\n**==单调递减队列最重要的特性==:<font color='red'>入队和出队的组合，可以在O(1)时间得到某个区间上的最大值</font>**\n\n### 情况讨论\n> 需要回答的问题：\n> * 这个区间是什么\n> * 怎样定量地描述这个区间\n> * 与队列中的元素个数有什么关系\n可以分以下两种情况来讨论：\n1. 只有入队的情况\n   在没有出队的情况下，对原数组的比较范围就会逐步增加\n   队首元素表示是已比较范围内的最大值\n2. 出队和入队混合的情况\n   控制覆盖范围为 k --> 滑动窗口\n    * 入队： 扩展单调队列的覆盖范围\n    * 出队： 控制单调队列的覆盖范围\n    * 队首元素是覆盖范围的最大值\n    * 队列中的元素个数小于覆盖范围的元素个数\n\n### 核心代码\n```golang\n//入队的代码\nfunc (q *queue)push(val int){\n    // 入队时候，要剔除掉尾部的元素，知道尾部元素大于或者是等于入队元素\n    while(!q.isEmpty() && q.getLast()<val){\n        q.removeLast()\n    }\n    // 将元素入队\n    q.addLast(val)\n}\n\n// 出队的时候，需要给出一个value\nfunc(q *queue) pop(val int){\n    if(!q.isEmpty() && q.getFirst()==val){\n        q.removeFirst()\n    }\n}\n```\n这样的代码编写关键：\n* 队首元素q.getFirst() 所获取的值是队列中的最大值\n* 出队时\n  * 如果一个元素已经被其他元素剔除出去了，那么他就不会再入队\n  * 如果一个元素是当前队列的最大值，会再出队\n\n### 滑动窗口的最大值\n\n\n### 捡金币游戏\n\n> 考点:\n> * 找到get数组，并知道get数组是当前元素和滑动窗口中最大值的和计算而来\n> * 利用单调队列在get[]数组上操作，找到滑动窗口的最大值\n\n拓展： 是否存在不同的出队方式\n\n> 整理一下代码模板：\n> <font color = 'red'>分层遍历</font>\n> <font color = 'red'>循环队列</font>\n> <font color = 'red'>单调队列</font>\n\n一些有意思的题目：\n* 利用栈实现一个队列\n* 利用队列实现一个栈\n\n\n# 优先级队列：堆与优先级队列，筛选最优元素\n\n## 堆\n FIFO队列： 节点之间的优先级是由遍历时的顺序决定的\n 优先级队列： 节点之间按照大小进行排序后，再决定优先级，底层依赖的数据结构一般是堆\n\n#### 堆的分类\n\n1. 大根堆\n   节点的值比他的孩子节点都大\n\n2. 小根堆\n   节点的值要比他的孩子节点都小\n   堆的特点--大堆的根是最大值，小堆的根是最小值\n\n\n#### 堆的实现\n> 以大堆为例子\n\n大多数时候都是使用数组来表示堆\n``` golang\ntype Heap struct {\n    data []int\n}\n\n// 创建新的大根堆\nfunc NewHeap() Heap {\n    return Heap{\n        data: make([]int, 0),\n    }\n}\n\n// 获取大根堆的长度\nfunc (h *Heap) Len() int {\n    return len(h.data)\n}\n\n// 获取指定位置元素的父节点位置\nfunc parent(i int) int {\n    return (i - 1) / 2\n}\n\n// 获取指定位置元素的左子节点位置\nfunc leftChild(i int) int {\n    return i*2 + 1\n}\n\n// 获取指定位置元素的右子节点位置\nfunc rightChild(i int) int {\n    return i*2 + 2\n}\n\n// 下沉操作，将指定位置的元素向下移动，直到它大于所有子节点为止\nfunc (h *Heap) sink(i int) {\n    for {\n        left, right := leftChild(i), rightChild(i)\n        maxPos := i\n        if left < h.Len() && h.data[left] > h.data[maxPos] {\n            maxPos = left\n        }\n        if right < h.Len() && h.data[right] > h.data[maxPos] {\n            maxPos = right\n        }\n        if maxPos == i {\n            break\n        }\n        h.data[i], h.data[maxPos] = h.data[maxPos], h.data[i]\n        i = maxPos\n    }\n}\n\n// 上浮操作，将指定位置的元素向上移动，直到它小于其父节点为止\nfunc (h *Heap) swim(i int) {\n    for i > 0 {\n        p := parent(i)\n        if h.data[p] >= h.data[i] {\n            break\n        }\n        h.data[p], h.data[i] = h.data[i], h.data[p]\n        i = p\n    }\n}\n\n// 出堆，弹出大根堆的堆顶元素，并重新调整堆结构\nfunc (h *Heap) pop() int {\n    res := h.data[0]\n    h.data[0] = h.data[len(h.data)-1]\n    h.data = h.data[:len(h.data)-1]\n    h.sink(0)\n    return res\n}\n\n// 入堆，将新元素插入到大根堆中，并重新调整堆结构\nfunc (h *Heap) push(val int) {\n    h.data = append(h.data, val)\n    h.swim(len(h.data) - 1)\n}\n\n```\n\n#### 最小的k个数\n> N 的数量级非常大，或者其希望能够获得一个较小的区间内的数字\n> 同时输出的操作是每时每刻的话，一直是用排序的代价就会很高\n在上述大根堆的基础上来完成的话，就是以下代码：\n\n```golang\nfunc getLeastNumbers(arr []int, k int) []int {\n    // 建立大根堆\n    minH := Heap{}\n    for i:=0; i < len(arr); i++{\n        minH.push(arr[i])\n        if len(minH.data) > k {\n            minH.pop()\n        }\n    }\n    return minH.data\n}\n```\n\n## 优先级队列               \n\n#### google 面试题目：有一台机器会每隔一秒输出一个信号，请在每次输出信号的时候输出所有信号的中间值，如果信号数量位偶数则返回中间两数的平均值\n题目连接：\n> leetcode 这道题目还能够用排序是因为算的是所有一共的，如果是实时输出就每次都需要排序，所以直接维护一个结构更适合\n\n\n# 链表： 如何利用\"假头，新链表，双指针\"解决链表类型题目\n> 解决链表问题的三板斧：\n> 假头\n> 新链表\n> 双指针\n> 链表尤其需要考虑各种边界条件、链表结构简单，但是查找交换反转非常容易出错\n>\n\n### 三板斧\n\n#### 假头\n在链表前面增加额外的节点--> 可以节省许多对于nil指针的操作，能够节省不少的精力\n\ndummy 指针初始化之后就不会再发生改变了\ntail  指针随着元素改变移动\n\n1. tail 插入节点\n2. 头部插入节点\n3. 查找结点（总是会查找目标节点的pre）\n4. 在指定位置插入节点--> getPre\n5. 删除节点\n```golang\ntype linkList interface{\n    initDummyList()\n    appendNode(*interface{})bool\n    getPre(int)*interface{}\n    findNode(int) *interface{}\n    insertNode(*interface{})bool\n    deletNode(int) bool\n}\n```\n\n\n# 树： 如何深度运用树的遍历\n> 大部分语言的map数据结构，基本上是基于树来实现的\nb+树，红黑树，二叉树等等，在leetcode和考题当中常见二叉树，同时对于其他的树结构，可以通过二叉树的遍历来扩展出对应的遍历方式。\n\n\n## **1** &ensp; 树节点的结构：\n\n```golang\ntype TreeNode struct{\n    val int\n    left *TreeNode\n    right *TreeNode\n}\n```\n## **2** &ensp; 前序遍历\n> <font color='red'>遍历根节点、左子树、右子树</font>\n\n### **2.1** &ensp; 使用递归完成前序遍历\n采用整体的思想：\n首先遍历根节点，然后遍历左子树的时候，就把左子树放到相应的位置，遍历右子树的时候，就把右子树放到相应的位置。\n然后展开左子树\n然后展开右子树\n\n> 时间复杂度：O(N)\n> 空间复杂度：O(K) K表示的树的高度\n<font color=CC6699>一定注意要问清楚:在访问每个节点的时候，是需要Print出来，还是放到一个链表/数组当中存储</font>\n\n``` Golang\n//使用递归方式\nfunc traverse(root *TreeNode){\n    if root == nil {\n        return \n    }\n    traverse(root.Left)\n    traverse(root.Right)\n}\n```\n\n### **2.2** &ensp; 使用栈完成前序遍历\n``` golang\npackage main\n\nimport \"fmt\"\n\ntype TreeNode struct {\n    Val   int\n    Left  *TreeNode\n    Right *TreeNode\n}\n\n// 前序遍历\nfunc preorderTraversal(root *TreeNode) []int {\n    if root == nil {\n        return []int{}\n    }\n\n    var res []int\n    var stack []*TreeNode\n    stack = append(stack, root)\n\n    for len(stack) > 0 {\n        node := stack[len(stack)-1]\n        stack = stack[:len(stack)-1]\n        res = append(res, node.Val)\n        if node.Right != nil {\n            stack = append(stack, node.Right)\n        }\n        if node.Left != nil {\n            stack = append(stack, node.Left)\n        }\n    }\n\n    return res\n}\n\n```\n\n### **2.2-1** &ensp; Morris 遍历: 只需要O(1)的空间\n\n\n### **2.3** &ensp; 题目\n下述为前序遍历常见题目\n\n#### **2.3.1** 验证二叉树\n验证一颗二叉树是否满足二叉搜索树的性质\n\n```golang\ntype basic struct{\n    node *TreeNode\n    leftboard int\n    rightboard int\n} \n\nfunc stackBst(root *TreeNode) bool{\n    // 构造边界影子树栈\n    stack := make([]basic,0)\n    left, right := math.MinInt64,math.MaxInt64\n    for root != nil || len(stack) > 0{\n        // 当还没有遍历完左子树\n        for root != nil{\n            // 判断不满足搜索树的节点要求\n            if root.Val <= left || root.Val >= right {\n                return false\n            }\n            // 满足范围要求，那就要往下继续找\n            // 先记录当前影子树的边界\n            stack = append(stack, basic{\n                node: root,\n                leftboard: left,\n                rightboard: right,\n            })\n            // 往下移动，同时缩小右边界\n            right = root.Val\n            root = root.Left\n        }\n        // 左子树遍历完了，找右子树\n        top := stack[len(stack)-1]\n        stack = stack[:len(stack)-1]\n\n        // 关键就是这里需要重新赋值比较的left和right\n        root = top.node\n        left,right = top.leftboard,top.rightboard\n        left = root.Val\n        root = root.Right       \n    }\n    return true\n}\n\nfunc isValidBST(root *TreeNode) bool {\n    return stackBst(root)\n}\n```\n或者是使用递归的方式\n```golang\nfunc isValidBST(root *TreeNode) bool {\n    ans := true\n    ans = preOderBST(root,math.MinInt64,math.MaxInt64)\n    return ans\n}\nfunc preOderBST(root *TreeNode, left int, right int)bool{\n\tif root == nil {\n\t\treturn true\n\t}\n\tif root.Val <= left || root.Val >= right {\n\t\treturn false\n\t}\n\treturn preOderBST(root.Left,left,root.Val) && preOderBST(root.Right,root.Val,right)\n}\n// // 特殊在于 golang 的特点： 传参如果要一直修改其中的值，就需要传入一个引用，或者是采用闭包的方式\n// func preOderBST(root *TreeNode, left int, right int, ans *bool){\n// \t// 递归是否达到条件，即到达叶节点，到达叶节点表示所有节点都满足情况，所以为true\n// \t// 第二个条件是 是否有判断出不满足的树，有的话ans就会变成false,直接返回\n// \tif root == nil || !(*ans) {\n// \t\treturn\n// \t}\n// \t// 判断条件就是 当前的值要小于right同时大于left才满足\n// \tif root.Val <= left || root.Val >= right {\n// \t\t*ans = false\n// \t\treturn\n// \t}\n// \t// 前序遍历\n// \tpreOderBST(root.Left, left, root.Val, ans)\n// \tpreOderBST(root.Right, root.Val, right, ans)\n// }\n```\n\n#### **2.3.2** 目标和的所有路径\nhttps://leetcode.cn/problems/path-sum/\n> 二叉树进行回溯的代码模板\n> * 遇到新的节点： 路径总是从尾部添加节点\n> * 遍历完节点，路径就把他从尾部扔掉\n```golang\n// func hasPathSum(root *TreeNode, targetSum int) bool {\n    \n//     var backTrace func(*TreeNode, int) bool\n//     backTrace = func(root *TreeNode, Sum int)bool{\n//         left , right := false,false \n\n//         if root == nil {\n//             return false\n//         }\n//         Sum += root.Val\n//         if root.Left == nil && root.Right == nil && Sum == targetSum {\n//             return true\n//         }\n//         if root.Left != nil{\n//             left = backTrace(root.Left,Sum)\n//         }\n//         if root.Right != nil{\n//             right = backTrace(root.Right,Sum)\n//         }\n//         return left || right\n//     }\n//     return backTrace(root,0)\n// }\n\n// // 使用广度优先的遍历--层序遍历--队列\n// func hasPathSum(root *TreeNode, targetSum int) bool {\n//     if root == nil{\n//         return false\n//     }\n//     fifo := make([]*TreeNode,0)\n//     Qsize := 1\n//     fifo = append(fifo,root)\n\n//     for len(fifo) > 0 {\n//         for Qsize > 0 {\n//             top := fifo[0]\n//             if top.Left == nil && top.Right == nil && top.Val == targetSum{\n//                 return true\n//             }\n//             if top.Left != nil{\n//                 top.Left.Val = top.Left.Val + top.Val\n//                 fifo = append(fifo,top.Left)\n//             }\n//             if top.Right != nil{\n//                 top.Right.Val = top.Right.Val + top.Val\n//                 fifo = append(fifo,top.Right)\n//             }\n//             fifo = fifo[1:]\n//             Qsize -= 1\n//         }\n//         Qsize = len(fifo)\n//     }\n//     return false\n// }\n\n// 使用栈来存储，栈中元素是当前树的路径\ntype path struct{\n    node *TreeNode\n    sum int\n}\n\nfunc hasPathSum(root *TreeNode, targetSum int) bool {\n    if root == nil {\n        return false\n    }\n    paths := make([]path,0)\n    paths = append(paths, path{\n        node: root,\n        sum: root.Val,\n    })\n    for len(paths) > 0 {\n        node := paths[len(paths)-1]\n        paths = paths[:len(paths)-1]\n        if node.node.Left == nil && node.node.Right == nil && node.sum == targetSum {\n            return true\n        }\n        if node.node.Right != nil {\n            right := node.node.Right\n            paths = append(paths,path{\n                node: right,\n                sum: right.Val + node.sum,\n            })\n        }\n        if node.node.Left != nil {\n            left := node.node.Left\n            paths = append(paths,path{\n                node: left,\n                sum: left.Val + node.sum,\n            })\n        }\n    } \n    return false\n}\n```\n\n#### **2.3.3** 得到路径和为指定数字的路径集合\nhttps://leetcode.cn/problems/path-sum-ii/solution/\n<font color='red'> 这道题目非常重要：有两大问题都在这个地方表现出来了</font>\n\n==Golang的特性：Defer函数的使用==\n这道题目在使用前序遍历的时候，由于在叶子节点以及从左子树转换为右子树的时候都需要将原本记录在path当中的路径节点删除pop出来，递归时候就需要考虑在什么时候执行出栈操作，没错即便是在递归当中也还是必须要考虑栈的操作，因为需要一个连续记录的路径信息\n\n关键在于pop的时机：pop的时机是：1. 本身是叶子节点，直接return 结束dfs，2. 左右的子树都被递归判断过的树中结点，也就是dfs(Left),dfs(Right)正常结束，刚好发现二者均都是在dfs执行完之后执行，而且覆盖了dfs执行完之后所有的情况\n同时 Golang 的 **Defer(){}** 会在函数执行完并在返回之前执行，完全满足这个场景的需求，所以可以在递归函数体当中使用defer来完成对应的操作\n\n==Golang的特性：切片索引==\n切片本身就是指针，且每次操作都会影响到底层数组\n如果不在递归函数体当中使用切片之前重新对切片进行赋值，那么，之后对于底层数组的操作也会反映到之前的切片上，产生的效果就是明明原本计算好了结果但最后得到的并不是正确答案，关键就在于==后面切片的操作修改了底层数组，导致原本切片对应的结果被修改了==\n\n```golang\nfunc pathSum(root *TreeNode, targetSum int) [][]int {\n    result := make([][]int,0)\n    path := make([]int,0)\n    if root == nil {\n        return result\n    }\n    var dfs func(*TreeNode,int)\n    dfs = func(root *TreeNode,left int){\n        if root == nil{\n            return \n        }\n        path = append(path,root.Val)\n        left = left - root.Val\n        defer func() { \n            path = path[:len(path)-1]\n        }()\n        if root.Left == nil && root.Right == nil && left == 0{\n            // new := make([]int,len(path))\n            // copy(new,path)\n            // result = append(result,new)\n            result = append(result,append([]int(nil),path...))\n            return \n        }\n        dfs(root.Left,left)\n        dfs(root.Right,left)\n    }\n    dfs(root,targetSum)\n    return result\n}\n```\n\n#### **2.3.3** \n> 等待回溯来看\n> https://leetcode.cn/problems/path-sum-iii/solution/437-lu-jing-zong-he-iii-dfshui-su-qian-zhui-he-yi-/\n\n\n## **3** 中序遍历\n<font color='red'>遍历左子树，然后是根节点，然后是右子树</font>\n\n### **3.1** &ensp; 使用递归完成中序遍历\n``` golang\n\n```\n\n### **3.2** &ensp; 使用栈完成中序遍历\n```golang\nfunc inorderTraversal(root *TreeNode) []int {\n    if root == nil {\n        return []int{}\n    }\n\n    var res []int\n    var stack []*TreeNode\n    var pathStack []string\n    node := root\n\n    for node != nil || len(stack) > 0 {\n        if node != nil {\n            stack = append(stack, node)\n            pathStack = append(pathStack, fmt.Sprintf(\"%d\", node.Val))\n            node = node.Left\n        } else {\n            node = stack[len(stack)-1]\n            stack = stack[:len(stack)-1]\n            path := pathStack[len(pathStack)-1]\n            pathStack = pathStack[:len(pathStack)-1]\n\n            if node.Left == nil && node.Right == nil {\n                res = append(res, node.Val)\n\n                // 输出到达叶子节点的路径\n                fmt.Println(path)\n            }\n\n            node = node.Right\n        }\n    }\n\n    return res\n}\n```\n\n### **3.3** 找出二叉搜索树里面出现次数最多的数\n找众数就需要遍历所有的节点，二叉搜索树中序遍历的结果会是一个递增的数组，其数据特性就在于使用中序遍历的时候，所有的元素都是连续的\n``` golang\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc findMode(root *TreeNode) []int {\n    // 结果数组\n    ans := make([]int,0)\n    base,count,maxnum := math.MinInt64,0,0\n\n    // 使用递归的方式\n    var dfs func(*TreeNode)\n    dfs = func(root *TreeNode){\n        if root == nil {\n            return \n        }\n        dfs(root.Left)\n        if root.Val == base {\n            count++\n        }else{\n            base = root.Val\n            count = 1\n        }\n        if count == maxnum {\n            ans = append(ans,base)\n        }\n        if count > maxnum {\n            ans = []int{}\n            maxnum = count\n            ans = append(ans,base)\n        }\n        dfs(root.Right)\n    }\n    dfs(root)\n    return ans\n}\n```\n\n### **3.4** 找出二叉搜索树里面任意两个节点之间绝对值得最小值\n\nhttps://leetcode.cn/problems/minimum-distance-between-bst-nodes/\n\n```golang\nfunc minDiffInBST(root *TreeNode) int {\n    // 使用栈来中序遍历，栈顶元素就是上一遍历的节点元素\n    stack := make([]*TreeNode,0)\n    res := make([]int,0)\n    for root != nil || len(stack) > 0{\n        for root != nil {\n            stack = append(stack,root)\n            root = root.Left\n        }\n\n        node := stack[len(stack)-1]\n        stack = stack[:len(stack)-1]\n        res = append(res,node.Val)\n\n        root = node\n        root = root.Right\n    }\n    m := math.MaxInt64\n    for i:= 0; i < len(res)-1; i++{\n        r := res[i+1]-res[i]\n        m = min(m,r) \n    } \n    return m\n}\n\nfunc min(args ...int)int{\n    min := args[0]\n    for _, val := range args{\n        if val < min {\n            min = val\n        }\n    }\n    return min\n}\n```\n\n### **3.5** 一棵二叉搜索树的两个节点被交换了，恢复这颗二叉搜索树\n\n```golang\nfunc recoverTree(root *TreeNode)  {\n    // 使用递归解决这个问题\n    problem := make([]*TreeNode,0)\n    var findP func(*TreeNode)\n    findP = func(root *TreeNode){\n        if root == nil{\n            return \n        }\n        findP(root.Left)\n        // if pre == math.MaxInt64{\n        //     pre = root.Val\n        //     return\n        // }\n        // if root.Val - pre < 0{\n        //     problem = append(problem,root)\n        // }\n        // pre = root.Val\n        problem = append(problem, root)\n        findP(root.Right)\n    }\n    findP(root)\n    pre,cur := -1,-1\n    for i := 0; i < len(problem)-1; i++{\n        if problem[i].Val > problem[i+1].Val {\n            cur = i + 1\n            if pre == -1 {\n                pre = i\n            }\n        }\n    }\n    problem[pre].Val,problem[cur].Val = problem[cur].Val,problem[pre].Val\n    return \n}\n```\n\n### 删除二叉搜索树的节点\n> 题目最重要的考点就是分类，讨论各种情况下的处理方式\n\n<font sizecolor ='red'>清晰地讲出每种情况的处理办法</font>\n<font sizecolor ='red'>清晰简介地实现代码</font>\n\n\n\n\n## 后序遍历\n\n### 使用栈完成后序遍历\n\n### 迭代写法的考点\n1. 是否有右子树\n2. pre指针是不是指向当前结点的右子树","source":"_posts/Algorithm/Alg_Basic/Golang-数据结构/Golang-算法课程--数据结构.md","raw":"---\ntitle: Golang 算法课程--数据结构\ncatalog: true\ndate: 2023-04-02 00:46:21\nsubtitle:\nheader-img:\ntags: working, 算法\ncategories: 算法，Golang\n---\n\n# 告别盲目刷题，击破算法面试\n> 学习拉钩教育算法课程记录加个人感悟记录\n> 如果有版权问题，请联系 2374087322@qq.com 删除课程部分的内容\n> \n> 算法能力的高度，决定了个人能够解决的实战问题复杂度的上限\n>\n> 数学基础决定了算法能力的高低\n\n## ==解题流程==：\n\n### ==四部分析法==\n\n* **==模拟==** ： 模拟题目的运行\n  使用简单且有一定量的小例子，将自己当作计算机来执行这个流程\n  *一般使用题目给的较长的那个例子就可以*\n  \n  这部分也是读题和理解输入输出内容的部分，理解题意的部分\n  \n  这个时候一定不能够着急，不要害怕或者是觉得麻烦，一定要耐下性子，把简单的一个逻辑过程给跑清楚，理解这段程序或者是业务需要咱们处理什么样的问题。\n  \n  跑的过程，不要完全先入为主，应当以题目的要求来推进演示。\n  \n  不要想着在这一步就把所有的问题都给解决，一步步推进就可以. \n  \n* **==规律==** ： 尝试总结出题目的一般规律和特点\n  \n  数学规律和特性一般来说很难直接从零归纳出来，但我们可以依赖所学习的高数、线性代数、离散数学、测度论等高等数学理论当中所见到的数学计算模型来匹配，这也是这部分最重要的基础\n\n  先总结一些考题可能会用到的观察特点：\n  * 形式相关：比如 括号匹配、从1加到100，\n  * 数量变化：数量变化与取模相关，数量变化呈现递推公式\n  * \n\n\n* **==匹配==** ： 找到符合这些特点的数据结构和算法\n  * 关注数据的输入类型：对输入数据进行分类，哪一些数据进行怎样的操作\n\n  * **==怎样匹配呢？==**：\n    * 题目模拟的时候（这部分一般使用栈、队列、二叉树）来理解题目要求的数字变化\n    * 观察结果集合，或者是原本中间的变化集合，当期符合某种数据结构的变化特征的时候，就可以选用这个数据结构\n\n\n* **==考虑边界条件==**： 考虑特殊情况\n  特殊情况：\n  * 字符串为空，字符串只有一个，两个、\n  * 数组为空，数字为0或者是其他不符合规律的特殊情况\n\n\n* **==深度思考==** ： 平时练习当中的流程，用于提高算法模型的积累\n  * 深度： 这种解法还可以怎么优化\n  * 广度： 这种解法的具有普适性吗？可以推广吗？问题的限定条件变多的话，这个模型是否还可以适合。\n  * 数学模式扩散： 这样特点的问题是否有对应的数学模型或者是理论描述过\n\n\n\n# 栈： 从简单栈到单调栈，让栈问题不再困难\n\n## 结构特征\n\n先进后出\n\n对栈的操作：\n* **==pop==** 弹出栈顶元素，一般来说栈中可操作的元素就是栈顶元素，其他元素也都是先pop出其上面的元素，变成栈顶元素之后再进行操作。\n*  **==peek==** 获取栈顶元素，只是读取操作，但并没有弹出栈顶元素\n*  **==push==** 将元素压入栈中\n\n### Golang 栈的使用\n\n在 Go 中并没有直接提供Stack的方法结构，但可以使用切片非常简单地表示和使用栈、队列结构。\n\n 先进后出的数据结构，使用**==切片==**表示，压入栈的操作就是往切片中添加元素，弹出栈的操作就是输出末尾元素，并将切片缩小为：`[:len(stack)-1]`\n\n以下为栈的代码模板实现：\n```golang\ntype Stack struct{\n    Stack []interface{}\n}\n\nfunc (s *Stack)push(x interface{}){\n    s = append(s,x)\n}\n\nfunc (s *Stack)pop(){\n    s = s[:len(s)-1]\n}\n\nfunc (s *Stack)peek()(x interface{}){\n    return s[len(s)-1]\n}\n```\n\n关键在于记住：\n* 栈顶元素 ---> 切片末尾元素\n* 切片是左闭右开，所以pop操作是 s = s[:len(s)-1], 但如果是队列pop出第一个元素就需要往后再移动一位 s = s[1:] 而不是 s = s[0:]\n\n## 典型题目\n\n### 判断字符串是否合法\n题目：https://leetcode.cn/problems/valid-parentheses/\n\n#### 正确解法和流程\nhttps://leetcode.cn/link/?target=https://www.bilibili.com/video/BV1AF411w78g\n```golang\nfunc isValid(s string) bool {\n    n := len(s)\n    if n % 2 == 1 {\n        return false\n    }\n    pairs := map[byte]byte{\n        ')': '(',\n        ']': '[',\n        '}': '{',\n    }\n    stack := []byte{}\n    for i := 0; i < n; i++ {\n        if pairs[s[i]] > 0 {\n            if len(stack) == 0 || stack[len(stack)-1] != pairs[s[i]] {\n                return false\n            }\n            stack = stack[:len(stack)-1]\n        } else {\n            stack = append(stack, s[i])\n        }\n    }\n    return len(stack) == 0\n}\n```\n\n#### 个人解法和流程\n\n> 问题集中体现在数据特性处理判断太过分散，属实是缝缝补补有一年\n> 对输入数据进行分类，哪一些数据进行怎样的操作\n> * 输入的是左括号应该入栈\n> * 输入的是右括号应该做判断\n<br />\n\n我的代码是：\n```golang\n    func isValid(s string) bool {\n    \n    l := len(s)\n    if l%2 != 0{\n        return false\n    }\n    stack := make([]rune, 0)\n\n    m := map[rune]rune{\n        ']':'[',\n        ')':'(',\n        '}':'{',\n    }\n    for _,v := range s{\n        if v == '[' ||v == '{' ||v == '('{\n            stack = append(stack,v)\n            continue\n        }\n        if len(stack) == 0{\n            return false\n        }\n        if stack[len(stack)-1] == m[v]{\n            stack = stack[:len(stack)-1]\n            continue\n        }\n\n        if m[v] != 0 {return false}\n    }\n\n    if len(stack) == 0{return true}\n\n    return false\n}\n```\n上述在判断栈顶元素的时候逻辑不够清晰，所以加了很多的if来补足条件，我们看例子当中所给的逻辑顺序：\n```golang\n        pairs := map[byte]byte{\n        ')': '(',\n        ']': '[',\n        '}': '{',\n    }\n    stack := []byte{}\n    for i := 0; i < n; i++ {\n        if pairs[s[i]] > 0 {\n            if len(stack) == 0 || stack[len(stack)-1] != pairs[s[i]] {\n                return false\n            }\n            stack = stack[:len(stack)-1]\n        } else {\n            stack = append(stack, s[i])\n        }\n    }\n    return len(stack) == 0\n```\n\n关键差距就在于这一句话：`pairs[s[i]] > 0 `, 这个判断对输入的数据做了一次分类，依据上面的map结构可知，这句话 < 0 时候标识map当中没有存储对应的对象，而map中存储的是所有的左括号，所以这个判断的作用是**当输入是右括号的时候进入函数**，然后逻辑体依据输入是右括号判断，如果当前栈里面没有元素或者是栈顶元素与右括号不匹配那么就返回false\n\\\n实际上我写的函数最后夜市做了类似的判断，但显然没有考虑数据分类的情况。\n\n\n### 判断大鱼吃小鱼最后留下的鱼\n题目：\n\n近似题目：https://www.nowcoder.com/questionTerminal/3fdfc63015df42c6a78fdae46709fa69?f=discussion\n\n<br />\n\n#### 正确解法和流程\n``` c++\nclass Solution {\npublic:\n    /**\n     * \n     * @param N int整型 N条鱼\n     * @param A int整型vector 每条鱼的体积为Ai\n     * @return int整型\n     */\n    struct P{\n        int x, t;\n    };\n    int solve(int N, vector<int>& A) {\n        stack<P> S;\n        int cnt = 0;\n        for(int i=N-1;i>=0;i--){\n            int t = 0;\n            while(!S.empty() && A[i]>S.top().x){\n                t = max(S.top().t, t+1);\n                S.pop();\n            }\n            S.push({A[i], t});\n            cnt = max(cnt, t);\n        }\n        return cnt;\n    }\n};\n```\n\n\n#### 个人解法和流程\n由于找不到相同的题目，就找了类似的题目，但是解题的思路不太一样\n图片上的大鱼吃小鱼，只需要每次比较栈顶元素和新进来的元素大小即可，当大于的时候，就不做操作，当栈顶元素小于输入元素的时候，pop出栈顶元素并push进入这个最大值，最后栈中元素就是结果。这个过程当中几处需要重视的地方是：\n* 当鱼的方向一致时候，大鱼并不会把同方向的小鱼给吃了【可能不论大小鱼的速度相同（bushi）】，而如果小鱼在左，大鱼在右，方向不同，则也不会吃\n\n\n牛客网的题目则加了非常多的条件和限制，是对栈问题的一个较大的变化\n\n> 对比上述两个题目可以观察到：\n> <font color ='blue'> 1. 消除的行为不同</font>\n>   括号匹配中，消除行为是配对的两者都会消除，也就是栈顶元素和输入元素一起被消除\n>   大鱼吃小鱼中，消除行为是配对的两者中会有一个被消除\n> --> 是否入栈和出栈的判断\n> <font color ='blue'> 2. 栈中的内容不同</font>\n>   括号匹配当中，栈中存放的就是内容本身\n>   大鱼吃小鱼当中，栈里存放的是内容的索引，可以通过索引找到内容\n> <font color ='blue'> 3. 弹栈的方式也不相同</font>\n>   括号匹配只需要每次弹出一个元素就可以\n>   大鱼则需要用while语句一直弹出到满足某个条件才停止\n\n\n## 栈问题的特征和解决流程\n\n### pop 行为不同\npop【弹栈的操作不一样】\n常见的就是每次循环都判断栈顶元素的特点而pop或者push或者不操作，但这样必须得是连续性的元素才有这样的特征\n\n**==在弹栈的时候，是否一定要满足某个条件才停止弹栈==**\n也就是说当输入元素之后需要将其和站内其他的元素进行比较，在使用的时候尤其要注意迭代过程\n\n### 栈中存储内容不相同\n是否栈中存储数据、还是存储索引、还是存储一个自建的新的结构\n\n### 栈顶元素的含义不相同\n\n\n## 单调栈\n\n单调栈是指栈中元素必须按照升序排列的栈或者是降序排列的栈\n\n单调栈分为：\n* 递增栈：\n    栈中元素从左到右遵守从小到大的顺序\n    入栈时候，当**入栈元素小于栈顶元素**就会pop出栈顶元素，直到入栈元素大于栈顶元素\n    特点是：\n    入栈小数会消除栈内大数\n\n* 递减栈\n    栈中元素从左到右遵守从大到小的顺序\n    入栈时候，当**入栈元素大于栈顶元素**就会pop出栈顶元素，直到入栈元素小于栈顶元素\n    特点是：\n    入栈大数会消除栈内小数\n\n\n### 典型代码：\n```golang\nstack := make([]int,0)\n/**递增栈的入栈\n* 用for 循环出栈，直到栈顶元素满足递增栈的要求\n*/\nfor len(stack)> 0 && A[i] > stack[len(stack)-1]{\n    // pop出栈内比 A[i]小但却在前面的元素\n    stack = stack[:len(stack)-1]\n}\nstack = append(stack,A[i])\n\n```\n### 找到当前数字右边最小的对应数字\n### 取k个字符，求字典序最小的组合\n> 字典序：\n> * 对单个元素按照ascii 表中大小顺序排列\n> * 多个元素时，按照从左到右顺序，先从高位字典排序，然后在相同高位中按照地位再字典排序\n### 给定一个数组，数组中元素代表模板的高度，请你求出相邻木板能剪出的最大矩形面积\n> 和求最大容积是一个题目\n\n<br />\n\n## leetcode 题目汇总\n\n> 以leetcode 题目为例子\n\n相关栈的题目汇总：\n[1][https://leetcode.cn/problem-list/xb9nqhhg/?topicSlugs=stack&page=1]\n[2][https://leetcode.cn/problem-list/e8X3pBZi/?page=1&topicSlugs=heap-priority-queue]\n[3][https://leetcode.cn/problem-list/2cktkvj/?page=1&topicSlugs=stack]\n\n\n# 队列：FIFO 队列与单调队列的深挖与扩展\n\n先进先出，是共同特征\n\n类别上可以分出：\n* FIFO队列\n* 单调队列\n\n## FIFO队列\n\n**==Push 元素时候， 总是将放在元素放在队列尾部，也就是操作 fifo[len(fifo)-1]==**\n**==Pop 元素时候，总是将队列首部的元素扔掉 ，也就是操作 fifo = fifo[1:]==**\n\n###  二叉树的层次遍历（两种方法）\n\n* 规律： \n  广度遍历（层次遍历）：由于二叉树的特点，当拿到第N层的结点A之后，可以通过 A 的left，right指针拿到下一层的节点\n  **但是与A在同一层的节点还有其他吗，这个时候就需要按层来存储节点，不能直接使用递归**\n\n    <br />\n    顺序输出：每层输出时，排在左边的节点，它的子节点同样排在下一层的最左边\n\n--> **==题目具备广度遍历（分层遍历）的特点 和 顺序输出的特点 ，应该想到应用FIFO队列==**\n\n* 边界\n  特殊判断： 如果发现是一棵空二叉树，就直接返回空结果\n  ==制定一个规则==： 不要让空指针进入到FIFO队列（一些编程的亮点）\n\n<font color = 'red'> 非常重要的概念： QSize 表示当前层数 </font>\n\n#### 层次遍历二叉树\n题目链接：https://leetcode.cn/problems/binary-tree-level-order-traversal/submissions/\n\n##### 解题思路1\n关键思路在于将每一层的节点都存在FIFO队列里面，在每次遍历的时候从左到右pop出该层的节点，同时在队尾加入他的左右孩子\n\n队首pop出当层节点，队尾append下一层的孩子节点\nQSize 记录当层的节点数量\n\n时间复杂度是O(n), 空间复杂度由QSize决定O(K),K表示QSize最大，也就是存储的一层节点数量最多的时候\n\n##### 代码\n```golang\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc levelOrder(root *TreeNode) [][]int {\n    // 创建FIFO 队列来存储遍历的过程\n    fifo := make([]*TreeNode,0)\n    // QSize 表示当前遍历的层\n    QSize := 1\n    // 初始化最终结果\n    result := make([][]int,0)\n    if root == nil{\n        return result\n    }\n    //将根节点入栈\n    fifo = append(fifo,root)\n    // 开始层序遍历，只要当前队列不为空\n    for len(fifo) > 0 {\n        // 创建结果数组用于存储当层pop出的元素值\n        tmp := make([]int, 0)\n        // 当层元素QSize全部遍历以此，这里不能用len(fifo)，因为fifo的长度是在变化的\n        for i := QSize;i > 0;i--{\n            // 拿出队列头元素\n            node := fifo[0]\n            // 判断他的左孩子是否为空\n            if node.Left!= nil{\n                fifo = append(fifo,node.Left)\n            }\n            // 判断他的右孩子是否为空\n            if node.Right != nil{\n                fifo = append(fifo,node.Right)\n            }\n            // 将该节点的值存入结果\n            tmp = append(tmp,node.Val)\n            // 推出队首元素\n            fifo = fifo[1:]\n        }\n        // 将结果 tmp 存入到结果数组当中\n        result = append(result,tmp)\n        // 重新计算当前层的节点数量\n        QSize = len(fifo)\n    }\n    return result\n}\n```\n##### 官方题解\n```golang\nfunc levelOrder(root *TreeNode) [][]int {\n    ret := [][]int{}\n    if root == nil {\n        return ret\n    }\n    q := []*TreeNode{root}\n    for i := 0; len(q) > 0; i++ {\n        ret = append(ret, []int{})\n        p := []*TreeNode{}\n        for j := 0; j < len(q); j++ {\n            node := q[j]\n            ret[i] = append(ret[i], node.Val)\n            if node.Left != nil {\n                p = append(p, node.Left)\n            }\n            if node.Right != nil {\n                p = append(p, node.Right)\n            }\n        }\n        q = p\n    }\n    return ret\n}\n\n```\n\n##### 解题思路2\n\n使用链表来解决问题\n\n#### 锯齿状层次遍历\n题目链接：https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/\n\n##### 解题思路\n层次遍历的基础上加一个qs，表示当前层是从左到右还是从右到左\n\n**==本题当中所犯的错误：==**：\n* 每一轮都需要重新计算qsize,一定不要忘了这一点\n* tmp 接收的时候还是按照栈的pop逻辑，所以顺序上还需要再反一次\n* 题目样例当中root是按照从左到右遍历过一次来计算的\n\n##### 代码\n\n```golang\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc zigzagLevelOrder(root *TreeNode) [][]int {\n    //结果数组\n    result := make([][]int,0)\n    //全局的fifo队列\n    fifo := make([]*TreeNode,0)\n    // Qsize 表示当前层的节点数，qs 表示该层的遍历顺序，0表示从左到右，1表示从右到左\n    Qsize ,qs := 1 , 1\n    // 如果树中没有节点则直接返回\n    if root == nil{\n        return result\n    }\n    // 将 root 放入队列\n    fifo = append(fifo,root)\n    //遍历整棵树\n    for len(fifo) > 0 {\n        tmp := make([]int,0)\n        for i:= 1; Qsize >= i && qs == 0 ;i++{\n            node := fifo[Qsize-i]\n            if node.Right != nil {\n                fifo = append(fifo,node.Right)\n            }\n            if node.Left != nil{\n                fifo = append(fifo,node.Left)\n            }\n            tmp = append(tmp,node.Val)                \n        }\n        for i:= 1; Qsize >= i && qs == 1 ;i++{\n            node := fifo[Qsize-i]\n            if node.Left != nil{\n                fifo = append(fifo,node.Left)\n            }\n            if node.Right != nil{\n                fifo = append(fifo,node.Right)\n            }\n            tmp = append(tmp,node.Val)                \n        }\n        fifo = fifo[Qsize:]\n        Qsize = len(fifo)\n        result = append(result,tmp)\n        if qs == 1{\n            qs = 0\n        }else{\n            qs = 1\n        }\n    }\n    return result\n}\n```\n\n\n\n#### 倒序层次遍历\n题目链接：https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/\n\n##### 解题思路\n从题目要求当中可以读出，是在之前的层序遍历基础上把结果倒过来输出，那么会比较自然想到可以在使用一个栈用来存储中间结果\n\n##### 代码\n\n```golang\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc levelOrderBottom(root *TreeNode) [][]int {\n    // 构造全局fifo队列\n    fifo := make([]*TreeNode,0)\n    // 构造结果栈\n    stack := make([][]int,0)\n    result := make([][]int,0)\n    //表示当前层的节点数量\n    Qsize := 1\n    fifo = append(fifo,root)\n    if root == nil{\n        return result\n    }\n    for len(fifo) > 0{\n        tmp := make([]int,0)\n        for Qsize > 0{\n            node:= fifo[0]\n            if node.Left != nil{\n                fifo =append(fifo,node.Left)\n            }\n            if node.Right != nil{\n                fifo = append(fifo,node.Right)\n            }\n            Qsize--\n            fifo = fifo[1:]\n            tmp = append(tmp,node.Val)\n        }\n        stack = append(stack,tmp)\n        Qsize = len(fifo)\n    }\n\n    // 将栈中元素pop 到结果当中\n    for len(stack) > 0{\n        result = append(result,stack[len(stack)-1])\n        stack = stack[:len(stack)-1]\n    }\n    return result\n}\n```\n\n## 循环队列\n\n设计一个可以容纳 k 个元素的循环队列，需要实现以下接口：\n\n```golang\ntype ringQueue interface{\n    //构造函数，参数k表示这个循环队列最多容纳k个元素\n    CircularQueue(int)\n    //将value放到队列中，成功返回true\n    EnQueue(int) bool\n    // 删除队首元素，成功返回true\n    DeQueue() bool\n    // 得到队首元素，如果队列为空，返回-1\n    Front() int\n    // 得到队尾元素，如果队列为空，返回-1\n    Rear() int\n    // 查看循环队列是否为空\n    isEmpty() bool\n    // 查看队列是否已经放满k个元素\n    isFull() bool\n}\n```\n\n* **==循环队列的重点在于==: <font color = 'red'>循环使用固定空间</font>**\n* **==难点在于==： <font color='red'>控制好 Front/Rear两个首位指示器</font>**\n\n### 表示方法1\n使用 `used`、`front`、`rear` 三个变量来控制，其中`used, front`都代表的是数组的下标\n\n注意以下几点：\n* index = i 的后一个是i+1，前一个是i+1\n* index = k-1 的后一个就是index=0\n* index = 0 的前一个是 index = k-1\n**==可以使用取模的方式统一处理==:**\n<font color='red'> index = i 的后一个元素下标是（i+1）% k</font>\n<font color='red'> index = i 的前一个元素下标是（i-1+k）% k</font>\n<font color='blue'>所有的循环数组下标的处理都需要按照这个取模的方式</font>\n\n参考的实例代码如下：\n```golang\ntype MyCircularQueue struct {\n    queue  []int\n    rear   int\n    front  int\n    used   int\n    length int\n}\n\nfunc CircularQueue(k int) ringQueue {\n    return &MyCircularQueue{\n        queue:  make([]int, k),\n        rear:   0,\n        front:  0,\n        used:   0,\n        length: k,\n    }\n}\n\nfunc (q *MyCircularQueue) EnQueue(value int) bool {\n    if q.isFull() {\n        return false \n    }\n    q.queue[q.rear] = value\n    q.rear = (q.rear + 1) % q.length\n    q.used++\n    return true\n}\n\nfunc (q *MyCircularQueue) DeQueue() bool {\n    if q.isEmpty() {\n        return false\n    }\n    q.front = (q.front + 1) % q.length\n    q.used--\n    return true\n}\n\nfunc (q *MyCircularQueue) Front() int {\n    if q.used == 0 {\n        return -1\n    }\n    return q.queue[q.front]\n}\n\nfunc (q *MyCircularQueue) Rear() int {\n    if q.used == 0 {\n        return -1\n    }\n    return q.queue[(q.rear-1+q.length)%q.length]\n}\n\nfunc (q *MyCircularQueue) isEmpty() bool {\n    return q.used == 0\n}\n\nfunc (q *MyCircularQueue) isFull() bool {\n    return q.used == q.length\n}\n```\n备注：\n在 `DeQueue()` 方法中，删除队首元素时并不会真的删除该元素，而是通过移动 `front` 指针来达到删除的效果。\n\n循环队列是一个环状的数据结构，可以想象成沿着环形路径移动指针。在实现循环队列时，每当删除队首元素时，我们需要将 `front` 指针向前移一位，指向队列中的下一个元素，这样队列中原来的第二个元素就成为了新的头部元素。这里使用 \"指向队列中的下一个元素\" 实际上是模运算的作用，如 `(i+1) % n` 将会得到指向 `i` 在循环数组中下一个元素的索引值。\n\n而在这个移动指针的过程中，由于队列的前面已经没有元素，所以我们不需要将队首元素真正地删除。相反，仅需要更新 `front` 指针，让它指向目前第一个元素，后面再添加新的元素，也会覆盖掉先前的元素，实现对队列的循环利用。\n\n### 表示方法2\n```golang\ntype MyCircularQueue struct {\n    // 使用 k + 1 ，也就是多余一个空格的循环队列来设计\n    queue []int\n    front int\n    rear int\n    capacity int\n}\n\n\nfunc Constructor(k int) MyCircularQueue {\n    return MyCircularQueue{\n        queue: make([]int,k+1),\n        front: 0,\n        rear: 0,\n        capacity: k+1,\n    }\n}\n\n\nfunc (this *MyCircularQueue) EnQueue(value int) bool {\n    if this.IsFull(){\n        return false\n    }\n    this.queue[this.rear] = value\n    this.rear = (this.rear + 1)%this.capacity\n    return true\n}\n\n\nfunc (this *MyCircularQueue) DeQueue() bool {\n    if this.IsEmpty(){\n        return false\n    }\n    this.front = (this.front+1)%this.capacity\n    return true\n}\n\n\nfunc (this *MyCircularQueue) Front() int {\n    if this.IsEmpty() {\n        return -1\n    }\n    return this.queue[this.front]\n}\n\n\nfunc (this *MyCircularQueue) Rear() int {\n    if this.IsEmpty(){\n        return -1\n    }\n    rearPosition := (this.rear-1+this.capacity)%this.capacity\n    return this.queue[rearPosition]\n}\n\n\nfunc (this *MyCircularQueue) IsEmpty() bool {\n    return this.rear ==this.front\n}\n\n\nfunc (this *MyCircularQueue) IsFull() bool {\n    return (this.rear+1)%this.capacity == this.front\n}\n\n/**\n * Your MyCircularQueue object will be instantiated and called as such:\n * obj := Constructor(k);\n * param_1 := obj.EnQueue(value);\n * param_2 := obj.DeQueue();\n * param_3 := obj.Front();\n * param_4 := obj.Rear();\n * param_5 := obj.IsEmpty();\n * param_6 := obj.IsFull();\n */\n```\n\n### 循环双向队列\n\n#### 解题思路\n\n\n**==犯错的地方：==**\n<font color='red'> InsertFront的时候，需要先移动front向前一位，然后再把值插进去</font>\n最开始想的，直接让front和rear都指向一个空白的空间，那么就需要在插入的时候先将front向前移动两位，但这样的话就会浪费一个数值的空间，因为多余一个位就完全可以满足要求\n\n使用k+1的情况，如果是在LRU缓存或者是Ringbuffer当中还需要考虑，将队尾[或者是队中]的元素插入到队首，也就是将最近使用的元素放到前面\n\n#### 代码\n\n```golang\ntype MyCircularDeque struct {\n    queue []int\n    front int\n    rear int \n    capacity int\n}\n\n\nfunc Constructor(k int) MyCircularDeque {\n    return MyCircularDeque{\n        queue: make([]int,k+1),\n        front: 0,\n        rear: 0,\n        capacity: k+1,\n    }\n}\n\n\nfunc (this *MyCircularDeque) InsertFront(value int) bool {\n    if this.IsFull(){\n        return false\n    }\n    this.front = (this.front-1 + this.capacity)%this.capacity\n    this.queue[this.front] = value\n    return true\n}\n\n\nfunc (this *MyCircularDeque) InsertLast(value int) bool {\n    if this.IsFull(){\n        return false\n    }\n    this.queue[this.rear] = value\n    this.rear = (this.rear+1)%this.capacity\n    return true\n}\n\n\nfunc (this *MyCircularDeque) DeleteFront() bool {\n    if this.IsEmpty(){\n        return false\n    }\n    this.front = (this.front+1)%this.capacity\n    return true\n}\n\n\nfunc (this *MyCircularDeque) DeleteLast() bool {\n    if this.IsEmpty(){\n        return false\n    }\n    this.rear = (this.rear-1+this.capacity)%this.capacity\n    return true\n}\n\n\nfunc (this *MyCircularDeque) GetFront() int {\n    if this.IsEmpty(){\n        return -1\n    }\n    return this.queue[this.front]\n}\n\n\nfunc (this *MyCircularDeque) GetRear() int {\n    if this.IsEmpty(){\n        return -1\n    }\n    return this.queue[(this.rear-1+this.capacity)%this.capacity]\n}\n\n\nfunc (this *MyCircularDeque) IsEmpty() bool {\n    return this.front == this.rear\n}\n\n\nfunc (this *MyCircularDeque) IsFull() bool {\n    return this.front == (this.rear+1)%this.capacity\n}\n\n\n/**\n * Your MyCircularDeque object will be instantiated and called as such:\n * obj := Constructor(k);\n * param_1 := obj.InsertFront(value);\n * param_2 := obj.InsertLast(value);\n * param_3 := obj.DeleteFront();\n * param_4 := obj.DeleteLast();\n * param_5 := obj.GetFront();\n * param_6 := obj.GetRear();\n * param_7 := obj.IsEmpty();\n * param_8 := obj.IsFull();\n */\n```\n\n相似点：\n* 都使用了取模的方式\n\n## 单调队列\n单调队列属于双端队列的一种\n\n要求队列中的元素必须满足单调性\n\n单调队列如对时候的要求：入队前后，单调性完整\n\n**==单调递减队列最重要的特性==:<font color='red'>入队和出队的组合，可以在O(1)时间得到某个区间上的最大值</font>**\n\n### 情况讨论\n> 需要回答的问题：\n> * 这个区间是什么\n> * 怎样定量地描述这个区间\n> * 与队列中的元素个数有什么关系\n可以分以下两种情况来讨论：\n1. 只有入队的情况\n   在没有出队的情况下，对原数组的比较范围就会逐步增加\n   队首元素表示是已比较范围内的最大值\n2. 出队和入队混合的情况\n   控制覆盖范围为 k --> 滑动窗口\n    * 入队： 扩展单调队列的覆盖范围\n    * 出队： 控制单调队列的覆盖范围\n    * 队首元素是覆盖范围的最大值\n    * 队列中的元素个数小于覆盖范围的元素个数\n\n### 核心代码\n```golang\n//入队的代码\nfunc (q *queue)push(val int){\n    // 入队时候，要剔除掉尾部的元素，知道尾部元素大于或者是等于入队元素\n    while(!q.isEmpty() && q.getLast()<val){\n        q.removeLast()\n    }\n    // 将元素入队\n    q.addLast(val)\n}\n\n// 出队的时候，需要给出一个value\nfunc(q *queue) pop(val int){\n    if(!q.isEmpty() && q.getFirst()==val){\n        q.removeFirst()\n    }\n}\n```\n这样的代码编写关键：\n* 队首元素q.getFirst() 所获取的值是队列中的最大值\n* 出队时\n  * 如果一个元素已经被其他元素剔除出去了，那么他就不会再入队\n  * 如果一个元素是当前队列的最大值，会再出队\n\n### 滑动窗口的最大值\n\n\n### 捡金币游戏\n\n> 考点:\n> * 找到get数组，并知道get数组是当前元素和滑动窗口中最大值的和计算而来\n> * 利用单调队列在get[]数组上操作，找到滑动窗口的最大值\n\n拓展： 是否存在不同的出队方式\n\n> 整理一下代码模板：\n> <font color = 'red'>分层遍历</font>\n> <font color = 'red'>循环队列</font>\n> <font color = 'red'>单调队列</font>\n\n一些有意思的题目：\n* 利用栈实现一个队列\n* 利用队列实现一个栈\n\n\n# 优先级队列：堆与优先级队列，筛选最优元素\n\n## 堆\n FIFO队列： 节点之间的优先级是由遍历时的顺序决定的\n 优先级队列： 节点之间按照大小进行排序后，再决定优先级，底层依赖的数据结构一般是堆\n\n#### 堆的分类\n\n1. 大根堆\n   节点的值比他的孩子节点都大\n\n2. 小根堆\n   节点的值要比他的孩子节点都小\n   堆的特点--大堆的根是最大值，小堆的根是最小值\n\n\n#### 堆的实现\n> 以大堆为例子\n\n大多数时候都是使用数组来表示堆\n``` golang\ntype Heap struct {\n    data []int\n}\n\n// 创建新的大根堆\nfunc NewHeap() Heap {\n    return Heap{\n        data: make([]int, 0),\n    }\n}\n\n// 获取大根堆的长度\nfunc (h *Heap) Len() int {\n    return len(h.data)\n}\n\n// 获取指定位置元素的父节点位置\nfunc parent(i int) int {\n    return (i - 1) / 2\n}\n\n// 获取指定位置元素的左子节点位置\nfunc leftChild(i int) int {\n    return i*2 + 1\n}\n\n// 获取指定位置元素的右子节点位置\nfunc rightChild(i int) int {\n    return i*2 + 2\n}\n\n// 下沉操作，将指定位置的元素向下移动，直到它大于所有子节点为止\nfunc (h *Heap) sink(i int) {\n    for {\n        left, right := leftChild(i), rightChild(i)\n        maxPos := i\n        if left < h.Len() && h.data[left] > h.data[maxPos] {\n            maxPos = left\n        }\n        if right < h.Len() && h.data[right] > h.data[maxPos] {\n            maxPos = right\n        }\n        if maxPos == i {\n            break\n        }\n        h.data[i], h.data[maxPos] = h.data[maxPos], h.data[i]\n        i = maxPos\n    }\n}\n\n// 上浮操作，将指定位置的元素向上移动，直到它小于其父节点为止\nfunc (h *Heap) swim(i int) {\n    for i > 0 {\n        p := parent(i)\n        if h.data[p] >= h.data[i] {\n            break\n        }\n        h.data[p], h.data[i] = h.data[i], h.data[p]\n        i = p\n    }\n}\n\n// 出堆，弹出大根堆的堆顶元素，并重新调整堆结构\nfunc (h *Heap) pop() int {\n    res := h.data[0]\n    h.data[0] = h.data[len(h.data)-1]\n    h.data = h.data[:len(h.data)-1]\n    h.sink(0)\n    return res\n}\n\n// 入堆，将新元素插入到大根堆中，并重新调整堆结构\nfunc (h *Heap) push(val int) {\n    h.data = append(h.data, val)\n    h.swim(len(h.data) - 1)\n}\n\n```\n\n#### 最小的k个数\n> N 的数量级非常大，或者其希望能够获得一个较小的区间内的数字\n> 同时输出的操作是每时每刻的话，一直是用排序的代价就会很高\n在上述大根堆的基础上来完成的话，就是以下代码：\n\n```golang\nfunc getLeastNumbers(arr []int, k int) []int {\n    // 建立大根堆\n    minH := Heap{}\n    for i:=0; i < len(arr); i++{\n        minH.push(arr[i])\n        if len(minH.data) > k {\n            minH.pop()\n        }\n    }\n    return minH.data\n}\n```\n\n## 优先级队列               \n\n#### google 面试题目：有一台机器会每隔一秒输出一个信号，请在每次输出信号的时候输出所有信号的中间值，如果信号数量位偶数则返回中间两数的平均值\n题目连接：\n> leetcode 这道题目还能够用排序是因为算的是所有一共的，如果是实时输出就每次都需要排序，所以直接维护一个结构更适合\n\n\n# 链表： 如何利用\"假头，新链表，双指针\"解决链表类型题目\n> 解决链表问题的三板斧：\n> 假头\n> 新链表\n> 双指针\n> 链表尤其需要考虑各种边界条件、链表结构简单，但是查找交换反转非常容易出错\n>\n\n### 三板斧\n\n#### 假头\n在链表前面增加额外的节点--> 可以节省许多对于nil指针的操作，能够节省不少的精力\n\ndummy 指针初始化之后就不会再发生改变了\ntail  指针随着元素改变移动\n\n1. tail 插入节点\n2. 头部插入节点\n3. 查找结点（总是会查找目标节点的pre）\n4. 在指定位置插入节点--> getPre\n5. 删除节点\n```golang\ntype linkList interface{\n    initDummyList()\n    appendNode(*interface{})bool\n    getPre(int)*interface{}\n    findNode(int) *interface{}\n    insertNode(*interface{})bool\n    deletNode(int) bool\n}\n```\n\n\n# 树： 如何深度运用树的遍历\n> 大部分语言的map数据结构，基本上是基于树来实现的\nb+树，红黑树，二叉树等等，在leetcode和考题当中常见二叉树，同时对于其他的树结构，可以通过二叉树的遍历来扩展出对应的遍历方式。\n\n\n## **1** &ensp; 树节点的结构：\n\n```golang\ntype TreeNode struct{\n    val int\n    left *TreeNode\n    right *TreeNode\n}\n```\n## **2** &ensp; 前序遍历\n> <font color='red'>遍历根节点、左子树、右子树</font>\n\n### **2.1** &ensp; 使用递归完成前序遍历\n采用整体的思想：\n首先遍历根节点，然后遍历左子树的时候，就把左子树放到相应的位置，遍历右子树的时候，就把右子树放到相应的位置。\n然后展开左子树\n然后展开右子树\n\n> 时间复杂度：O(N)\n> 空间复杂度：O(K) K表示的树的高度\n<font color=CC6699>一定注意要问清楚:在访问每个节点的时候，是需要Print出来，还是放到一个链表/数组当中存储</font>\n\n``` Golang\n//使用递归方式\nfunc traverse(root *TreeNode){\n    if root == nil {\n        return \n    }\n    traverse(root.Left)\n    traverse(root.Right)\n}\n```\n\n### **2.2** &ensp; 使用栈完成前序遍历\n``` golang\npackage main\n\nimport \"fmt\"\n\ntype TreeNode struct {\n    Val   int\n    Left  *TreeNode\n    Right *TreeNode\n}\n\n// 前序遍历\nfunc preorderTraversal(root *TreeNode) []int {\n    if root == nil {\n        return []int{}\n    }\n\n    var res []int\n    var stack []*TreeNode\n    stack = append(stack, root)\n\n    for len(stack) > 0 {\n        node := stack[len(stack)-1]\n        stack = stack[:len(stack)-1]\n        res = append(res, node.Val)\n        if node.Right != nil {\n            stack = append(stack, node.Right)\n        }\n        if node.Left != nil {\n            stack = append(stack, node.Left)\n        }\n    }\n\n    return res\n}\n\n```\n\n### **2.2-1** &ensp; Morris 遍历: 只需要O(1)的空间\n\n\n### **2.3** &ensp; 题目\n下述为前序遍历常见题目\n\n#### **2.3.1** 验证二叉树\n验证一颗二叉树是否满足二叉搜索树的性质\n\n```golang\ntype basic struct{\n    node *TreeNode\n    leftboard int\n    rightboard int\n} \n\nfunc stackBst(root *TreeNode) bool{\n    // 构造边界影子树栈\n    stack := make([]basic,0)\n    left, right := math.MinInt64,math.MaxInt64\n    for root != nil || len(stack) > 0{\n        // 当还没有遍历完左子树\n        for root != nil{\n            // 判断不满足搜索树的节点要求\n            if root.Val <= left || root.Val >= right {\n                return false\n            }\n            // 满足范围要求，那就要往下继续找\n            // 先记录当前影子树的边界\n            stack = append(stack, basic{\n                node: root,\n                leftboard: left,\n                rightboard: right,\n            })\n            // 往下移动，同时缩小右边界\n            right = root.Val\n            root = root.Left\n        }\n        // 左子树遍历完了，找右子树\n        top := stack[len(stack)-1]\n        stack = stack[:len(stack)-1]\n\n        // 关键就是这里需要重新赋值比较的left和right\n        root = top.node\n        left,right = top.leftboard,top.rightboard\n        left = root.Val\n        root = root.Right       \n    }\n    return true\n}\n\nfunc isValidBST(root *TreeNode) bool {\n    return stackBst(root)\n}\n```\n或者是使用递归的方式\n```golang\nfunc isValidBST(root *TreeNode) bool {\n    ans := true\n    ans = preOderBST(root,math.MinInt64,math.MaxInt64)\n    return ans\n}\nfunc preOderBST(root *TreeNode, left int, right int)bool{\n\tif root == nil {\n\t\treturn true\n\t}\n\tif root.Val <= left || root.Val >= right {\n\t\treturn false\n\t}\n\treturn preOderBST(root.Left,left,root.Val) && preOderBST(root.Right,root.Val,right)\n}\n// // 特殊在于 golang 的特点： 传参如果要一直修改其中的值，就需要传入一个引用，或者是采用闭包的方式\n// func preOderBST(root *TreeNode, left int, right int, ans *bool){\n// \t// 递归是否达到条件，即到达叶节点，到达叶节点表示所有节点都满足情况，所以为true\n// \t// 第二个条件是 是否有判断出不满足的树，有的话ans就会变成false,直接返回\n// \tif root == nil || !(*ans) {\n// \t\treturn\n// \t}\n// \t// 判断条件就是 当前的值要小于right同时大于left才满足\n// \tif root.Val <= left || root.Val >= right {\n// \t\t*ans = false\n// \t\treturn\n// \t}\n// \t// 前序遍历\n// \tpreOderBST(root.Left, left, root.Val, ans)\n// \tpreOderBST(root.Right, root.Val, right, ans)\n// }\n```\n\n#### **2.3.2** 目标和的所有路径\nhttps://leetcode.cn/problems/path-sum/\n> 二叉树进行回溯的代码模板\n> * 遇到新的节点： 路径总是从尾部添加节点\n> * 遍历完节点，路径就把他从尾部扔掉\n```golang\n// func hasPathSum(root *TreeNode, targetSum int) bool {\n    \n//     var backTrace func(*TreeNode, int) bool\n//     backTrace = func(root *TreeNode, Sum int)bool{\n//         left , right := false,false \n\n//         if root == nil {\n//             return false\n//         }\n//         Sum += root.Val\n//         if root.Left == nil && root.Right == nil && Sum == targetSum {\n//             return true\n//         }\n//         if root.Left != nil{\n//             left = backTrace(root.Left,Sum)\n//         }\n//         if root.Right != nil{\n//             right = backTrace(root.Right,Sum)\n//         }\n//         return left || right\n//     }\n//     return backTrace(root,0)\n// }\n\n// // 使用广度优先的遍历--层序遍历--队列\n// func hasPathSum(root *TreeNode, targetSum int) bool {\n//     if root == nil{\n//         return false\n//     }\n//     fifo := make([]*TreeNode,0)\n//     Qsize := 1\n//     fifo = append(fifo,root)\n\n//     for len(fifo) > 0 {\n//         for Qsize > 0 {\n//             top := fifo[0]\n//             if top.Left == nil && top.Right == nil && top.Val == targetSum{\n//                 return true\n//             }\n//             if top.Left != nil{\n//                 top.Left.Val = top.Left.Val + top.Val\n//                 fifo = append(fifo,top.Left)\n//             }\n//             if top.Right != nil{\n//                 top.Right.Val = top.Right.Val + top.Val\n//                 fifo = append(fifo,top.Right)\n//             }\n//             fifo = fifo[1:]\n//             Qsize -= 1\n//         }\n//         Qsize = len(fifo)\n//     }\n//     return false\n// }\n\n// 使用栈来存储，栈中元素是当前树的路径\ntype path struct{\n    node *TreeNode\n    sum int\n}\n\nfunc hasPathSum(root *TreeNode, targetSum int) bool {\n    if root == nil {\n        return false\n    }\n    paths := make([]path,0)\n    paths = append(paths, path{\n        node: root,\n        sum: root.Val,\n    })\n    for len(paths) > 0 {\n        node := paths[len(paths)-1]\n        paths = paths[:len(paths)-1]\n        if node.node.Left == nil && node.node.Right == nil && node.sum == targetSum {\n            return true\n        }\n        if node.node.Right != nil {\n            right := node.node.Right\n            paths = append(paths,path{\n                node: right,\n                sum: right.Val + node.sum,\n            })\n        }\n        if node.node.Left != nil {\n            left := node.node.Left\n            paths = append(paths,path{\n                node: left,\n                sum: left.Val + node.sum,\n            })\n        }\n    } \n    return false\n}\n```\n\n#### **2.3.3** 得到路径和为指定数字的路径集合\nhttps://leetcode.cn/problems/path-sum-ii/solution/\n<font color='red'> 这道题目非常重要：有两大问题都在这个地方表现出来了</font>\n\n==Golang的特性：Defer函数的使用==\n这道题目在使用前序遍历的时候，由于在叶子节点以及从左子树转换为右子树的时候都需要将原本记录在path当中的路径节点删除pop出来，递归时候就需要考虑在什么时候执行出栈操作，没错即便是在递归当中也还是必须要考虑栈的操作，因为需要一个连续记录的路径信息\n\n关键在于pop的时机：pop的时机是：1. 本身是叶子节点，直接return 结束dfs，2. 左右的子树都被递归判断过的树中结点，也就是dfs(Left),dfs(Right)正常结束，刚好发现二者均都是在dfs执行完之后执行，而且覆盖了dfs执行完之后所有的情况\n同时 Golang 的 **Defer(){}** 会在函数执行完并在返回之前执行，完全满足这个场景的需求，所以可以在递归函数体当中使用defer来完成对应的操作\n\n==Golang的特性：切片索引==\n切片本身就是指针，且每次操作都会影响到底层数组\n如果不在递归函数体当中使用切片之前重新对切片进行赋值，那么，之后对于底层数组的操作也会反映到之前的切片上，产生的效果就是明明原本计算好了结果但最后得到的并不是正确答案，关键就在于==后面切片的操作修改了底层数组，导致原本切片对应的结果被修改了==\n\n```golang\nfunc pathSum(root *TreeNode, targetSum int) [][]int {\n    result := make([][]int,0)\n    path := make([]int,0)\n    if root == nil {\n        return result\n    }\n    var dfs func(*TreeNode,int)\n    dfs = func(root *TreeNode,left int){\n        if root == nil{\n            return \n        }\n        path = append(path,root.Val)\n        left = left - root.Val\n        defer func() { \n            path = path[:len(path)-1]\n        }()\n        if root.Left == nil && root.Right == nil && left == 0{\n            // new := make([]int,len(path))\n            // copy(new,path)\n            // result = append(result,new)\n            result = append(result,append([]int(nil),path...))\n            return \n        }\n        dfs(root.Left,left)\n        dfs(root.Right,left)\n    }\n    dfs(root,targetSum)\n    return result\n}\n```\n\n#### **2.3.3** \n> 等待回溯来看\n> https://leetcode.cn/problems/path-sum-iii/solution/437-lu-jing-zong-he-iii-dfshui-su-qian-zhui-he-yi-/\n\n\n## **3** 中序遍历\n<font color='red'>遍历左子树，然后是根节点，然后是右子树</font>\n\n### **3.1** &ensp; 使用递归完成中序遍历\n``` golang\n\n```\n\n### **3.2** &ensp; 使用栈完成中序遍历\n```golang\nfunc inorderTraversal(root *TreeNode) []int {\n    if root == nil {\n        return []int{}\n    }\n\n    var res []int\n    var stack []*TreeNode\n    var pathStack []string\n    node := root\n\n    for node != nil || len(stack) > 0 {\n        if node != nil {\n            stack = append(stack, node)\n            pathStack = append(pathStack, fmt.Sprintf(\"%d\", node.Val))\n            node = node.Left\n        } else {\n            node = stack[len(stack)-1]\n            stack = stack[:len(stack)-1]\n            path := pathStack[len(pathStack)-1]\n            pathStack = pathStack[:len(pathStack)-1]\n\n            if node.Left == nil && node.Right == nil {\n                res = append(res, node.Val)\n\n                // 输出到达叶子节点的路径\n                fmt.Println(path)\n            }\n\n            node = node.Right\n        }\n    }\n\n    return res\n}\n```\n\n### **3.3** 找出二叉搜索树里面出现次数最多的数\n找众数就需要遍历所有的节点，二叉搜索树中序遍历的结果会是一个递增的数组，其数据特性就在于使用中序遍历的时候，所有的元素都是连续的\n``` golang\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc findMode(root *TreeNode) []int {\n    // 结果数组\n    ans := make([]int,0)\n    base,count,maxnum := math.MinInt64,0,0\n\n    // 使用递归的方式\n    var dfs func(*TreeNode)\n    dfs = func(root *TreeNode){\n        if root == nil {\n            return \n        }\n        dfs(root.Left)\n        if root.Val == base {\n            count++\n        }else{\n            base = root.Val\n            count = 1\n        }\n        if count == maxnum {\n            ans = append(ans,base)\n        }\n        if count > maxnum {\n            ans = []int{}\n            maxnum = count\n            ans = append(ans,base)\n        }\n        dfs(root.Right)\n    }\n    dfs(root)\n    return ans\n}\n```\n\n### **3.4** 找出二叉搜索树里面任意两个节点之间绝对值得最小值\n\nhttps://leetcode.cn/problems/minimum-distance-between-bst-nodes/\n\n```golang\nfunc minDiffInBST(root *TreeNode) int {\n    // 使用栈来中序遍历，栈顶元素就是上一遍历的节点元素\n    stack := make([]*TreeNode,0)\n    res := make([]int,0)\n    for root != nil || len(stack) > 0{\n        for root != nil {\n            stack = append(stack,root)\n            root = root.Left\n        }\n\n        node := stack[len(stack)-1]\n        stack = stack[:len(stack)-1]\n        res = append(res,node.Val)\n\n        root = node\n        root = root.Right\n    }\n    m := math.MaxInt64\n    for i:= 0; i < len(res)-1; i++{\n        r := res[i+1]-res[i]\n        m = min(m,r) \n    } \n    return m\n}\n\nfunc min(args ...int)int{\n    min := args[0]\n    for _, val := range args{\n        if val < min {\n            min = val\n        }\n    }\n    return min\n}\n```\n\n### **3.5** 一棵二叉搜索树的两个节点被交换了，恢复这颗二叉搜索树\n\n```golang\nfunc recoverTree(root *TreeNode)  {\n    // 使用递归解决这个问题\n    problem := make([]*TreeNode,0)\n    var findP func(*TreeNode)\n    findP = func(root *TreeNode){\n        if root == nil{\n            return \n        }\n        findP(root.Left)\n        // if pre == math.MaxInt64{\n        //     pre = root.Val\n        //     return\n        // }\n        // if root.Val - pre < 0{\n        //     problem = append(problem,root)\n        // }\n        // pre = root.Val\n        problem = append(problem, root)\n        findP(root.Right)\n    }\n    findP(root)\n    pre,cur := -1,-1\n    for i := 0; i < len(problem)-1; i++{\n        if problem[i].Val > problem[i+1].Val {\n            cur = i + 1\n            if pre == -1 {\n                pre = i\n            }\n        }\n    }\n    problem[pre].Val,problem[cur].Val = problem[cur].Val,problem[pre].Val\n    return \n}\n```\n\n### 删除二叉搜索树的节点\n> 题目最重要的考点就是分类，讨论各种情况下的处理方式\n\n<font sizecolor ='red'>清晰地讲出每种情况的处理办法</font>\n<font sizecolor ='red'>清晰简介地实现代码</font>\n\n\n\n\n## 后序遍历\n\n### 使用栈完成后序遍历\n\n### 迭代写法的考点\n1. 是否有右子树\n2. pre指针是不是指向当前结点的右子树","slug":"Algorithm/Alg_Basic/Golang-数据结构/Golang-算法课程--数据结构","published":1,"updated":"2023-05-03T01:57:04.911Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli796r140026byjxae3qg31v","content":"<h1 id=\"告别盲目刷题，击破算法面试\"><a href=\"#告别盲目刷题，击破算法面试\" class=\"headerlink\" title=\"告别盲目刷题，击破算法面试\"></a>告别盲目刷题，击破算法面试</h1><blockquote>\n<p>学习拉钩教育算法课程记录加个人感悟记录<br>如果有版权问题，请联系 <a href=\"mailto:&#50;&#x33;&#55;&#x34;&#48;&#x38;&#x37;&#51;&#x32;&#50;&#64;&#x71;&#113;&#x2e;&#x63;&#x6f;&#109;\">&#50;&#x33;&#55;&#x34;&#48;&#x38;&#x37;&#51;&#x32;&#50;&#64;&#x71;&#113;&#x2e;&#x63;&#x6f;&#109;</a> 删除课程部分的内容</p>\n<p>算法能力的高度，决定了个人能够解决的实战问题复杂度的上限</p>\n<p>数学基础决定了算法能力的高低</p>\n</blockquote>\n<h2 id=\"解题流程-：\"><a href=\"#解题流程-：\" class=\"headerlink\" title=\"==解题流程==：\"></a>==解题流程==：</h2><h3 id=\"四部分析法\"><a href=\"#四部分析法\" class=\"headerlink\" title=\"==四部分析法==\"></a>==四部分析法==</h3><ul>\n<li><p><strong>==模拟==</strong> ： 模拟题目的运行<br>使用简单且有一定量的小例子，将自己当作计算机来执行这个流程<br><em>一般使用题目给的较长的那个例子就可以</em></p>\n<p>这部分也是读题和理解输入输出内容的部分，理解题意的部分</p>\n<p>这个时候一定不能够着急，不要害怕或者是觉得麻烦，一定要耐下性子，把简单的一个逻辑过程给跑清楚，理解这段程序或者是业务需要咱们处理什么样的问题。</p>\n<p>跑的过程，不要完全先入为主，应当以题目的要求来推进演示。</p>\n<p>不要想着在这一步就把所有的问题都给解决，一步步推进就可以. </p>\n</li>\n<li><p><strong>==规律==</strong> ： 尝试总结出题目的一般规律和特点</p>\n<p>数学规律和特性一般来说很难直接从零归纳出来，但我们可以依赖所学习的高数、线性代数、离散数学、测度论等高等数学理论当中所见到的数学计算模型来匹配，这也是这部分最重要的基础</p>\n<p>先总结一些考题可能会用到的观察特点：</p>\n<ul>\n<li>形式相关：比如 括号匹配、从1加到100，</li>\n<li>数量变化：数量变化与取模相关，数量变化呈现递推公式</li>\n<li></li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p><strong>==匹配==</strong> ： 找到符合这些特点的数据结构和算法</p>\n<ul>\n<li><p>关注数据的输入类型：对输入数据进行分类，哪一些数据进行怎样的操作</p>\n</li>\n<li><p>**==怎样匹配呢？==**：</p>\n<ul>\n<li>题目模拟的时候（这部分一般使用栈、队列、二叉树）来理解题目要求的数字变化</li>\n<li>观察结果集合，或者是原本中间的变化集合，当期符合某种数据结构的变化特征的时候，就可以选用这个数据结构</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>**==考虑边界条件==**： 考虑特殊情况<br>特殊情况：<ul>\n<li>字符串为空，字符串只有一个，两个、</li>\n<li>数组为空，数字为0或者是其他不符合规律的特殊情况</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><strong>==深度思考==</strong> ： 平时练习当中的流程，用于提高算法模型的积累<ul>\n<li>深度： 这种解法还可以怎么优化</li>\n<li>广度： 这种解法的具有普适性吗？可以推广吗？问题的限定条件变多的话，这个模型是否还可以适合。</li>\n<li>数学模式扩散： 这样特点的问题是否有对应的数学模型或者是理论描述过</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"栈：-从简单栈到单调栈，让栈问题不再困难\"><a href=\"#栈：-从简单栈到单调栈，让栈问题不再困难\" class=\"headerlink\" title=\"栈： 从简单栈到单调栈，让栈问题不再困难\"></a>栈： 从简单栈到单调栈，让栈问题不再困难</h1><h2 id=\"结构特征\"><a href=\"#结构特征\" class=\"headerlink\" title=\"结构特征\"></a>结构特征</h2><p>先进后出</p>\n<p>对栈的操作：</p>\n<ul>\n<li><strong>==pop==</strong> 弹出栈顶元素，一般来说栈中可操作的元素就是栈顶元素，其他元素也都是先pop出其上面的元素，变成栈顶元素之后再进行操作。</li>\n<li> <strong>==peek==</strong> 获取栈顶元素，只是读取操作，但并没有弹出栈顶元素</li>\n<li> <strong>==push==</strong> 将元素压入栈中</li>\n</ul>\n<h3 id=\"Golang-栈的使用\"><a href=\"#Golang-栈的使用\" class=\"headerlink\" title=\"Golang 栈的使用\"></a>Golang 栈的使用</h3><p>在 Go 中并没有直接提供Stack的方法结构，但可以使用切片非常简单地表示和使用栈、队列结构。</p>\n<p> 先进后出的数据结构，使用**==切片==**表示，压入栈的操作就是往切片中添加元素，弹出栈的操作就是输出末尾元素，并将切片缩小为：<code>[:len(stack)-1]</code></p>\n<p>以下为栈的代码模板实现：</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Stack <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">    Stack []<span class=\"keyword\">interface</span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *Stack)</span></span>push(x <span class=\"keyword\">interface</span>&#123;&#125;)&#123;</span><br><span class=\"line\">    s = <span class=\"built_in\">append</span>(s,x)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *Stack)</span></span>pop()&#123;</span><br><span class=\"line\">    s = s[:<span class=\"built_in\">len</span>(s)<span class=\"number\">-1</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *Stack)</span></span>peek()(x <span class=\"keyword\">interface</span>&#123;&#125;)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s[<span class=\"built_in\">len</span>(s)<span class=\"number\">-1</span>]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>关键在于记住：</p>\n<ul>\n<li>栈顶元素 —&gt; 切片末尾元素</li>\n<li>切片是左闭右开，所以pop操作是 s = s[:len(s)-1], 但如果是队列pop出第一个元素就需要往后再移动一位 s = s[1:] 而不是 s = s[0:]</li>\n</ul>\n<h2 id=\"典型题目\"><a href=\"#典型题目\" class=\"headerlink\" title=\"典型题目\"></a>典型题目</h2><h3 id=\"判断字符串是否合法\"><a href=\"#判断字符串是否合法\" class=\"headerlink\" title=\"判断字符串是否合法\"></a>判断字符串是否合法</h3><p>题目：<a href=\"https://leetcode.cn/problems/valid-parentheses/\">https://leetcode.cn/problems/valid-parentheses/</a></p>\n<h4 id=\"正确解法和流程\"><a href=\"#正确解法和流程\" class=\"headerlink\" title=\"正确解法和流程\"></a>正确解法和流程</h4><p><a href=\"https://leetcode.cn/link/?target=https://www.bilibili.com/video/BV1AF411w78g\">https://leetcode.cn/link/?target=https://www.bilibili.com/video/BV1AF411w78g</a></p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">isValid</span><span class=\"params\">(s <span class=\"type\">string</span>)</span></span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    n := <span class=\"built_in\">len</span>(s)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> n % <span class=\"number\">2</span> == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    pairs := <span class=\"keyword\">map</span>[<span class=\"type\">byte</span>]<span class=\"type\">byte</span>&#123;</span><br><span class=\"line\">        <span class=\"string\">&#x27;)&#x27;</span>: <span class=\"string\">&#x27;(&#x27;</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;]&#x27;</span>: <span class=\"string\">&#x27;[&#x27;</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;&#125;&#x27;</span>: <span class=\"string\">&#x27;&#123;&#x27;</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    stack := []<span class=\"type\">byte</span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; n; i++ &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> pairs[s[i]] &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(stack) == <span class=\"number\">0</span> || stack[<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>] != pairs[s[i]] &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            stack = stack[:<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>]</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            stack = <span class=\"built_in\">append</span>(stack, s[i])</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(stack) == <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"个人解法和流程\"><a href=\"#个人解法和流程\" class=\"headerlink\" title=\"个人解法和流程\"></a>个人解法和流程</h4><blockquote>\n<p>问题集中体现在数据特性处理判断太过分散，属实是缝缝补补有一年<br>对输入数据进行分类，哪一些数据进行怎样的操作</p>\n<ul>\n<li>输入的是左括号应该入栈</li>\n<li>输入的是右括号应该做判断<br /></li>\n</ul>\n</blockquote>\n<p>我的代码是：</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">isValid</span><span class=\"params\">(s <span class=\"type\">string</span>)</span></span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    l := <span class=\"built_in\">len</span>(s)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> l%<span class=\"number\">2</span> != <span class=\"number\">0</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    stack := <span class=\"built_in\">make</span>([]<span class=\"type\">rune</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    m := <span class=\"keyword\">map</span>[<span class=\"type\">rune</span>]<span class=\"type\">rune</span>&#123;</span><br><span class=\"line\">        <span class=\"string\">&#x27;]&#x27;</span>:<span class=\"string\">&#x27;[&#x27;</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;)&#x27;</span>:<span class=\"string\">&#x27;(&#x27;</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;&#125;&#x27;</span>:<span class=\"string\">&#x27;&#123;&#x27;</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _,v := <span class=\"keyword\">range</span> s&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> v == <span class=\"string\">&#x27;[&#x27;</span> ||v == <span class=\"string\">&#x27;&#123;&#x27;</span> ||v == <span class=\"string\">&#x27;(&#x27;</span>&#123;</span><br><span class=\"line\">            stack = <span class=\"built_in\">append</span>(stack,v)</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(stack) == <span class=\"number\">0</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> stack[<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>] == m[v]&#123;</span><br><span class=\"line\">            stack = stack[:<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>]</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> m[v] != <span class=\"number\">0</span> &#123;<span class=\"keyword\">return</span> <span class=\"literal\">false</span>&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(stack) == <span class=\"number\">0</span>&#123;<span class=\"keyword\">return</span> <span class=\"literal\">true</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述在判断栈顶元素的时候逻辑不够清晰，所以加了很多的if来补足条件，我们看例子当中所给的逻辑顺序：</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    pairs := <span class=\"keyword\">map</span>[<span class=\"type\">byte</span>]<span class=\"type\">byte</span>&#123;</span><br><span class=\"line\">    <span class=\"string\">&#x27;)&#x27;</span>: <span class=\"string\">&#x27;(&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;]&#x27;</span>: <span class=\"string\">&#x27;[&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;&#125;&#x27;</span>: <span class=\"string\">&#x27;&#123;&#x27;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">stack := []<span class=\"type\">byte</span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; n; i++ &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> pairs[s[i]] &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(stack) == <span class=\"number\">0</span> || stack[<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>] != pairs[s[i]] &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        stack = stack[:<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>]</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        stack = <span class=\"built_in\">append</span>(stack, s[i])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(stack) == <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n\n<p>关键差距就在于这一句话：<code>pairs[s[i]] &gt; 0 </code>, 这个判断对输入的数据做了一次分类，依据上面的map结构可知，这句话 &lt; 0 时候标识map当中没有存储对应的对象，而map中存储的是所有的左括号，所以这个判断的作用是<strong>当输入是右括号的时候进入函数</strong>，然后逻辑体依据输入是右括号判断，如果当前栈里面没有元素或者是栈顶元素与右括号不匹配那么就返回false<br><br>实际上我写的函数最后夜市做了类似的判断，但显然没有考虑数据分类的情况。</p>\n<h3 id=\"判断大鱼吃小鱼最后留下的鱼\"><a href=\"#判断大鱼吃小鱼最后留下的鱼\" class=\"headerlink\" title=\"判断大鱼吃小鱼最后留下的鱼\"></a>判断大鱼吃小鱼最后留下的鱼</h3><p>题目：</p>\n<p>近似题目：<a href=\"https://www.nowcoder.com/questionTerminal/3fdfc63015df42c6a78fdae46709fa69?f=discussion\">https://www.nowcoder.com/questionTerminal/3fdfc63015df42c6a78fdae46709fa69?f=discussion</a></p>\n<br />\n\n<h4 id=\"正确解法和流程-1\"><a href=\"#正确解法和流程-1\" class=\"headerlink\" title=\"正确解法和流程\"></a>正确解法和流程</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * </span></span><br><span class=\"line\"><span class=\"comment\">     * @param N int整型 N条鱼</span></span><br><span class=\"line\"><span class=\"comment\">     * @param A int整型vector 每条鱼的体积为Ai</span></span><br><span class=\"line\"><span class=\"comment\">     * @return int整型</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">P</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> x, t;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">solve</span><span class=\"params\">(<span class=\"type\">int</span> N, vector&lt;<span class=\"type\">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class=\"line\">        stack&lt;P&gt; S;</span><br><span class=\"line\">        <span class=\"type\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=N<span class=\"number\">-1</span>;i&gt;=<span class=\"number\">0</span>;i--)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> t = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(!S.<span class=\"built_in\">empty</span>() &amp;&amp; A[i]&gt;S.<span class=\"built_in\">top</span>().x)&#123;</span><br><span class=\"line\">                t = <span class=\"built_in\">max</span>(S.<span class=\"built_in\">top</span>().t, t+<span class=\"number\">1</span>);</span><br><span class=\"line\">                S.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            S.<span class=\"built_in\">push</span>(&#123;A[i], t&#125;);</span><br><span class=\"line\">            cnt = <span class=\"built_in\">max</span>(cnt, t);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cnt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"个人解法和流程-1\"><a href=\"#个人解法和流程-1\" class=\"headerlink\" title=\"个人解法和流程\"></a>个人解法和流程</h4><p>由于找不到相同的题目，就找了类似的题目，但是解题的思路不太一样<br>图片上的大鱼吃小鱼，只需要每次比较栈顶元素和新进来的元素大小即可，当大于的时候，就不做操作，当栈顶元素小于输入元素的时候，pop出栈顶元素并push进入这个最大值，最后栈中元素就是结果。这个过程当中几处需要重视的地方是：</p>\n<ul>\n<li>当鱼的方向一致时候，大鱼并不会把同方向的小鱼给吃了【可能不论大小鱼的速度相同（bushi）】，而如果小鱼在左，大鱼在右，方向不同，则也不会吃</li>\n</ul>\n<p>牛客网的题目则加了非常多的条件和限制，是对栈问题的一个较大的变化</p>\n<blockquote>\n<p>对比上述两个题目可以观察到：<br><font color ='blue'> 1. 消除的行为不同</font><br>  括号匹配中，消除行为是配对的两者都会消除，也就是栈顶元素和输入元素一起被消除<br>  大鱼吃小鱼中，消除行为是配对的两者中会有一个被消除<br>–&gt; 是否入栈和出栈的判断<br><font color ='blue'> 2. 栈中的内容不同</font><br>  括号匹配当中，栈中存放的就是内容本身<br>  大鱼吃小鱼当中，栈里存放的是内容的索引，可以通过索引找到内容<br><font color ='blue'> 3. 弹栈的方式也不相同</font><br>  括号匹配只需要每次弹出一个元素就可以<br>  大鱼则需要用while语句一直弹出到满足某个条件才停止</p>\n</blockquote>\n<h2 id=\"栈问题的特征和解决流程\"><a href=\"#栈问题的特征和解决流程\" class=\"headerlink\" title=\"栈问题的特征和解决流程\"></a>栈问题的特征和解决流程</h2><h3 id=\"pop-行为不同\"><a href=\"#pop-行为不同\" class=\"headerlink\" title=\"pop 行为不同\"></a>pop 行为不同</h3><p>pop【弹栈的操作不一样】<br>常见的就是每次循环都判断栈顶元素的特点而pop或者push或者不操作，但这样必须得是连续性的元素才有这样的特征</p>\n<p><strong>==在弹栈的时候，是否一定要满足某个条件才停止弹栈==</strong><br>也就是说当输入元素之后需要将其和站内其他的元素进行比较，在使用的时候尤其要注意迭代过程</p>\n<h3 id=\"栈中存储内容不相同\"><a href=\"#栈中存储内容不相同\" class=\"headerlink\" title=\"栈中存储内容不相同\"></a>栈中存储内容不相同</h3><p>是否栈中存储数据、还是存储索引、还是存储一个自建的新的结构</p>\n<h3 id=\"栈顶元素的含义不相同\"><a href=\"#栈顶元素的含义不相同\" class=\"headerlink\" title=\"栈顶元素的含义不相同\"></a>栈顶元素的含义不相同</h3><h2 id=\"单调栈\"><a href=\"#单调栈\" class=\"headerlink\" title=\"单调栈\"></a>单调栈</h2><p>单调栈是指栈中元素必须按照升序排列的栈或者是降序排列的栈</p>\n<p>单调栈分为：</p>\n<ul>\n<li><p>递增栈：<br>  栈中元素从左到右遵守从小到大的顺序<br>  入栈时候，当<strong>入栈元素小于栈顶元素</strong>就会pop出栈顶元素，直到入栈元素大于栈顶元素<br>  特点是：<br>  入栈小数会消除栈内大数</p>\n</li>\n<li><p>递减栈<br>  栈中元素从左到右遵守从大到小的顺序<br>  入栈时候，当<strong>入栈元素大于栈顶元素</strong>就会pop出栈顶元素，直到入栈元素小于栈顶元素<br>  特点是：<br>  入栈大数会消除栈内小数</p>\n</li>\n</ul>\n<h3 id=\"典型代码：\"><a href=\"#典型代码：\" class=\"headerlink\" title=\"典型代码：\"></a>典型代码：</h3><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stack := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"comment\">/**递增栈的入栈</span></span><br><span class=\"line\"><span class=\"comment\">* 用for 循环出栈，直到栈顶元素满足递增栈的要求</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> <span class=\"built_in\">len</span>(stack)&gt; <span class=\"number\">0</span> &amp;&amp; A[i] &gt; stack[<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>]&#123;</span><br><span class=\"line\">    <span class=\"comment\">// pop出栈内比 A[i]小但却在前面的元素</span></span><br><span class=\"line\">    stack = stack[:<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">stack = <span class=\"built_in\">append</span>(stack,A[i])</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"找到当前数字右边最小的对应数字\"><a href=\"#找到当前数字右边最小的对应数字\" class=\"headerlink\" title=\"找到当前数字右边最小的对应数字\"></a>找到当前数字右边最小的对应数字</h3><h3 id=\"取k个字符，求字典序最小的组合\"><a href=\"#取k个字符，求字典序最小的组合\" class=\"headerlink\" title=\"取k个字符，求字典序最小的组合\"></a>取k个字符，求字典序最小的组合</h3><blockquote>\n<p>字典序：</p>\n<ul>\n<li>对单个元素按照ascii 表中大小顺序排列</li>\n<li>多个元素时，按照从左到右顺序，先从高位字典排序，然后在相同高位中按照地位再字典排序</li>\n</ul>\n</blockquote>\n<h3 id=\"给定一个数组，数组中元素代表模板的高度，请你求出相邻木板能剪出的最大矩形面积\"><a href=\"#给定一个数组，数组中元素代表模板的高度，请你求出相邻木板能剪出的最大矩形面积\" class=\"headerlink\" title=\"给定一个数组，数组中元素代表模板的高度，请你求出相邻木板能剪出的最大矩形面积\"></a>给定一个数组，数组中元素代表模板的高度，请你求出相邻木板能剪出的最大矩形面积</h3><blockquote>\n<p>和求最大容积是一个题目</p>\n</blockquote>\n<br />\n\n<h2 id=\"leetcode-题目汇总\"><a href=\"#leetcode-题目汇总\" class=\"headerlink\" title=\"leetcode 题目汇总\"></a>leetcode 题目汇总</h2><blockquote>\n<p>以leetcode 题目为例子</p>\n</blockquote>\n<p>相关栈的题目汇总：<br>[1][<a href=\"https://leetcode.cn/problem-list/xb9nqhhg/?topicSlugs=stack&amp;page=1%5D\">https://leetcode.cn/problem-list/xb9nqhhg/?topicSlugs=stack&amp;page=1]</a><br>[2][<a href=\"https://leetcode.cn/problem-list/e8X3pBZi/?page=1&amp;topicSlugs=heap-priority-queue%5D\">https://leetcode.cn/problem-list/e8X3pBZi/?page=1&amp;topicSlugs=heap-priority-queue]</a><br>[3][<a href=\"https://leetcode.cn/problem-list/2cktkvj/?page=1&amp;topicSlugs=stack%5D\">https://leetcode.cn/problem-list/2cktkvj/?page=1&amp;topicSlugs=stack]</a></p>\n<h1 id=\"队列：FIFO-队列与单调队列的深挖与扩展\"><a href=\"#队列：FIFO-队列与单调队列的深挖与扩展\" class=\"headerlink\" title=\"队列：FIFO 队列与单调队列的深挖与扩展\"></a>队列：FIFO 队列与单调队列的深挖与扩展</h1><p>先进先出，是共同特征</p>\n<p>类别上可以分出：</p>\n<ul>\n<li>FIFO队列</li>\n<li>单调队列</li>\n</ul>\n<h2 id=\"FIFO队列\"><a href=\"#FIFO队列\" class=\"headerlink\" title=\"FIFO队列\"></a>FIFO队列</h2><p><strong>==Push 元素时候， 总是将放在元素放在队列尾部，也就是操作 fifo[len(fifo)-1]==</strong><br><strong>==Pop 元素时候，总是将队列首部的元素扔掉 ，也就是操作 fifo = fifo[1:]==</strong></p>\n<h3 id=\"二叉树的层次遍历（两种方法）\"><a href=\"#二叉树的层次遍历（两种方法）\" class=\"headerlink\" title=\"二叉树的层次遍历（两种方法）\"></a>二叉树的层次遍历（两种方法）</h3><ul>\n<li><p>规律：<br>广度遍历（层次遍历）：由于二叉树的特点，当拿到第N层的结点A之后，可以通过 A 的left，right指针拿到下一层的节点<br><strong>但是与A在同一层的节点还有其他吗，这个时候就需要按层来存储节点，不能直接使用递归</strong></p>\n  <br />\n  顺序输出：每层输出时，排在左边的节点，它的子节点同样排在下一层的最左边</li>\n</ul>\n<p>–&gt; <strong>==题目具备广度遍历（分层遍历）的特点 和 顺序输出的特点 ，应该想到应用FIFO队列==</strong></p>\n<ul>\n<li>边界<br>特殊判断： 如果发现是一棵空二叉树，就直接返回空结果<br>==制定一个规则==： 不要让空指针进入到FIFO队列（一些编程的亮点）</li>\n</ul>\n<p><font color = 'red'> 非常重要的概念： QSize 表示当前层数 </font></p>\n<h4 id=\"层次遍历二叉树\"><a href=\"#层次遍历二叉树\" class=\"headerlink\" title=\"层次遍历二叉树\"></a>层次遍历二叉树</h4><p>题目链接：<a href=\"https://leetcode.cn/problems/binary-tree-level-order-traversal/submissions/\">https://leetcode.cn/problems/binary-tree-level-order-traversal/submissions/</a></p>\n<h5 id=\"解题思路1\"><a href=\"#解题思路1\" class=\"headerlink\" title=\"解题思路1\"></a>解题思路1</h5><p>关键思路在于将每一层的节点都存在FIFO队列里面，在每次遍历的时候从左到右pop出该层的节点，同时在队尾加入他的左右孩子</p>\n<p>队首pop出当层节点，队尾append下一层的孩子节点<br>QSize 记录当层的节点数量</p>\n<p>时间复杂度是O(n), 空间复杂度由QSize决定O(K),K表示QSize最大，也就是存储的一层节点数量最多的时候</p>\n<h5 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h5><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * type TreeNode struct &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     Val int</span></span><br><span class=\"line\"><span class=\"comment\"> *     Left *TreeNode</span></span><br><span class=\"line\"><span class=\"comment\"> *     Right *TreeNode</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">levelOrder</span><span class=\"params\">(root *TreeNode)</span></span> [][]<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建FIFO 队列来存储遍历的过程</span></span><br><span class=\"line\">    fifo := <span class=\"built_in\">make</span>([]*TreeNode,<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"comment\">// QSize 表示当前遍历的层</span></span><br><span class=\"line\">    QSize := <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"comment\">// 初始化最终结果</span></span><br><span class=\"line\">    result := <span class=\"built_in\">make</span>([][]<span class=\"type\">int</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> root == <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//将根节点入栈</span></span><br><span class=\"line\">    fifo = <span class=\"built_in\">append</span>(fifo,root)</span><br><span class=\"line\">    <span class=\"comment\">// 开始层序遍历，只要当前队列不为空</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"built_in\">len</span>(fifo) &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建结果数组用于存储当层pop出的元素值</span></span><br><span class=\"line\">        tmp := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"comment\">// 当层元素QSize全部遍历以此，这里不能用len(fifo)，因为fifo的长度是在变化的</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i := QSize;i &gt; <span class=\"number\">0</span>;i--&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 拿出队列头元素</span></span><br><span class=\"line\">            node := fifo[<span class=\"number\">0</span>]</span><br><span class=\"line\">            <span class=\"comment\">// 判断他的左孩子是否为空</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> node.Left!= <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">                fifo = <span class=\"built_in\">append</span>(fifo,node.Left)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 判断他的右孩子是否为空</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> node.Right != <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">                fifo = <span class=\"built_in\">append</span>(fifo,node.Right)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 将该节点的值存入结果</span></span><br><span class=\"line\">            tmp = <span class=\"built_in\">append</span>(tmp,node.Val)</span><br><span class=\"line\">            <span class=\"comment\">// 推出队首元素</span></span><br><span class=\"line\">            fifo = fifo[<span class=\"number\">1</span>:]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 将结果 tmp 存入到结果数组当中</span></span><br><span class=\"line\">        result = <span class=\"built_in\">append</span>(result,tmp)</span><br><span class=\"line\">        <span class=\"comment\">// 重新计算当前层的节点数量</span></span><br><span class=\"line\">        QSize = <span class=\"built_in\">len</span>(fifo)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"官方题解\"><a href=\"#官方题解\" class=\"headerlink\" title=\"官方题解\"></a>官方题解</h5><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">levelOrder</span><span class=\"params\">(root *TreeNode)</span></span> [][]<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    ret := [][]<span class=\"type\">int</span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> root == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    q := []*TreeNode&#123;root&#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; <span class=\"built_in\">len</span>(q) &gt; <span class=\"number\">0</span>; i++ &#123;</span><br><span class=\"line\">        ret = <span class=\"built_in\">append</span>(ret, []<span class=\"type\">int</span>&#123;&#125;)</span><br><span class=\"line\">        p := []*TreeNode&#123;&#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j := <span class=\"number\">0</span>; j &lt; <span class=\"built_in\">len</span>(q); j++ &#123;</span><br><span class=\"line\">            node := q[j]</span><br><span class=\"line\">            ret[i] = <span class=\"built_in\">append</span>(ret[i], node.Val)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> node.Left != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">                p = <span class=\"built_in\">append</span>(p, node.Left)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> node.Right != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">                p = <span class=\"built_in\">append</span>(p, node.Right)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        q = p</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"解题思路2\"><a href=\"#解题思路2\" class=\"headerlink\" title=\"解题思路2\"></a>解题思路2</h5><p>使用链表来解决问题</p>\n<h4 id=\"锯齿状层次遍历\"><a href=\"#锯齿状层次遍历\" class=\"headerlink\" title=\"锯齿状层次遍历\"></a>锯齿状层次遍历</h4><p>题目链接：<a href=\"https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/\">https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/</a></p>\n<h5 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h5><p>层次遍历的基础上加一个qs，表示当前层是从左到右还是从右到左</p>\n<p>**==本题当中所犯的错误：==**：</p>\n<ul>\n<li>每一轮都需要重新计算qsize,一定不要忘了这一点</li>\n<li>tmp 接收的时候还是按照栈的pop逻辑，所以顺序上还需要再反一次</li>\n<li>题目样例当中root是按照从左到右遍历过一次来计算的</li>\n</ul>\n<h5 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h5><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * type TreeNode struct &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     Val int</span></span><br><span class=\"line\"><span class=\"comment\"> *     Left *TreeNode</span></span><br><span class=\"line\"><span class=\"comment\"> *     Right *TreeNode</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">zigzagLevelOrder</span><span class=\"params\">(root *TreeNode)</span></span> [][]<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//结果数组</span></span><br><span class=\"line\">    result := <span class=\"built_in\">make</span>([][]<span class=\"type\">int</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"comment\">//全局的fifo队列</span></span><br><span class=\"line\">    fifo := <span class=\"built_in\">make</span>([]*TreeNode,<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"comment\">// Qsize 表示当前层的节点数，qs 表示该层的遍历顺序，0表示从左到右，1表示从右到左</span></span><br><span class=\"line\">    Qsize ,qs := <span class=\"number\">1</span> , <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果树中没有节点则直接返回</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> root == <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 将 root 放入队列</span></span><br><span class=\"line\">    fifo = <span class=\"built_in\">append</span>(fifo,root)</span><br><span class=\"line\">    <span class=\"comment\">//遍历整棵树</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"built_in\">len</span>(fifo) &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        tmp := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i:= <span class=\"number\">1</span>; Qsize &gt;= i &amp;&amp; qs == <span class=\"number\">0</span> ;i++&#123;</span><br><span class=\"line\">            node := fifo[Qsize-i]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> node.Right != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">                fifo = <span class=\"built_in\">append</span>(fifo,node.Right)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> node.Left != <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">                fifo = <span class=\"built_in\">append</span>(fifo,node.Left)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            tmp = <span class=\"built_in\">append</span>(tmp,node.Val)                </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i:= <span class=\"number\">1</span>; Qsize &gt;= i &amp;&amp; qs == <span class=\"number\">1</span> ;i++&#123;</span><br><span class=\"line\">            node := fifo[Qsize-i]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> node.Left != <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">                fifo = <span class=\"built_in\">append</span>(fifo,node.Left)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> node.Right != <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">                fifo = <span class=\"built_in\">append</span>(fifo,node.Right)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            tmp = <span class=\"built_in\">append</span>(tmp,node.Val)                </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        fifo = fifo[Qsize:]</span><br><span class=\"line\">        Qsize = <span class=\"built_in\">len</span>(fifo)</span><br><span class=\"line\">        result = <span class=\"built_in\">append</span>(result,tmp)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> qs == <span class=\"number\">1</span>&#123;</span><br><span class=\"line\">            qs = <span class=\"number\">0</span></span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            qs = <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"倒序层次遍历\"><a href=\"#倒序层次遍历\" class=\"headerlink\" title=\"倒序层次遍历\"></a>倒序层次遍历</h4><p>题目链接：<a href=\"https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/\">https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/</a></p>\n<h5 id=\"解题思路-1\"><a href=\"#解题思路-1\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h5><p>从题目要求当中可以读出，是在之前的层序遍历基础上把结果倒过来输出，那么会比较自然想到可以在使用一个栈用来存储中间结果</p>\n<h5 id=\"代码-2\"><a href=\"#代码-2\" class=\"headerlink\" title=\"代码\"></a>代码</h5><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * type TreeNode struct &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     Val int</span></span><br><span class=\"line\"><span class=\"comment\"> *     Left *TreeNode</span></span><br><span class=\"line\"><span class=\"comment\"> *     Right *TreeNode</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">levelOrderBottom</span><span class=\"params\">(root *TreeNode)</span></span> [][]<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 构造全局fifo队列</span></span><br><span class=\"line\">    fifo := <span class=\"built_in\">make</span>([]*TreeNode,<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"comment\">// 构造结果栈</span></span><br><span class=\"line\">    stack := <span class=\"built_in\">make</span>([][]<span class=\"type\">int</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">    result := <span class=\"built_in\">make</span>([][]<span class=\"type\">int</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"comment\">//表示当前层的节点数量</span></span><br><span class=\"line\">    Qsize := <span class=\"number\">1</span></span><br><span class=\"line\">    fifo = <span class=\"built_in\">append</span>(fifo,root)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> root == <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"built_in\">len</span>(fifo) &gt; <span class=\"number\">0</span>&#123;</span><br><span class=\"line\">        tmp := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> Qsize &gt; <span class=\"number\">0</span>&#123;</span><br><span class=\"line\">            node:= fifo[<span class=\"number\">0</span>]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> node.Left != <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">                fifo =<span class=\"built_in\">append</span>(fifo,node.Left)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> node.Right != <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">                fifo = <span class=\"built_in\">append</span>(fifo,node.Right)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            Qsize--</span><br><span class=\"line\">            fifo = fifo[<span class=\"number\">1</span>:]</span><br><span class=\"line\">            tmp = <span class=\"built_in\">append</span>(tmp,node.Val)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        stack = <span class=\"built_in\">append</span>(stack,tmp)</span><br><span class=\"line\">        Qsize = <span class=\"built_in\">len</span>(fifo)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将栈中元素pop 到结果当中</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"built_in\">len</span>(stack) &gt; <span class=\"number\">0</span>&#123;</span><br><span class=\"line\">        result = <span class=\"built_in\">append</span>(result,stack[<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>])</span><br><span class=\"line\">        stack = stack[:<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"循环队列\"><a href=\"#循环队列\" class=\"headerlink\" title=\"循环队列\"></a>循环队列</h2><p>设计一个可以容纳 k 个元素的循环队列，需要实现以下接口：</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> ringQueue <span class=\"keyword\">interface</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//构造函数，参数k表示这个循环队列最多容纳k个元素</span></span><br><span class=\"line\">    CircularQueue(<span class=\"type\">int</span>)</span><br><span class=\"line\">    <span class=\"comment\">//将value放到队列中，成功返回true</span></span><br><span class=\"line\">    EnQueue(<span class=\"type\">int</span>) <span class=\"type\">bool</span></span><br><span class=\"line\">    <span class=\"comment\">// 删除队首元素，成功返回true</span></span><br><span class=\"line\">    DeQueue() <span class=\"type\">bool</span></span><br><span class=\"line\">    <span class=\"comment\">// 得到队首元素，如果队列为空，返回-1</span></span><br><span class=\"line\">    Front() <span class=\"type\">int</span></span><br><span class=\"line\">    <span class=\"comment\">// 得到队尾元素，如果队列为空，返回-1</span></span><br><span class=\"line\">    Rear() <span class=\"type\">int</span></span><br><span class=\"line\">    <span class=\"comment\">// 查看循环队列是否为空</span></span><br><span class=\"line\">    isEmpty() <span class=\"type\">bool</span></span><br><span class=\"line\">    <span class=\"comment\">// 查看队列是否已经放满k个元素</span></span><br><span class=\"line\">    isFull() <span class=\"type\">bool</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>==循环队列的重点在于==: <font color = 'red'>循环使用固定空间</font></strong></li>\n<li><strong>==难点在于==： <font color='red'>控制好 Front/Rear两个首位指示器</font></strong></li>\n</ul>\n<h3 id=\"表示方法1\"><a href=\"#表示方法1\" class=\"headerlink\" title=\"表示方法1\"></a>表示方法1</h3><p>使用 <code>used</code>、<code>front</code>、<code>rear</code> 三个变量来控制，其中<code>used, front</code>都代表的是数组的下标</p>\n<p>注意以下几点：</p>\n<ul>\n<li>index = i 的后一个是i+1，前一个是i+1</li>\n<li>index = k-1 的后一个就是index=0</li>\n<li>index = 0 的前一个是 index = k-1</li>\n<li><em>==可以使用取模的方式统一处理==:</em>*<br><font color='red'> index = i 的后一个元素下标是（i+1）% k</font><br><font color='red'> index = i 的前一个元素下标是（i-1+k）% k</font><br><font color='blue'>所有的循环数组下标的处理都需要按照这个取模的方式</font></li>\n</ul>\n<p>参考的实例代码如下：</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> MyCircularQueue <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    queue  []<span class=\"type\">int</span></span><br><span class=\"line\">    rear   <span class=\"type\">int</span></span><br><span class=\"line\">    front  <span class=\"type\">int</span></span><br><span class=\"line\">    used   <span class=\"type\">int</span></span><br><span class=\"line\">    length <span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">CircularQueue</span><span class=\"params\">(k <span class=\"type\">int</span>)</span></span> ringQueue &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;MyCircularQueue&#123;</span><br><span class=\"line\">        queue:  <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, k),</span><br><span class=\"line\">        rear:   <span class=\"number\">0</span>,</span><br><span class=\"line\">        front:  <span class=\"number\">0</span>,</span><br><span class=\"line\">        used:   <span class=\"number\">0</span>,</span><br><span class=\"line\">        length: k,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(q *MyCircularQueue)</span></span> EnQueue(value <span class=\"type\">int</span>) <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> q.isFull() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span> </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    q.queue[q.rear] = value</span><br><span class=\"line\">    q.rear = (q.rear + <span class=\"number\">1</span>) % q.length</span><br><span class=\"line\">    q.used++</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(q *MyCircularQueue)</span></span> DeQueue() <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> q.isEmpty() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    q.front = (q.front + <span class=\"number\">1</span>) % q.length</span><br><span class=\"line\">    q.used--</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(q *MyCircularQueue)</span></span> Front() <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> q.used == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> q.queue[q.front]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(q *MyCircularQueue)</span></span> Rear() <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> q.used == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> q.queue[(q.rear<span class=\"number\">-1</span>+q.length)%q.length]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(q *MyCircularQueue)</span></span> isEmpty() <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> q.used == <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(q *MyCircularQueue)</span></span> isFull() <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> q.used == q.length</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>备注：<br>在 <code>DeQueue()</code> 方法中，删除队首元素时并不会真的删除该元素，而是通过移动 <code>front</code> 指针来达到删除的效果。</p>\n<p>循环队列是一个环状的数据结构，可以想象成沿着环形路径移动指针。在实现循环队列时，每当删除队首元素时，我们需要将 <code>front</code> 指针向前移一位，指向队列中的下一个元素，这样队列中原来的第二个元素就成为了新的头部元素。这里使用 “指向队列中的下一个元素” 实际上是模运算的作用，如 <code>(i+1) % n</code> 将会得到指向 <code>i</code> 在循环数组中下一个元素的索引值。</p>\n<p>而在这个移动指针的过程中，由于队列的前面已经没有元素，所以我们不需要将队首元素真正地删除。相反，仅需要更新 <code>front</code> 指针，让它指向目前第一个元素，后面再添加新的元素，也会覆盖掉先前的元素，实现对队列的循环利用。</p>\n<h3 id=\"表示方法2\"><a href=\"#表示方法2\" class=\"headerlink\" title=\"表示方法2\"></a>表示方法2</h3><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> MyCircularQueue <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用 k + 1 ，也就是多余一个空格的循环队列来设计</span></span><br><span class=\"line\">    queue []<span class=\"type\">int</span></span><br><span class=\"line\">    front <span class=\"type\">int</span></span><br><span class=\"line\">    rear <span class=\"type\">int</span></span><br><span class=\"line\">    capacity <span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Constructor</span><span class=\"params\">(k <span class=\"type\">int</span>)</span></span> MyCircularQueue &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> MyCircularQueue&#123;</span><br><span class=\"line\">        queue: <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>,k+<span class=\"number\">1</span>),</span><br><span class=\"line\">        front: <span class=\"number\">0</span>,</span><br><span class=\"line\">        rear: <span class=\"number\">0</span>,</span><br><span class=\"line\">        capacity: k+<span class=\"number\">1</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyCircularQueue)</span></span> EnQueue(value <span class=\"type\">int</span>) <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> this.IsFull()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    this.queue[this.rear] = value</span><br><span class=\"line\">    this.rear = (this.rear + <span class=\"number\">1</span>)%this.capacity</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyCircularQueue)</span></span> DeQueue() <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> this.IsEmpty()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    this.front = (this.front+<span class=\"number\">1</span>)%this.capacity</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyCircularQueue)</span></span> Front() <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> this.IsEmpty() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> this.queue[this.front]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyCircularQueue)</span></span> Rear() <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> this.IsEmpty()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    rearPosition := (this.rear<span class=\"number\">-1</span>+this.capacity)%this.capacity</span><br><span class=\"line\">    <span class=\"keyword\">return</span> this.queue[rearPosition]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyCircularQueue)</span></span> IsEmpty() <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> this.rear ==this.front</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyCircularQueue)</span></span> IsFull() <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (this.rear+<span class=\"number\">1</span>)%this.capacity == this.front</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Your MyCircularQueue object will be instantiated and called as such:</span></span><br><span class=\"line\"><span class=\"comment\"> * obj := Constructor(k);</span></span><br><span class=\"line\"><span class=\"comment\"> * param_1 := obj.EnQueue(value);</span></span><br><span class=\"line\"><span class=\"comment\"> * param_2 := obj.DeQueue();</span></span><br><span class=\"line\"><span class=\"comment\"> * param_3 := obj.Front();</span></span><br><span class=\"line\"><span class=\"comment\"> * param_4 := obj.Rear();</span></span><br><span class=\"line\"><span class=\"comment\"> * param_5 := obj.IsEmpty();</span></span><br><span class=\"line\"><span class=\"comment\"> * param_6 := obj.IsFull();</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"循环双向队列\"><a href=\"#循环双向队列\" class=\"headerlink\" title=\"循环双向队列\"></a>循环双向队列</h3><h4 id=\"解题思路-2\"><a href=\"#解题思路-2\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h4><p><strong>==犯错的地方：==</strong><br><font color='red'> InsertFront的时候，需要先移动front向前一位，然后再把值插进去</font><br>最开始想的，直接让front和rear都指向一个空白的空间，那么就需要在插入的时候先将front向前移动两位，但这样的话就会浪费一个数值的空间，因为多余一个位就完全可以满足要求</p>\n<p>使用k+1的情况，如果是在LRU缓存或者是Ringbuffer当中还需要考虑，将队尾[或者是队中]的元素插入到队首，也就是将最近使用的元素放到前面</p>\n<h4 id=\"代码-3\"><a href=\"#代码-3\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> MyCircularDeque <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    queue []<span class=\"type\">int</span></span><br><span class=\"line\">    front <span class=\"type\">int</span></span><br><span class=\"line\">    rear <span class=\"type\">int</span> </span><br><span class=\"line\">    capacity <span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Constructor</span><span class=\"params\">(k <span class=\"type\">int</span>)</span></span> MyCircularDeque &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> MyCircularDeque&#123;</span><br><span class=\"line\">        queue: <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>,k+<span class=\"number\">1</span>),</span><br><span class=\"line\">        front: <span class=\"number\">0</span>,</span><br><span class=\"line\">        rear: <span class=\"number\">0</span>,</span><br><span class=\"line\">        capacity: k+<span class=\"number\">1</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyCircularDeque)</span></span> InsertFront(value <span class=\"type\">int</span>) <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> this.IsFull()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    this.front = (this.front<span class=\"number\">-1</span> + this.capacity)%this.capacity</span><br><span class=\"line\">    this.queue[this.front] = value</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyCircularDeque)</span></span> InsertLast(value <span class=\"type\">int</span>) <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> this.IsFull()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    this.queue[this.rear] = value</span><br><span class=\"line\">    this.rear = (this.rear+<span class=\"number\">1</span>)%this.capacity</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyCircularDeque)</span></span> DeleteFront() <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> this.IsEmpty()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    this.front = (this.front+<span class=\"number\">1</span>)%this.capacity</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyCircularDeque)</span></span> DeleteLast() <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> this.IsEmpty()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    this.rear = (this.rear<span class=\"number\">-1</span>+this.capacity)%this.capacity</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyCircularDeque)</span></span> GetFront() <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> this.IsEmpty()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> this.queue[this.front]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyCircularDeque)</span></span> GetRear() <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> this.IsEmpty()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> this.queue[(this.rear<span class=\"number\">-1</span>+this.capacity)%this.capacity]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyCircularDeque)</span></span> IsEmpty() <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> this.front == this.rear</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyCircularDeque)</span></span> IsFull() <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> this.front == (this.rear+<span class=\"number\">1</span>)%this.capacity</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Your MyCircularDeque object will be instantiated and called as such:</span></span><br><span class=\"line\"><span class=\"comment\"> * obj := Constructor(k);</span></span><br><span class=\"line\"><span class=\"comment\"> * param_1 := obj.InsertFront(value);</span></span><br><span class=\"line\"><span class=\"comment\"> * param_2 := obj.InsertLast(value);</span></span><br><span class=\"line\"><span class=\"comment\"> * param_3 := obj.DeleteFront();</span></span><br><span class=\"line\"><span class=\"comment\"> * param_4 := obj.DeleteLast();</span></span><br><span class=\"line\"><span class=\"comment\"> * param_5 := obj.GetFront();</span></span><br><span class=\"line\"><span class=\"comment\"> * param_6 := obj.GetRear();</span></span><br><span class=\"line\"><span class=\"comment\"> * param_7 := obj.IsEmpty();</span></span><br><span class=\"line\"><span class=\"comment\"> * param_8 := obj.IsFull();</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n\n<p>相似点：</p>\n<ul>\n<li>都使用了取模的方式</li>\n</ul>\n<h2 id=\"单调队列\"><a href=\"#单调队列\" class=\"headerlink\" title=\"单调队列\"></a>单调队列</h2><p>单调队列属于双端队列的一种</p>\n<p>要求队列中的元素必须满足单调性</p>\n<p>单调队列如对时候的要求：入队前后，单调性完整</p>\n<p><strong>==单调递减队列最重要的特性==:<font color='red'>入队和出队的组合，可以在O(1)时间得到某个区间上的最大值</font></strong></p>\n<h3 id=\"情况讨论\"><a href=\"#情况讨论\" class=\"headerlink\" title=\"情况讨论\"></a>情况讨论</h3><blockquote>\n<p>需要回答的问题：</p>\n<ul>\n<li>这个区间是什么</li>\n<li>怎样定量地描述这个区间</li>\n<li>与队列中的元素个数有什么关系<br>可以分以下两种情况来讨论：</li>\n</ul>\n</blockquote>\n<ol>\n<li>只有入队的情况<br>在没有出队的情况下，对原数组的比较范围就会逐步增加<br>队首元素表示是已比较范围内的最大值</li>\n<li>出队和入队混合的情况<br>控制覆盖范围为 k –&gt; 滑动窗口<ul>\n<li>入队： 扩展单调队列的覆盖范围</li>\n<li>出队： 控制单调队列的覆盖范围</li>\n<li>队首元素是覆盖范围的最大值</li>\n<li>队列中的元素个数小于覆盖范围的元素个数</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"核心代码\"><a href=\"#核心代码\" class=\"headerlink\" title=\"核心代码\"></a>核心代码</h3><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//入队的代码</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(q *queue)</span></span>push(val <span class=\"type\">int</span>)&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 入队时候，要剔除掉尾部的元素，知道尾部元素大于或者是等于入队元素</span></span><br><span class=\"line\">    while(!q.isEmpty() &amp;&amp; q.getLast()&lt;val)&#123;</span><br><span class=\"line\">        q.removeLast()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 将元素入队</span></span><br><span class=\"line\">    q.addLast(val)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 出队的时候，需要给出一个value</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(q *queue)</span></span> pop(val <span class=\"type\">int</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!q.isEmpty() &amp;&amp; q.getFirst()==val)&#123;</span><br><span class=\"line\">        q.removeFirst()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样的代码编写关键：</p>\n<ul>\n<li>队首元素q.getFirst() 所获取的值是队列中的最大值</li>\n<li>出队时<ul>\n<li>如果一个元素已经被其他元素剔除出去了，那么他就不会再入队</li>\n<li>如果一个元素是当前队列的最大值，会再出队</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"滑动窗口的最大值\"><a href=\"#滑动窗口的最大值\" class=\"headerlink\" title=\"滑动窗口的最大值\"></a>滑动窗口的最大值</h3><h3 id=\"捡金币游戏\"><a href=\"#捡金币游戏\" class=\"headerlink\" title=\"捡金币游戏\"></a>捡金币游戏</h3><blockquote>\n<p>考点:</p>\n<ul>\n<li>找到get数组，并知道get数组是当前元素和滑动窗口中最大值的和计算而来</li>\n<li>利用单调队列在get[]数组上操作，找到滑动窗口的最大值</li>\n</ul>\n</blockquote>\n<p>拓展： 是否存在不同的出队方式</p>\n<blockquote>\n<p>整理一下代码模板：<br><font color = 'red'>分层遍历</font><br><font color = 'red'>循环队列</font><br><font color = 'red'>单调队列</font></p>\n</blockquote>\n<p>一些有意思的题目：</p>\n<ul>\n<li>利用栈实现一个队列</li>\n<li>利用队列实现一个栈</li>\n</ul>\n<h1 id=\"优先级队列：堆与优先级队列，筛选最优元素\"><a href=\"#优先级队列：堆与优先级队列，筛选最优元素\" class=\"headerlink\" title=\"优先级队列：堆与优先级队列，筛选最优元素\"></a>优先级队列：堆与优先级队列，筛选最优元素</h1><h2 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h2><p> FIFO队列： 节点之间的优先级是由遍历时的顺序决定的<br> 优先级队列： 节点之间按照大小进行排序后，再决定优先级，底层依赖的数据结构一般是堆</p>\n<h4 id=\"堆的分类\"><a href=\"#堆的分类\" class=\"headerlink\" title=\"堆的分类\"></a>堆的分类</h4><ol>\n<li><p>大根堆<br>节点的值比他的孩子节点都大</p>\n</li>\n<li><p>小根堆<br>节点的值要比他的孩子节点都小<br>堆的特点–大堆的根是最大值，小堆的根是最小值</p>\n</li>\n</ol>\n<h4 id=\"堆的实现\"><a href=\"#堆的实现\" class=\"headerlink\" title=\"堆的实现\"></a>堆的实现</h4><blockquote>\n<p>以大堆为例子</p>\n</blockquote>\n<p>大多数时候都是使用数组来表示堆</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Heap <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    data []<span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建新的大根堆</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewHeap</span><span class=\"params\">()</span></span> Heap &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Heap&#123;</span><br><span class=\"line\">        data: <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, <span class=\"number\">0</span>),</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取大根堆的长度</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h *Heap)</span></span> Len() <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(h.data)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取指定位置元素的父节点位置</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">parent</span><span class=\"params\">(i <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (i - <span class=\"number\">1</span>) / <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取指定位置元素的左子节点位置</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">leftChild</span><span class=\"params\">(i <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> i*<span class=\"number\">2</span> + <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取指定位置元素的右子节点位置</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">rightChild</span><span class=\"params\">(i <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> i*<span class=\"number\">2</span> + <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 下沉操作，将指定位置的元素向下移动，直到它大于所有子节点为止</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h *Heap)</span></span> sink(i <span class=\"type\">int</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">        left, right := leftChild(i), rightChild(i)</span><br><span class=\"line\">        maxPos := i</span><br><span class=\"line\">        <span class=\"keyword\">if</span> left &lt; h.Len() &amp;&amp; h.data[left] &gt; h.data[maxPos] &#123;</span><br><span class=\"line\">            maxPos = left</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> right &lt; h.Len() &amp;&amp; h.data[right] &gt; h.data[maxPos] &#123;</span><br><span class=\"line\">            maxPos = right</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> maxPos == i &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        h.data[i], h.data[maxPos] = h.data[maxPos], h.data[i]</span><br><span class=\"line\">        i = maxPos</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 上浮操作，将指定位置的元素向上移动，直到它小于其父节点为止</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h *Heap)</span></span> swim(i <span class=\"type\">int</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        p := parent(i)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> h.data[p] &gt;= h.data[i] &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        h.data[p], h.data[i] = h.data[i], h.data[p]</span><br><span class=\"line\">        i = p</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 出堆，弹出大根堆的堆顶元素，并重新调整堆结构</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h *Heap)</span></span> pop() <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    res := h.data[<span class=\"number\">0</span>]</span><br><span class=\"line\">    h.data[<span class=\"number\">0</span>] = h.data[<span class=\"built_in\">len</span>(h.data)<span class=\"number\">-1</span>]</span><br><span class=\"line\">    h.data = h.data[:<span class=\"built_in\">len</span>(h.data)<span class=\"number\">-1</span>]</span><br><span class=\"line\">    h.sink(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 入堆，将新元素插入到大根堆中，并重新调整堆结构</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h *Heap)</span></span> push(val <span class=\"type\">int</span>) &#123;</span><br><span class=\"line\">    h.data = <span class=\"built_in\">append</span>(h.data, val)</span><br><span class=\"line\">    h.swim(<span class=\"built_in\">len</span>(h.data) - <span class=\"number\">1</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"最小的k个数\"><a href=\"#最小的k个数\" class=\"headerlink\" title=\"最小的k个数\"></a>最小的k个数</h4><blockquote>\n<p>N 的数量级非常大，或者其希望能够获得一个较小的区间内的数字<br>同时输出的操作是每时每刻的话，一直是用排序的代价就会很高<br>在上述大根堆的基础上来完成的话，就是以下代码：</p>\n</blockquote>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">getLeastNumbers</span><span class=\"params\">(arr []<span class=\"type\">int</span>, k <span class=\"type\">int</span>)</span></span> []<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 建立大根堆</span></span><br><span class=\"line\">    minH := Heap&#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i:=<span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(arr); i++&#123;</span><br><span class=\"line\">        minH.push(arr[i])</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(minH.data) &gt; k &#123;</span><br><span class=\"line\">            minH.pop()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> minH.data</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"优先级队列\"><a href=\"#优先级队列\" class=\"headerlink\" title=\"优先级队列\"></a>优先级队列</h2><h4 id=\"google-面试题目：有一台机器会每隔一秒输出一个信号，请在每次输出信号的时候输出所有信号的中间值，如果信号数量位偶数则返回中间两数的平均值\"><a href=\"#google-面试题目：有一台机器会每隔一秒输出一个信号，请在每次输出信号的时候输出所有信号的中间值，如果信号数量位偶数则返回中间两数的平均值\" class=\"headerlink\" title=\"google 面试题目：有一台机器会每隔一秒输出一个信号，请在每次输出信号的时候输出所有信号的中间值，如果信号数量位偶数则返回中间两数的平均值\"></a>google 面试题目：有一台机器会每隔一秒输出一个信号，请在每次输出信号的时候输出所有信号的中间值，如果信号数量位偶数则返回中间两数的平均值</h4><p>题目连接：</p>\n<blockquote>\n<p>leetcode 这道题目还能够用排序是因为算的是所有一共的，如果是实时输出就每次都需要排序，所以直接维护一个结构更适合</p>\n</blockquote>\n<h1 id=\"链表：-如何利用”假头，新链表，双指针”解决链表类型题目\"><a href=\"#链表：-如何利用”假头，新链表，双指针”解决链表类型题目\" class=\"headerlink\" title=\"链表： 如何利用”假头，新链表，双指针”解决链表类型题目\"></a>链表： 如何利用”假头，新链表，双指针”解决链表类型题目</h1><blockquote>\n<p>解决链表问题的三板斧：<br>假头<br>新链表<br>双指针<br>链表尤其需要考虑各种边界条件、链表结构简单，但是查找交换反转非常容易出错</p>\n</blockquote>\n<h3 id=\"三板斧\"><a href=\"#三板斧\" class=\"headerlink\" title=\"三板斧\"></a>三板斧</h3><h4 id=\"假头\"><a href=\"#假头\" class=\"headerlink\" title=\"假头\"></a>假头</h4><p>在链表前面增加额外的节点–&gt; 可以节省许多对于nil指针的操作，能够节省不少的精力</p>\n<p>dummy 指针初始化之后就不会再发生改变了<br>tail  指针随着元素改变移动</p>\n<ol>\n<li>tail 插入节点</li>\n<li>头部插入节点</li>\n<li>查找结点（总是会查找目标节点的pre）</li>\n<li>在指定位置插入节点–&gt; getPre</li>\n<li>删除节点<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> linkList <span class=\"keyword\">interface</span>&#123;</span><br><span class=\"line\">    initDummyList()</span><br><span class=\"line\">    appendNode(*<span class=\"keyword\">interface</span>&#123;&#125;)<span class=\"type\">bool</span></span><br><span class=\"line\">    getPre(<span class=\"type\">int</span>)*<span class=\"keyword\">interface</span>&#123;&#125;</span><br><span class=\"line\">    findNode(<span class=\"type\">int</span>) *<span class=\"keyword\">interface</span>&#123;&#125;</span><br><span class=\"line\">    insertNode(*<span class=\"keyword\">interface</span>&#123;&#125;)<span class=\"type\">bool</span></span><br><span class=\"line\">    deletNode(<span class=\"type\">int</span>) <span class=\"type\">bool</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h1 id=\"树：-如何深度运用树的遍历\"><a href=\"#树：-如何深度运用树的遍历\" class=\"headerlink\" title=\"树： 如何深度运用树的遍历\"></a>树： 如何深度运用树的遍历</h1><blockquote>\n<p>大部分语言的map数据结构，基本上是基于树来实现的<br>b+树，红黑树，二叉树等等，在leetcode和考题当中常见二叉树，同时对于其他的树结构，可以通过二叉树的遍历来扩展出对应的遍历方式。</p>\n</blockquote>\n<h2 id=\"1-ensp-树节点的结构：\"><a href=\"#1-ensp-树节点的结构：\" class=\"headerlink\" title=\"1 &ensp; 树节点的结构：\"></a><strong>1</strong> &ensp; 树节点的结构：</h2><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> TreeNode <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">    val <span class=\"type\">int</span></span><br><span class=\"line\">    left *TreeNode</span><br><span class=\"line\">    right *TreeNode</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-ensp-前序遍历\"><a href=\"#2-ensp-前序遍历\" class=\"headerlink\" title=\"2 &ensp; 前序遍历\"></a><strong>2</strong> &ensp; 前序遍历</h2><blockquote>\n<p><font color='red'>遍历根节点、左子树、右子树</font></p>\n</blockquote>\n<h3 id=\"2-1-ensp-使用递归完成前序遍历\"><a href=\"#2-1-ensp-使用递归完成前序遍历\" class=\"headerlink\" title=\"2.1 &ensp; 使用递归完成前序遍历\"></a><strong>2.1</strong> &ensp; 使用递归完成前序遍历</h3><p>采用整体的思想：<br>首先遍历根节点，然后遍历左子树的时候，就把左子树放到相应的位置，遍历右子树的时候，就把右子树放到相应的位置。<br>然后展开左子树<br>然后展开右子树</p>\n<blockquote>\n<p>时间复杂度：O(N)<br>空间复杂度：O(K) K表示的树的高度<br><font color=CC6699>一定注意要问清楚:在访问每个节点的时候，是需要Print出来，还是放到一个链表/数组当中存储</font></p>\n</blockquote>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//使用递归方式</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">traverse</span><span class=\"params\">(root *TreeNode)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> root == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    traverse(root.Left)</span><br><span class=\"line\">    traverse(root.Right)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-ensp-使用栈完成前序遍历\"><a href=\"#2-2-ensp-使用栈完成前序遍历\" class=\"headerlink\" title=\"2.2 &ensp; 使用栈完成前序遍历\"></a><strong>2.2</strong> &ensp; 使用栈完成前序遍历</h3><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> TreeNode <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Val   <span class=\"type\">int</span></span><br><span class=\"line\">    Left  *TreeNode</span><br><span class=\"line\">    Right *TreeNode</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 前序遍历</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">preorderTraversal</span><span class=\"params\">(root *TreeNode)</span></span> []<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> root == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> []<span class=\"type\">int</span>&#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> res []<span class=\"type\">int</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> stack []*TreeNode</span><br><span class=\"line\">    stack = <span class=\"built_in\">append</span>(stack, root)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"built_in\">len</span>(stack) &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        node := stack[<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>]</span><br><span class=\"line\">        stack = stack[:<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>]</span><br><span class=\"line\">        res = <span class=\"built_in\">append</span>(res, node.Val)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> node.Right != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            stack = <span class=\"built_in\">append</span>(stack, node.Right)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> node.Left != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            stack = <span class=\"built_in\">append</span>(stack, node.Left)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-1-ensp-Morris-遍历-只需要O-1-的空间\"><a href=\"#2-2-1-ensp-Morris-遍历-只需要O-1-的空间\" class=\"headerlink\" title=\"2.2-1 &ensp; Morris 遍历: 只需要O(1)的空间\"></a><strong>2.2-1</strong> &ensp; Morris 遍历: 只需要O(1)的空间</h3><h3 id=\"2-3-ensp-题目\"><a href=\"#2-3-ensp-题目\" class=\"headerlink\" title=\"2.3 &ensp; 题目\"></a><strong>2.3</strong> &ensp; 题目</h3><p>下述为前序遍历常见题目</p>\n<h4 id=\"2-3-1-验证二叉树\"><a href=\"#2-3-1-验证二叉树\" class=\"headerlink\" title=\"2.3.1 验证二叉树\"></a><strong>2.3.1</strong> 验证二叉树</h4><p>验证一颗二叉树是否满足二叉搜索树的性质</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> basic <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">    node *TreeNode</span><br><span class=\"line\">    leftboard <span class=\"type\">int</span></span><br><span class=\"line\">    rightboard <span class=\"type\">int</span></span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">stackBst</span><span class=\"params\">(root *TreeNode)</span></span> <span class=\"type\">bool</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 构造边界影子树栈</span></span><br><span class=\"line\">    stack := <span class=\"built_in\">make</span>([]basic,<span class=\"number\">0</span>)</span><br><span class=\"line\">    left, right := math.MinInt64,math.MaxInt64</span><br><span class=\"line\">    <span class=\"keyword\">for</span> root != <span class=\"literal\">nil</span> || <span class=\"built_in\">len</span>(stack) &gt; <span class=\"number\">0</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 当还没有遍历完左子树</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> root != <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 判断不满足搜索树的节点要求</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> root.Val &lt;= left || root.Val &gt;= right &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 满足范围要求，那就要往下继续找</span></span><br><span class=\"line\">            <span class=\"comment\">// 先记录当前影子树的边界</span></span><br><span class=\"line\">            stack = <span class=\"built_in\">append</span>(stack, basic&#123;</span><br><span class=\"line\">                node: root,</span><br><span class=\"line\">                leftboard: left,</span><br><span class=\"line\">                rightboard: right,</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">            <span class=\"comment\">// 往下移动，同时缩小右边界</span></span><br><span class=\"line\">            right = root.Val</span><br><span class=\"line\">            root = root.Left</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 左子树遍历完了，找右子树</span></span><br><span class=\"line\">        top := stack[<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>]</span><br><span class=\"line\">        stack = stack[:<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 关键就是这里需要重新赋值比较的left和right</span></span><br><span class=\"line\">        root = top.node</span><br><span class=\"line\">        left,right = top.leftboard,top.rightboard</span><br><span class=\"line\">        left = root.Val</span><br><span class=\"line\">        root = root.Right       </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">isValidBST</span><span class=\"params\">(root *TreeNode)</span></span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> stackBst(root)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>或者是使用递归的方式</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">isValidBST</span><span class=\"params\">(root *TreeNode)</span></span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    ans := <span class=\"literal\">true</span></span><br><span class=\"line\">    ans = preOderBST(root,math.MinInt64,math.MaxInt64)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">preOderBST</span><span class=\"params\">(root *TreeNode, left <span class=\"type\">int</span>, right <span class=\"type\">int</span>)</span></span><span class=\"type\">bool</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> root == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> root.Val &lt;= left || root.Val &gt;= right &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> preOderBST(root.Left,left,root.Val) &amp;&amp; preOderBST(root.Right,root.Val,right)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// // 特殊在于 golang 的特点： 传参如果要一直修改其中的值，就需要传入一个引用，或者是采用闭包的方式</span></span><br><span class=\"line\"><span class=\"comment\">// func preOderBST(root *TreeNode, left int, right int, ans *bool)&#123;</span></span><br><span class=\"line\"><span class=\"comment\">// \t// 递归是否达到条件，即到达叶节点，到达叶节点表示所有节点都满足情况，所以为true</span></span><br><span class=\"line\"><span class=\"comment\">// \t// 第二个条件是 是否有判断出不满足的树，有的话ans就会变成false,直接返回</span></span><br><span class=\"line\"><span class=\"comment\">// \tif root == nil || !(*ans) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">// \t\treturn</span></span><br><span class=\"line\"><span class=\"comment\">// \t&#125;</span></span><br><span class=\"line\"><span class=\"comment\">// \t// 判断条件就是 当前的值要小于right同时大于left才满足</span></span><br><span class=\"line\"><span class=\"comment\">// \tif root.Val &lt;= left || root.Val &gt;= right &#123;</span></span><br><span class=\"line\"><span class=\"comment\">// \t\t*ans = false</span></span><br><span class=\"line\"><span class=\"comment\">// \t\treturn</span></span><br><span class=\"line\"><span class=\"comment\">// \t&#125;</span></span><br><span class=\"line\"><span class=\"comment\">// \t// 前序遍历</span></span><br><span class=\"line\"><span class=\"comment\">// \tpreOderBST(root.Left, left, root.Val, ans)</span></span><br><span class=\"line\"><span class=\"comment\">// \tpreOderBST(root.Right, root.Val, right, ans)</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-3-2-目标和的所有路径\"><a href=\"#2-3-2-目标和的所有路径\" class=\"headerlink\" title=\"2.3.2 目标和的所有路径\"></a><strong>2.3.2</strong> 目标和的所有路径</h4><p><a href=\"https://leetcode.cn/problems/path-sum/\">https://leetcode.cn/problems/path-sum/</a></p>\n<blockquote>\n<p>二叉树进行回溯的代码模板</p>\n<ul>\n<li>遇到新的节点： 路径总是从尾部添加节点</li>\n<li>遍历完节点，路径就把他从尾部扔掉</li>\n</ul>\n</blockquote>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// func hasPathSum(root *TreeNode, targetSum int) bool &#123;</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">//     var backTrace func(*TreeNode, int) bool</span></span><br><span class=\"line\"><span class=\"comment\">//     backTrace = func(root *TreeNode, Sum int)bool&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//         left , right := false,false </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//         if root == nil &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//             return false</span></span><br><span class=\"line\"><span class=\"comment\">//         &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//         Sum += root.Val</span></span><br><span class=\"line\"><span class=\"comment\">//         if root.Left == nil &amp;&amp; root.Right == nil &amp;&amp; Sum == targetSum &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//             return true</span></span><br><span class=\"line\"><span class=\"comment\">//         &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//         if root.Left != nil&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//             left = backTrace(root.Left,Sum)</span></span><br><span class=\"line\"><span class=\"comment\">//         &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//         if root.Right != nil&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//             right = backTrace(root.Right,Sum)</span></span><br><span class=\"line\"><span class=\"comment\">//         &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//         return left || right</span></span><br><span class=\"line\"><span class=\"comment\">//     &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//     return backTrace(root,0)</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// // 使用广度优先的遍历--层序遍历--队列</span></span><br><span class=\"line\"><span class=\"comment\">// func hasPathSum(root *TreeNode, targetSum int) bool &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//     if root == nil&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//         return false</span></span><br><span class=\"line\"><span class=\"comment\">//     &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//     fifo := make([]*TreeNode,0)</span></span><br><span class=\"line\"><span class=\"comment\">//     Qsize := 1</span></span><br><span class=\"line\"><span class=\"comment\">//     fifo = append(fifo,root)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//     for len(fifo) &gt; 0 &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//         for Qsize &gt; 0 &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//             top := fifo[0]</span></span><br><span class=\"line\"><span class=\"comment\">//             if top.Left == nil &amp;&amp; top.Right == nil &amp;&amp; top.Val == targetSum&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//                 return true</span></span><br><span class=\"line\"><span class=\"comment\">//             &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//             if top.Left != nil&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//                 top.Left.Val = top.Left.Val + top.Val</span></span><br><span class=\"line\"><span class=\"comment\">//                 fifo = append(fifo,top.Left)</span></span><br><span class=\"line\"><span class=\"comment\">//             &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//             if top.Right != nil&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//                 top.Right.Val = top.Right.Val + top.Val</span></span><br><span class=\"line\"><span class=\"comment\">//                 fifo = append(fifo,top.Right)</span></span><br><span class=\"line\"><span class=\"comment\">//             &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//             fifo = fifo[1:]</span></span><br><span class=\"line\"><span class=\"comment\">//             Qsize -= 1</span></span><br><span class=\"line\"><span class=\"comment\">//         &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//         Qsize = len(fifo)</span></span><br><span class=\"line\"><span class=\"comment\">//     &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//     return false</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用栈来存储，栈中元素是当前树的路径</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> path <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">    node *TreeNode</span><br><span class=\"line\">    sum <span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">hasPathSum</span><span class=\"params\">(root *TreeNode, targetSum <span class=\"type\">int</span>)</span></span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> root == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    paths := <span class=\"built_in\">make</span>([]path,<span class=\"number\">0</span>)</span><br><span class=\"line\">    paths = <span class=\"built_in\">append</span>(paths, path&#123;</span><br><span class=\"line\">        node: root,</span><br><span class=\"line\">        sum: root.Val,</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"built_in\">len</span>(paths) &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        node := paths[<span class=\"built_in\">len</span>(paths)<span class=\"number\">-1</span>]</span><br><span class=\"line\">        paths = paths[:<span class=\"built_in\">len</span>(paths)<span class=\"number\">-1</span>]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> node.node.Left == <span class=\"literal\">nil</span> &amp;&amp; node.node.Right == <span class=\"literal\">nil</span> &amp;&amp; node.sum == targetSum &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> node.node.Right != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            right := node.node.Right</span><br><span class=\"line\">            paths = <span class=\"built_in\">append</span>(paths,path&#123;</span><br><span class=\"line\">                node: right,</span><br><span class=\"line\">                sum: right.Val + node.sum,</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> node.node.Left != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            left := node.node.Left</span><br><span class=\"line\">            paths = <span class=\"built_in\">append</span>(paths,path&#123;</span><br><span class=\"line\">                node: left,</span><br><span class=\"line\">                sum: left.Val + node.sum,</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-3-3-得到路径和为指定数字的路径集合\"><a href=\"#2-3-3-得到路径和为指定数字的路径集合\" class=\"headerlink\" title=\"2.3.3 得到路径和为指定数字的路径集合\"></a><strong>2.3.3</strong> 得到路径和为指定数字的路径集合</h4><p><a href=\"https://leetcode.cn/problems/path-sum-ii/solution/\">https://leetcode.cn/problems/path-sum-ii/solution/</a><br><font color='red'> 这道题目非常重要：有两大问题都在这个地方表现出来了</font></p>\n<p>==Golang的特性：Defer函数的使用==<br>这道题目在使用前序遍历的时候，由于在叶子节点以及从左子树转换为右子树的时候都需要将原本记录在path当中的路径节点删除pop出来，递归时候就需要考虑在什么时候执行出栈操作，没错即便是在递归当中也还是必须要考虑栈的操作，因为需要一个连续记录的路径信息</p>\n<p>关键在于pop的时机：pop的时机是：1. 本身是叶子节点，直接return 结束dfs，2. 左右的子树都被递归判断过的树中结点，也就是dfs(Left),dfs(Right)正常结束，刚好发现二者均都是在dfs执行完之后执行，而且覆盖了dfs执行完之后所有的情况<br>同时 Golang 的 <strong>Defer(){}</strong> 会在函数执行完并在返回之前执行，完全满足这个场景的需求，所以可以在递归函数体当中使用defer来完成对应的操作</p>\n<p>==Golang的特性：切片索引==<br>切片本身就是指针，且每次操作都会影响到底层数组<br>如果不在递归函数体当中使用切片之前重新对切片进行赋值，那么，之后对于底层数组的操作也会反映到之前的切片上，产生的效果就是明明原本计算好了结果但最后得到的并不是正确答案，关键就在于==后面切片的操作修改了底层数组，导致原本切片对应的结果被修改了==</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">pathSum</span><span class=\"params\">(root *TreeNode, targetSum <span class=\"type\">int</span>)</span></span> [][]<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    result := <span class=\"built_in\">make</span>([][]<span class=\"type\">int</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">    path := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> root == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> dfs <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(*TreeNode,<span class=\"type\">int</span>)</span></span></span><br><span class=\"line\">    dfs = <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(root *TreeNode,left <span class=\"type\">int</span>)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> root == <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        path = <span class=\"built_in\">append</span>(path,root.Val)</span><br><span class=\"line\">        left = left - root.Val</span><br><span class=\"line\">        <span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123; </span><br><span class=\"line\">            path = path[:<span class=\"built_in\">len</span>(path)<span class=\"number\">-1</span>]</span><br><span class=\"line\">        &#125;()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> root.Left == <span class=\"literal\">nil</span> &amp;&amp; root.Right == <span class=\"literal\">nil</span> &amp;&amp; left == <span class=\"number\">0</span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// new := make([]int,len(path))</span></span><br><span class=\"line\">            <span class=\"comment\">// copy(new,path)</span></span><br><span class=\"line\">            <span class=\"comment\">// result = append(result,new)</span></span><br><span class=\"line\">            result = <span class=\"built_in\">append</span>(result,<span class=\"built_in\">append</span>([]<span class=\"type\">int</span>(<span class=\"literal\">nil</span>),path...))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        dfs(root.Left,left)</span><br><span class=\"line\">        dfs(root.Right,left)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dfs(root,targetSum)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-3-3\"><a href=\"#2-3-3\" class=\"headerlink\" title=\"2.3.3\"></a><strong>2.3.3</strong></h4><blockquote>\n<p>等待回溯来看<br><a href=\"https://leetcode.cn/problems/path-sum-iii/solution/437-lu-jing-zong-he-iii-dfshui-su-qian-zhui-he-yi-/\">https://leetcode.cn/problems/path-sum-iii/solution/437-lu-jing-zong-he-iii-dfshui-su-qian-zhui-he-yi-/</a></p>\n</blockquote>\n<h2 id=\"3-中序遍历\"><a href=\"#3-中序遍历\" class=\"headerlink\" title=\"3 中序遍历\"></a><strong>3</strong> 中序遍历</h2><p><font color='red'>遍历左子树，然后是根节点，然后是右子树</font></p>\n<h3 id=\"3-1-ensp-使用递归完成中序遍历\"><a href=\"#3-1-ensp-使用递归完成中序遍历\" class=\"headerlink\" title=\"3.1 &ensp; 使用递归完成中序遍历\"></a><strong>3.1</strong> &ensp; 使用递归完成中序遍历</h3><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-ensp-使用栈完成中序遍历\"><a href=\"#3-2-ensp-使用栈完成中序遍历\" class=\"headerlink\" title=\"3.2 &ensp; 使用栈完成中序遍历\"></a><strong>3.2</strong> &ensp; 使用栈完成中序遍历</h3><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">inorderTraversal</span><span class=\"params\">(root *TreeNode)</span></span> []<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> root == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> []<span class=\"type\">int</span>&#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> res []<span class=\"type\">int</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> stack []*TreeNode</span><br><span class=\"line\">    <span class=\"keyword\">var</span> pathStack []<span class=\"type\">string</span></span><br><span class=\"line\">    node := root</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> node != <span class=\"literal\">nil</span> || <span class=\"built_in\">len</span>(stack) &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> node != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            stack = <span class=\"built_in\">append</span>(stack, node)</span><br><span class=\"line\">            pathStack = <span class=\"built_in\">append</span>(pathStack, fmt.Sprintf(<span class=\"string\">&quot;%d&quot;</span>, node.Val))</span><br><span class=\"line\">            node = node.Left</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            node = stack[<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>]</span><br><span class=\"line\">            stack = stack[:<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>]</span><br><span class=\"line\">            path := pathStack[<span class=\"built_in\">len</span>(pathStack)<span class=\"number\">-1</span>]</span><br><span class=\"line\">            pathStack = pathStack[:<span class=\"built_in\">len</span>(pathStack)<span class=\"number\">-1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> node.Left == <span class=\"literal\">nil</span> &amp;&amp; node.Right == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">                res = <span class=\"built_in\">append</span>(res, node.Val)</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 输出到达叶子节点的路径</span></span><br><span class=\"line\">                fmt.Println(path)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            node = node.Right</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-3-找出二叉搜索树里面出现次数最多的数\"><a href=\"#3-3-找出二叉搜索树里面出现次数最多的数\" class=\"headerlink\" title=\"3.3 找出二叉搜索树里面出现次数最多的数\"></a><strong>3.3</strong> 找出二叉搜索树里面出现次数最多的数</h3><p>找众数就需要遍历所有的节点，二叉搜索树中序遍历的结果会是一个递增的数组，其数据特性就在于使用中序遍历的时候，所有的元素都是连续的</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * type TreeNode struct &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     Val int</span></span><br><span class=\"line\"><span class=\"comment\"> *     Left *TreeNode</span></span><br><span class=\"line\"><span class=\"comment\"> *     Right *TreeNode</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">findMode</span><span class=\"params\">(root *TreeNode)</span></span> []<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 结果数组</span></span><br><span class=\"line\">    ans := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">    base,count,maxnum := math.MinInt64,<span class=\"number\">0</span>,<span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使用递归的方式</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> dfs <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(*TreeNode)</span></span></span><br><span class=\"line\">    dfs = <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(root *TreeNode)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> root == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        dfs(root.Left)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> root.Val == base &#123;</span><br><span class=\"line\">            count++</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            base = root.Val</span><br><span class=\"line\">            count = <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> count == maxnum &#123;</span><br><span class=\"line\">            ans = <span class=\"built_in\">append</span>(ans,base)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> count &gt; maxnum &#123;</span><br><span class=\"line\">            ans = []<span class=\"type\">int</span>&#123;&#125;</span><br><span class=\"line\">            maxnum = count</span><br><span class=\"line\">            ans = <span class=\"built_in\">append</span>(ans,base)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        dfs(root.Right)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dfs(root)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-4-找出二叉搜索树里面任意两个节点之间绝对值得最小值\"><a href=\"#3-4-找出二叉搜索树里面任意两个节点之间绝对值得最小值\" class=\"headerlink\" title=\"3.4 找出二叉搜索树里面任意两个节点之间绝对值得最小值\"></a><strong>3.4</strong> 找出二叉搜索树里面任意两个节点之间绝对值得最小值</h3><p><a href=\"https://leetcode.cn/problems/minimum-distance-between-bst-nodes/\">https://leetcode.cn/problems/minimum-distance-between-bst-nodes/</a></p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">minDiffInBST</span><span class=\"params\">(root *TreeNode)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用栈来中序遍历，栈顶元素就是上一遍历的节点元素</span></span><br><span class=\"line\">    stack := <span class=\"built_in\">make</span>([]*TreeNode,<span class=\"number\">0</span>)</span><br><span class=\"line\">    res := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> root != <span class=\"literal\">nil</span> || <span class=\"built_in\">len</span>(stack) &gt; <span class=\"number\">0</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> root != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            stack = <span class=\"built_in\">append</span>(stack,root)</span><br><span class=\"line\">            root = root.Left</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        node := stack[<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>]</span><br><span class=\"line\">        stack = stack[:<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>]</span><br><span class=\"line\">        res = <span class=\"built_in\">append</span>(res,node.Val)</span><br><span class=\"line\"></span><br><span class=\"line\">        root = node</span><br><span class=\"line\">        root = root.Right</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    m := math.MaxInt64</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i:= <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(res)<span class=\"number\">-1</span>; i++&#123;</span><br><span class=\"line\">        r := res[i+<span class=\"number\">1</span>]-res[i]</span><br><span class=\"line\">        m = min(m,r) </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> m</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">min</span><span class=\"params\">(args ...<span class=\"type\">int</span>)</span></span><span class=\"type\">int</span>&#123;</span><br><span class=\"line\">    min := args[<span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, val := <span class=\"keyword\">range</span> args&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> val &lt; min &#123;</span><br><span class=\"line\">            min = val</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> min</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-5-一棵二叉搜索树的两个节点被交换了，恢复这颗二叉搜索树\"><a href=\"#3-5-一棵二叉搜索树的两个节点被交换了，恢复这颗二叉搜索树\" class=\"headerlink\" title=\"3.5 一棵二叉搜索树的两个节点被交换了，恢复这颗二叉搜索树\"></a><strong>3.5</strong> 一棵二叉搜索树的两个节点被交换了，恢复这颗二叉搜索树</h3><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">recoverTree</span><span class=\"params\">(root *TreeNode)</span></span>  &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用递归解决这个问题</span></span><br><span class=\"line\">    problem := <span class=\"built_in\">make</span>([]*TreeNode,<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">var</span> findP <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(*TreeNode)</span></span></span><br><span class=\"line\">    findP = <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(root *TreeNode)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> root == <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        findP(root.Left)</span><br><span class=\"line\">        <span class=\"comment\">// if pre == math.MaxInt64&#123;</span></span><br><span class=\"line\">        <span class=\"comment\">//     pre = root.Val</span></span><br><span class=\"line\">        <span class=\"comment\">//     return</span></span><br><span class=\"line\">        <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">        <span class=\"comment\">// if root.Val - pre &lt; 0&#123;</span></span><br><span class=\"line\">        <span class=\"comment\">//     problem = append(problem,root)</span></span><br><span class=\"line\">        <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">        <span class=\"comment\">// pre = root.Val</span></span><br><span class=\"line\">        problem = <span class=\"built_in\">append</span>(problem, root)</span><br><span class=\"line\">        findP(root.Right)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    findP(root)</span><br><span class=\"line\">    pre,cur := <span class=\"number\">-1</span>,<span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(problem)<span class=\"number\">-1</span>; i++&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> problem[i].Val &gt; problem[i+<span class=\"number\">1</span>].Val &#123;</span><br><span class=\"line\">            cur = i + <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> pre == <span class=\"number\">-1</span> &#123;</span><br><span class=\"line\">                pre = i</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    problem[pre].Val,problem[cur].Val = problem[cur].Val,problem[pre].Val</span><br><span class=\"line\">    <span class=\"keyword\">return</span> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"删除二叉搜索树的节点\"><a href=\"#删除二叉搜索树的节点\" class=\"headerlink\" title=\"删除二叉搜索树的节点\"></a>删除二叉搜索树的节点</h3><blockquote>\n<p>题目最重要的考点就是分类，讨论各种情况下的处理方式</p>\n</blockquote>\n<p><font sizecolor ='red'>清晰地讲出每种情况的处理办法</font><br><font sizecolor ='red'>清晰简介地实现代码</font></p>\n<h2 id=\"后序遍历\"><a href=\"#后序遍历\" class=\"headerlink\" title=\"后序遍历\"></a>后序遍历</h2><h3 id=\"使用栈完成后序遍历\"><a href=\"#使用栈完成后序遍历\" class=\"headerlink\" title=\"使用栈完成后序遍历\"></a>使用栈完成后序遍历</h3><h3 id=\"迭代写法的考点\"><a href=\"#迭代写法的考点\" class=\"headerlink\" title=\"迭代写法的考点\"></a>迭代写法的考点</h3><ol>\n<li>是否有右子树</li>\n<li>pre指针是不是指向当前结点的右子树</li>\n</ol>\n","site":{"data":{}},"cover":"/img/cover/sky4.png","cover_type":"img","excerpt":"","more":"<h1 id=\"告别盲目刷题，击破算法面试\"><a href=\"#告别盲目刷题，击破算法面试\" class=\"headerlink\" title=\"告别盲目刷题，击破算法面试\"></a>告别盲目刷题，击破算法面试</h1><blockquote>\n<p>学习拉钩教育算法课程记录加个人感悟记录<br>如果有版权问题，请联系 <a href=\"mailto:&#50;&#x33;&#55;&#x34;&#48;&#x38;&#x37;&#51;&#x32;&#50;&#64;&#x71;&#113;&#x2e;&#x63;&#x6f;&#109;\">&#50;&#x33;&#55;&#x34;&#48;&#x38;&#x37;&#51;&#x32;&#50;&#64;&#x71;&#113;&#x2e;&#x63;&#x6f;&#109;</a> 删除课程部分的内容</p>\n<p>算法能力的高度，决定了个人能够解决的实战问题复杂度的上限</p>\n<p>数学基础决定了算法能力的高低</p>\n</blockquote>\n<h2 id=\"解题流程-：\"><a href=\"#解题流程-：\" class=\"headerlink\" title=\"==解题流程==：\"></a>==解题流程==：</h2><h3 id=\"四部分析法\"><a href=\"#四部分析法\" class=\"headerlink\" title=\"==四部分析法==\"></a>==四部分析法==</h3><ul>\n<li><p><strong>==模拟==</strong> ： 模拟题目的运行<br>使用简单且有一定量的小例子，将自己当作计算机来执行这个流程<br><em>一般使用题目给的较长的那个例子就可以</em></p>\n<p>这部分也是读题和理解输入输出内容的部分，理解题意的部分</p>\n<p>这个时候一定不能够着急，不要害怕或者是觉得麻烦，一定要耐下性子，把简单的一个逻辑过程给跑清楚，理解这段程序或者是业务需要咱们处理什么样的问题。</p>\n<p>跑的过程，不要完全先入为主，应当以题目的要求来推进演示。</p>\n<p>不要想着在这一步就把所有的问题都给解决，一步步推进就可以. </p>\n</li>\n<li><p><strong>==规律==</strong> ： 尝试总结出题目的一般规律和特点</p>\n<p>数学规律和特性一般来说很难直接从零归纳出来，但我们可以依赖所学习的高数、线性代数、离散数学、测度论等高等数学理论当中所见到的数学计算模型来匹配，这也是这部分最重要的基础</p>\n<p>先总结一些考题可能会用到的观察特点：</p>\n<ul>\n<li>形式相关：比如 括号匹配、从1加到100，</li>\n<li>数量变化：数量变化与取模相关，数量变化呈现递推公式</li>\n<li></li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p><strong>==匹配==</strong> ： 找到符合这些特点的数据结构和算法</p>\n<ul>\n<li><p>关注数据的输入类型：对输入数据进行分类，哪一些数据进行怎样的操作</p>\n</li>\n<li><p>**==怎样匹配呢？==**：</p>\n<ul>\n<li>题目模拟的时候（这部分一般使用栈、队列、二叉树）来理解题目要求的数字变化</li>\n<li>观察结果集合，或者是原本中间的变化集合，当期符合某种数据结构的变化特征的时候，就可以选用这个数据结构</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>**==考虑边界条件==**： 考虑特殊情况<br>特殊情况：<ul>\n<li>字符串为空，字符串只有一个，两个、</li>\n<li>数组为空，数字为0或者是其他不符合规律的特殊情况</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><strong>==深度思考==</strong> ： 平时练习当中的流程，用于提高算法模型的积累<ul>\n<li>深度： 这种解法还可以怎么优化</li>\n<li>广度： 这种解法的具有普适性吗？可以推广吗？问题的限定条件变多的话，这个模型是否还可以适合。</li>\n<li>数学模式扩散： 这样特点的问题是否有对应的数学模型或者是理论描述过</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"栈：-从简单栈到单调栈，让栈问题不再困难\"><a href=\"#栈：-从简单栈到单调栈，让栈问题不再困难\" class=\"headerlink\" title=\"栈： 从简单栈到单调栈，让栈问题不再困难\"></a>栈： 从简单栈到单调栈，让栈问题不再困难</h1><h2 id=\"结构特征\"><a href=\"#结构特征\" class=\"headerlink\" title=\"结构特征\"></a>结构特征</h2><p>先进后出</p>\n<p>对栈的操作：</p>\n<ul>\n<li><strong>==pop==</strong> 弹出栈顶元素，一般来说栈中可操作的元素就是栈顶元素，其他元素也都是先pop出其上面的元素，变成栈顶元素之后再进行操作。</li>\n<li> <strong>==peek==</strong> 获取栈顶元素，只是读取操作，但并没有弹出栈顶元素</li>\n<li> <strong>==push==</strong> 将元素压入栈中</li>\n</ul>\n<h3 id=\"Golang-栈的使用\"><a href=\"#Golang-栈的使用\" class=\"headerlink\" title=\"Golang 栈的使用\"></a>Golang 栈的使用</h3><p>在 Go 中并没有直接提供Stack的方法结构，但可以使用切片非常简单地表示和使用栈、队列结构。</p>\n<p> 先进后出的数据结构，使用**==切片==**表示，压入栈的操作就是往切片中添加元素，弹出栈的操作就是输出末尾元素，并将切片缩小为：<code>[:len(stack)-1]</code></p>\n<p>以下为栈的代码模板实现：</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Stack <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">    Stack []<span class=\"keyword\">interface</span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *Stack)</span></span>push(x <span class=\"keyword\">interface</span>&#123;&#125;)&#123;</span><br><span class=\"line\">    s = <span class=\"built_in\">append</span>(s,x)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *Stack)</span></span>pop()&#123;</span><br><span class=\"line\">    s = s[:<span class=\"built_in\">len</span>(s)<span class=\"number\">-1</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *Stack)</span></span>peek()(x <span class=\"keyword\">interface</span>&#123;&#125;)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s[<span class=\"built_in\">len</span>(s)<span class=\"number\">-1</span>]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>关键在于记住：</p>\n<ul>\n<li>栈顶元素 —&gt; 切片末尾元素</li>\n<li>切片是左闭右开，所以pop操作是 s = s[:len(s)-1], 但如果是队列pop出第一个元素就需要往后再移动一位 s = s[1:] 而不是 s = s[0:]</li>\n</ul>\n<h2 id=\"典型题目\"><a href=\"#典型题目\" class=\"headerlink\" title=\"典型题目\"></a>典型题目</h2><h3 id=\"判断字符串是否合法\"><a href=\"#判断字符串是否合法\" class=\"headerlink\" title=\"判断字符串是否合法\"></a>判断字符串是否合法</h3><p>题目：<a href=\"https://leetcode.cn/problems/valid-parentheses/\">https://leetcode.cn/problems/valid-parentheses/</a></p>\n<h4 id=\"正确解法和流程\"><a href=\"#正确解法和流程\" class=\"headerlink\" title=\"正确解法和流程\"></a>正确解法和流程</h4><p><a href=\"https://leetcode.cn/link/?target=https://www.bilibili.com/video/BV1AF411w78g\">https://leetcode.cn/link/?target=https://www.bilibili.com/video/BV1AF411w78g</a></p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">isValid</span><span class=\"params\">(s <span class=\"type\">string</span>)</span></span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    n := <span class=\"built_in\">len</span>(s)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> n % <span class=\"number\">2</span> == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    pairs := <span class=\"keyword\">map</span>[<span class=\"type\">byte</span>]<span class=\"type\">byte</span>&#123;</span><br><span class=\"line\">        <span class=\"string\">&#x27;)&#x27;</span>: <span class=\"string\">&#x27;(&#x27;</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;]&#x27;</span>: <span class=\"string\">&#x27;[&#x27;</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;&#125;&#x27;</span>: <span class=\"string\">&#x27;&#123;&#x27;</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    stack := []<span class=\"type\">byte</span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; n; i++ &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> pairs[s[i]] &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(stack) == <span class=\"number\">0</span> || stack[<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>] != pairs[s[i]] &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            stack = stack[:<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>]</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            stack = <span class=\"built_in\">append</span>(stack, s[i])</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(stack) == <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"个人解法和流程\"><a href=\"#个人解法和流程\" class=\"headerlink\" title=\"个人解法和流程\"></a>个人解法和流程</h4><blockquote>\n<p>问题集中体现在数据特性处理判断太过分散，属实是缝缝补补有一年<br>对输入数据进行分类，哪一些数据进行怎样的操作</p>\n<ul>\n<li>输入的是左括号应该入栈</li>\n<li>输入的是右括号应该做判断<br /></li>\n</ul>\n</blockquote>\n<p>我的代码是：</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">isValid</span><span class=\"params\">(s <span class=\"type\">string</span>)</span></span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    l := <span class=\"built_in\">len</span>(s)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> l%<span class=\"number\">2</span> != <span class=\"number\">0</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    stack := <span class=\"built_in\">make</span>([]<span class=\"type\">rune</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    m := <span class=\"keyword\">map</span>[<span class=\"type\">rune</span>]<span class=\"type\">rune</span>&#123;</span><br><span class=\"line\">        <span class=\"string\">&#x27;]&#x27;</span>:<span class=\"string\">&#x27;[&#x27;</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;)&#x27;</span>:<span class=\"string\">&#x27;(&#x27;</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;&#125;&#x27;</span>:<span class=\"string\">&#x27;&#123;&#x27;</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _,v := <span class=\"keyword\">range</span> s&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> v == <span class=\"string\">&#x27;[&#x27;</span> ||v == <span class=\"string\">&#x27;&#123;&#x27;</span> ||v == <span class=\"string\">&#x27;(&#x27;</span>&#123;</span><br><span class=\"line\">            stack = <span class=\"built_in\">append</span>(stack,v)</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(stack) == <span class=\"number\">0</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> stack[<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>] == m[v]&#123;</span><br><span class=\"line\">            stack = stack[:<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>]</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> m[v] != <span class=\"number\">0</span> &#123;<span class=\"keyword\">return</span> <span class=\"literal\">false</span>&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(stack) == <span class=\"number\">0</span>&#123;<span class=\"keyword\">return</span> <span class=\"literal\">true</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述在判断栈顶元素的时候逻辑不够清晰，所以加了很多的if来补足条件，我们看例子当中所给的逻辑顺序：</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    pairs := <span class=\"keyword\">map</span>[<span class=\"type\">byte</span>]<span class=\"type\">byte</span>&#123;</span><br><span class=\"line\">    <span class=\"string\">&#x27;)&#x27;</span>: <span class=\"string\">&#x27;(&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;]&#x27;</span>: <span class=\"string\">&#x27;[&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;&#125;&#x27;</span>: <span class=\"string\">&#x27;&#123;&#x27;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">stack := []<span class=\"type\">byte</span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; n; i++ &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> pairs[s[i]] &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(stack) == <span class=\"number\">0</span> || stack[<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>] != pairs[s[i]] &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        stack = stack[:<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>]</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        stack = <span class=\"built_in\">append</span>(stack, s[i])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(stack) == <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n\n<p>关键差距就在于这一句话：<code>pairs[s[i]] &gt; 0 </code>, 这个判断对输入的数据做了一次分类，依据上面的map结构可知，这句话 &lt; 0 时候标识map当中没有存储对应的对象，而map中存储的是所有的左括号，所以这个判断的作用是<strong>当输入是右括号的时候进入函数</strong>，然后逻辑体依据输入是右括号判断，如果当前栈里面没有元素或者是栈顶元素与右括号不匹配那么就返回false<br><br>实际上我写的函数最后夜市做了类似的判断，但显然没有考虑数据分类的情况。</p>\n<h3 id=\"判断大鱼吃小鱼最后留下的鱼\"><a href=\"#判断大鱼吃小鱼最后留下的鱼\" class=\"headerlink\" title=\"判断大鱼吃小鱼最后留下的鱼\"></a>判断大鱼吃小鱼最后留下的鱼</h3><p>题目：</p>\n<p>近似题目：<a href=\"https://www.nowcoder.com/questionTerminal/3fdfc63015df42c6a78fdae46709fa69?f=discussion\">https://www.nowcoder.com/questionTerminal/3fdfc63015df42c6a78fdae46709fa69?f=discussion</a></p>\n<br />\n\n<h4 id=\"正确解法和流程-1\"><a href=\"#正确解法和流程-1\" class=\"headerlink\" title=\"正确解法和流程\"></a>正确解法和流程</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * </span></span><br><span class=\"line\"><span class=\"comment\">     * @param N int整型 N条鱼</span></span><br><span class=\"line\"><span class=\"comment\">     * @param A int整型vector 每条鱼的体积为Ai</span></span><br><span class=\"line\"><span class=\"comment\">     * @return int整型</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">P</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> x, t;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">solve</span><span class=\"params\">(<span class=\"type\">int</span> N, vector&lt;<span class=\"type\">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class=\"line\">        stack&lt;P&gt; S;</span><br><span class=\"line\">        <span class=\"type\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=N<span class=\"number\">-1</span>;i&gt;=<span class=\"number\">0</span>;i--)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> t = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(!S.<span class=\"built_in\">empty</span>() &amp;&amp; A[i]&gt;S.<span class=\"built_in\">top</span>().x)&#123;</span><br><span class=\"line\">                t = <span class=\"built_in\">max</span>(S.<span class=\"built_in\">top</span>().t, t+<span class=\"number\">1</span>);</span><br><span class=\"line\">                S.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            S.<span class=\"built_in\">push</span>(&#123;A[i], t&#125;);</span><br><span class=\"line\">            cnt = <span class=\"built_in\">max</span>(cnt, t);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cnt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"个人解法和流程-1\"><a href=\"#个人解法和流程-1\" class=\"headerlink\" title=\"个人解法和流程\"></a>个人解法和流程</h4><p>由于找不到相同的题目，就找了类似的题目，但是解题的思路不太一样<br>图片上的大鱼吃小鱼，只需要每次比较栈顶元素和新进来的元素大小即可，当大于的时候，就不做操作，当栈顶元素小于输入元素的时候，pop出栈顶元素并push进入这个最大值，最后栈中元素就是结果。这个过程当中几处需要重视的地方是：</p>\n<ul>\n<li>当鱼的方向一致时候，大鱼并不会把同方向的小鱼给吃了【可能不论大小鱼的速度相同（bushi）】，而如果小鱼在左，大鱼在右，方向不同，则也不会吃</li>\n</ul>\n<p>牛客网的题目则加了非常多的条件和限制，是对栈问题的一个较大的变化</p>\n<blockquote>\n<p>对比上述两个题目可以观察到：<br><font color ='blue'> 1. 消除的行为不同</font><br>  括号匹配中，消除行为是配对的两者都会消除，也就是栈顶元素和输入元素一起被消除<br>  大鱼吃小鱼中，消除行为是配对的两者中会有一个被消除<br>–&gt; 是否入栈和出栈的判断<br><font color ='blue'> 2. 栈中的内容不同</font><br>  括号匹配当中，栈中存放的就是内容本身<br>  大鱼吃小鱼当中，栈里存放的是内容的索引，可以通过索引找到内容<br><font color ='blue'> 3. 弹栈的方式也不相同</font><br>  括号匹配只需要每次弹出一个元素就可以<br>  大鱼则需要用while语句一直弹出到满足某个条件才停止</p>\n</blockquote>\n<h2 id=\"栈问题的特征和解决流程\"><a href=\"#栈问题的特征和解决流程\" class=\"headerlink\" title=\"栈问题的特征和解决流程\"></a>栈问题的特征和解决流程</h2><h3 id=\"pop-行为不同\"><a href=\"#pop-行为不同\" class=\"headerlink\" title=\"pop 行为不同\"></a>pop 行为不同</h3><p>pop【弹栈的操作不一样】<br>常见的就是每次循环都判断栈顶元素的特点而pop或者push或者不操作，但这样必须得是连续性的元素才有这样的特征</p>\n<p><strong>==在弹栈的时候，是否一定要满足某个条件才停止弹栈==</strong><br>也就是说当输入元素之后需要将其和站内其他的元素进行比较，在使用的时候尤其要注意迭代过程</p>\n<h3 id=\"栈中存储内容不相同\"><a href=\"#栈中存储内容不相同\" class=\"headerlink\" title=\"栈中存储内容不相同\"></a>栈中存储内容不相同</h3><p>是否栈中存储数据、还是存储索引、还是存储一个自建的新的结构</p>\n<h3 id=\"栈顶元素的含义不相同\"><a href=\"#栈顶元素的含义不相同\" class=\"headerlink\" title=\"栈顶元素的含义不相同\"></a>栈顶元素的含义不相同</h3><h2 id=\"单调栈\"><a href=\"#单调栈\" class=\"headerlink\" title=\"单调栈\"></a>单调栈</h2><p>单调栈是指栈中元素必须按照升序排列的栈或者是降序排列的栈</p>\n<p>单调栈分为：</p>\n<ul>\n<li><p>递增栈：<br>  栈中元素从左到右遵守从小到大的顺序<br>  入栈时候，当<strong>入栈元素小于栈顶元素</strong>就会pop出栈顶元素，直到入栈元素大于栈顶元素<br>  特点是：<br>  入栈小数会消除栈内大数</p>\n</li>\n<li><p>递减栈<br>  栈中元素从左到右遵守从大到小的顺序<br>  入栈时候，当<strong>入栈元素大于栈顶元素</strong>就会pop出栈顶元素，直到入栈元素小于栈顶元素<br>  特点是：<br>  入栈大数会消除栈内小数</p>\n</li>\n</ul>\n<h3 id=\"典型代码：\"><a href=\"#典型代码：\" class=\"headerlink\" title=\"典型代码：\"></a>典型代码：</h3><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stack := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"comment\">/**递增栈的入栈</span></span><br><span class=\"line\"><span class=\"comment\">* 用for 循环出栈，直到栈顶元素满足递增栈的要求</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> <span class=\"built_in\">len</span>(stack)&gt; <span class=\"number\">0</span> &amp;&amp; A[i] &gt; stack[<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>]&#123;</span><br><span class=\"line\">    <span class=\"comment\">// pop出栈内比 A[i]小但却在前面的元素</span></span><br><span class=\"line\">    stack = stack[:<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">stack = <span class=\"built_in\">append</span>(stack,A[i])</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"找到当前数字右边最小的对应数字\"><a href=\"#找到当前数字右边最小的对应数字\" class=\"headerlink\" title=\"找到当前数字右边最小的对应数字\"></a>找到当前数字右边最小的对应数字</h3><h3 id=\"取k个字符，求字典序最小的组合\"><a href=\"#取k个字符，求字典序最小的组合\" class=\"headerlink\" title=\"取k个字符，求字典序最小的组合\"></a>取k个字符，求字典序最小的组合</h3><blockquote>\n<p>字典序：</p>\n<ul>\n<li>对单个元素按照ascii 表中大小顺序排列</li>\n<li>多个元素时，按照从左到右顺序，先从高位字典排序，然后在相同高位中按照地位再字典排序</li>\n</ul>\n</blockquote>\n<h3 id=\"给定一个数组，数组中元素代表模板的高度，请你求出相邻木板能剪出的最大矩形面积\"><a href=\"#给定一个数组，数组中元素代表模板的高度，请你求出相邻木板能剪出的最大矩形面积\" class=\"headerlink\" title=\"给定一个数组，数组中元素代表模板的高度，请你求出相邻木板能剪出的最大矩形面积\"></a>给定一个数组，数组中元素代表模板的高度，请你求出相邻木板能剪出的最大矩形面积</h3><blockquote>\n<p>和求最大容积是一个题目</p>\n</blockquote>\n<br />\n\n<h2 id=\"leetcode-题目汇总\"><a href=\"#leetcode-题目汇总\" class=\"headerlink\" title=\"leetcode 题目汇总\"></a>leetcode 题目汇总</h2><blockquote>\n<p>以leetcode 题目为例子</p>\n</blockquote>\n<p>相关栈的题目汇总：<br>[1][<a href=\"https://leetcode.cn/problem-list/xb9nqhhg/?topicSlugs=stack&amp;page=1%5D\">https://leetcode.cn/problem-list/xb9nqhhg/?topicSlugs=stack&amp;page=1]</a><br>[2][<a href=\"https://leetcode.cn/problem-list/e8X3pBZi/?page=1&amp;topicSlugs=heap-priority-queue%5D\">https://leetcode.cn/problem-list/e8X3pBZi/?page=1&amp;topicSlugs=heap-priority-queue]</a><br>[3][<a href=\"https://leetcode.cn/problem-list/2cktkvj/?page=1&amp;topicSlugs=stack%5D\">https://leetcode.cn/problem-list/2cktkvj/?page=1&amp;topicSlugs=stack]</a></p>\n<h1 id=\"队列：FIFO-队列与单调队列的深挖与扩展\"><a href=\"#队列：FIFO-队列与单调队列的深挖与扩展\" class=\"headerlink\" title=\"队列：FIFO 队列与单调队列的深挖与扩展\"></a>队列：FIFO 队列与单调队列的深挖与扩展</h1><p>先进先出，是共同特征</p>\n<p>类别上可以分出：</p>\n<ul>\n<li>FIFO队列</li>\n<li>单调队列</li>\n</ul>\n<h2 id=\"FIFO队列\"><a href=\"#FIFO队列\" class=\"headerlink\" title=\"FIFO队列\"></a>FIFO队列</h2><p><strong>==Push 元素时候， 总是将放在元素放在队列尾部，也就是操作 fifo[len(fifo)-1]==</strong><br><strong>==Pop 元素时候，总是将队列首部的元素扔掉 ，也就是操作 fifo = fifo[1:]==</strong></p>\n<h3 id=\"二叉树的层次遍历（两种方法）\"><a href=\"#二叉树的层次遍历（两种方法）\" class=\"headerlink\" title=\"二叉树的层次遍历（两种方法）\"></a>二叉树的层次遍历（两种方法）</h3><ul>\n<li><p>规律：<br>广度遍历（层次遍历）：由于二叉树的特点，当拿到第N层的结点A之后，可以通过 A 的left，right指针拿到下一层的节点<br><strong>但是与A在同一层的节点还有其他吗，这个时候就需要按层来存储节点，不能直接使用递归</strong></p>\n  <br />\n  顺序输出：每层输出时，排在左边的节点，它的子节点同样排在下一层的最左边</li>\n</ul>\n<p>–&gt; <strong>==题目具备广度遍历（分层遍历）的特点 和 顺序输出的特点 ，应该想到应用FIFO队列==</strong></p>\n<ul>\n<li>边界<br>特殊判断： 如果发现是一棵空二叉树，就直接返回空结果<br>==制定一个规则==： 不要让空指针进入到FIFO队列（一些编程的亮点）</li>\n</ul>\n<p><font color = 'red'> 非常重要的概念： QSize 表示当前层数 </font></p>\n<h4 id=\"层次遍历二叉树\"><a href=\"#层次遍历二叉树\" class=\"headerlink\" title=\"层次遍历二叉树\"></a>层次遍历二叉树</h4><p>题目链接：<a href=\"https://leetcode.cn/problems/binary-tree-level-order-traversal/submissions/\">https://leetcode.cn/problems/binary-tree-level-order-traversal/submissions/</a></p>\n<h5 id=\"解题思路1\"><a href=\"#解题思路1\" class=\"headerlink\" title=\"解题思路1\"></a>解题思路1</h5><p>关键思路在于将每一层的节点都存在FIFO队列里面，在每次遍历的时候从左到右pop出该层的节点，同时在队尾加入他的左右孩子</p>\n<p>队首pop出当层节点，队尾append下一层的孩子节点<br>QSize 记录当层的节点数量</p>\n<p>时间复杂度是O(n), 空间复杂度由QSize决定O(K),K表示QSize最大，也就是存储的一层节点数量最多的时候</p>\n<h5 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h5><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * type TreeNode struct &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     Val int</span></span><br><span class=\"line\"><span class=\"comment\"> *     Left *TreeNode</span></span><br><span class=\"line\"><span class=\"comment\"> *     Right *TreeNode</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">levelOrder</span><span class=\"params\">(root *TreeNode)</span></span> [][]<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建FIFO 队列来存储遍历的过程</span></span><br><span class=\"line\">    fifo := <span class=\"built_in\">make</span>([]*TreeNode,<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"comment\">// QSize 表示当前遍历的层</span></span><br><span class=\"line\">    QSize := <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"comment\">// 初始化最终结果</span></span><br><span class=\"line\">    result := <span class=\"built_in\">make</span>([][]<span class=\"type\">int</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> root == <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//将根节点入栈</span></span><br><span class=\"line\">    fifo = <span class=\"built_in\">append</span>(fifo,root)</span><br><span class=\"line\">    <span class=\"comment\">// 开始层序遍历，只要当前队列不为空</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"built_in\">len</span>(fifo) &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建结果数组用于存储当层pop出的元素值</span></span><br><span class=\"line\">        tmp := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"comment\">// 当层元素QSize全部遍历以此，这里不能用len(fifo)，因为fifo的长度是在变化的</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i := QSize;i &gt; <span class=\"number\">0</span>;i--&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 拿出队列头元素</span></span><br><span class=\"line\">            node := fifo[<span class=\"number\">0</span>]</span><br><span class=\"line\">            <span class=\"comment\">// 判断他的左孩子是否为空</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> node.Left!= <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">                fifo = <span class=\"built_in\">append</span>(fifo,node.Left)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 判断他的右孩子是否为空</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> node.Right != <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">                fifo = <span class=\"built_in\">append</span>(fifo,node.Right)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 将该节点的值存入结果</span></span><br><span class=\"line\">            tmp = <span class=\"built_in\">append</span>(tmp,node.Val)</span><br><span class=\"line\">            <span class=\"comment\">// 推出队首元素</span></span><br><span class=\"line\">            fifo = fifo[<span class=\"number\">1</span>:]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 将结果 tmp 存入到结果数组当中</span></span><br><span class=\"line\">        result = <span class=\"built_in\">append</span>(result,tmp)</span><br><span class=\"line\">        <span class=\"comment\">// 重新计算当前层的节点数量</span></span><br><span class=\"line\">        QSize = <span class=\"built_in\">len</span>(fifo)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"官方题解\"><a href=\"#官方题解\" class=\"headerlink\" title=\"官方题解\"></a>官方题解</h5><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">levelOrder</span><span class=\"params\">(root *TreeNode)</span></span> [][]<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    ret := [][]<span class=\"type\">int</span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> root == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    q := []*TreeNode&#123;root&#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; <span class=\"built_in\">len</span>(q) &gt; <span class=\"number\">0</span>; i++ &#123;</span><br><span class=\"line\">        ret = <span class=\"built_in\">append</span>(ret, []<span class=\"type\">int</span>&#123;&#125;)</span><br><span class=\"line\">        p := []*TreeNode&#123;&#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j := <span class=\"number\">0</span>; j &lt; <span class=\"built_in\">len</span>(q); j++ &#123;</span><br><span class=\"line\">            node := q[j]</span><br><span class=\"line\">            ret[i] = <span class=\"built_in\">append</span>(ret[i], node.Val)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> node.Left != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">                p = <span class=\"built_in\">append</span>(p, node.Left)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> node.Right != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">                p = <span class=\"built_in\">append</span>(p, node.Right)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        q = p</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"解题思路2\"><a href=\"#解题思路2\" class=\"headerlink\" title=\"解题思路2\"></a>解题思路2</h5><p>使用链表来解决问题</p>\n<h4 id=\"锯齿状层次遍历\"><a href=\"#锯齿状层次遍历\" class=\"headerlink\" title=\"锯齿状层次遍历\"></a>锯齿状层次遍历</h4><p>题目链接：<a href=\"https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/\">https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/</a></p>\n<h5 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h5><p>层次遍历的基础上加一个qs，表示当前层是从左到右还是从右到左</p>\n<p>**==本题当中所犯的错误：==**：</p>\n<ul>\n<li>每一轮都需要重新计算qsize,一定不要忘了这一点</li>\n<li>tmp 接收的时候还是按照栈的pop逻辑，所以顺序上还需要再反一次</li>\n<li>题目样例当中root是按照从左到右遍历过一次来计算的</li>\n</ul>\n<h5 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h5><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * type TreeNode struct &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     Val int</span></span><br><span class=\"line\"><span class=\"comment\"> *     Left *TreeNode</span></span><br><span class=\"line\"><span class=\"comment\"> *     Right *TreeNode</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">zigzagLevelOrder</span><span class=\"params\">(root *TreeNode)</span></span> [][]<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//结果数组</span></span><br><span class=\"line\">    result := <span class=\"built_in\">make</span>([][]<span class=\"type\">int</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"comment\">//全局的fifo队列</span></span><br><span class=\"line\">    fifo := <span class=\"built_in\">make</span>([]*TreeNode,<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"comment\">// Qsize 表示当前层的节点数，qs 表示该层的遍历顺序，0表示从左到右，1表示从右到左</span></span><br><span class=\"line\">    Qsize ,qs := <span class=\"number\">1</span> , <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果树中没有节点则直接返回</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> root == <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 将 root 放入队列</span></span><br><span class=\"line\">    fifo = <span class=\"built_in\">append</span>(fifo,root)</span><br><span class=\"line\">    <span class=\"comment\">//遍历整棵树</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"built_in\">len</span>(fifo) &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        tmp := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i:= <span class=\"number\">1</span>; Qsize &gt;= i &amp;&amp; qs == <span class=\"number\">0</span> ;i++&#123;</span><br><span class=\"line\">            node := fifo[Qsize-i]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> node.Right != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">                fifo = <span class=\"built_in\">append</span>(fifo,node.Right)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> node.Left != <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">                fifo = <span class=\"built_in\">append</span>(fifo,node.Left)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            tmp = <span class=\"built_in\">append</span>(tmp,node.Val)                </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i:= <span class=\"number\">1</span>; Qsize &gt;= i &amp;&amp; qs == <span class=\"number\">1</span> ;i++&#123;</span><br><span class=\"line\">            node := fifo[Qsize-i]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> node.Left != <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">                fifo = <span class=\"built_in\">append</span>(fifo,node.Left)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> node.Right != <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">                fifo = <span class=\"built_in\">append</span>(fifo,node.Right)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            tmp = <span class=\"built_in\">append</span>(tmp,node.Val)                </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        fifo = fifo[Qsize:]</span><br><span class=\"line\">        Qsize = <span class=\"built_in\">len</span>(fifo)</span><br><span class=\"line\">        result = <span class=\"built_in\">append</span>(result,tmp)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> qs == <span class=\"number\">1</span>&#123;</span><br><span class=\"line\">            qs = <span class=\"number\">0</span></span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            qs = <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"倒序层次遍历\"><a href=\"#倒序层次遍历\" class=\"headerlink\" title=\"倒序层次遍历\"></a>倒序层次遍历</h4><p>题目链接：<a href=\"https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/\">https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/</a></p>\n<h5 id=\"解题思路-1\"><a href=\"#解题思路-1\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h5><p>从题目要求当中可以读出，是在之前的层序遍历基础上把结果倒过来输出，那么会比较自然想到可以在使用一个栈用来存储中间结果</p>\n<h5 id=\"代码-2\"><a href=\"#代码-2\" class=\"headerlink\" title=\"代码\"></a>代码</h5><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * type TreeNode struct &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     Val int</span></span><br><span class=\"line\"><span class=\"comment\"> *     Left *TreeNode</span></span><br><span class=\"line\"><span class=\"comment\"> *     Right *TreeNode</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">levelOrderBottom</span><span class=\"params\">(root *TreeNode)</span></span> [][]<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 构造全局fifo队列</span></span><br><span class=\"line\">    fifo := <span class=\"built_in\">make</span>([]*TreeNode,<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"comment\">// 构造结果栈</span></span><br><span class=\"line\">    stack := <span class=\"built_in\">make</span>([][]<span class=\"type\">int</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">    result := <span class=\"built_in\">make</span>([][]<span class=\"type\">int</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"comment\">//表示当前层的节点数量</span></span><br><span class=\"line\">    Qsize := <span class=\"number\">1</span></span><br><span class=\"line\">    fifo = <span class=\"built_in\">append</span>(fifo,root)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> root == <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"built_in\">len</span>(fifo) &gt; <span class=\"number\">0</span>&#123;</span><br><span class=\"line\">        tmp := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> Qsize &gt; <span class=\"number\">0</span>&#123;</span><br><span class=\"line\">            node:= fifo[<span class=\"number\">0</span>]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> node.Left != <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">                fifo =<span class=\"built_in\">append</span>(fifo,node.Left)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> node.Right != <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">                fifo = <span class=\"built_in\">append</span>(fifo,node.Right)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            Qsize--</span><br><span class=\"line\">            fifo = fifo[<span class=\"number\">1</span>:]</span><br><span class=\"line\">            tmp = <span class=\"built_in\">append</span>(tmp,node.Val)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        stack = <span class=\"built_in\">append</span>(stack,tmp)</span><br><span class=\"line\">        Qsize = <span class=\"built_in\">len</span>(fifo)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将栈中元素pop 到结果当中</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"built_in\">len</span>(stack) &gt; <span class=\"number\">0</span>&#123;</span><br><span class=\"line\">        result = <span class=\"built_in\">append</span>(result,stack[<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>])</span><br><span class=\"line\">        stack = stack[:<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"循环队列\"><a href=\"#循环队列\" class=\"headerlink\" title=\"循环队列\"></a>循环队列</h2><p>设计一个可以容纳 k 个元素的循环队列，需要实现以下接口：</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> ringQueue <span class=\"keyword\">interface</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//构造函数，参数k表示这个循环队列最多容纳k个元素</span></span><br><span class=\"line\">    CircularQueue(<span class=\"type\">int</span>)</span><br><span class=\"line\">    <span class=\"comment\">//将value放到队列中，成功返回true</span></span><br><span class=\"line\">    EnQueue(<span class=\"type\">int</span>) <span class=\"type\">bool</span></span><br><span class=\"line\">    <span class=\"comment\">// 删除队首元素，成功返回true</span></span><br><span class=\"line\">    DeQueue() <span class=\"type\">bool</span></span><br><span class=\"line\">    <span class=\"comment\">// 得到队首元素，如果队列为空，返回-1</span></span><br><span class=\"line\">    Front() <span class=\"type\">int</span></span><br><span class=\"line\">    <span class=\"comment\">// 得到队尾元素，如果队列为空，返回-1</span></span><br><span class=\"line\">    Rear() <span class=\"type\">int</span></span><br><span class=\"line\">    <span class=\"comment\">// 查看循环队列是否为空</span></span><br><span class=\"line\">    isEmpty() <span class=\"type\">bool</span></span><br><span class=\"line\">    <span class=\"comment\">// 查看队列是否已经放满k个元素</span></span><br><span class=\"line\">    isFull() <span class=\"type\">bool</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>==循环队列的重点在于==: <font color = 'red'>循环使用固定空间</font></strong></li>\n<li><strong>==难点在于==： <font color='red'>控制好 Front/Rear两个首位指示器</font></strong></li>\n</ul>\n<h3 id=\"表示方法1\"><a href=\"#表示方法1\" class=\"headerlink\" title=\"表示方法1\"></a>表示方法1</h3><p>使用 <code>used</code>、<code>front</code>、<code>rear</code> 三个变量来控制，其中<code>used, front</code>都代表的是数组的下标</p>\n<p>注意以下几点：</p>\n<ul>\n<li>index = i 的后一个是i+1，前一个是i+1</li>\n<li>index = k-1 的后一个就是index=0</li>\n<li>index = 0 的前一个是 index = k-1</li>\n<li><em>==可以使用取模的方式统一处理==:</em>*<br><font color='red'> index = i 的后一个元素下标是（i+1）% k</font><br><font color='red'> index = i 的前一个元素下标是（i-1+k）% k</font><br><font color='blue'>所有的循环数组下标的处理都需要按照这个取模的方式</font></li>\n</ul>\n<p>参考的实例代码如下：</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> MyCircularQueue <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    queue  []<span class=\"type\">int</span></span><br><span class=\"line\">    rear   <span class=\"type\">int</span></span><br><span class=\"line\">    front  <span class=\"type\">int</span></span><br><span class=\"line\">    used   <span class=\"type\">int</span></span><br><span class=\"line\">    length <span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">CircularQueue</span><span class=\"params\">(k <span class=\"type\">int</span>)</span></span> ringQueue &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;MyCircularQueue&#123;</span><br><span class=\"line\">        queue:  <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, k),</span><br><span class=\"line\">        rear:   <span class=\"number\">0</span>,</span><br><span class=\"line\">        front:  <span class=\"number\">0</span>,</span><br><span class=\"line\">        used:   <span class=\"number\">0</span>,</span><br><span class=\"line\">        length: k,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(q *MyCircularQueue)</span></span> EnQueue(value <span class=\"type\">int</span>) <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> q.isFull() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span> </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    q.queue[q.rear] = value</span><br><span class=\"line\">    q.rear = (q.rear + <span class=\"number\">1</span>) % q.length</span><br><span class=\"line\">    q.used++</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(q *MyCircularQueue)</span></span> DeQueue() <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> q.isEmpty() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    q.front = (q.front + <span class=\"number\">1</span>) % q.length</span><br><span class=\"line\">    q.used--</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(q *MyCircularQueue)</span></span> Front() <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> q.used == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> q.queue[q.front]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(q *MyCircularQueue)</span></span> Rear() <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> q.used == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> q.queue[(q.rear<span class=\"number\">-1</span>+q.length)%q.length]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(q *MyCircularQueue)</span></span> isEmpty() <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> q.used == <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(q *MyCircularQueue)</span></span> isFull() <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> q.used == q.length</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>备注：<br>在 <code>DeQueue()</code> 方法中，删除队首元素时并不会真的删除该元素，而是通过移动 <code>front</code> 指针来达到删除的效果。</p>\n<p>循环队列是一个环状的数据结构，可以想象成沿着环形路径移动指针。在实现循环队列时，每当删除队首元素时，我们需要将 <code>front</code> 指针向前移一位，指向队列中的下一个元素，这样队列中原来的第二个元素就成为了新的头部元素。这里使用 “指向队列中的下一个元素” 实际上是模运算的作用，如 <code>(i+1) % n</code> 将会得到指向 <code>i</code> 在循环数组中下一个元素的索引值。</p>\n<p>而在这个移动指针的过程中，由于队列的前面已经没有元素，所以我们不需要将队首元素真正地删除。相反，仅需要更新 <code>front</code> 指针，让它指向目前第一个元素，后面再添加新的元素，也会覆盖掉先前的元素，实现对队列的循环利用。</p>\n<h3 id=\"表示方法2\"><a href=\"#表示方法2\" class=\"headerlink\" title=\"表示方法2\"></a>表示方法2</h3><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> MyCircularQueue <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用 k + 1 ，也就是多余一个空格的循环队列来设计</span></span><br><span class=\"line\">    queue []<span class=\"type\">int</span></span><br><span class=\"line\">    front <span class=\"type\">int</span></span><br><span class=\"line\">    rear <span class=\"type\">int</span></span><br><span class=\"line\">    capacity <span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Constructor</span><span class=\"params\">(k <span class=\"type\">int</span>)</span></span> MyCircularQueue &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> MyCircularQueue&#123;</span><br><span class=\"line\">        queue: <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>,k+<span class=\"number\">1</span>),</span><br><span class=\"line\">        front: <span class=\"number\">0</span>,</span><br><span class=\"line\">        rear: <span class=\"number\">0</span>,</span><br><span class=\"line\">        capacity: k+<span class=\"number\">1</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyCircularQueue)</span></span> EnQueue(value <span class=\"type\">int</span>) <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> this.IsFull()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    this.queue[this.rear] = value</span><br><span class=\"line\">    this.rear = (this.rear + <span class=\"number\">1</span>)%this.capacity</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyCircularQueue)</span></span> DeQueue() <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> this.IsEmpty()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    this.front = (this.front+<span class=\"number\">1</span>)%this.capacity</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyCircularQueue)</span></span> Front() <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> this.IsEmpty() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> this.queue[this.front]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyCircularQueue)</span></span> Rear() <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> this.IsEmpty()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    rearPosition := (this.rear<span class=\"number\">-1</span>+this.capacity)%this.capacity</span><br><span class=\"line\">    <span class=\"keyword\">return</span> this.queue[rearPosition]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyCircularQueue)</span></span> IsEmpty() <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> this.rear ==this.front</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyCircularQueue)</span></span> IsFull() <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (this.rear+<span class=\"number\">1</span>)%this.capacity == this.front</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Your MyCircularQueue object will be instantiated and called as such:</span></span><br><span class=\"line\"><span class=\"comment\"> * obj := Constructor(k);</span></span><br><span class=\"line\"><span class=\"comment\"> * param_1 := obj.EnQueue(value);</span></span><br><span class=\"line\"><span class=\"comment\"> * param_2 := obj.DeQueue();</span></span><br><span class=\"line\"><span class=\"comment\"> * param_3 := obj.Front();</span></span><br><span class=\"line\"><span class=\"comment\"> * param_4 := obj.Rear();</span></span><br><span class=\"line\"><span class=\"comment\"> * param_5 := obj.IsEmpty();</span></span><br><span class=\"line\"><span class=\"comment\"> * param_6 := obj.IsFull();</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"循环双向队列\"><a href=\"#循环双向队列\" class=\"headerlink\" title=\"循环双向队列\"></a>循环双向队列</h3><h4 id=\"解题思路-2\"><a href=\"#解题思路-2\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h4><p><strong>==犯错的地方：==</strong><br><font color='red'> InsertFront的时候，需要先移动front向前一位，然后再把值插进去</font><br>最开始想的，直接让front和rear都指向一个空白的空间，那么就需要在插入的时候先将front向前移动两位，但这样的话就会浪费一个数值的空间，因为多余一个位就完全可以满足要求</p>\n<p>使用k+1的情况，如果是在LRU缓存或者是Ringbuffer当中还需要考虑，将队尾[或者是队中]的元素插入到队首，也就是将最近使用的元素放到前面</p>\n<h4 id=\"代码-3\"><a href=\"#代码-3\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> MyCircularDeque <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    queue []<span class=\"type\">int</span></span><br><span class=\"line\">    front <span class=\"type\">int</span></span><br><span class=\"line\">    rear <span class=\"type\">int</span> </span><br><span class=\"line\">    capacity <span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Constructor</span><span class=\"params\">(k <span class=\"type\">int</span>)</span></span> MyCircularDeque &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> MyCircularDeque&#123;</span><br><span class=\"line\">        queue: <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>,k+<span class=\"number\">1</span>),</span><br><span class=\"line\">        front: <span class=\"number\">0</span>,</span><br><span class=\"line\">        rear: <span class=\"number\">0</span>,</span><br><span class=\"line\">        capacity: k+<span class=\"number\">1</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyCircularDeque)</span></span> InsertFront(value <span class=\"type\">int</span>) <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> this.IsFull()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    this.front = (this.front<span class=\"number\">-1</span> + this.capacity)%this.capacity</span><br><span class=\"line\">    this.queue[this.front] = value</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyCircularDeque)</span></span> InsertLast(value <span class=\"type\">int</span>) <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> this.IsFull()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    this.queue[this.rear] = value</span><br><span class=\"line\">    this.rear = (this.rear+<span class=\"number\">1</span>)%this.capacity</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyCircularDeque)</span></span> DeleteFront() <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> this.IsEmpty()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    this.front = (this.front+<span class=\"number\">1</span>)%this.capacity</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyCircularDeque)</span></span> DeleteLast() <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> this.IsEmpty()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    this.rear = (this.rear<span class=\"number\">-1</span>+this.capacity)%this.capacity</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyCircularDeque)</span></span> GetFront() <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> this.IsEmpty()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> this.queue[this.front]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyCircularDeque)</span></span> GetRear() <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> this.IsEmpty()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> this.queue[(this.rear<span class=\"number\">-1</span>+this.capacity)%this.capacity]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyCircularDeque)</span></span> IsEmpty() <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> this.front == this.rear</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyCircularDeque)</span></span> IsFull() <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> this.front == (this.rear+<span class=\"number\">1</span>)%this.capacity</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Your MyCircularDeque object will be instantiated and called as such:</span></span><br><span class=\"line\"><span class=\"comment\"> * obj := Constructor(k);</span></span><br><span class=\"line\"><span class=\"comment\"> * param_1 := obj.InsertFront(value);</span></span><br><span class=\"line\"><span class=\"comment\"> * param_2 := obj.InsertLast(value);</span></span><br><span class=\"line\"><span class=\"comment\"> * param_3 := obj.DeleteFront();</span></span><br><span class=\"line\"><span class=\"comment\"> * param_4 := obj.DeleteLast();</span></span><br><span class=\"line\"><span class=\"comment\"> * param_5 := obj.GetFront();</span></span><br><span class=\"line\"><span class=\"comment\"> * param_6 := obj.GetRear();</span></span><br><span class=\"line\"><span class=\"comment\"> * param_7 := obj.IsEmpty();</span></span><br><span class=\"line\"><span class=\"comment\"> * param_8 := obj.IsFull();</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n\n<p>相似点：</p>\n<ul>\n<li>都使用了取模的方式</li>\n</ul>\n<h2 id=\"单调队列\"><a href=\"#单调队列\" class=\"headerlink\" title=\"单调队列\"></a>单调队列</h2><p>单调队列属于双端队列的一种</p>\n<p>要求队列中的元素必须满足单调性</p>\n<p>单调队列如对时候的要求：入队前后，单调性完整</p>\n<p><strong>==单调递减队列最重要的特性==:<font color='red'>入队和出队的组合，可以在O(1)时间得到某个区间上的最大值</font></strong></p>\n<h3 id=\"情况讨论\"><a href=\"#情况讨论\" class=\"headerlink\" title=\"情况讨论\"></a>情况讨论</h3><blockquote>\n<p>需要回答的问题：</p>\n<ul>\n<li>这个区间是什么</li>\n<li>怎样定量地描述这个区间</li>\n<li>与队列中的元素个数有什么关系<br>可以分以下两种情况来讨论：</li>\n</ul>\n</blockquote>\n<ol>\n<li>只有入队的情况<br>在没有出队的情况下，对原数组的比较范围就会逐步增加<br>队首元素表示是已比较范围内的最大值</li>\n<li>出队和入队混合的情况<br>控制覆盖范围为 k –&gt; 滑动窗口<ul>\n<li>入队： 扩展单调队列的覆盖范围</li>\n<li>出队： 控制单调队列的覆盖范围</li>\n<li>队首元素是覆盖范围的最大值</li>\n<li>队列中的元素个数小于覆盖范围的元素个数</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"核心代码\"><a href=\"#核心代码\" class=\"headerlink\" title=\"核心代码\"></a>核心代码</h3><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//入队的代码</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(q *queue)</span></span>push(val <span class=\"type\">int</span>)&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 入队时候，要剔除掉尾部的元素，知道尾部元素大于或者是等于入队元素</span></span><br><span class=\"line\">    while(!q.isEmpty() &amp;&amp; q.getLast()&lt;val)&#123;</span><br><span class=\"line\">        q.removeLast()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 将元素入队</span></span><br><span class=\"line\">    q.addLast(val)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 出队的时候，需要给出一个value</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(q *queue)</span></span> pop(val <span class=\"type\">int</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!q.isEmpty() &amp;&amp; q.getFirst()==val)&#123;</span><br><span class=\"line\">        q.removeFirst()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样的代码编写关键：</p>\n<ul>\n<li>队首元素q.getFirst() 所获取的值是队列中的最大值</li>\n<li>出队时<ul>\n<li>如果一个元素已经被其他元素剔除出去了，那么他就不会再入队</li>\n<li>如果一个元素是当前队列的最大值，会再出队</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"滑动窗口的最大值\"><a href=\"#滑动窗口的最大值\" class=\"headerlink\" title=\"滑动窗口的最大值\"></a>滑动窗口的最大值</h3><h3 id=\"捡金币游戏\"><a href=\"#捡金币游戏\" class=\"headerlink\" title=\"捡金币游戏\"></a>捡金币游戏</h3><blockquote>\n<p>考点:</p>\n<ul>\n<li>找到get数组，并知道get数组是当前元素和滑动窗口中最大值的和计算而来</li>\n<li>利用单调队列在get[]数组上操作，找到滑动窗口的最大值</li>\n</ul>\n</blockquote>\n<p>拓展： 是否存在不同的出队方式</p>\n<blockquote>\n<p>整理一下代码模板：<br><font color = 'red'>分层遍历</font><br><font color = 'red'>循环队列</font><br><font color = 'red'>单调队列</font></p>\n</blockquote>\n<p>一些有意思的题目：</p>\n<ul>\n<li>利用栈实现一个队列</li>\n<li>利用队列实现一个栈</li>\n</ul>\n<h1 id=\"优先级队列：堆与优先级队列，筛选最优元素\"><a href=\"#优先级队列：堆与优先级队列，筛选最优元素\" class=\"headerlink\" title=\"优先级队列：堆与优先级队列，筛选最优元素\"></a>优先级队列：堆与优先级队列，筛选最优元素</h1><h2 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h2><p> FIFO队列： 节点之间的优先级是由遍历时的顺序决定的<br> 优先级队列： 节点之间按照大小进行排序后，再决定优先级，底层依赖的数据结构一般是堆</p>\n<h4 id=\"堆的分类\"><a href=\"#堆的分类\" class=\"headerlink\" title=\"堆的分类\"></a>堆的分类</h4><ol>\n<li><p>大根堆<br>节点的值比他的孩子节点都大</p>\n</li>\n<li><p>小根堆<br>节点的值要比他的孩子节点都小<br>堆的特点–大堆的根是最大值，小堆的根是最小值</p>\n</li>\n</ol>\n<h4 id=\"堆的实现\"><a href=\"#堆的实现\" class=\"headerlink\" title=\"堆的实现\"></a>堆的实现</h4><blockquote>\n<p>以大堆为例子</p>\n</blockquote>\n<p>大多数时候都是使用数组来表示堆</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Heap <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    data []<span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建新的大根堆</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewHeap</span><span class=\"params\">()</span></span> Heap &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Heap&#123;</span><br><span class=\"line\">        data: <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, <span class=\"number\">0</span>),</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取大根堆的长度</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h *Heap)</span></span> Len() <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(h.data)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取指定位置元素的父节点位置</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">parent</span><span class=\"params\">(i <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (i - <span class=\"number\">1</span>) / <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取指定位置元素的左子节点位置</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">leftChild</span><span class=\"params\">(i <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> i*<span class=\"number\">2</span> + <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取指定位置元素的右子节点位置</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">rightChild</span><span class=\"params\">(i <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> i*<span class=\"number\">2</span> + <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 下沉操作，将指定位置的元素向下移动，直到它大于所有子节点为止</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h *Heap)</span></span> sink(i <span class=\"type\">int</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">        left, right := leftChild(i), rightChild(i)</span><br><span class=\"line\">        maxPos := i</span><br><span class=\"line\">        <span class=\"keyword\">if</span> left &lt; h.Len() &amp;&amp; h.data[left] &gt; h.data[maxPos] &#123;</span><br><span class=\"line\">            maxPos = left</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> right &lt; h.Len() &amp;&amp; h.data[right] &gt; h.data[maxPos] &#123;</span><br><span class=\"line\">            maxPos = right</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> maxPos == i &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        h.data[i], h.data[maxPos] = h.data[maxPos], h.data[i]</span><br><span class=\"line\">        i = maxPos</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 上浮操作，将指定位置的元素向上移动，直到它小于其父节点为止</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h *Heap)</span></span> swim(i <span class=\"type\">int</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        p := parent(i)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> h.data[p] &gt;= h.data[i] &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        h.data[p], h.data[i] = h.data[i], h.data[p]</span><br><span class=\"line\">        i = p</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 出堆，弹出大根堆的堆顶元素，并重新调整堆结构</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h *Heap)</span></span> pop() <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    res := h.data[<span class=\"number\">0</span>]</span><br><span class=\"line\">    h.data[<span class=\"number\">0</span>] = h.data[<span class=\"built_in\">len</span>(h.data)<span class=\"number\">-1</span>]</span><br><span class=\"line\">    h.data = h.data[:<span class=\"built_in\">len</span>(h.data)<span class=\"number\">-1</span>]</span><br><span class=\"line\">    h.sink(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 入堆，将新元素插入到大根堆中，并重新调整堆结构</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h *Heap)</span></span> push(val <span class=\"type\">int</span>) &#123;</span><br><span class=\"line\">    h.data = <span class=\"built_in\">append</span>(h.data, val)</span><br><span class=\"line\">    h.swim(<span class=\"built_in\">len</span>(h.data) - <span class=\"number\">1</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"最小的k个数\"><a href=\"#最小的k个数\" class=\"headerlink\" title=\"最小的k个数\"></a>最小的k个数</h4><blockquote>\n<p>N 的数量级非常大，或者其希望能够获得一个较小的区间内的数字<br>同时输出的操作是每时每刻的话，一直是用排序的代价就会很高<br>在上述大根堆的基础上来完成的话，就是以下代码：</p>\n</blockquote>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">getLeastNumbers</span><span class=\"params\">(arr []<span class=\"type\">int</span>, k <span class=\"type\">int</span>)</span></span> []<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 建立大根堆</span></span><br><span class=\"line\">    minH := Heap&#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i:=<span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(arr); i++&#123;</span><br><span class=\"line\">        minH.push(arr[i])</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(minH.data) &gt; k &#123;</span><br><span class=\"line\">            minH.pop()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> minH.data</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"优先级队列\"><a href=\"#优先级队列\" class=\"headerlink\" title=\"优先级队列\"></a>优先级队列</h2><h4 id=\"google-面试题目：有一台机器会每隔一秒输出一个信号，请在每次输出信号的时候输出所有信号的中间值，如果信号数量位偶数则返回中间两数的平均值\"><a href=\"#google-面试题目：有一台机器会每隔一秒输出一个信号，请在每次输出信号的时候输出所有信号的中间值，如果信号数量位偶数则返回中间两数的平均值\" class=\"headerlink\" title=\"google 面试题目：有一台机器会每隔一秒输出一个信号，请在每次输出信号的时候输出所有信号的中间值，如果信号数量位偶数则返回中间两数的平均值\"></a>google 面试题目：有一台机器会每隔一秒输出一个信号，请在每次输出信号的时候输出所有信号的中间值，如果信号数量位偶数则返回中间两数的平均值</h4><p>题目连接：</p>\n<blockquote>\n<p>leetcode 这道题目还能够用排序是因为算的是所有一共的，如果是实时输出就每次都需要排序，所以直接维护一个结构更适合</p>\n</blockquote>\n<h1 id=\"链表：-如何利用”假头，新链表，双指针”解决链表类型题目\"><a href=\"#链表：-如何利用”假头，新链表，双指针”解决链表类型题目\" class=\"headerlink\" title=\"链表： 如何利用”假头，新链表，双指针”解决链表类型题目\"></a>链表： 如何利用”假头，新链表，双指针”解决链表类型题目</h1><blockquote>\n<p>解决链表问题的三板斧：<br>假头<br>新链表<br>双指针<br>链表尤其需要考虑各种边界条件、链表结构简单，但是查找交换反转非常容易出错</p>\n</blockquote>\n<h3 id=\"三板斧\"><a href=\"#三板斧\" class=\"headerlink\" title=\"三板斧\"></a>三板斧</h3><h4 id=\"假头\"><a href=\"#假头\" class=\"headerlink\" title=\"假头\"></a>假头</h4><p>在链表前面增加额外的节点–&gt; 可以节省许多对于nil指针的操作，能够节省不少的精力</p>\n<p>dummy 指针初始化之后就不会再发生改变了<br>tail  指针随着元素改变移动</p>\n<ol>\n<li>tail 插入节点</li>\n<li>头部插入节点</li>\n<li>查找结点（总是会查找目标节点的pre）</li>\n<li>在指定位置插入节点–&gt; getPre</li>\n<li>删除节点<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> linkList <span class=\"keyword\">interface</span>&#123;</span><br><span class=\"line\">    initDummyList()</span><br><span class=\"line\">    appendNode(*<span class=\"keyword\">interface</span>&#123;&#125;)<span class=\"type\">bool</span></span><br><span class=\"line\">    getPre(<span class=\"type\">int</span>)*<span class=\"keyword\">interface</span>&#123;&#125;</span><br><span class=\"line\">    findNode(<span class=\"type\">int</span>) *<span class=\"keyword\">interface</span>&#123;&#125;</span><br><span class=\"line\">    insertNode(*<span class=\"keyword\">interface</span>&#123;&#125;)<span class=\"type\">bool</span></span><br><span class=\"line\">    deletNode(<span class=\"type\">int</span>) <span class=\"type\">bool</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h1 id=\"树：-如何深度运用树的遍历\"><a href=\"#树：-如何深度运用树的遍历\" class=\"headerlink\" title=\"树： 如何深度运用树的遍历\"></a>树： 如何深度运用树的遍历</h1><blockquote>\n<p>大部分语言的map数据结构，基本上是基于树来实现的<br>b+树，红黑树，二叉树等等，在leetcode和考题当中常见二叉树，同时对于其他的树结构，可以通过二叉树的遍历来扩展出对应的遍历方式。</p>\n</blockquote>\n<h2 id=\"1-ensp-树节点的结构：\"><a href=\"#1-ensp-树节点的结构：\" class=\"headerlink\" title=\"1 &ensp; 树节点的结构：\"></a><strong>1</strong> &ensp; 树节点的结构：</h2><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> TreeNode <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">    val <span class=\"type\">int</span></span><br><span class=\"line\">    left *TreeNode</span><br><span class=\"line\">    right *TreeNode</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-ensp-前序遍历\"><a href=\"#2-ensp-前序遍历\" class=\"headerlink\" title=\"2 &ensp; 前序遍历\"></a><strong>2</strong> &ensp; 前序遍历</h2><blockquote>\n<p><font color='red'>遍历根节点、左子树、右子树</font></p>\n</blockquote>\n<h3 id=\"2-1-ensp-使用递归完成前序遍历\"><a href=\"#2-1-ensp-使用递归完成前序遍历\" class=\"headerlink\" title=\"2.1 &ensp; 使用递归完成前序遍历\"></a><strong>2.1</strong> &ensp; 使用递归完成前序遍历</h3><p>采用整体的思想：<br>首先遍历根节点，然后遍历左子树的时候，就把左子树放到相应的位置，遍历右子树的时候，就把右子树放到相应的位置。<br>然后展开左子树<br>然后展开右子树</p>\n<blockquote>\n<p>时间复杂度：O(N)<br>空间复杂度：O(K) K表示的树的高度<br><font color=CC6699>一定注意要问清楚:在访问每个节点的时候，是需要Print出来，还是放到一个链表/数组当中存储</font></p>\n</blockquote>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//使用递归方式</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">traverse</span><span class=\"params\">(root *TreeNode)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> root == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    traverse(root.Left)</span><br><span class=\"line\">    traverse(root.Right)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-ensp-使用栈完成前序遍历\"><a href=\"#2-2-ensp-使用栈完成前序遍历\" class=\"headerlink\" title=\"2.2 &ensp; 使用栈完成前序遍历\"></a><strong>2.2</strong> &ensp; 使用栈完成前序遍历</h3><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> TreeNode <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Val   <span class=\"type\">int</span></span><br><span class=\"line\">    Left  *TreeNode</span><br><span class=\"line\">    Right *TreeNode</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 前序遍历</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">preorderTraversal</span><span class=\"params\">(root *TreeNode)</span></span> []<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> root == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> []<span class=\"type\">int</span>&#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> res []<span class=\"type\">int</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> stack []*TreeNode</span><br><span class=\"line\">    stack = <span class=\"built_in\">append</span>(stack, root)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"built_in\">len</span>(stack) &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        node := stack[<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>]</span><br><span class=\"line\">        stack = stack[:<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>]</span><br><span class=\"line\">        res = <span class=\"built_in\">append</span>(res, node.Val)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> node.Right != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            stack = <span class=\"built_in\">append</span>(stack, node.Right)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> node.Left != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            stack = <span class=\"built_in\">append</span>(stack, node.Left)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-1-ensp-Morris-遍历-只需要O-1-的空间\"><a href=\"#2-2-1-ensp-Morris-遍历-只需要O-1-的空间\" class=\"headerlink\" title=\"2.2-1 &ensp; Morris 遍历: 只需要O(1)的空间\"></a><strong>2.2-1</strong> &ensp; Morris 遍历: 只需要O(1)的空间</h3><h3 id=\"2-3-ensp-题目\"><a href=\"#2-3-ensp-题目\" class=\"headerlink\" title=\"2.3 &ensp; 题目\"></a><strong>2.3</strong> &ensp; 题目</h3><p>下述为前序遍历常见题目</p>\n<h4 id=\"2-3-1-验证二叉树\"><a href=\"#2-3-1-验证二叉树\" class=\"headerlink\" title=\"2.3.1 验证二叉树\"></a><strong>2.3.1</strong> 验证二叉树</h4><p>验证一颗二叉树是否满足二叉搜索树的性质</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> basic <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">    node *TreeNode</span><br><span class=\"line\">    leftboard <span class=\"type\">int</span></span><br><span class=\"line\">    rightboard <span class=\"type\">int</span></span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">stackBst</span><span class=\"params\">(root *TreeNode)</span></span> <span class=\"type\">bool</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 构造边界影子树栈</span></span><br><span class=\"line\">    stack := <span class=\"built_in\">make</span>([]basic,<span class=\"number\">0</span>)</span><br><span class=\"line\">    left, right := math.MinInt64,math.MaxInt64</span><br><span class=\"line\">    <span class=\"keyword\">for</span> root != <span class=\"literal\">nil</span> || <span class=\"built_in\">len</span>(stack) &gt; <span class=\"number\">0</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 当还没有遍历完左子树</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> root != <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 判断不满足搜索树的节点要求</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> root.Val &lt;= left || root.Val &gt;= right &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 满足范围要求，那就要往下继续找</span></span><br><span class=\"line\">            <span class=\"comment\">// 先记录当前影子树的边界</span></span><br><span class=\"line\">            stack = <span class=\"built_in\">append</span>(stack, basic&#123;</span><br><span class=\"line\">                node: root,</span><br><span class=\"line\">                leftboard: left,</span><br><span class=\"line\">                rightboard: right,</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">            <span class=\"comment\">// 往下移动，同时缩小右边界</span></span><br><span class=\"line\">            right = root.Val</span><br><span class=\"line\">            root = root.Left</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 左子树遍历完了，找右子树</span></span><br><span class=\"line\">        top := stack[<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>]</span><br><span class=\"line\">        stack = stack[:<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 关键就是这里需要重新赋值比较的left和right</span></span><br><span class=\"line\">        root = top.node</span><br><span class=\"line\">        left,right = top.leftboard,top.rightboard</span><br><span class=\"line\">        left = root.Val</span><br><span class=\"line\">        root = root.Right       </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">isValidBST</span><span class=\"params\">(root *TreeNode)</span></span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> stackBst(root)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>或者是使用递归的方式</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">isValidBST</span><span class=\"params\">(root *TreeNode)</span></span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    ans := <span class=\"literal\">true</span></span><br><span class=\"line\">    ans = preOderBST(root,math.MinInt64,math.MaxInt64)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">preOderBST</span><span class=\"params\">(root *TreeNode, left <span class=\"type\">int</span>, right <span class=\"type\">int</span>)</span></span><span class=\"type\">bool</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> root == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> root.Val &lt;= left || root.Val &gt;= right &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> preOderBST(root.Left,left,root.Val) &amp;&amp; preOderBST(root.Right,root.Val,right)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// // 特殊在于 golang 的特点： 传参如果要一直修改其中的值，就需要传入一个引用，或者是采用闭包的方式</span></span><br><span class=\"line\"><span class=\"comment\">// func preOderBST(root *TreeNode, left int, right int, ans *bool)&#123;</span></span><br><span class=\"line\"><span class=\"comment\">// \t// 递归是否达到条件，即到达叶节点，到达叶节点表示所有节点都满足情况，所以为true</span></span><br><span class=\"line\"><span class=\"comment\">// \t// 第二个条件是 是否有判断出不满足的树，有的话ans就会变成false,直接返回</span></span><br><span class=\"line\"><span class=\"comment\">// \tif root == nil || !(*ans) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">// \t\treturn</span></span><br><span class=\"line\"><span class=\"comment\">// \t&#125;</span></span><br><span class=\"line\"><span class=\"comment\">// \t// 判断条件就是 当前的值要小于right同时大于left才满足</span></span><br><span class=\"line\"><span class=\"comment\">// \tif root.Val &lt;= left || root.Val &gt;= right &#123;</span></span><br><span class=\"line\"><span class=\"comment\">// \t\t*ans = false</span></span><br><span class=\"line\"><span class=\"comment\">// \t\treturn</span></span><br><span class=\"line\"><span class=\"comment\">// \t&#125;</span></span><br><span class=\"line\"><span class=\"comment\">// \t// 前序遍历</span></span><br><span class=\"line\"><span class=\"comment\">// \tpreOderBST(root.Left, left, root.Val, ans)</span></span><br><span class=\"line\"><span class=\"comment\">// \tpreOderBST(root.Right, root.Val, right, ans)</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-3-2-目标和的所有路径\"><a href=\"#2-3-2-目标和的所有路径\" class=\"headerlink\" title=\"2.3.2 目标和的所有路径\"></a><strong>2.3.2</strong> 目标和的所有路径</h4><p><a href=\"https://leetcode.cn/problems/path-sum/\">https://leetcode.cn/problems/path-sum/</a></p>\n<blockquote>\n<p>二叉树进行回溯的代码模板</p>\n<ul>\n<li>遇到新的节点： 路径总是从尾部添加节点</li>\n<li>遍历完节点，路径就把他从尾部扔掉</li>\n</ul>\n</blockquote>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// func hasPathSum(root *TreeNode, targetSum int) bool &#123;</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">//     var backTrace func(*TreeNode, int) bool</span></span><br><span class=\"line\"><span class=\"comment\">//     backTrace = func(root *TreeNode, Sum int)bool&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//         left , right := false,false </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//         if root == nil &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//             return false</span></span><br><span class=\"line\"><span class=\"comment\">//         &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//         Sum += root.Val</span></span><br><span class=\"line\"><span class=\"comment\">//         if root.Left == nil &amp;&amp; root.Right == nil &amp;&amp; Sum == targetSum &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//             return true</span></span><br><span class=\"line\"><span class=\"comment\">//         &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//         if root.Left != nil&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//             left = backTrace(root.Left,Sum)</span></span><br><span class=\"line\"><span class=\"comment\">//         &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//         if root.Right != nil&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//             right = backTrace(root.Right,Sum)</span></span><br><span class=\"line\"><span class=\"comment\">//         &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//         return left || right</span></span><br><span class=\"line\"><span class=\"comment\">//     &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//     return backTrace(root,0)</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// // 使用广度优先的遍历--层序遍历--队列</span></span><br><span class=\"line\"><span class=\"comment\">// func hasPathSum(root *TreeNode, targetSum int) bool &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//     if root == nil&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//         return false</span></span><br><span class=\"line\"><span class=\"comment\">//     &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//     fifo := make([]*TreeNode,0)</span></span><br><span class=\"line\"><span class=\"comment\">//     Qsize := 1</span></span><br><span class=\"line\"><span class=\"comment\">//     fifo = append(fifo,root)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//     for len(fifo) &gt; 0 &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//         for Qsize &gt; 0 &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//             top := fifo[0]</span></span><br><span class=\"line\"><span class=\"comment\">//             if top.Left == nil &amp;&amp; top.Right == nil &amp;&amp; top.Val == targetSum&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//                 return true</span></span><br><span class=\"line\"><span class=\"comment\">//             &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//             if top.Left != nil&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//                 top.Left.Val = top.Left.Val + top.Val</span></span><br><span class=\"line\"><span class=\"comment\">//                 fifo = append(fifo,top.Left)</span></span><br><span class=\"line\"><span class=\"comment\">//             &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//             if top.Right != nil&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//                 top.Right.Val = top.Right.Val + top.Val</span></span><br><span class=\"line\"><span class=\"comment\">//                 fifo = append(fifo,top.Right)</span></span><br><span class=\"line\"><span class=\"comment\">//             &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//             fifo = fifo[1:]</span></span><br><span class=\"line\"><span class=\"comment\">//             Qsize -= 1</span></span><br><span class=\"line\"><span class=\"comment\">//         &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//         Qsize = len(fifo)</span></span><br><span class=\"line\"><span class=\"comment\">//     &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//     return false</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用栈来存储，栈中元素是当前树的路径</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> path <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">    node *TreeNode</span><br><span class=\"line\">    sum <span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">hasPathSum</span><span class=\"params\">(root *TreeNode, targetSum <span class=\"type\">int</span>)</span></span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> root == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    paths := <span class=\"built_in\">make</span>([]path,<span class=\"number\">0</span>)</span><br><span class=\"line\">    paths = <span class=\"built_in\">append</span>(paths, path&#123;</span><br><span class=\"line\">        node: root,</span><br><span class=\"line\">        sum: root.Val,</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"built_in\">len</span>(paths) &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        node := paths[<span class=\"built_in\">len</span>(paths)<span class=\"number\">-1</span>]</span><br><span class=\"line\">        paths = paths[:<span class=\"built_in\">len</span>(paths)<span class=\"number\">-1</span>]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> node.node.Left == <span class=\"literal\">nil</span> &amp;&amp; node.node.Right == <span class=\"literal\">nil</span> &amp;&amp; node.sum == targetSum &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> node.node.Right != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            right := node.node.Right</span><br><span class=\"line\">            paths = <span class=\"built_in\">append</span>(paths,path&#123;</span><br><span class=\"line\">                node: right,</span><br><span class=\"line\">                sum: right.Val + node.sum,</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> node.node.Left != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            left := node.node.Left</span><br><span class=\"line\">            paths = <span class=\"built_in\">append</span>(paths,path&#123;</span><br><span class=\"line\">                node: left,</span><br><span class=\"line\">                sum: left.Val + node.sum,</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-3-3-得到路径和为指定数字的路径集合\"><a href=\"#2-3-3-得到路径和为指定数字的路径集合\" class=\"headerlink\" title=\"2.3.3 得到路径和为指定数字的路径集合\"></a><strong>2.3.3</strong> 得到路径和为指定数字的路径集合</h4><p><a href=\"https://leetcode.cn/problems/path-sum-ii/solution/\">https://leetcode.cn/problems/path-sum-ii/solution/</a><br><font color='red'> 这道题目非常重要：有两大问题都在这个地方表现出来了</font></p>\n<p>==Golang的特性：Defer函数的使用==<br>这道题目在使用前序遍历的时候，由于在叶子节点以及从左子树转换为右子树的时候都需要将原本记录在path当中的路径节点删除pop出来，递归时候就需要考虑在什么时候执行出栈操作，没错即便是在递归当中也还是必须要考虑栈的操作，因为需要一个连续记录的路径信息</p>\n<p>关键在于pop的时机：pop的时机是：1. 本身是叶子节点，直接return 结束dfs，2. 左右的子树都被递归判断过的树中结点，也就是dfs(Left),dfs(Right)正常结束，刚好发现二者均都是在dfs执行完之后执行，而且覆盖了dfs执行完之后所有的情况<br>同时 Golang 的 <strong>Defer(){}</strong> 会在函数执行完并在返回之前执行，完全满足这个场景的需求，所以可以在递归函数体当中使用defer来完成对应的操作</p>\n<p>==Golang的特性：切片索引==<br>切片本身就是指针，且每次操作都会影响到底层数组<br>如果不在递归函数体当中使用切片之前重新对切片进行赋值，那么，之后对于底层数组的操作也会反映到之前的切片上，产生的效果就是明明原本计算好了结果但最后得到的并不是正确答案，关键就在于==后面切片的操作修改了底层数组，导致原本切片对应的结果被修改了==</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">pathSum</span><span class=\"params\">(root *TreeNode, targetSum <span class=\"type\">int</span>)</span></span> [][]<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    result := <span class=\"built_in\">make</span>([][]<span class=\"type\">int</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">    path := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> root == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> dfs <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(*TreeNode,<span class=\"type\">int</span>)</span></span></span><br><span class=\"line\">    dfs = <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(root *TreeNode,left <span class=\"type\">int</span>)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> root == <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        path = <span class=\"built_in\">append</span>(path,root.Val)</span><br><span class=\"line\">        left = left - root.Val</span><br><span class=\"line\">        <span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123; </span><br><span class=\"line\">            path = path[:<span class=\"built_in\">len</span>(path)<span class=\"number\">-1</span>]</span><br><span class=\"line\">        &#125;()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> root.Left == <span class=\"literal\">nil</span> &amp;&amp; root.Right == <span class=\"literal\">nil</span> &amp;&amp; left == <span class=\"number\">0</span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// new := make([]int,len(path))</span></span><br><span class=\"line\">            <span class=\"comment\">// copy(new,path)</span></span><br><span class=\"line\">            <span class=\"comment\">// result = append(result,new)</span></span><br><span class=\"line\">            result = <span class=\"built_in\">append</span>(result,<span class=\"built_in\">append</span>([]<span class=\"type\">int</span>(<span class=\"literal\">nil</span>),path...))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        dfs(root.Left,left)</span><br><span class=\"line\">        dfs(root.Right,left)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dfs(root,targetSum)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-3-3\"><a href=\"#2-3-3\" class=\"headerlink\" title=\"2.3.3\"></a><strong>2.3.3</strong></h4><blockquote>\n<p>等待回溯来看<br><a href=\"https://leetcode.cn/problems/path-sum-iii/solution/437-lu-jing-zong-he-iii-dfshui-su-qian-zhui-he-yi-/\">https://leetcode.cn/problems/path-sum-iii/solution/437-lu-jing-zong-he-iii-dfshui-su-qian-zhui-he-yi-/</a></p>\n</blockquote>\n<h2 id=\"3-中序遍历\"><a href=\"#3-中序遍历\" class=\"headerlink\" title=\"3 中序遍历\"></a><strong>3</strong> 中序遍历</h2><p><font color='red'>遍历左子树，然后是根节点，然后是右子树</font></p>\n<h3 id=\"3-1-ensp-使用递归完成中序遍历\"><a href=\"#3-1-ensp-使用递归完成中序遍历\" class=\"headerlink\" title=\"3.1 &ensp; 使用递归完成中序遍历\"></a><strong>3.1</strong> &ensp; 使用递归完成中序遍历</h3><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-ensp-使用栈完成中序遍历\"><a href=\"#3-2-ensp-使用栈完成中序遍历\" class=\"headerlink\" title=\"3.2 &ensp; 使用栈完成中序遍历\"></a><strong>3.2</strong> &ensp; 使用栈完成中序遍历</h3><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">inorderTraversal</span><span class=\"params\">(root *TreeNode)</span></span> []<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> root == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> []<span class=\"type\">int</span>&#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> res []<span class=\"type\">int</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> stack []*TreeNode</span><br><span class=\"line\">    <span class=\"keyword\">var</span> pathStack []<span class=\"type\">string</span></span><br><span class=\"line\">    node := root</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> node != <span class=\"literal\">nil</span> || <span class=\"built_in\">len</span>(stack) &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> node != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            stack = <span class=\"built_in\">append</span>(stack, node)</span><br><span class=\"line\">            pathStack = <span class=\"built_in\">append</span>(pathStack, fmt.Sprintf(<span class=\"string\">&quot;%d&quot;</span>, node.Val))</span><br><span class=\"line\">            node = node.Left</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            node = stack[<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>]</span><br><span class=\"line\">            stack = stack[:<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>]</span><br><span class=\"line\">            path := pathStack[<span class=\"built_in\">len</span>(pathStack)<span class=\"number\">-1</span>]</span><br><span class=\"line\">            pathStack = pathStack[:<span class=\"built_in\">len</span>(pathStack)<span class=\"number\">-1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> node.Left == <span class=\"literal\">nil</span> &amp;&amp; node.Right == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">                res = <span class=\"built_in\">append</span>(res, node.Val)</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 输出到达叶子节点的路径</span></span><br><span class=\"line\">                fmt.Println(path)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            node = node.Right</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-3-找出二叉搜索树里面出现次数最多的数\"><a href=\"#3-3-找出二叉搜索树里面出现次数最多的数\" class=\"headerlink\" title=\"3.3 找出二叉搜索树里面出现次数最多的数\"></a><strong>3.3</strong> 找出二叉搜索树里面出现次数最多的数</h3><p>找众数就需要遍历所有的节点，二叉搜索树中序遍历的结果会是一个递增的数组，其数据特性就在于使用中序遍历的时候，所有的元素都是连续的</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * type TreeNode struct &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     Val int</span></span><br><span class=\"line\"><span class=\"comment\"> *     Left *TreeNode</span></span><br><span class=\"line\"><span class=\"comment\"> *     Right *TreeNode</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">findMode</span><span class=\"params\">(root *TreeNode)</span></span> []<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 结果数组</span></span><br><span class=\"line\">    ans := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">    base,count,maxnum := math.MinInt64,<span class=\"number\">0</span>,<span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使用递归的方式</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> dfs <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(*TreeNode)</span></span></span><br><span class=\"line\">    dfs = <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(root *TreeNode)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> root == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        dfs(root.Left)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> root.Val == base &#123;</span><br><span class=\"line\">            count++</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            base = root.Val</span><br><span class=\"line\">            count = <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> count == maxnum &#123;</span><br><span class=\"line\">            ans = <span class=\"built_in\">append</span>(ans,base)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> count &gt; maxnum &#123;</span><br><span class=\"line\">            ans = []<span class=\"type\">int</span>&#123;&#125;</span><br><span class=\"line\">            maxnum = count</span><br><span class=\"line\">            ans = <span class=\"built_in\">append</span>(ans,base)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        dfs(root.Right)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dfs(root)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-4-找出二叉搜索树里面任意两个节点之间绝对值得最小值\"><a href=\"#3-4-找出二叉搜索树里面任意两个节点之间绝对值得最小值\" class=\"headerlink\" title=\"3.4 找出二叉搜索树里面任意两个节点之间绝对值得最小值\"></a><strong>3.4</strong> 找出二叉搜索树里面任意两个节点之间绝对值得最小值</h3><p><a href=\"https://leetcode.cn/problems/minimum-distance-between-bst-nodes/\">https://leetcode.cn/problems/minimum-distance-between-bst-nodes/</a></p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">minDiffInBST</span><span class=\"params\">(root *TreeNode)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用栈来中序遍历，栈顶元素就是上一遍历的节点元素</span></span><br><span class=\"line\">    stack := <span class=\"built_in\">make</span>([]*TreeNode,<span class=\"number\">0</span>)</span><br><span class=\"line\">    res := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> root != <span class=\"literal\">nil</span> || <span class=\"built_in\">len</span>(stack) &gt; <span class=\"number\">0</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> root != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            stack = <span class=\"built_in\">append</span>(stack,root)</span><br><span class=\"line\">            root = root.Left</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        node := stack[<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>]</span><br><span class=\"line\">        stack = stack[:<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>]</span><br><span class=\"line\">        res = <span class=\"built_in\">append</span>(res,node.Val)</span><br><span class=\"line\"></span><br><span class=\"line\">        root = node</span><br><span class=\"line\">        root = root.Right</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    m := math.MaxInt64</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i:= <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(res)<span class=\"number\">-1</span>; i++&#123;</span><br><span class=\"line\">        r := res[i+<span class=\"number\">1</span>]-res[i]</span><br><span class=\"line\">        m = min(m,r) </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> m</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">min</span><span class=\"params\">(args ...<span class=\"type\">int</span>)</span></span><span class=\"type\">int</span>&#123;</span><br><span class=\"line\">    min := args[<span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, val := <span class=\"keyword\">range</span> args&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> val &lt; min &#123;</span><br><span class=\"line\">            min = val</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> min</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-5-一棵二叉搜索树的两个节点被交换了，恢复这颗二叉搜索树\"><a href=\"#3-5-一棵二叉搜索树的两个节点被交换了，恢复这颗二叉搜索树\" class=\"headerlink\" title=\"3.5 一棵二叉搜索树的两个节点被交换了，恢复这颗二叉搜索树\"></a><strong>3.5</strong> 一棵二叉搜索树的两个节点被交换了，恢复这颗二叉搜索树</h3><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">recoverTree</span><span class=\"params\">(root *TreeNode)</span></span>  &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用递归解决这个问题</span></span><br><span class=\"line\">    problem := <span class=\"built_in\">make</span>([]*TreeNode,<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">var</span> findP <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(*TreeNode)</span></span></span><br><span class=\"line\">    findP = <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(root *TreeNode)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> root == <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        findP(root.Left)</span><br><span class=\"line\">        <span class=\"comment\">// if pre == math.MaxInt64&#123;</span></span><br><span class=\"line\">        <span class=\"comment\">//     pre = root.Val</span></span><br><span class=\"line\">        <span class=\"comment\">//     return</span></span><br><span class=\"line\">        <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">        <span class=\"comment\">// if root.Val - pre &lt; 0&#123;</span></span><br><span class=\"line\">        <span class=\"comment\">//     problem = append(problem,root)</span></span><br><span class=\"line\">        <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">        <span class=\"comment\">// pre = root.Val</span></span><br><span class=\"line\">        problem = <span class=\"built_in\">append</span>(problem, root)</span><br><span class=\"line\">        findP(root.Right)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    findP(root)</span><br><span class=\"line\">    pre,cur := <span class=\"number\">-1</span>,<span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(problem)<span class=\"number\">-1</span>; i++&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> problem[i].Val &gt; problem[i+<span class=\"number\">1</span>].Val &#123;</span><br><span class=\"line\">            cur = i + <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> pre == <span class=\"number\">-1</span> &#123;</span><br><span class=\"line\">                pre = i</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    problem[pre].Val,problem[cur].Val = problem[cur].Val,problem[pre].Val</span><br><span class=\"line\">    <span class=\"keyword\">return</span> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"删除二叉搜索树的节点\"><a href=\"#删除二叉搜索树的节点\" class=\"headerlink\" title=\"删除二叉搜索树的节点\"></a>删除二叉搜索树的节点</h3><blockquote>\n<p>题目最重要的考点就是分类，讨论各种情况下的处理方式</p>\n</blockquote>\n<p><font sizecolor ='red'>清晰地讲出每种情况的处理办法</font><br><font sizecolor ='red'>清晰简介地实现代码</font></p>\n<h2 id=\"后序遍历\"><a href=\"#后序遍历\" class=\"headerlink\" title=\"后序遍历\"></a>后序遍历</h2><h3 id=\"使用栈完成后序遍历\"><a href=\"#使用栈完成后序遍历\" class=\"headerlink\" title=\"使用栈完成后序遍历\"></a>使用栈完成后序遍历</h3><h3 id=\"迭代写法的考点\"><a href=\"#迭代写法的考点\" class=\"headerlink\" title=\"迭代写法的考点\"></a>迭代写法的考点</h3><ol>\n<li>是否有右子树</li>\n<li>pre指针是不是指向当前结点的右子树</li>\n</ol>\n"},{"title":"动态规划入门","catalog":true,"date":"2023-03-23T18:20:14.000Z","subtitle":null,"header-img":null,"published":0,"_content":"\n# [动态规划] 动态规划入门\n\n> 核心特征： 动态规划中，每一个状态是有上一个状态推导出来的\n\n## 什么是动态规划\n> 对于一个问题，如何才能够识别出他是一个需要用动态规划解决的问题\n\n问题本质上不能够被划归为 DP(Dynamic Problem) 问题，因为 DP 是解决方法的特征并不是问题的特征。\n\n那么目标就变成哪一些问题可以使用 DP 来解决呢？\n\n首先是明确 DP 方法的特点： DP 本质上是**暴力解法，列举计算所有的可能，但通过 “memoized approach”(缓存思想)去消除了重复性的工作**。比如在斐波那契数列当中，当需要计算 f[i]的数值时候，完全可以从f[1],f[0] 重新开始计算，但当我们将f[i]和f[i-1]的计算式子排在一起的时候，就会发现二者从f[0]到f[i-2]的计算流程是完全一样的，也就是说f[i] 的结果可以从f[i-1]的结果上获取；那么从这个例子来看，我们可以将 DP 的方法流程理解为：\n* 求解问题需要列举/计算所有可能的解[问题的解包含在全集当中]\n* 计算每一种可能的流程和方法是完全一致的，且相互关联，一部分的结果可以帮助计算其它部分的结果\n\n\n结合上述的 DP 方法特点分析，依照笔者刷题看论文的经验来说，当一个问题是优化性质的问题，需要求解“最短/最长、最小化/最大化、最少/最多、最少/最大、最大/最小”的目标，而求解这个目标需要遍历几乎所有可能的排列组合，这类型的题目如果没有微积分、取模或者是其他更加直接的计算方式，那么简化的暴力破解方法-- DP 可能就是一个比较好的选择。\n这类型问题的表述可以是：“找到编辑操作的最小数量”，“找到最长的公共子序列”，\n\n\n## 动态规划与递归\n> 核心不同点就是：动态规划自下而上，递归自上而下\n\n动态规划和递归相同的特征在于：解决问题时候复用了计算的公式和流程，也就是说获得每一个阶段结果的计算流程(公式)是相同的，所以可以用同一段函数代码来表示\n\n不相同的地方在于：递归是从 f[i] 开始，不断回退调用之前的计算流程；而动态规划是从 f[0] 开始，不断累积存储中间的结果，直到遍历找到 f[i]\n\n## 使用动态规划的方法\n\n参考已有文章所给出的方法，结合个人的分析，给出以下解题流程：\n\n### 分析问题的解题流程，是否存在上述所说优化特征以及遍历形式，确定是否使用 DP 解题\n   \n\n### 使用 DP 解题\n\n1. 确定dp数组（dp table）以及下标的含义\n   **什么是DP数组呢？**\n   dp[i] 代表的是 i 位置的结果值(就是遍历到 i 值应该得出的结果值)\n   > dp 当然也不一定就是一维数组, 可以是dp[i][j], 得看 DP 遍历时候每一层循环分别的计算公式和意义是什么\n\n\n\n2. 确定递推公式\n3. dp数组如何初始化\n4. 确定遍历顺序\n5. 举例推导dp数组\n\n\n# 参考文献\n[1] 代码随想录: [https://programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E8%A7%A3%E9%A2%98%E6%AD%A5%E9%AA%A4]\n\n[2] Quora: [https://www.quora.com/How-do-I-recognize-a-problem-as-a-dynamic-programming-problem]\n\n[3] StackFlow: \n* [https://stackoverflow.com/questions/6164629/what-is-the-difference-between-bottom-up-and-top-down]\n* [https://stackoverflow.blog/2022/01/31/the-complete-beginners-guide-to-dynamic-programming/]\n* [https://softwareengineering.stackexchange.com/questions/219802/how-do-you-identify-a-problem-as-being-suitable-for-dynamic-programming]\n* [https://stackoverflow.com/questions/6184869/what-is-the-difference-between-memoization-and-dynamic-programming]\n\n[4] SpiceWorks: [https://www.spiceworks.com/tech/devops/articles/what-is-dynamic-programming/]\n\n[5] WAYNE W BISHOP：\n* [https://www.waynewbishop.com/dynamic-programming-problems]\n* [https://www.waynewbishop.com/computer-science-interview-questions]\n\n[6] Blog:\n* [https://people.computing.clemson.edu/~bcdean/dp_practice/]\n\n[7] Not used But may useful in the future:\n* [https://learntocodewith.me/posts/dynamic-programming/]\n* [https://medium.com/@adam.dejans/using-dynamic-programming-for-problem-solving-b54be2e47747]","source":"_posts/Algorithm/script/[动态规划] 动态规划入门/[动态规划] 动态规划入门.md","raw":"---\ntitle: 动态规划入门\ncatalog: true\ndate: 2023-03-24 02:20:14\nsubtitle: \nheader-img:\ntags: Dynamic Programming\ncategories: 算法\npublished: false\n---\n\n# [动态规划] 动态规划入门\n\n> 核心特征： 动态规划中，每一个状态是有上一个状态推导出来的\n\n## 什么是动态规划\n> 对于一个问题，如何才能够识别出他是一个需要用动态规划解决的问题\n\n问题本质上不能够被划归为 DP(Dynamic Problem) 问题，因为 DP 是解决方法的特征并不是问题的特征。\n\n那么目标就变成哪一些问题可以使用 DP 来解决呢？\n\n首先是明确 DP 方法的特点： DP 本质上是**暴力解法，列举计算所有的可能，但通过 “memoized approach”(缓存思想)去消除了重复性的工作**。比如在斐波那契数列当中，当需要计算 f[i]的数值时候，完全可以从f[1],f[0] 重新开始计算，但当我们将f[i]和f[i-1]的计算式子排在一起的时候，就会发现二者从f[0]到f[i-2]的计算流程是完全一样的，也就是说f[i] 的结果可以从f[i-1]的结果上获取；那么从这个例子来看，我们可以将 DP 的方法流程理解为：\n* 求解问题需要列举/计算所有可能的解[问题的解包含在全集当中]\n* 计算每一种可能的流程和方法是完全一致的，且相互关联，一部分的结果可以帮助计算其它部分的结果\n\n\n结合上述的 DP 方法特点分析，依照笔者刷题看论文的经验来说，当一个问题是优化性质的问题，需要求解“最短/最长、最小化/最大化、最少/最多、最少/最大、最大/最小”的目标，而求解这个目标需要遍历几乎所有可能的排列组合，这类型的题目如果没有微积分、取模或者是其他更加直接的计算方式，那么简化的暴力破解方法-- DP 可能就是一个比较好的选择。\n这类型问题的表述可以是：“找到编辑操作的最小数量”，“找到最长的公共子序列”，\n\n\n## 动态规划与递归\n> 核心不同点就是：动态规划自下而上，递归自上而下\n\n动态规划和递归相同的特征在于：解决问题时候复用了计算的公式和流程，也就是说获得每一个阶段结果的计算流程(公式)是相同的，所以可以用同一段函数代码来表示\n\n不相同的地方在于：递归是从 f[i] 开始，不断回退调用之前的计算流程；而动态规划是从 f[0] 开始，不断累积存储中间的结果，直到遍历找到 f[i]\n\n## 使用动态规划的方法\n\n参考已有文章所给出的方法，结合个人的分析，给出以下解题流程：\n\n### 分析问题的解题流程，是否存在上述所说优化特征以及遍历形式，确定是否使用 DP 解题\n   \n\n### 使用 DP 解题\n\n1. 确定dp数组（dp table）以及下标的含义\n   **什么是DP数组呢？**\n   dp[i] 代表的是 i 位置的结果值(就是遍历到 i 值应该得出的结果值)\n   > dp 当然也不一定就是一维数组, 可以是dp[i][j], 得看 DP 遍历时候每一层循环分别的计算公式和意义是什么\n\n\n\n2. 确定递推公式\n3. dp数组如何初始化\n4. 确定遍历顺序\n5. 举例推导dp数组\n\n\n# 参考文献\n[1] 代码随想录: [https://programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E8%A7%A3%E9%A2%98%E6%AD%A5%E9%AA%A4]\n\n[2] Quora: [https://www.quora.com/How-do-I-recognize-a-problem-as-a-dynamic-programming-problem]\n\n[3] StackFlow: \n* [https://stackoverflow.com/questions/6164629/what-is-the-difference-between-bottom-up-and-top-down]\n* [https://stackoverflow.blog/2022/01/31/the-complete-beginners-guide-to-dynamic-programming/]\n* [https://softwareengineering.stackexchange.com/questions/219802/how-do-you-identify-a-problem-as-being-suitable-for-dynamic-programming]\n* [https://stackoverflow.com/questions/6184869/what-is-the-difference-between-memoization-and-dynamic-programming]\n\n[4] SpiceWorks: [https://www.spiceworks.com/tech/devops/articles/what-is-dynamic-programming/]\n\n[5] WAYNE W BISHOP：\n* [https://www.waynewbishop.com/dynamic-programming-problems]\n* [https://www.waynewbishop.com/computer-science-interview-questions]\n\n[6] Blog:\n* [https://people.computing.clemson.edu/~bcdean/dp_practice/]\n\n[7] Not used But may useful in the future:\n* [https://learntocodewith.me/posts/dynamic-programming/]\n* [https://medium.com/@adam.dejans/using-dynamic-programming-for-problem-solving-b54be2e47747]","slug":"Algorithm/script/[动态规划] 动态规划入门/[动态规划] 动态规划入门","updated":"2023-04-22T13:24:02.176Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli796r150027byjxck4n8y08","content":"<h1 id=\"动态规划-动态规划入门\"><a href=\"#动态规划-动态规划入门\" class=\"headerlink\" title=\"[动态规划] 动态规划入门\"></a>[动态规划] 动态规划入门</h1><blockquote>\n<p>核心特征： 动态规划中，每一个状态是有上一个状态推导出来的</p>\n</blockquote>\n<h2 id=\"什么是动态规划\"><a href=\"#什么是动态规划\" class=\"headerlink\" title=\"什么是动态规划\"></a>什么是动态规划</h2><blockquote>\n<p>对于一个问题，如何才能够识别出他是一个需要用动态规划解决的问题</p>\n</blockquote>\n<p>问题本质上不能够被划归为 DP(Dynamic Problem) 问题，因为 DP 是解决方法的特征并不是问题的特征。</p>\n<p>那么目标就变成哪一些问题可以使用 DP 来解决呢？</p>\n<p>首先是明确 DP 方法的特点： DP 本质上是<strong>暴力解法，列举计算所有的可能，但通过 “memoized approach”(缓存思想)去消除了重复性的工作</strong>。比如在斐波那契数列当中，当需要计算 f[i]的数值时候，完全可以从f[1],f[0] 重新开始计算，但当我们将f[i]和f[i-1]的计算式子排在一起的时候，就会发现二者从f[0]到f[i-2]的计算流程是完全一样的，也就是说f[i] 的结果可以从f[i-1]的结果上获取；那么从这个例子来看，我们可以将 DP 的方法流程理解为：</p>\n<ul>\n<li>求解问题需要列举/计算所有可能的解[问题的解包含在全集当中]</li>\n<li>计算每一种可能的流程和方法是完全一致的，且相互关联，一部分的结果可以帮助计算其它部分的结果</li>\n</ul>\n<p>结合上述的 DP 方法特点分析，依照笔者刷题看论文的经验来说，当一个问题是优化性质的问题，需要求解“最短/最长、最小化/最大化、最少/最多、最少/最大、最大/最小”的目标，而求解这个目标需要遍历几乎所有可能的排列组合，这类型的题目如果没有微积分、取模或者是其他更加直接的计算方式，那么简化的暴力破解方法– DP 可能就是一个比较好的选择。<br>这类型问题的表述可以是：“找到编辑操作的最小数量”，“找到最长的公共子序列”，</p>\n<h2 id=\"动态规划与递归\"><a href=\"#动态规划与递归\" class=\"headerlink\" title=\"动态规划与递归\"></a>动态规划与递归</h2><blockquote>\n<p>核心不同点就是：动态规划自下而上，递归自上而下</p>\n</blockquote>\n<p>动态规划和递归相同的特征在于：解决问题时候复用了计算的公式和流程，也就是说获得每一个阶段结果的计算流程(公式)是相同的，所以可以用同一段函数代码来表示</p>\n<p>不相同的地方在于：递归是从 f[i] 开始，不断回退调用之前的计算流程；而动态规划是从 f[0] 开始，不断累积存储中间的结果，直到遍历找到 f[i]</p>\n<h2 id=\"使用动态规划的方法\"><a href=\"#使用动态规划的方法\" class=\"headerlink\" title=\"使用动态规划的方法\"></a>使用动态规划的方法</h2><p>参考已有文章所给出的方法，结合个人的分析，给出以下解题流程：</p>\n<h3 id=\"分析问题的解题流程，是否存在上述所说优化特征以及遍历形式，确定是否使用-DP-解题\"><a href=\"#分析问题的解题流程，是否存在上述所说优化特征以及遍历形式，确定是否使用-DP-解题\" class=\"headerlink\" title=\"分析问题的解题流程，是否存在上述所说优化特征以及遍历形式，确定是否使用 DP 解题\"></a>分析问题的解题流程，是否存在上述所说优化特征以及遍历形式，确定是否使用 DP 解题</h3><h3 id=\"使用-DP-解题\"><a href=\"#使用-DP-解题\" class=\"headerlink\" title=\"使用 DP 解题\"></a>使用 DP 解题</h3><ol>\n<li>确定dp数组（dp table）以及下标的含义<br><strong>什么是DP数组呢？</strong><br>dp[i] 代表的是 i 位置的结果值(就是遍历到 i 值应该得出的结果值)<blockquote>\n<p>dp 当然也不一定就是一维数组, 可以是dp[i][j], 得看 DP 遍历时候每一层循环分别的计算公式和意义是什么</p>\n</blockquote>\n</li>\n</ol>\n<ol start=\"2\">\n<li>确定递推公式</li>\n<li>dp数组如何初始化</li>\n<li>确定遍历顺序</li>\n<li>举例推导dp数组</li>\n</ol>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><p>[1] 代码随想录: [<a href=\"https://programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E8%A7%A3%E9%A2%98%E6%AD%A5%E9%AA%A4]\">https://programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E8%A7%A3%E9%A2%98%E6%AD%A5%E9%AA%A4]</a></p>\n<p>[2] Quora: [<a href=\"https://www.quora.com/How-do-I-recognize-a-problem-as-a-dynamic-programming-problem]\">https://www.quora.com/How-do-I-recognize-a-problem-as-a-dynamic-programming-problem]</a></p>\n<p>[3] StackFlow: </p>\n<ul>\n<li>[<a href=\"https://stackoverflow.com/questions/6164629/what-is-the-difference-between-bottom-up-and-top-down]\">https://stackoverflow.com/questions/6164629/what-is-the-difference-between-bottom-up-and-top-down]</a></li>\n<li>[<a href=\"https://stackoverflow.blog/2022/01/31/the-complete-beginners-guide-to-dynamic-programming/]\">https://stackoverflow.blog/2022/01/31/the-complete-beginners-guide-to-dynamic-programming/]</a></li>\n<li>[<a href=\"https://softwareengineering.stackexchange.com/questions/219802/how-do-you-identify-a-problem-as-being-suitable-for-dynamic-programming]\">https://softwareengineering.stackexchange.com/questions/219802/how-do-you-identify-a-problem-as-being-suitable-for-dynamic-programming]</a></li>\n<li>[<a href=\"https://stackoverflow.com/questions/6184869/what-is-the-difference-between-memoization-and-dynamic-programming]\">https://stackoverflow.com/questions/6184869/what-is-the-difference-between-memoization-and-dynamic-programming]</a></li>\n</ul>\n<p>[4] SpiceWorks: [<a href=\"https://www.spiceworks.com/tech/devops/articles/what-is-dynamic-programming/]\">https://www.spiceworks.com/tech/devops/articles/what-is-dynamic-programming/]</a></p>\n<p>[5] WAYNE W BISHOP：</p>\n<ul>\n<li>[<a href=\"https://www.waynewbishop.com/dynamic-programming-problems]\">https://www.waynewbishop.com/dynamic-programming-problems]</a></li>\n<li>[<a href=\"https://www.waynewbishop.com/computer-science-interview-questions]\">https://www.waynewbishop.com/computer-science-interview-questions]</a></li>\n</ul>\n<p>[6] Blog:</p>\n<ul>\n<li>[<a href=\"https://people.computing.clemson.edu/~bcdean/dp_practice/]\">https://people.computing.clemson.edu/~bcdean/dp_practice/]</a></li>\n</ul>\n<p>[7] Not used But may useful in the future:</p>\n<ul>\n<li>[<a href=\"https://learntocodewith.me/posts/dynamic-programming/]\">https://learntocodewith.me/posts/dynamic-programming/]</a></li>\n<li>[<a href=\"https://medium.com/@adam.dejans/using-dynamic-programming-for-problem-solving-b54be2e47747]\">https://medium.com/@adam.dejans/using-dynamic-programming-for-problem-solving-b54be2e47747]</a></li>\n</ul>\n","site":{"data":{}},"cover":"/img/cover/2077_city.png","cover_type":"img","excerpt":"","more":"<h1 id=\"动态规划-动态规划入门\"><a href=\"#动态规划-动态规划入门\" class=\"headerlink\" title=\"[动态规划] 动态规划入门\"></a>[动态规划] 动态规划入门</h1><blockquote>\n<p>核心特征： 动态规划中，每一个状态是有上一个状态推导出来的</p>\n</blockquote>\n<h2 id=\"什么是动态规划\"><a href=\"#什么是动态规划\" class=\"headerlink\" title=\"什么是动态规划\"></a>什么是动态规划</h2><blockquote>\n<p>对于一个问题，如何才能够识别出他是一个需要用动态规划解决的问题</p>\n</blockquote>\n<p>问题本质上不能够被划归为 DP(Dynamic Problem) 问题，因为 DP 是解决方法的特征并不是问题的特征。</p>\n<p>那么目标就变成哪一些问题可以使用 DP 来解决呢？</p>\n<p>首先是明确 DP 方法的特点： DP 本质上是<strong>暴力解法，列举计算所有的可能，但通过 “memoized approach”(缓存思想)去消除了重复性的工作</strong>。比如在斐波那契数列当中，当需要计算 f[i]的数值时候，完全可以从f[1],f[0] 重新开始计算，但当我们将f[i]和f[i-1]的计算式子排在一起的时候，就会发现二者从f[0]到f[i-2]的计算流程是完全一样的，也就是说f[i] 的结果可以从f[i-1]的结果上获取；那么从这个例子来看，我们可以将 DP 的方法流程理解为：</p>\n<ul>\n<li>求解问题需要列举/计算所有可能的解[问题的解包含在全集当中]</li>\n<li>计算每一种可能的流程和方法是完全一致的，且相互关联，一部分的结果可以帮助计算其它部分的结果</li>\n</ul>\n<p>结合上述的 DP 方法特点分析，依照笔者刷题看论文的经验来说，当一个问题是优化性质的问题，需要求解“最短/最长、最小化/最大化、最少/最多、最少/最大、最大/最小”的目标，而求解这个目标需要遍历几乎所有可能的排列组合，这类型的题目如果没有微积分、取模或者是其他更加直接的计算方式，那么简化的暴力破解方法– DP 可能就是一个比较好的选择。<br>这类型问题的表述可以是：“找到编辑操作的最小数量”，“找到最长的公共子序列”，</p>\n<h2 id=\"动态规划与递归\"><a href=\"#动态规划与递归\" class=\"headerlink\" title=\"动态规划与递归\"></a>动态规划与递归</h2><blockquote>\n<p>核心不同点就是：动态规划自下而上，递归自上而下</p>\n</blockquote>\n<p>动态规划和递归相同的特征在于：解决问题时候复用了计算的公式和流程，也就是说获得每一个阶段结果的计算流程(公式)是相同的，所以可以用同一段函数代码来表示</p>\n<p>不相同的地方在于：递归是从 f[i] 开始，不断回退调用之前的计算流程；而动态规划是从 f[0] 开始，不断累积存储中间的结果，直到遍历找到 f[i]</p>\n<h2 id=\"使用动态规划的方法\"><a href=\"#使用动态规划的方法\" class=\"headerlink\" title=\"使用动态规划的方法\"></a>使用动态规划的方法</h2><p>参考已有文章所给出的方法，结合个人的分析，给出以下解题流程：</p>\n<h3 id=\"分析问题的解题流程，是否存在上述所说优化特征以及遍历形式，确定是否使用-DP-解题\"><a href=\"#分析问题的解题流程，是否存在上述所说优化特征以及遍历形式，确定是否使用-DP-解题\" class=\"headerlink\" title=\"分析问题的解题流程，是否存在上述所说优化特征以及遍历形式，确定是否使用 DP 解题\"></a>分析问题的解题流程，是否存在上述所说优化特征以及遍历形式，确定是否使用 DP 解题</h3><h3 id=\"使用-DP-解题\"><a href=\"#使用-DP-解题\" class=\"headerlink\" title=\"使用 DP 解题\"></a>使用 DP 解题</h3><ol>\n<li>确定dp数组（dp table）以及下标的含义<br><strong>什么是DP数组呢？</strong><br>dp[i] 代表的是 i 位置的结果值(就是遍历到 i 值应该得出的结果值)<blockquote>\n<p>dp 当然也不一定就是一维数组, 可以是dp[i][j], 得看 DP 遍历时候每一层循环分别的计算公式和意义是什么</p>\n</blockquote>\n</li>\n</ol>\n<ol start=\"2\">\n<li>确定递推公式</li>\n<li>dp数组如何初始化</li>\n<li>确定遍历顺序</li>\n<li>举例推导dp数组</li>\n</ol>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><p>[1] 代码随想录: [<a href=\"https://programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E8%A7%A3%E9%A2%98%E6%AD%A5%E9%AA%A4]\">https://programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E8%A7%A3%E9%A2%98%E6%AD%A5%E9%AA%A4]</a></p>\n<p>[2] Quora: [<a href=\"https://www.quora.com/How-do-I-recognize-a-problem-as-a-dynamic-programming-problem]\">https://www.quora.com/How-do-I-recognize-a-problem-as-a-dynamic-programming-problem]</a></p>\n<p>[3] StackFlow: </p>\n<ul>\n<li>[<a href=\"https://stackoverflow.com/questions/6164629/what-is-the-difference-between-bottom-up-and-top-down]\">https://stackoverflow.com/questions/6164629/what-is-the-difference-between-bottom-up-and-top-down]</a></li>\n<li>[<a href=\"https://stackoverflow.blog/2022/01/31/the-complete-beginners-guide-to-dynamic-programming/]\">https://stackoverflow.blog/2022/01/31/the-complete-beginners-guide-to-dynamic-programming/]</a></li>\n<li>[<a href=\"https://softwareengineering.stackexchange.com/questions/219802/how-do-you-identify-a-problem-as-being-suitable-for-dynamic-programming]\">https://softwareengineering.stackexchange.com/questions/219802/how-do-you-identify-a-problem-as-being-suitable-for-dynamic-programming]</a></li>\n<li>[<a href=\"https://stackoverflow.com/questions/6184869/what-is-the-difference-between-memoization-and-dynamic-programming]\">https://stackoverflow.com/questions/6184869/what-is-the-difference-between-memoization-and-dynamic-programming]</a></li>\n</ul>\n<p>[4] SpiceWorks: [<a href=\"https://www.spiceworks.com/tech/devops/articles/what-is-dynamic-programming/]\">https://www.spiceworks.com/tech/devops/articles/what-is-dynamic-programming/]</a></p>\n<p>[5] WAYNE W BISHOP：</p>\n<ul>\n<li>[<a href=\"https://www.waynewbishop.com/dynamic-programming-problems]\">https://www.waynewbishop.com/dynamic-programming-problems]</a></li>\n<li>[<a href=\"https://www.waynewbishop.com/computer-science-interview-questions]\">https://www.waynewbishop.com/computer-science-interview-questions]</a></li>\n</ul>\n<p>[6] Blog:</p>\n<ul>\n<li>[<a href=\"https://people.computing.clemson.edu/~bcdean/dp_practice/]\">https://people.computing.clemson.edu/~bcdean/dp_practice/]</a></li>\n</ul>\n<p>[7] Not used But may useful in the future:</p>\n<ul>\n<li>[<a href=\"https://learntocodewith.me/posts/dynamic-programming/]\">https://learntocodewith.me/posts/dynamic-programming/]</a></li>\n<li>[<a href=\"https://medium.com/@adam.dejans/using-dynamic-programming-for-problem-solving-b54be2e47747]\">https://medium.com/@adam.dejans/using-dynamic-programming-for-problem-solving-b54be2e47747]</a></li>\n</ul>\n"},{"title":"动态规划问题","catalog":true,"date":"2023-03-24T16:27:34.000Z","subtitle":null,"header-img":null,"published":0,"_content":"\n# [动态规划] 动态规划问题\n> 本文将过一遍所遇见的所有动态规划解决的问题并给出代码\n>\n\n## 斐波那契数\n> 力扣题目链接[https://leetcode.cn/problems/fibonacci-number/]\n>\n\n### 解题流程\n1. 问题分析\n   斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列。\n   \n   该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： F(0) = 0，F(1) = 1 F(n) = F(n - 1) + F(n - 2)，其中 n > 1 问题需求是给n ，请计算 F(n) 的值。\n\n   显然 i 的值包含整个定义域，求解的F(i) 也就是整个解集，需要遍历整个结果集来找对应 i 的解，可以使用 DP 来求解。\n   \n\n2. DP 解题流程\n   \n   * **确定dp数组以及下标的含义**\n  \n        dp[i]的定义为：第i个数的斐波那契数值是dp[i]\n\n   * **确定递推公式**\n\n        确定得到每一个dp[i]的公式，或者说遍历整个结果集合的方式\n    \n        在本题目当中，直接给出的是斐波那契数列\n   状态转移方程 dp[i] = dp[i - 1] + dp[i - 2];\n\n   * **dp数组如何初始化**\n  \n        > 本质上就是**寻找边界值，什么时候开始、什么时候结束**，在所有需要遍历的操作当中都需要考虑这个问题\n\n        一般的斐波那契数列已经给出初始边界值：\n        ```go\n        dp[0] := 0\n        dp[1] := 1\n        ```\n   \n   * **确定遍历顺序**\n\n        从递归公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，dp[i]是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序一定是从前到后遍历的\n\n   * **举例推导dp数组**\n\n        按照这个递推公式dp[i] = dp[i - 1] + dp[i - 2]，我们来推导一下，当N为10的时候，dp数组应该是如下的数列：\n   \n        0 1 1 2 3 5 8 13 21 34 55\n   \n        如果代码写出来，发现结果不对，就把dp数组打印出来看看和我们推导的数列是不是一致的。\n\n\n\n### 代码实现\n\n使用一个数组保存所有遍历的结果，通过索引i直接找到 f[i]对应的值：\n```golang\nfunc fib(n int) int {\n    var ans []int\n    ans = append(ans,0)\n    ans = append(ans,1)\n\n    for i := 2 ; i <= n ; i++ {\n        temp := ans[i-1] + ans[i-2]\n        ans = append(ans,temp)\n    }\n    return ans[n]\n}\n```\n* 时间复杂度：O(n)\n* 空间复杂度：O(n)\n\n但是可以观察到保留的 f 数组其实只用到了一个变量f[i], 并且最后需要的结果是一个固定值 n，也就是说结果是确定位置的，那么是可以只保留计算获得 f[n] 相关的值就可以：f[n-1] 和 f[n-2]，这样的保留过程对于其他的 i 值来说也完全一样，除了 n=0 和 n=1 两个时候的值，那么就需要单独对这两个值来做处理\n\n只保留的pre和now,也可以改成 tmp[i-1] 和 tmp[i-2]也就是改成一个长度为2的一维数组--滚动数组，该数组存储有效信息并跟随遍历的阶段移动\n\n```golang\nfunc fib(n int) int {\n    pre := 0\n    now := 1\n\n    for i:= 2 ; i <= n ; i++{\n        tmp := now\n        now = now + pre\n        pre = tmp\n    }\n    if n == 0 {\n        now = 0\n    }\n    return now\n}\n```\n\n---\n\n## 编辑距离\n> 力扣题目链接: (https://leetcode.cn/problems/edit-distance/)\n\n### 解题流程\n1. 问题分析\n   将word1变成word2，共有三类型的操作：增加、删除、替换；同时计算操作数最小的情况。\n\n   **是否使用动态规划**\n   一个最直白的想法就是我先把word1里面每一个字母都删除，进行len(word1)次操作；然后再加上word2里面的每一个字母，进行len(word2)次操作，当然这样的操作是次数最多的，是完全没有考虑到两个字符之间的关联性，当在字符串里面有相同的字母时候，就可以不操作跳过，再对后面的字符进行操作。\n\n   这样不断地替换中间的操作流程就是一个全遍历的过程，需要找寻几乎所有的排列组合且存在着 **最小值的优化目标 --> 适合动态规划**   \n\n\n   **为什么感觉问题解决会复杂？**\n\n   会发现增删都会改变字母的对应位置，而替换不改变位置，一些不同位置的字母可以通过增删变成对应相同位置的字母，也就是说三个操作之间相互关联。\n\n   同样的问题思考时候，word1变成word2其实也等价于word2变成word1,解题的流程是完全对称的。\n\n   结合以上因素，可以说一个dp状态就有了三种类型的迁移计算，那么我们需要设置一个dp[][][]的三维数组来分别表示三类状态迁移嘛？并不需要，因为替换可以等效为先减少一个字母，然后再增加一个字母只是代价增加为1而不是2，所以可以使用一个二维数组来表示：也就是dp[i][j]；其中i方向可以表示为减少word1 字母的操作，j方向标识增加word2字母的操作，i和j 同时增长表示替换操作：即先减少word1字母，然后增加word2字母。\n\n   还可以看到的是，依据上面的思考流程，i/j应当是和word1/2当中的单词位置相关联的；而麻烦的地方就集中在这个地方的理解上 <font color='red'>dp[i][j] 表示的是将word1前i-1个字符变成word2前j-1个字符最少的操作数</font>，dp[i][j]并不代表一个字符串或者说一个字符串形式，但是到dp[i][j]的路径可以唯一对应一个字符串\n\n   同时当我们使用上述的二位矩阵来计算时会发现，实质上我们也计算了将 word2 变成 word1的最小操作数\n\n\n\n2. DP 解题流程\n   * **确定dp数组以及下标的含义**\n   dp[i][j] 表示的是将word1前i-1个字符变成word2前j-1个字符最少的操作数\n\n   这里有两个需要强调的点：\n   * dp[i] 对应的字母是 word[i-1], 而 dp[0] 对应的是空字符\n   这样来规定矩阵的计算形式更有利于计算\n   * 矩阵中元素对应着操作数，到达操作数的路径对应字符串\n\n   * **确定递推公式**\n   > 也就是确认矩阵元素的迁移计算方向并计算操作数\n\n   如果word1[i - 1] == word2[j - 1]，也就意味着对应位置的字母是相同的，那么增删或者删增同一个字母是没有必要，在矩阵元素迁移中，表示向右下移动一格遍历一个字母，但是不用操作两字符串，dp[i][j]操作数不用增加。\n\n   如果word1[i - 1] != word2[j - 1]，那么接下来在矩阵当中移动，在i方向就意味着对word1[i-1]字母进行减操作，在j方向就意味着对word2[j-1]字母进行加操作\n\n   ```\n    if (word1[i - 1] == word2[j - 1])\n        不操作\n    if (word1[i - 1] != word2[j - 1])\n        dp[i][j] = min (增,删,换)\n   ```\n\n   * **dp数组如何初始化**\n   考虑到空字符串的计算，也就是说对另一方不做操作的情况：\n    * d[i][0] 表示只减少word1的字母\n    * d[0][j] 表示只增加word2的字母\n    * d[0][0] 表示空字母\n\n\n   * **确定遍历顺序**\n   将word1变成word2，也就是意味着需要遍历每一个word1字母和每一个word2字母\n   ```\n    dp[i][j] = dp[i - 1][j - 1]  // i-1,j-1位置两个字符串的字母相同，不用操作，所以在状态迁移时候不用增加dp操作数\n\n    //i-1,j-1位置两个字符串的字母不相同，需要对i-1，j-1位置上的字母做操作\n    dp[i][j] = dp[i - 1][j - 1] + 1 //替换\n    dp[i][j] = dp[i][j - 1] + 1 // 增加\n    dp[i][j] = dp[i - 1][j] + 1 // 减少\n   ```\n\n\n   * **举例推导dp数组**\n\n\n\n### 代码实现\n\n---\n## 两个字符串的删除操作\n> 题目链接：(https://leetcode.cn/problems/delete-operation-for-two-strings/)\n### 解题流程\n1. 问题分析\n   \n2. DP 解题流程\n   * **确定dp数组以及下标的含义**\n   * **确定递推公式**\n   * **dp数组如何初始化**\n   * **确定遍历顺序**\n   * **举例推导dp数组**\n### 代码实现\n\n\n---\n## 最长公共子序列\n> 题目链接：(https://leetcode.cn/problems/longest-common-subsequence/)\n### 解题流程\n1. 问题分析\n   \n2. DP 解题流程\n   * **确定dp数组以及下标的含义**\n   * **确定递推公式**\n   * **dp数组如何初始化**\n   * **确定遍历顺序**\n   * **举例推导dp数组**\n### 代码实现\n\n---\n## 打家劫舍\n### 解题流程\n1. 问题分析\n2. DP 解题流程\n   * **确定dp数组以及下标的含义**\n   * **确定递推公式**\n   * **dp数组如何初始化**\n   * **确定遍历顺序**\n   * **举例推导dp数组**\n### 代码实现\n\n---\n## 斐波那契数\n### 解题流程\n1. 问题分析\n2. DP 解题流程\n   * **确定dp数组以及下标的含义**\n   * **确定递推公式**\n   * **dp数组如何初始化**\n   * **确定遍历顺序**\n   * **举例推导dp数组**\n### 代码实现","source":"_posts/Algorithm/script/[动态规划] 动态规划问题/ [动态规划] 动态规划问题.md","raw":"---\ntitle: 动态规划问题\ncatalog: true\ndate: 2023-03-25 00:27:34\nsubtitle:\nheader-img:\ntags:\ncategories:\npublished: false\n---\n\n# [动态规划] 动态规划问题\n> 本文将过一遍所遇见的所有动态规划解决的问题并给出代码\n>\n\n## 斐波那契数\n> 力扣题目链接[https://leetcode.cn/problems/fibonacci-number/]\n>\n\n### 解题流程\n1. 问题分析\n   斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列。\n   \n   该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： F(0) = 0，F(1) = 1 F(n) = F(n - 1) + F(n - 2)，其中 n > 1 问题需求是给n ，请计算 F(n) 的值。\n\n   显然 i 的值包含整个定义域，求解的F(i) 也就是整个解集，需要遍历整个结果集来找对应 i 的解，可以使用 DP 来求解。\n   \n\n2. DP 解题流程\n   \n   * **确定dp数组以及下标的含义**\n  \n        dp[i]的定义为：第i个数的斐波那契数值是dp[i]\n\n   * **确定递推公式**\n\n        确定得到每一个dp[i]的公式，或者说遍历整个结果集合的方式\n    \n        在本题目当中，直接给出的是斐波那契数列\n   状态转移方程 dp[i] = dp[i - 1] + dp[i - 2];\n\n   * **dp数组如何初始化**\n  \n        > 本质上就是**寻找边界值，什么时候开始、什么时候结束**，在所有需要遍历的操作当中都需要考虑这个问题\n\n        一般的斐波那契数列已经给出初始边界值：\n        ```go\n        dp[0] := 0\n        dp[1] := 1\n        ```\n   \n   * **确定遍历顺序**\n\n        从递归公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，dp[i]是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序一定是从前到后遍历的\n\n   * **举例推导dp数组**\n\n        按照这个递推公式dp[i] = dp[i - 1] + dp[i - 2]，我们来推导一下，当N为10的时候，dp数组应该是如下的数列：\n   \n        0 1 1 2 3 5 8 13 21 34 55\n   \n        如果代码写出来，发现结果不对，就把dp数组打印出来看看和我们推导的数列是不是一致的。\n\n\n\n### 代码实现\n\n使用一个数组保存所有遍历的结果，通过索引i直接找到 f[i]对应的值：\n```golang\nfunc fib(n int) int {\n    var ans []int\n    ans = append(ans,0)\n    ans = append(ans,1)\n\n    for i := 2 ; i <= n ; i++ {\n        temp := ans[i-1] + ans[i-2]\n        ans = append(ans,temp)\n    }\n    return ans[n]\n}\n```\n* 时间复杂度：O(n)\n* 空间复杂度：O(n)\n\n但是可以观察到保留的 f 数组其实只用到了一个变量f[i], 并且最后需要的结果是一个固定值 n，也就是说结果是确定位置的，那么是可以只保留计算获得 f[n] 相关的值就可以：f[n-1] 和 f[n-2]，这样的保留过程对于其他的 i 值来说也完全一样，除了 n=0 和 n=1 两个时候的值，那么就需要单独对这两个值来做处理\n\n只保留的pre和now,也可以改成 tmp[i-1] 和 tmp[i-2]也就是改成一个长度为2的一维数组--滚动数组，该数组存储有效信息并跟随遍历的阶段移动\n\n```golang\nfunc fib(n int) int {\n    pre := 0\n    now := 1\n\n    for i:= 2 ; i <= n ; i++{\n        tmp := now\n        now = now + pre\n        pre = tmp\n    }\n    if n == 0 {\n        now = 0\n    }\n    return now\n}\n```\n\n---\n\n## 编辑距离\n> 力扣题目链接: (https://leetcode.cn/problems/edit-distance/)\n\n### 解题流程\n1. 问题分析\n   将word1变成word2，共有三类型的操作：增加、删除、替换；同时计算操作数最小的情况。\n\n   **是否使用动态规划**\n   一个最直白的想法就是我先把word1里面每一个字母都删除，进行len(word1)次操作；然后再加上word2里面的每一个字母，进行len(word2)次操作，当然这样的操作是次数最多的，是完全没有考虑到两个字符之间的关联性，当在字符串里面有相同的字母时候，就可以不操作跳过，再对后面的字符进行操作。\n\n   这样不断地替换中间的操作流程就是一个全遍历的过程，需要找寻几乎所有的排列组合且存在着 **最小值的优化目标 --> 适合动态规划**   \n\n\n   **为什么感觉问题解决会复杂？**\n\n   会发现增删都会改变字母的对应位置，而替换不改变位置，一些不同位置的字母可以通过增删变成对应相同位置的字母，也就是说三个操作之间相互关联。\n\n   同样的问题思考时候，word1变成word2其实也等价于word2变成word1,解题的流程是完全对称的。\n\n   结合以上因素，可以说一个dp状态就有了三种类型的迁移计算，那么我们需要设置一个dp[][][]的三维数组来分别表示三类状态迁移嘛？并不需要，因为替换可以等效为先减少一个字母，然后再增加一个字母只是代价增加为1而不是2，所以可以使用一个二维数组来表示：也就是dp[i][j]；其中i方向可以表示为减少word1 字母的操作，j方向标识增加word2字母的操作，i和j 同时增长表示替换操作：即先减少word1字母，然后增加word2字母。\n\n   还可以看到的是，依据上面的思考流程，i/j应当是和word1/2当中的单词位置相关联的；而麻烦的地方就集中在这个地方的理解上 <font color='red'>dp[i][j] 表示的是将word1前i-1个字符变成word2前j-1个字符最少的操作数</font>，dp[i][j]并不代表一个字符串或者说一个字符串形式，但是到dp[i][j]的路径可以唯一对应一个字符串\n\n   同时当我们使用上述的二位矩阵来计算时会发现，实质上我们也计算了将 word2 变成 word1的最小操作数\n\n\n\n2. DP 解题流程\n   * **确定dp数组以及下标的含义**\n   dp[i][j] 表示的是将word1前i-1个字符变成word2前j-1个字符最少的操作数\n\n   这里有两个需要强调的点：\n   * dp[i] 对应的字母是 word[i-1], 而 dp[0] 对应的是空字符\n   这样来规定矩阵的计算形式更有利于计算\n   * 矩阵中元素对应着操作数，到达操作数的路径对应字符串\n\n   * **确定递推公式**\n   > 也就是确认矩阵元素的迁移计算方向并计算操作数\n\n   如果word1[i - 1] == word2[j - 1]，也就意味着对应位置的字母是相同的，那么增删或者删增同一个字母是没有必要，在矩阵元素迁移中，表示向右下移动一格遍历一个字母，但是不用操作两字符串，dp[i][j]操作数不用增加。\n\n   如果word1[i - 1] != word2[j - 1]，那么接下来在矩阵当中移动，在i方向就意味着对word1[i-1]字母进行减操作，在j方向就意味着对word2[j-1]字母进行加操作\n\n   ```\n    if (word1[i - 1] == word2[j - 1])\n        不操作\n    if (word1[i - 1] != word2[j - 1])\n        dp[i][j] = min (增,删,换)\n   ```\n\n   * **dp数组如何初始化**\n   考虑到空字符串的计算，也就是说对另一方不做操作的情况：\n    * d[i][0] 表示只减少word1的字母\n    * d[0][j] 表示只增加word2的字母\n    * d[0][0] 表示空字母\n\n\n   * **确定遍历顺序**\n   将word1变成word2，也就是意味着需要遍历每一个word1字母和每一个word2字母\n   ```\n    dp[i][j] = dp[i - 1][j - 1]  // i-1,j-1位置两个字符串的字母相同，不用操作，所以在状态迁移时候不用增加dp操作数\n\n    //i-1,j-1位置两个字符串的字母不相同，需要对i-1，j-1位置上的字母做操作\n    dp[i][j] = dp[i - 1][j - 1] + 1 //替换\n    dp[i][j] = dp[i][j - 1] + 1 // 增加\n    dp[i][j] = dp[i - 1][j] + 1 // 减少\n   ```\n\n\n   * **举例推导dp数组**\n\n\n\n### 代码实现\n\n---\n## 两个字符串的删除操作\n> 题目链接：(https://leetcode.cn/problems/delete-operation-for-two-strings/)\n### 解题流程\n1. 问题分析\n   \n2. DP 解题流程\n   * **确定dp数组以及下标的含义**\n   * **确定递推公式**\n   * **dp数组如何初始化**\n   * **确定遍历顺序**\n   * **举例推导dp数组**\n### 代码实现\n\n\n---\n## 最长公共子序列\n> 题目链接：(https://leetcode.cn/problems/longest-common-subsequence/)\n### 解题流程\n1. 问题分析\n   \n2. DP 解题流程\n   * **确定dp数组以及下标的含义**\n   * **确定递推公式**\n   * **dp数组如何初始化**\n   * **确定遍历顺序**\n   * **举例推导dp数组**\n### 代码实现\n\n---\n## 打家劫舍\n### 解题流程\n1. 问题分析\n2. DP 解题流程\n   * **确定dp数组以及下标的含义**\n   * **确定递推公式**\n   * **dp数组如何初始化**\n   * **确定遍历顺序**\n   * **举例推导dp数组**\n### 代码实现\n\n---\n## 斐波那契数\n### 解题流程\n1. 问题分析\n2. DP 解题流程\n   * **确定dp数组以及下标的含义**\n   * **确定递推公式**\n   * **dp数组如何初始化**\n   * **确定遍历顺序**\n   * **举例推导dp数组**\n### 代码实现","slug":"Algorithm/script/[动态规划] 动态规划问题/ [动态规划] 动态规划问题","updated":"2023-04-22T13:24:02.164Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli796r16002bbyjxat45dak8","content":"<h1 id=\"动态规划-动态规划问题\"><a href=\"#动态规划-动态规划问题\" class=\"headerlink\" title=\"[动态规划] 动态规划问题\"></a>[动态规划] 动态规划问题</h1><blockquote>\n<p>本文将过一遍所遇见的所有动态规划解决的问题并给出代码</p>\n</blockquote>\n<h2 id=\"斐波那契数\"><a href=\"#斐波那契数\" class=\"headerlink\" title=\"斐波那契数\"></a>斐波那契数</h2><blockquote>\n<p>力扣题目链接[<a href=\"https://leetcode.cn/problems/fibonacci-number/]\">https://leetcode.cn/problems/fibonacci-number/]</a></p>\n</blockquote>\n<h3 id=\"解题流程\"><a href=\"#解题流程\" class=\"headerlink\" title=\"解题流程\"></a>解题流程</h3><ol>\n<li><p>问题分析<br>斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列。</p>\n<p>该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： F(0) = 0，F(1) = 1 F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1 问题需求是给n ，请计算 F(n) 的值。</p>\n<p>显然 i 的值包含整个定义域，求解的F(i) 也就是整个解集，需要遍历整个结果集来找对应 i 的解，可以使用 DP 来求解。</p>\n</li>\n<li><p>DP 解题流程</p>\n<ul>\n<li><p><strong>确定dp数组以及下标的含义</strong></p>\n<p>   dp[i]的定义为：第i个数的斐波那契数值是dp[i]</p>\n</li>\n<li><p><strong>确定递推公式</strong></p>\n<p>   确定得到每一个dp[i]的公式，或者说遍历整个结果集合的方式</p>\n<p>   在本题目当中，直接给出的是斐波那契数列<br>状态转移方程 dp[i] = dp[i - 1] + dp[i - 2];</p>\n</li>\n<li><p><strong>dp数组如何初始化</strong></p>\n<blockquote>\n<p>本质上就是<strong>寻找边界值，什么时候开始、什么时候结束</strong>，在所有需要遍历的操作当中都需要考虑这个问题</p>\n</blockquote>\n<p>   一般的斐波那契数列已经给出初始边界值：</p>\n   <figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dp[<span class=\"number\">0</span>] := <span class=\"number\">0</span></span><br><span class=\"line\">dp[<span class=\"number\">1</span>] := <span class=\"number\">1</span></span><br></pre></td></tr></table></figure></li>\n<li><p><strong>确定遍历顺序</strong></p>\n<p>   从递归公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，dp[i]是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序一定是从前到后遍历的</p>\n</li>\n<li><p><strong>举例推导dp数组</strong></p>\n<p>   按照这个递推公式dp[i] = dp[i - 1] + dp[i - 2]，我们来推导一下，当N为10的时候，dp数组应该是如下的数列：</p>\n<p>   0 1 1 2 3 5 8 13 21 34 55</p>\n<p>   如果代码写出来，发现结果不对，就把dp数组打印出来看看和我们推导的数列是不是一致的。</p>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><p>使用一个数组保存所有遍历的结果，通过索引i直接找到 f[i]对应的值：</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">fib</span><span class=\"params\">(n <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> ans []<span class=\"type\">int</span></span><br><span class=\"line\">    ans = <span class=\"built_in\">append</span>(ans,<span class=\"number\">0</span>)</span><br><span class=\"line\">    ans = <span class=\"built_in\">append</span>(ans,<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">2</span> ; i &lt;= n ; i++ &#123;</span><br><span class=\"line\">        temp := ans[i<span class=\"number\">-1</span>] + ans[i<span class=\"number\">-2</span>]</span><br><span class=\"line\">        ans = <span class=\"built_in\">append</span>(ans,temp)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans[n]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>时间复杂度：O(n)</li>\n<li>空间复杂度：O(n)</li>\n</ul>\n<p>但是可以观察到保留的 f 数组其实只用到了一个变量f[i], 并且最后需要的结果是一个固定值 n，也就是说结果是确定位置的，那么是可以只保留计算获得 f[n] 相关的值就可以：f[n-1] 和 f[n-2]，这样的保留过程对于其他的 i 值来说也完全一样，除了 n=0 和 n=1 两个时候的值，那么就需要单独对这两个值来做处理</p>\n<p>只保留的pre和now,也可以改成 tmp[i-1] 和 tmp[i-2]也就是改成一个长度为2的一维数组–滚动数组，该数组存储有效信息并跟随遍历的阶段移动</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">fib</span><span class=\"params\">(n <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    pre := <span class=\"number\">0</span></span><br><span class=\"line\">    now := <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i:= <span class=\"number\">2</span> ; i &lt;= n ; i++&#123;</span><br><span class=\"line\">        tmp := now</span><br><span class=\"line\">        now = now + pre</span><br><span class=\"line\">        pre = tmp</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> n == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        now = <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> now</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"编辑距离\"><a href=\"#编辑距离\" class=\"headerlink\" title=\"编辑距离\"></a>编辑距离</h2><blockquote>\n<p>力扣题目链接: (<a href=\"https://leetcode.cn/problems/edit-distance/\">https://leetcode.cn/problems/edit-distance/</a>)</p>\n</blockquote>\n<h3 id=\"解题流程-1\"><a href=\"#解题流程-1\" class=\"headerlink\" title=\"解题流程\"></a>解题流程</h3><ol>\n<li><p>问题分析<br>将word1变成word2，共有三类型的操作：增加、删除、替换；同时计算操作数最小的情况。</p>\n<p><strong>是否使用动态规划</strong><br>一个最直白的想法就是我先把word1里面每一个字母都删除，进行len(word1)次操作；然后再加上word2里面的每一个字母，进行len(word2)次操作，当然这样的操作是次数最多的，是完全没有考虑到两个字符之间的关联性，当在字符串里面有相同的字母时候，就可以不操作跳过，再对后面的字符进行操作。</p>\n<p>这样不断地替换中间的操作流程就是一个全遍历的过程，需要找寻几乎所有的排列组合且存在着 <strong>最小值的优化目标 –&gt; 适合动态规划</strong>   </p>\n</li>\n</ol>\n<p>   <strong>为什么感觉问题解决会复杂？</strong></p>\n<p>   会发现增删都会改变字母的对应位置，而替换不改变位置，一些不同位置的字母可以通过增删变成对应相同位置的字母，也就是说三个操作之间相互关联。</p>\n<p>   同样的问题思考时候，word1变成word2其实也等价于word2变成word1,解题的流程是完全对称的。</p>\n<p>   结合以上因素，可以说一个dp状态就有了三种类型的迁移计算，那么我们需要设置一个dp[][][]的三维数组来分别表示三类状态迁移嘛？并不需要，因为替换可以等效为先减少一个字母，然后再增加一个字母只是代价增加为1而不是2，所以可以使用一个二维数组来表示：也就是dp[i][j]；其中i方向可以表示为减少word1 字母的操作，j方向标识增加word2字母的操作，i和j 同时增长表示替换操作：即先减少word1字母，然后增加word2字母。</p>\n<p>   还可以看到的是，依据上面的思考流程，i/j应当是和word1/2当中的单词位置相关联的；而麻烦的地方就集中在这个地方的理解上 <font color='red'>dp[i][j] 表示的是将word1前i-1个字符变成word2前j-1个字符最少的操作数</font>，dp[i][j]并不代表一个字符串或者说一个字符串形式，但是到dp[i][j]的路径可以唯一对应一个字符串</p>\n<p>   同时当我们使用上述的二位矩阵来计算时会发现，实质上我们也计算了将 word2 变成 word1的最小操作数</p>\n<ol start=\"2\">\n<li><p>DP 解题流程</p>\n<ul>\n<li><strong>确定dp数组以及下标的含义</strong><br>dp[i][j] 表示的是将word1前i-1个字符变成word2前j-1个字符最少的操作数</li>\n</ul>\n<p>这里有两个需要强调的点：</p>\n<ul>\n<li><p>dp[i] 对应的字母是 word[i-1], 而 dp[0] 对应的是空字符<br>这样来规定矩阵的计算形式更有利于计算</p>\n</li>\n<li><p>矩阵中元素对应着操作数，到达操作数的路径对应字符串</p>\n</li>\n<li><p><strong>确定递推公式</strong></p>\n<blockquote>\n<p>也就是确认矩阵元素的迁移计算方向并计算操作数</p>\n</blockquote>\n</li>\n</ul>\n<p>如果word1[i - 1] == word2[j - 1]，也就意味着对应位置的字母是相同的，那么增删或者删增同一个字母是没有必要，在矩阵元素迁移中，表示向右下移动一格遍历一个字母，但是不用操作两字符串，dp[i][j]操作数不用增加。</p>\n<p>如果word1[i - 1] != word2[j - 1]，那么接下来在矩阵当中移动，在i方向就意味着对word1[i-1]字母进行减操作，在j方向就意味着对word2[j-1]字母进行加操作</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (word1[i - 1] == word2[j - 1])</span><br><span class=\"line\">    不操作</span><br><span class=\"line\">if (word1[i - 1] != word2[j - 1])</span><br><span class=\"line\">    dp[i][j] = min (增,删,换)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>dp数组如何初始化</strong><br>考虑到空字符串的计算，也就是说对另一方不做操作的情况：</li>\n<li>d[i][0] 表示只减少word1的字母</li>\n<li>d[0][j] 表示只增加word2的字母</li>\n<li>d[0][0] 表示空字母</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li><strong>确定遍历顺序</strong><br>将word1变成word2，也就是意味着需要遍历每一个word1字母和每一个word2字母<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dp[i][j] = dp[i - 1][j - 1]  // i-1,j-1位置两个字符串的字母相同，不用操作，所以在状态迁移时候不用增加dp操作数</span><br><span class=\"line\"></span><br><span class=\"line\">//i-1,j-1位置两个字符串的字母不相同，需要对i-1，j-1位置上的字母做操作</span><br><span class=\"line\">dp[i][j] = dp[i - 1][j - 1] + 1 //替换</span><br><span class=\"line\">dp[i][j] = dp[i][j - 1] + 1 // 增加</span><br><span class=\"line\">dp[i][j] = dp[i - 1][j] + 1 // 减少</span><br></pre></td></tr></table></figure></li>\n</ul>\n<ul>\n<li><strong>举例推导dp数组</strong></li>\n</ul>\n<h3 id=\"代码实现-1\"><a href=\"#代码实现-1\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><hr>\n<h2 id=\"两个字符串的删除操作\"><a href=\"#两个字符串的删除操作\" class=\"headerlink\" title=\"两个字符串的删除操作\"></a>两个字符串的删除操作</h2><blockquote>\n<p>题目链接：(<a href=\"https://leetcode.cn/problems/delete-operation-for-two-strings/\">https://leetcode.cn/problems/delete-operation-for-two-strings/</a>)</p>\n</blockquote>\n<h3 id=\"解题流程-2\"><a href=\"#解题流程-2\" class=\"headerlink\" title=\"解题流程\"></a>解题流程</h3><ol>\n<li>问题分析</li>\n<li>DP 解题流程<ul>\n<li><strong>确定dp数组以及下标的含义</strong></li>\n<li><strong>确定递推公式</strong></li>\n<li><strong>dp数组如何初始化</strong></li>\n<li><strong>确定遍历顺序</strong></li>\n<li><strong>举例推导dp数组</strong><h3 id=\"代码实现-2\"><a href=\"#代码实现-2\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3></li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2 id=\"最长公共子序列\"><a href=\"#最长公共子序列\" class=\"headerlink\" title=\"最长公共子序列\"></a>最长公共子序列</h2><blockquote>\n<p>题目链接：(<a href=\"https://leetcode.cn/problems/longest-common-subsequence/\">https://leetcode.cn/problems/longest-common-subsequence/</a>)</p>\n</blockquote>\n<h3 id=\"解题流程-3\"><a href=\"#解题流程-3\" class=\"headerlink\" title=\"解题流程\"></a>解题流程</h3><ol>\n<li>问题分析</li>\n<li>DP 解题流程<ul>\n<li><strong>确定dp数组以及下标的含义</strong></li>\n<li><strong>确定递推公式</strong></li>\n<li><strong>dp数组如何初始化</strong></li>\n<li><strong>确定遍历顺序</strong></li>\n<li><strong>举例推导dp数组</strong><h3 id=\"代码实现-3\"><a href=\"#代码实现-3\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3></li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2 id=\"打家劫舍\"><a href=\"#打家劫舍\" class=\"headerlink\" title=\"打家劫舍\"></a>打家劫舍</h2><h3 id=\"解题流程-4\"><a href=\"#解题流程-4\" class=\"headerlink\" title=\"解题流程\"></a>解题流程</h3><ol>\n<li>问题分析</li>\n<li>DP 解题流程<ul>\n<li><strong>确定dp数组以及下标的含义</strong></li>\n<li><strong>确定递推公式</strong></li>\n<li><strong>dp数组如何初始化</strong></li>\n<li><strong>确定遍历顺序</strong></li>\n<li><strong>举例推导dp数组</strong><h3 id=\"代码实现-4\"><a href=\"#代码实现-4\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3></li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2 id=\"斐波那契数-1\"><a href=\"#斐波那契数-1\" class=\"headerlink\" title=\"斐波那契数\"></a>斐波那契数</h2><h3 id=\"解题流程-5\"><a href=\"#解题流程-5\" class=\"headerlink\" title=\"解题流程\"></a>解题流程</h3><ol>\n<li>问题分析</li>\n<li>DP 解题流程<ul>\n<li><strong>确定dp数组以及下标的含义</strong></li>\n<li><strong>确定递推公式</strong></li>\n<li><strong>dp数组如何初始化</strong></li>\n<li><strong>确定遍历顺序</strong></li>\n<li><strong>举例推导dp数组</strong><h3 id=\"代码实现-5\"><a href=\"#代码实现-5\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3></li>\n</ul>\n</li>\n</ol>\n","site":{"data":{}},"cover":"/img/cover/sky2.png","cover_type":"img","excerpt":"","more":"<h1 id=\"动态规划-动态规划问题\"><a href=\"#动态规划-动态规划问题\" class=\"headerlink\" title=\"[动态规划] 动态规划问题\"></a>[动态规划] 动态规划问题</h1><blockquote>\n<p>本文将过一遍所遇见的所有动态规划解决的问题并给出代码</p>\n</blockquote>\n<h2 id=\"斐波那契数\"><a href=\"#斐波那契数\" class=\"headerlink\" title=\"斐波那契数\"></a>斐波那契数</h2><blockquote>\n<p>力扣题目链接[<a href=\"https://leetcode.cn/problems/fibonacci-number/]\">https://leetcode.cn/problems/fibonacci-number/]</a></p>\n</blockquote>\n<h3 id=\"解题流程\"><a href=\"#解题流程\" class=\"headerlink\" title=\"解题流程\"></a>解题流程</h3><ol>\n<li><p>问题分析<br>斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列。</p>\n<p>该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： F(0) = 0，F(1) = 1 F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1 问题需求是给n ，请计算 F(n) 的值。</p>\n<p>显然 i 的值包含整个定义域，求解的F(i) 也就是整个解集，需要遍历整个结果集来找对应 i 的解，可以使用 DP 来求解。</p>\n</li>\n<li><p>DP 解题流程</p>\n<ul>\n<li><p><strong>确定dp数组以及下标的含义</strong></p>\n<p>   dp[i]的定义为：第i个数的斐波那契数值是dp[i]</p>\n</li>\n<li><p><strong>确定递推公式</strong></p>\n<p>   确定得到每一个dp[i]的公式，或者说遍历整个结果集合的方式</p>\n<p>   在本题目当中，直接给出的是斐波那契数列<br>状态转移方程 dp[i] = dp[i - 1] + dp[i - 2];</p>\n</li>\n<li><p><strong>dp数组如何初始化</strong></p>\n<blockquote>\n<p>本质上就是<strong>寻找边界值，什么时候开始、什么时候结束</strong>，在所有需要遍历的操作当中都需要考虑这个问题</p>\n</blockquote>\n<p>   一般的斐波那契数列已经给出初始边界值：</p>\n   <figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dp[<span class=\"number\">0</span>] := <span class=\"number\">0</span></span><br><span class=\"line\">dp[<span class=\"number\">1</span>] := <span class=\"number\">1</span></span><br></pre></td></tr></table></figure></li>\n<li><p><strong>确定遍历顺序</strong></p>\n<p>   从递归公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，dp[i]是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序一定是从前到后遍历的</p>\n</li>\n<li><p><strong>举例推导dp数组</strong></p>\n<p>   按照这个递推公式dp[i] = dp[i - 1] + dp[i - 2]，我们来推导一下，当N为10的时候，dp数组应该是如下的数列：</p>\n<p>   0 1 1 2 3 5 8 13 21 34 55</p>\n<p>   如果代码写出来，发现结果不对，就把dp数组打印出来看看和我们推导的数列是不是一致的。</p>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><p>使用一个数组保存所有遍历的结果，通过索引i直接找到 f[i]对应的值：</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">fib</span><span class=\"params\">(n <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> ans []<span class=\"type\">int</span></span><br><span class=\"line\">    ans = <span class=\"built_in\">append</span>(ans,<span class=\"number\">0</span>)</span><br><span class=\"line\">    ans = <span class=\"built_in\">append</span>(ans,<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">2</span> ; i &lt;= n ; i++ &#123;</span><br><span class=\"line\">        temp := ans[i<span class=\"number\">-1</span>] + ans[i<span class=\"number\">-2</span>]</span><br><span class=\"line\">        ans = <span class=\"built_in\">append</span>(ans,temp)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans[n]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>时间复杂度：O(n)</li>\n<li>空间复杂度：O(n)</li>\n</ul>\n<p>但是可以观察到保留的 f 数组其实只用到了一个变量f[i], 并且最后需要的结果是一个固定值 n，也就是说结果是确定位置的，那么是可以只保留计算获得 f[n] 相关的值就可以：f[n-1] 和 f[n-2]，这样的保留过程对于其他的 i 值来说也完全一样，除了 n=0 和 n=1 两个时候的值，那么就需要单独对这两个值来做处理</p>\n<p>只保留的pre和now,也可以改成 tmp[i-1] 和 tmp[i-2]也就是改成一个长度为2的一维数组–滚动数组，该数组存储有效信息并跟随遍历的阶段移动</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">fib</span><span class=\"params\">(n <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    pre := <span class=\"number\">0</span></span><br><span class=\"line\">    now := <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i:= <span class=\"number\">2</span> ; i &lt;= n ; i++&#123;</span><br><span class=\"line\">        tmp := now</span><br><span class=\"line\">        now = now + pre</span><br><span class=\"line\">        pre = tmp</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> n == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        now = <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> now</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"编辑距离\"><a href=\"#编辑距离\" class=\"headerlink\" title=\"编辑距离\"></a>编辑距离</h2><blockquote>\n<p>力扣题目链接: (<a href=\"https://leetcode.cn/problems/edit-distance/\">https://leetcode.cn/problems/edit-distance/</a>)</p>\n</blockquote>\n<h3 id=\"解题流程-1\"><a href=\"#解题流程-1\" class=\"headerlink\" title=\"解题流程\"></a>解题流程</h3><ol>\n<li><p>问题分析<br>将word1变成word2，共有三类型的操作：增加、删除、替换；同时计算操作数最小的情况。</p>\n<p><strong>是否使用动态规划</strong><br>一个最直白的想法就是我先把word1里面每一个字母都删除，进行len(word1)次操作；然后再加上word2里面的每一个字母，进行len(word2)次操作，当然这样的操作是次数最多的，是完全没有考虑到两个字符之间的关联性，当在字符串里面有相同的字母时候，就可以不操作跳过，再对后面的字符进行操作。</p>\n<p>这样不断地替换中间的操作流程就是一个全遍历的过程，需要找寻几乎所有的排列组合且存在着 <strong>最小值的优化目标 –&gt; 适合动态规划</strong>   </p>\n</li>\n</ol>\n<p>   <strong>为什么感觉问题解决会复杂？</strong></p>\n<p>   会发现增删都会改变字母的对应位置，而替换不改变位置，一些不同位置的字母可以通过增删变成对应相同位置的字母，也就是说三个操作之间相互关联。</p>\n<p>   同样的问题思考时候，word1变成word2其实也等价于word2变成word1,解题的流程是完全对称的。</p>\n<p>   结合以上因素，可以说一个dp状态就有了三种类型的迁移计算，那么我们需要设置一个dp[][][]的三维数组来分别表示三类状态迁移嘛？并不需要，因为替换可以等效为先减少一个字母，然后再增加一个字母只是代价增加为1而不是2，所以可以使用一个二维数组来表示：也就是dp[i][j]；其中i方向可以表示为减少word1 字母的操作，j方向标识增加word2字母的操作，i和j 同时增长表示替换操作：即先减少word1字母，然后增加word2字母。</p>\n<p>   还可以看到的是，依据上面的思考流程，i/j应当是和word1/2当中的单词位置相关联的；而麻烦的地方就集中在这个地方的理解上 <font color='red'>dp[i][j] 表示的是将word1前i-1个字符变成word2前j-1个字符最少的操作数</font>，dp[i][j]并不代表一个字符串或者说一个字符串形式，但是到dp[i][j]的路径可以唯一对应一个字符串</p>\n<p>   同时当我们使用上述的二位矩阵来计算时会发现，实质上我们也计算了将 word2 变成 word1的最小操作数</p>\n<ol start=\"2\">\n<li><p>DP 解题流程</p>\n<ul>\n<li><strong>确定dp数组以及下标的含义</strong><br>dp[i][j] 表示的是将word1前i-1个字符变成word2前j-1个字符最少的操作数</li>\n</ul>\n<p>这里有两个需要强调的点：</p>\n<ul>\n<li><p>dp[i] 对应的字母是 word[i-1], 而 dp[0] 对应的是空字符<br>这样来规定矩阵的计算形式更有利于计算</p>\n</li>\n<li><p>矩阵中元素对应着操作数，到达操作数的路径对应字符串</p>\n</li>\n<li><p><strong>确定递推公式</strong></p>\n<blockquote>\n<p>也就是确认矩阵元素的迁移计算方向并计算操作数</p>\n</blockquote>\n</li>\n</ul>\n<p>如果word1[i - 1] == word2[j - 1]，也就意味着对应位置的字母是相同的，那么增删或者删增同一个字母是没有必要，在矩阵元素迁移中，表示向右下移动一格遍历一个字母，但是不用操作两字符串，dp[i][j]操作数不用增加。</p>\n<p>如果word1[i - 1] != word2[j - 1]，那么接下来在矩阵当中移动，在i方向就意味着对word1[i-1]字母进行减操作，在j方向就意味着对word2[j-1]字母进行加操作</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (word1[i - 1] == word2[j - 1])</span><br><span class=\"line\">    不操作</span><br><span class=\"line\">if (word1[i - 1] != word2[j - 1])</span><br><span class=\"line\">    dp[i][j] = min (增,删,换)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>dp数组如何初始化</strong><br>考虑到空字符串的计算，也就是说对另一方不做操作的情况：</li>\n<li>d[i][0] 表示只减少word1的字母</li>\n<li>d[0][j] 表示只增加word2的字母</li>\n<li>d[0][0] 表示空字母</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li><strong>确定遍历顺序</strong><br>将word1变成word2，也就是意味着需要遍历每一个word1字母和每一个word2字母<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dp[i][j] = dp[i - 1][j - 1]  // i-1,j-1位置两个字符串的字母相同，不用操作，所以在状态迁移时候不用增加dp操作数</span><br><span class=\"line\"></span><br><span class=\"line\">//i-1,j-1位置两个字符串的字母不相同，需要对i-1，j-1位置上的字母做操作</span><br><span class=\"line\">dp[i][j] = dp[i - 1][j - 1] + 1 //替换</span><br><span class=\"line\">dp[i][j] = dp[i][j - 1] + 1 // 增加</span><br><span class=\"line\">dp[i][j] = dp[i - 1][j] + 1 // 减少</span><br></pre></td></tr></table></figure></li>\n</ul>\n<ul>\n<li><strong>举例推导dp数组</strong></li>\n</ul>\n<h3 id=\"代码实现-1\"><a href=\"#代码实现-1\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><hr>\n<h2 id=\"两个字符串的删除操作\"><a href=\"#两个字符串的删除操作\" class=\"headerlink\" title=\"两个字符串的删除操作\"></a>两个字符串的删除操作</h2><blockquote>\n<p>题目链接：(<a href=\"https://leetcode.cn/problems/delete-operation-for-two-strings/\">https://leetcode.cn/problems/delete-operation-for-two-strings/</a>)</p>\n</blockquote>\n<h3 id=\"解题流程-2\"><a href=\"#解题流程-2\" class=\"headerlink\" title=\"解题流程\"></a>解题流程</h3><ol>\n<li>问题分析</li>\n<li>DP 解题流程<ul>\n<li><strong>确定dp数组以及下标的含义</strong></li>\n<li><strong>确定递推公式</strong></li>\n<li><strong>dp数组如何初始化</strong></li>\n<li><strong>确定遍历顺序</strong></li>\n<li><strong>举例推导dp数组</strong><h3 id=\"代码实现-2\"><a href=\"#代码实现-2\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3></li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2 id=\"最长公共子序列\"><a href=\"#最长公共子序列\" class=\"headerlink\" title=\"最长公共子序列\"></a>最长公共子序列</h2><blockquote>\n<p>题目链接：(<a href=\"https://leetcode.cn/problems/longest-common-subsequence/\">https://leetcode.cn/problems/longest-common-subsequence/</a>)</p>\n</blockquote>\n<h3 id=\"解题流程-3\"><a href=\"#解题流程-3\" class=\"headerlink\" title=\"解题流程\"></a>解题流程</h3><ol>\n<li>问题分析</li>\n<li>DP 解题流程<ul>\n<li><strong>确定dp数组以及下标的含义</strong></li>\n<li><strong>确定递推公式</strong></li>\n<li><strong>dp数组如何初始化</strong></li>\n<li><strong>确定遍历顺序</strong></li>\n<li><strong>举例推导dp数组</strong><h3 id=\"代码实现-3\"><a href=\"#代码实现-3\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3></li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2 id=\"打家劫舍\"><a href=\"#打家劫舍\" class=\"headerlink\" title=\"打家劫舍\"></a>打家劫舍</h2><h3 id=\"解题流程-4\"><a href=\"#解题流程-4\" class=\"headerlink\" title=\"解题流程\"></a>解题流程</h3><ol>\n<li>问题分析</li>\n<li>DP 解题流程<ul>\n<li><strong>确定dp数组以及下标的含义</strong></li>\n<li><strong>确定递推公式</strong></li>\n<li><strong>dp数组如何初始化</strong></li>\n<li><strong>确定遍历顺序</strong></li>\n<li><strong>举例推导dp数组</strong><h3 id=\"代码实现-4\"><a href=\"#代码实现-4\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3></li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2 id=\"斐波那契数-1\"><a href=\"#斐波那契数-1\" class=\"headerlink\" title=\"斐波那契数\"></a>斐波那契数</h2><h3 id=\"解题流程-5\"><a href=\"#解题流程-5\" class=\"headerlink\" title=\"解题流程\"></a>解题流程</h3><ol>\n<li>问题分析</li>\n<li>DP 解题流程<ul>\n<li><strong>确定dp数组以及下标的含义</strong></li>\n<li><strong>确定递推公式</strong></li>\n<li><strong>dp数组如何初始化</strong></li>\n<li><strong>确定遍历顺序</strong></li>\n<li><strong>举例推导dp数组</strong><h3 id=\"代码实现-5\"><a href=\"#代码实现-5\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3></li>\n</ul>\n</li>\n</ol>\n"},{"title":"Golang 算法课程--算法","catalog":true,"date":"2023-04-04T16:46:21.000Z","subtitle":null,"header-img":null,"_content":"\n> 考前简单题目遍历：\n\n\n\n### [双边判断 - 最后一个单词的长度 - 力扣（LeetCode）](https://leetcode.cn/problems/length-of-last-word/solution/shuang-bian-pan-duan-by-xing-82s-xing/)\n\n- 下标 < 0 或者是 下标 > 数组长度-1的情况都需要考虑\n- for 循环要善用，一般的结构组成就是 for{if{}}\n\n```go\nfunc lengthOfLastWord(s string) int {\n    if len(s) == 1 && s[0] == ' ' {\n        return 0\n    }\n    // 计算下标--双指针\n    l := len(s)\n    left, right := l-1,l-1\n    // 找到末尾第一个非空字符\n    for i := l-1 ; s[i] == ' '; i--{\n        right--\n    }\n    // 找到末尾第二轮开始空的字符\n    left = right\n    for i := right ; s[i] != ' '; i--{\n        left--\n        if left < 0{\n            break\n        }\n    }\n    return right - left\n}\n```\n\n\n\n### [使用数组按位 - 二进制求和 - 力扣（LeetCode）](https://leetcode.cn/problems/add-binary/solution/shi-yong-shu-zu-an-wei-by-xing-82s-ris9/)\n\n本题目是位计算和字符串转数值计算的典型例子：\n仅针对字符串的处理有几点需要格外关注：\n\nstring 转 int 按位处理需要借助 byte (当然也可以直接使用strconv.ParseInt(a,2,64),但这样就需要考虑符号位以及其他的因素了)\nstring 的 a[i] ，所获取的值是 byte 类型（补充如果是一整个string转化位 []byte，如果含有中文使用[]rune）\n得到第 i 位的十进制表示的二进制数方式是： i := int(a[i]-'0')\n字符串的 + 存在先后顺序；换句话说 i+j 与 j+i所获得字符串不相同是ij,ji,这里的注意点是字符串计算不再使用栈来规划顺序，可以直接使用符号位置来表示\ncarry 同时表示了进位和当前位的结果值，这个特点是在位运算当中常见，需要记忆模板，其他题目的类型按照结果归纳，需要归类\n这里需要计算对齐的是两数的末位，所以需要计算的下标为la-i-1\n\n```go\nfunc addBinary(a string, b string) string {\n    //  按位计算并保存一个进位的结果\n    //  1. string 按位计算不能够一步到位直接转化为int，需要借助中间值byte\n    //  2. 优化逻辑：O(n)的复杂度，遍历的时间复杂度取决于 最长的字符串的长度\n    la,lb := len(a),len(b)\n    l := maxi(la,lb)\n    res := \"\"\n    carry:= 0\n    for i := 0; i < l; i++{\n        if i < la {\n            carry += int(a[la-i-1]-'0')\n        }\n        if i < lb {\n            carry += int(b[lb-i-1]-'0')\n        }\n        res = strconv.Itoa(carry%2) + res\n        carry /= 2\n    }\n    if carry > 0 {\n        res = \"1\" + res\n    }\n    return res\n}\n```\n\n\n\n### [字符串转数字比较 - 重复的DNA序列 - 力扣（LeetCode）](https://leetcode.cn/problems/repeated-dna-sequences/solution/zi-fu-chuan-zhuan-shu-zi-bi-jiao-by-xing-lye5/)\n\n```go\nconst L = 10\nvar bmap = map[byte]int{'A':0,'C':1,'G':2,'T':3}\n\nfunc findRepeatedDnaSequences(s string) (ans []string) {\n    // 滑动窗口\n    // 需要对边界条件 n 小于窗口大小时候判断,当等于窗口大小的时候，也不满足条件，一定要注意等号的边界条件\n    if len(s) <= L {\n        return \n    }\n    win := 0\n    // 初始化窗口，将 L 个字符统计出来\n    // 注意点1： string 单取是byte类型,而map 当中所存的应该也是单个字符byte\n    // 注意点2： for  range 遍历的时候，并不需要控制中间的i对象，所以可以直接用迭代的 v\n    // 注意点3： 这里的初始化只需要将首先的10个数字包含进来就可以\n    for _, v := range s[:L-1] {\n        win = (win<<2) | bmap[byte(v)]\n    }\n\n    res := make(map[int]int,0)\n    // 选择低位作为开始是为了解决切片的问题，这样加入到结果的字符串当中，只需要操作 s[i:i+L]\n    for i := 0; i <= len(s)-L;i++{\n        win = ((win<<2) | bmap[s[i+L-1]]) & ((1<<20)-1)\n        res[win]++\n        // 这个地方只能判断为 2 但不能够是其他的情况，因为出现多次，只需要大于2就满足条件了，但是这个循环会把大于1的字符串每次都加在结果数组当中一次，这样结果当中就会存在非常多的重复的字符串了\n        if res[win] == 2  {\n            ans = append(ans,s[i:i+L])\n        }\n    }\n    return ans\n}\n```\n\n\n\n### [二分法解决这道题目 - x 的平方根 - 力扣（LeetCode）](https://leetcode.cn/problems/sqrtx/solution/er-fen-fa-jie-jue-zhe-dao-ti-mu-by-xing-pq1tt/)\n\n这道题目是用二分法来找到一个近似的大致解，逻辑是二分搜索小于 x 区间上的数，数理逻辑是简单的，因为他的根肯定比他自己小等，且把问题只求整数区间的答案，是完全有限的\n\n问题在于二分法的边界问题：\n\n题目的二分区间是 左右均闭区间，所以循环结束条件是二者相相遇时候，而移动指针，则因为判断不满足条件时候要抛弃边界值，所以左右指针都会在mid基础上改变，模板为：\n\n    for left <= right {\n        mid = left + (right-left)/2\n        ValueOfMid = func(mid)\n        if ValueOfMid <= target{\n            res = mid//  因为这里判断的结果边界就是所需要的答案\n            left = mid + 1 // 左闭区间，如果 mid 不是所求答案，则必然小于答案，直接抛弃mid值\n        }else{\n            right = mid - 1 // 右闭区间\n        }\n}\n我做了改动，使其变成 左闭右开区间，但这可情况下忽略了 right == left 以及二者相差为1时候的情况，所以在前面补全，但是这并不意味着这个判断就不好，由于左闭右开，所以右边实际上一直指向的是一个空值（逻辑上），在判断条件最后相遇的情况下，可以明确的就是答案一定不会在 [right, x-1]这个区间范围内，所以查找的循环只会在 left < right；如果二者相遇还没找到答案，那么就代表不存在解。\n\n```go\nfunc mySqrt(x int) int {\n    // 使用二分法来解决\n    left,right := 0,x\n    ans := -1\n    if right - left <= 1 {\n        return x\n    }\n    for left < right {\n        mid := left + (right - left)/2\n        if mid*mid <= x {\n            ans = mid\n            left = mid + 1\n        }else{\n            right = mid\n        }\n    }\n    return ans\n}\n```\n\n\n\n### [70. 爬楼梯 - 力扣（LeetCode）](https://leetcode.cn/problems/climbing-stairs/submissions/)\n\n![image-20230506104126885](Y:\\Blog\\blog\\source\\_posts\\Algorithm\\leetcode\\leet_simple_70.png)\n\n```go\nfunc climbStairs(n int) int {\n    // 使用回溯法来解决这个问题\n    // 但是递归回溯存在大量的重复判断排列组合的部分\n    // res := 0\n    // var stepin func(left int)\n    // stepin = func(left int){\n    //     if left < 0 {\n    //         return \n    //     }\n    //     if left == 0 {\n    //         res++\n    //     }\n    //     stepin(left-1)\n    //     stepin(left-2)\n    // }\n    // stepin(n)\n    // return res\n    // 动态规划\n    // dp := make([]int,n+1)\n    // dp[0],dp[1] = 1,1\n    // for i := 2; i <= n; i++{\n    //     dp[i] = dp[i-1]+dp[i-2]\n    // }\n    // return dp[n]\n    // 优化内存的表现\n    pre, cur ,tmp := 1,1,0\n    for i := 0; i < n; i++{\n        tmp = pre + cur\n        pre = cur\n        cur = tmp\n    }\n    return pre\n}\n```\n\n\n\n### [合并两个有序数组 - 合并两个有序数组 - 力扣（LeetCode）](https://leetcode.cn/problems/merge-sorted-array/solution/he-bing-liang-ge-you-xu-shu-zu-by-leetco-rrb0/)\n\n使用双指针的时候，因为创建了新的数组，而返回值使原本的数组切片指针，这个时候要么再来一个for循环修改原num1的底层数组，要么只能深拷贝 copy(nums1,sorted)\n\n```go\nfunc merge(nums1 []int, m int, nums2 []int, n int) {\n    sorted := make([]int, 0, m+n)\n    p1, p2 := 0, 0\n    // 使用双指针分别指向此时对应的最小值\n    for {\n        // 这两个if的判断很典型，当双指针有其中一个到达了边界，证明对方为空\n        // 将长的数组剩余全部加入\n        // 使用方法是append(sorted,num[p2:]...)\n        // 需要记住这个一次性加入多个切片的操作写法:append(target, n[]...)\n        if p1 == m {\n            sorted = append(sorted, nums2[p2:]...)\n            break\n        }\n        if p2 == n {\n            sorted = append(sorted, nums1[p1:]...)\n            break\n        }\n        if nums1[p1] < nums2[p2] {\n            sorted = append(sorted, nums1[p1])\n            p1++\n        } else {\n            sorted = append(sorted, nums2[p2])\n            p2++\n        }\n    }\n    // 对底层数组的修改，需要尤为注意\n    // 只有 copy会把底层数组的值给复制过去，其他使用 = 的情况只是切片对象，也就是一个指针，如果底层数组改变了，那么结果也就改变了\n    copy(nums1, sorted)\n}\n```\n\n\n\n### [ 二叉树的最大深度 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-depth-of-binary-tree/solution/ke-yi-shi-xiao-gai-goyu-yan-zhu-xing-zhu-q5a0/)\n\n```go\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc maxDepth(root *TreeNode) int {\n  \t//根节点为空，最大深度返回0 \n    if root == nil {\n\t\treturn 0\n\t}\n    //记录左子树的最大深度\n\tleftMax := maxDepth(root.Left)\n    //记录有右子树的最大深度\n\trightMax := maxDepth(root.Right)\n    //最终的深度=左子树和右子树的max，然就再加上根节点还有的1,\n\theight := 1 + max(leftMax, rightMax)\n\treturn height\n}\n\nfunc max(a,b int)int {\n    if a>b {\n        return a\n    }\n    return b \n}\n```\n\n\n\n### [将有序数组转换为二叉搜索树 - 力扣（LeetCode）](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/solution/tu-jie-er-cha-sou-suo-shu-gou-zao-di-gui-python-go/)\n\n构造树，不论顺序如何，必定是存在着 `node := &TreeNode{val, getTree(right/left), getTree(right/left) }`  , 先得把节点构造出来作为根节点，然后再去遍历找其他的节点\n\n```go\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc sortedArrayToBST(nums []int) *TreeNode {\n    if len(nums) == 0 {\n        return nil\n    }\n\n    mid := len(nums) / 2\n    \n    left := nums[:mid]\n    right := nums[mid+1:]\n    // 这个递归的设计非常优美，递归的核心是构造了mid值得根节点，然后继续递归传入左右的切片\n    node := &TreeNode{nums[mid], sortedArrayToBST(left), sortedArrayToBST(right)}\n\n    return node\n}\n```\n\n\n\n### [ 二叉树的最小深度 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-depth-of-binary-tree/solution/ke-yi-shi-xiao-gai-goyu-yan-zhu-xing-zhu-q9ed/)\n\n出现特殊情况是因为最小深度，会计算到有一个子树为空的情况，但是另一个子树不一定为空，那么其根节点就不是叶子节点\n\n```go\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\n \n//tips:利用左右根（后续遍历） 求出的最小高度，也是这棵树的最小深度\nfunc minDepth(root *TreeNode) int {\n\tif root == nil {\n\t\treturn 0\n\t}\n\t//先求出左右子树的最小深度\n\tleftMin := minDepth(root.Left)\n\trightMin := minDepth(root.Right)\n\n\t/*\n\t\t1.但是要考虑特殊情况，根节点的左子树为空，右子树不为空，\n        不能直接min(root.Left,root.Right)，\n\t\t2.因为不符合题目“根节点到最近叶子节点的最短路径上的节点数量”\n        的要求一定要有叶子节点\n\t*/\n\tif root.Left == nil && root.Right != nil {\n\t\treturn 1 + rightMin\n\t\t//如上\n\t} else if root.Left != nil && root.Right == nil {\n\t\treturn 1 + leftMin\n\t\t//如果左右子树都不为空才能用min\n\t} else {\n\t\treturn 1 + min(leftMin, rightMin)\n\t}\n}\n\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n```\n\n\n\n### [118. 杨辉三角 - 力扣（LeetCode）](https://leetcode.cn/problems/pascals-triangle/submissions/)\n\n使用 dp 解题,核心在于杨辉三角的计算过程符合 dp 的问题拆解\n\n```go\nfunc generate(numRows int) [][]int {\n    // dp 模板1： 创建dp数组一维或者是二维\n    dp := make([][]int, numRows)\n\tif numRows == 0 {\n\t\treturn dp\n\t}\n    // dp 数组的初始化，一般来说需要在纸上把这个dp数组画出来，然后观察数组的规律，将那些dp[][]边界值给计算出来\n    \n\tfor k := range dp {\n\t\tdp[k] = make([]int, k+1)\n\t}\n\tfor i := 0; i < numRows; i++ {\n\t\tfor j := 0; j < i+1; j++ {\n\t\t\tif j == 0 || j == i {\n\t\t\t\tdp[i][j] = 1\n\t\t\t} else {\n\t\t\t\tdp[i][j] = dp[i-1][j] + dp[i-1][j-1]\n\t\t\t}\n\t\t}\n\t}\n\treturn dp\n}\n```\n\n\n\n### [单调栈，贪心算法，最简单的思路，找到最小值，找到其后最大值，两个相减即可得 - 买卖股票的最佳时机 - 力扣（LeetCode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/solution/-by-gracious-vvilson1bb-w8yb/)\n\n关键常数，直接背住：\n\n```go\n\tmaxs :=math.MinInt64\n\tmins :=math.MaxInt64\n```\n\n单调栈来一次 O(n^2)遍历一次找到所有的元素向右间距，比较出最大值就可以\n\n题目做了优化，考虑贪心的方法\n\n```go\nfunc maxProfit(prices []int) (s int) {\n\tmaxs :=math.MinInt64\n\tmins :=math.MaxInt64\n\tfor i := 0; i < len(prices); i++ {\n        // 由于 max 总是在已有的 mins 基础上来计算，相当于这个问题就变成了\n        // 遍历先找当前最小的元素\n        // 再计算当前元素比之前最小元素大的间距\n        // 因为本体的大小关系只局限在数组元素的大小，而不考虑数组下标的间距，所以可以直接寻找最优解\n\t\t//记一个最小值\n\t\tmins =min(mins,prices[i])\n\t\t//记一个最大值\n\t\tmaxs =max(maxs,prices[i]-mins)\n\n\t}\n\t//返回最大差值\n\treturn maxs\n}\n\nfunc max(x, y int) int {\n\tif x > y {\n\t\treturn x\n\t} else {\n\t\treturn y\n\t}\n}\nfunc min(x, y int) int {\n\tif x > y {\n\t\treturn y\n\t} else {\n\t\treturn x\n\t}\n}\n```\n\n\n\n### [dp-丑数 II - 丑数 II - 力扣（LeetCode）](https://leetcode.cn/problems/ugly-number-ii/solution/chou-shu-ii-by-beney-2-0uk5/)\n\n关键点1 ： 求因数的计算常规是：\n\n```go\n%n == 0 表示n是他的因数\n```\n\n关键点2：第 n  个丑数是前面 某个丑数 *2或者 *3 或者 *5 得来的，且对于同一个数而言他的丑数因数乘以2，3，5肯定不一样（可证），反过来也就是说每一个丑数 乘2乘3乘5所得的丑数不一样\n\n```go\nfunc nthUglyNumber(n int) int {\n    if n == 0 {\n        panic(errors.New(\"invalid n\"))\n    }\n    m2, m3, m5 := 0, 0, 0\n    dp := make([]int, n)\n    dp[0] = 1\n    for i := 1; i < n; i++ {\n        a, b, c := dp[m2]*2, dp[m3]*3, dp[m5]*5\n        dp[i] = min(a, min(b, c))\n        if dp[i] == a {\n            m2++\n        }\n        if dp[i] == b {\n            m3++\n        }\n        if dp[i] == c {\n            m5++\n        }\n    }\n    return dp[n-1]\n}\n\nfunc min(x, y int) int {\n    if x < y {\n        return x\n    }\n    return y\n}\n```\n\n\n\n\n\n### [验证回文串 - 验证回文串 - 力扣（LeetCode）](https://leetcode.cn/problems/valid-palindrome/solution/yan-zheng-hui-wen-chuan-by-leetcode-solution/)\n\n关键点在于对输入数据的处理:48,65,97\n\n1. 判断是否是字母数字字符\n\n   ```go\n   func isalnum(ch byte) bool {\n       return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z') || (ch >= '0' && ch <= '9')\n   }\n   ```\n\n2. 大写转小写\n\n   ```go\n   strings.ToLower(s)\n   strings.ToUpper(s)\n   ```\n\n   其他常用提醒：\n\n   ```go\n   ```\n\n   \n\n","source":"_posts/Algorithm/script/leetcode/leet code 简单题目突破.md","raw":"---\ntitle: Golang 算法课程--算法\ncatalog: true\ndate: 2023-04-05 00:46:21\nsubtitle:\nheader-img:\ntags: working, 算法\ncategories: 算法，Golang\n---\n\n> 考前简单题目遍历：\n\n\n\n### [双边判断 - 最后一个单词的长度 - 力扣（LeetCode）](https://leetcode.cn/problems/length-of-last-word/solution/shuang-bian-pan-duan-by-xing-82s-xing/)\n\n- 下标 < 0 或者是 下标 > 数组长度-1的情况都需要考虑\n- for 循环要善用，一般的结构组成就是 for{if{}}\n\n```go\nfunc lengthOfLastWord(s string) int {\n    if len(s) == 1 && s[0] == ' ' {\n        return 0\n    }\n    // 计算下标--双指针\n    l := len(s)\n    left, right := l-1,l-1\n    // 找到末尾第一个非空字符\n    for i := l-1 ; s[i] == ' '; i--{\n        right--\n    }\n    // 找到末尾第二轮开始空的字符\n    left = right\n    for i := right ; s[i] != ' '; i--{\n        left--\n        if left < 0{\n            break\n        }\n    }\n    return right - left\n}\n```\n\n\n\n### [使用数组按位 - 二进制求和 - 力扣（LeetCode）](https://leetcode.cn/problems/add-binary/solution/shi-yong-shu-zu-an-wei-by-xing-82s-ris9/)\n\n本题目是位计算和字符串转数值计算的典型例子：\n仅针对字符串的处理有几点需要格外关注：\n\nstring 转 int 按位处理需要借助 byte (当然也可以直接使用strconv.ParseInt(a,2,64),但这样就需要考虑符号位以及其他的因素了)\nstring 的 a[i] ，所获取的值是 byte 类型（补充如果是一整个string转化位 []byte，如果含有中文使用[]rune）\n得到第 i 位的十进制表示的二进制数方式是： i := int(a[i]-'0')\n字符串的 + 存在先后顺序；换句话说 i+j 与 j+i所获得字符串不相同是ij,ji,这里的注意点是字符串计算不再使用栈来规划顺序，可以直接使用符号位置来表示\ncarry 同时表示了进位和当前位的结果值，这个特点是在位运算当中常见，需要记忆模板，其他题目的类型按照结果归纳，需要归类\n这里需要计算对齐的是两数的末位，所以需要计算的下标为la-i-1\n\n```go\nfunc addBinary(a string, b string) string {\n    //  按位计算并保存一个进位的结果\n    //  1. string 按位计算不能够一步到位直接转化为int，需要借助中间值byte\n    //  2. 优化逻辑：O(n)的复杂度，遍历的时间复杂度取决于 最长的字符串的长度\n    la,lb := len(a),len(b)\n    l := maxi(la,lb)\n    res := \"\"\n    carry:= 0\n    for i := 0; i < l; i++{\n        if i < la {\n            carry += int(a[la-i-1]-'0')\n        }\n        if i < lb {\n            carry += int(b[lb-i-1]-'0')\n        }\n        res = strconv.Itoa(carry%2) + res\n        carry /= 2\n    }\n    if carry > 0 {\n        res = \"1\" + res\n    }\n    return res\n}\n```\n\n\n\n### [字符串转数字比较 - 重复的DNA序列 - 力扣（LeetCode）](https://leetcode.cn/problems/repeated-dna-sequences/solution/zi-fu-chuan-zhuan-shu-zi-bi-jiao-by-xing-lye5/)\n\n```go\nconst L = 10\nvar bmap = map[byte]int{'A':0,'C':1,'G':2,'T':3}\n\nfunc findRepeatedDnaSequences(s string) (ans []string) {\n    // 滑动窗口\n    // 需要对边界条件 n 小于窗口大小时候判断,当等于窗口大小的时候，也不满足条件，一定要注意等号的边界条件\n    if len(s) <= L {\n        return \n    }\n    win := 0\n    // 初始化窗口，将 L 个字符统计出来\n    // 注意点1： string 单取是byte类型,而map 当中所存的应该也是单个字符byte\n    // 注意点2： for  range 遍历的时候，并不需要控制中间的i对象，所以可以直接用迭代的 v\n    // 注意点3： 这里的初始化只需要将首先的10个数字包含进来就可以\n    for _, v := range s[:L-1] {\n        win = (win<<2) | bmap[byte(v)]\n    }\n\n    res := make(map[int]int,0)\n    // 选择低位作为开始是为了解决切片的问题，这样加入到结果的字符串当中，只需要操作 s[i:i+L]\n    for i := 0; i <= len(s)-L;i++{\n        win = ((win<<2) | bmap[s[i+L-1]]) & ((1<<20)-1)\n        res[win]++\n        // 这个地方只能判断为 2 但不能够是其他的情况，因为出现多次，只需要大于2就满足条件了，但是这个循环会把大于1的字符串每次都加在结果数组当中一次，这样结果当中就会存在非常多的重复的字符串了\n        if res[win] == 2  {\n            ans = append(ans,s[i:i+L])\n        }\n    }\n    return ans\n}\n```\n\n\n\n### [二分法解决这道题目 - x 的平方根 - 力扣（LeetCode）](https://leetcode.cn/problems/sqrtx/solution/er-fen-fa-jie-jue-zhe-dao-ti-mu-by-xing-pq1tt/)\n\n这道题目是用二分法来找到一个近似的大致解，逻辑是二分搜索小于 x 区间上的数，数理逻辑是简单的，因为他的根肯定比他自己小等，且把问题只求整数区间的答案，是完全有限的\n\n问题在于二分法的边界问题：\n\n题目的二分区间是 左右均闭区间，所以循环结束条件是二者相相遇时候，而移动指针，则因为判断不满足条件时候要抛弃边界值，所以左右指针都会在mid基础上改变，模板为：\n\n    for left <= right {\n        mid = left + (right-left)/2\n        ValueOfMid = func(mid)\n        if ValueOfMid <= target{\n            res = mid//  因为这里判断的结果边界就是所需要的答案\n            left = mid + 1 // 左闭区间，如果 mid 不是所求答案，则必然小于答案，直接抛弃mid值\n        }else{\n            right = mid - 1 // 右闭区间\n        }\n}\n我做了改动，使其变成 左闭右开区间，但这可情况下忽略了 right == left 以及二者相差为1时候的情况，所以在前面补全，但是这并不意味着这个判断就不好，由于左闭右开，所以右边实际上一直指向的是一个空值（逻辑上），在判断条件最后相遇的情况下，可以明确的就是答案一定不会在 [right, x-1]这个区间范围内，所以查找的循环只会在 left < right；如果二者相遇还没找到答案，那么就代表不存在解。\n\n```go\nfunc mySqrt(x int) int {\n    // 使用二分法来解决\n    left,right := 0,x\n    ans := -1\n    if right - left <= 1 {\n        return x\n    }\n    for left < right {\n        mid := left + (right - left)/2\n        if mid*mid <= x {\n            ans = mid\n            left = mid + 1\n        }else{\n            right = mid\n        }\n    }\n    return ans\n}\n```\n\n\n\n### [70. 爬楼梯 - 力扣（LeetCode）](https://leetcode.cn/problems/climbing-stairs/submissions/)\n\n![image-20230506104126885](Y:\\Blog\\blog\\source\\_posts\\Algorithm\\leetcode\\leet_simple_70.png)\n\n```go\nfunc climbStairs(n int) int {\n    // 使用回溯法来解决这个问题\n    // 但是递归回溯存在大量的重复判断排列组合的部分\n    // res := 0\n    // var stepin func(left int)\n    // stepin = func(left int){\n    //     if left < 0 {\n    //         return \n    //     }\n    //     if left == 0 {\n    //         res++\n    //     }\n    //     stepin(left-1)\n    //     stepin(left-2)\n    // }\n    // stepin(n)\n    // return res\n    // 动态规划\n    // dp := make([]int,n+1)\n    // dp[0],dp[1] = 1,1\n    // for i := 2; i <= n; i++{\n    //     dp[i] = dp[i-1]+dp[i-2]\n    // }\n    // return dp[n]\n    // 优化内存的表现\n    pre, cur ,tmp := 1,1,0\n    for i := 0; i < n; i++{\n        tmp = pre + cur\n        pre = cur\n        cur = tmp\n    }\n    return pre\n}\n```\n\n\n\n### [合并两个有序数组 - 合并两个有序数组 - 力扣（LeetCode）](https://leetcode.cn/problems/merge-sorted-array/solution/he-bing-liang-ge-you-xu-shu-zu-by-leetco-rrb0/)\n\n使用双指针的时候，因为创建了新的数组，而返回值使原本的数组切片指针，这个时候要么再来一个for循环修改原num1的底层数组，要么只能深拷贝 copy(nums1,sorted)\n\n```go\nfunc merge(nums1 []int, m int, nums2 []int, n int) {\n    sorted := make([]int, 0, m+n)\n    p1, p2 := 0, 0\n    // 使用双指针分别指向此时对应的最小值\n    for {\n        // 这两个if的判断很典型，当双指针有其中一个到达了边界，证明对方为空\n        // 将长的数组剩余全部加入\n        // 使用方法是append(sorted,num[p2:]...)\n        // 需要记住这个一次性加入多个切片的操作写法:append(target, n[]...)\n        if p1 == m {\n            sorted = append(sorted, nums2[p2:]...)\n            break\n        }\n        if p2 == n {\n            sorted = append(sorted, nums1[p1:]...)\n            break\n        }\n        if nums1[p1] < nums2[p2] {\n            sorted = append(sorted, nums1[p1])\n            p1++\n        } else {\n            sorted = append(sorted, nums2[p2])\n            p2++\n        }\n    }\n    // 对底层数组的修改，需要尤为注意\n    // 只有 copy会把底层数组的值给复制过去，其他使用 = 的情况只是切片对象，也就是一个指针，如果底层数组改变了，那么结果也就改变了\n    copy(nums1, sorted)\n}\n```\n\n\n\n### [ 二叉树的最大深度 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-depth-of-binary-tree/solution/ke-yi-shi-xiao-gai-goyu-yan-zhu-xing-zhu-q5a0/)\n\n```go\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc maxDepth(root *TreeNode) int {\n  \t//根节点为空，最大深度返回0 \n    if root == nil {\n\t\treturn 0\n\t}\n    //记录左子树的最大深度\n\tleftMax := maxDepth(root.Left)\n    //记录有右子树的最大深度\n\trightMax := maxDepth(root.Right)\n    //最终的深度=左子树和右子树的max，然就再加上根节点还有的1,\n\theight := 1 + max(leftMax, rightMax)\n\treturn height\n}\n\nfunc max(a,b int)int {\n    if a>b {\n        return a\n    }\n    return b \n}\n```\n\n\n\n### [将有序数组转换为二叉搜索树 - 力扣（LeetCode）](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/solution/tu-jie-er-cha-sou-suo-shu-gou-zao-di-gui-python-go/)\n\n构造树，不论顺序如何，必定是存在着 `node := &TreeNode{val, getTree(right/left), getTree(right/left) }`  , 先得把节点构造出来作为根节点，然后再去遍历找其他的节点\n\n```go\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc sortedArrayToBST(nums []int) *TreeNode {\n    if len(nums) == 0 {\n        return nil\n    }\n\n    mid := len(nums) / 2\n    \n    left := nums[:mid]\n    right := nums[mid+1:]\n    // 这个递归的设计非常优美，递归的核心是构造了mid值得根节点，然后继续递归传入左右的切片\n    node := &TreeNode{nums[mid], sortedArrayToBST(left), sortedArrayToBST(right)}\n\n    return node\n}\n```\n\n\n\n### [ 二叉树的最小深度 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-depth-of-binary-tree/solution/ke-yi-shi-xiao-gai-goyu-yan-zhu-xing-zhu-q9ed/)\n\n出现特殊情况是因为最小深度，会计算到有一个子树为空的情况，但是另一个子树不一定为空，那么其根节点就不是叶子节点\n\n```go\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\n \n//tips:利用左右根（后续遍历） 求出的最小高度，也是这棵树的最小深度\nfunc minDepth(root *TreeNode) int {\n\tif root == nil {\n\t\treturn 0\n\t}\n\t//先求出左右子树的最小深度\n\tleftMin := minDepth(root.Left)\n\trightMin := minDepth(root.Right)\n\n\t/*\n\t\t1.但是要考虑特殊情况，根节点的左子树为空，右子树不为空，\n        不能直接min(root.Left,root.Right)，\n\t\t2.因为不符合题目“根节点到最近叶子节点的最短路径上的节点数量”\n        的要求一定要有叶子节点\n\t*/\n\tif root.Left == nil && root.Right != nil {\n\t\treturn 1 + rightMin\n\t\t//如上\n\t} else if root.Left != nil && root.Right == nil {\n\t\treturn 1 + leftMin\n\t\t//如果左右子树都不为空才能用min\n\t} else {\n\t\treturn 1 + min(leftMin, rightMin)\n\t}\n}\n\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n```\n\n\n\n### [118. 杨辉三角 - 力扣（LeetCode）](https://leetcode.cn/problems/pascals-triangle/submissions/)\n\n使用 dp 解题,核心在于杨辉三角的计算过程符合 dp 的问题拆解\n\n```go\nfunc generate(numRows int) [][]int {\n    // dp 模板1： 创建dp数组一维或者是二维\n    dp := make([][]int, numRows)\n\tif numRows == 0 {\n\t\treturn dp\n\t}\n    // dp 数组的初始化，一般来说需要在纸上把这个dp数组画出来，然后观察数组的规律，将那些dp[][]边界值给计算出来\n    \n\tfor k := range dp {\n\t\tdp[k] = make([]int, k+1)\n\t}\n\tfor i := 0; i < numRows; i++ {\n\t\tfor j := 0; j < i+1; j++ {\n\t\t\tif j == 0 || j == i {\n\t\t\t\tdp[i][j] = 1\n\t\t\t} else {\n\t\t\t\tdp[i][j] = dp[i-1][j] + dp[i-1][j-1]\n\t\t\t}\n\t\t}\n\t}\n\treturn dp\n}\n```\n\n\n\n### [单调栈，贪心算法，最简单的思路，找到最小值，找到其后最大值，两个相减即可得 - 买卖股票的最佳时机 - 力扣（LeetCode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/solution/-by-gracious-vvilson1bb-w8yb/)\n\n关键常数，直接背住：\n\n```go\n\tmaxs :=math.MinInt64\n\tmins :=math.MaxInt64\n```\n\n单调栈来一次 O(n^2)遍历一次找到所有的元素向右间距，比较出最大值就可以\n\n题目做了优化，考虑贪心的方法\n\n```go\nfunc maxProfit(prices []int) (s int) {\n\tmaxs :=math.MinInt64\n\tmins :=math.MaxInt64\n\tfor i := 0; i < len(prices); i++ {\n        // 由于 max 总是在已有的 mins 基础上来计算，相当于这个问题就变成了\n        // 遍历先找当前最小的元素\n        // 再计算当前元素比之前最小元素大的间距\n        // 因为本体的大小关系只局限在数组元素的大小，而不考虑数组下标的间距，所以可以直接寻找最优解\n\t\t//记一个最小值\n\t\tmins =min(mins,prices[i])\n\t\t//记一个最大值\n\t\tmaxs =max(maxs,prices[i]-mins)\n\n\t}\n\t//返回最大差值\n\treturn maxs\n}\n\nfunc max(x, y int) int {\n\tif x > y {\n\t\treturn x\n\t} else {\n\t\treturn y\n\t}\n}\nfunc min(x, y int) int {\n\tif x > y {\n\t\treturn y\n\t} else {\n\t\treturn x\n\t}\n}\n```\n\n\n\n### [dp-丑数 II - 丑数 II - 力扣（LeetCode）](https://leetcode.cn/problems/ugly-number-ii/solution/chou-shu-ii-by-beney-2-0uk5/)\n\n关键点1 ： 求因数的计算常规是：\n\n```go\n%n == 0 表示n是他的因数\n```\n\n关键点2：第 n  个丑数是前面 某个丑数 *2或者 *3 或者 *5 得来的，且对于同一个数而言他的丑数因数乘以2，3，5肯定不一样（可证），反过来也就是说每一个丑数 乘2乘3乘5所得的丑数不一样\n\n```go\nfunc nthUglyNumber(n int) int {\n    if n == 0 {\n        panic(errors.New(\"invalid n\"))\n    }\n    m2, m3, m5 := 0, 0, 0\n    dp := make([]int, n)\n    dp[0] = 1\n    for i := 1; i < n; i++ {\n        a, b, c := dp[m2]*2, dp[m3]*3, dp[m5]*5\n        dp[i] = min(a, min(b, c))\n        if dp[i] == a {\n            m2++\n        }\n        if dp[i] == b {\n            m3++\n        }\n        if dp[i] == c {\n            m5++\n        }\n    }\n    return dp[n-1]\n}\n\nfunc min(x, y int) int {\n    if x < y {\n        return x\n    }\n    return y\n}\n```\n\n\n\n\n\n### [验证回文串 - 验证回文串 - 力扣（LeetCode）](https://leetcode.cn/problems/valid-palindrome/solution/yan-zheng-hui-wen-chuan-by-leetcode-solution/)\n\n关键点在于对输入数据的处理:48,65,97\n\n1. 判断是否是字母数字字符\n\n   ```go\n   func isalnum(ch byte) bool {\n       return (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z') || (ch >= '0' && ch <= '9')\n   }\n   ```\n\n2. 大写转小写\n\n   ```go\n   strings.ToLower(s)\n   strings.ToUpper(s)\n   ```\n\n   其他常用提醒：\n\n   ```go\n   ```\n\n   \n\n","slug":"Algorithm/script/leetcode/leet code 简单题目突破","published":1,"updated":"2023-05-06T10:12:46.082Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli796r16002ebyjx27hp8h84","content":"<blockquote>\n<p>考前简单题目遍历：</p>\n</blockquote>\n<h3 id=\"双边判断-最后一个单词的长度-力扣（LeetCode）\"><a href=\"#双边判断-最后一个单词的长度-力扣（LeetCode）\" class=\"headerlink\" title=\"双边判断 - 最后一个单词的长度 - 力扣（LeetCode）\"></a><a href=\"https://leetcode.cn/problems/length-of-last-word/solution/shuang-bian-pan-duan-by-xing-82s-xing/\">双边判断 - 最后一个单词的长度 - 力扣（LeetCode）</a></h3><ul>\n<li>下标 &lt; 0 或者是 下标 &gt; 数组长度-1的情况都需要考虑</li>\n<li>for 循环要善用，一般的结构组成就是 for{if{}}</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">lengthOfLastWord</span><span class=\"params\">(s <span class=\"type\">string</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(s) == <span class=\"number\">1</span> &amp;&amp; s[<span class=\"number\">0</span>] == <span class=\"string\">&#x27; &#x27;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 计算下标--双指针</span></span><br><span class=\"line\">    l := <span class=\"built_in\">len</span>(s)</span><br><span class=\"line\">    left, right := l<span class=\"number\">-1</span>,l<span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"comment\">// 找到末尾第一个非空字符</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := l<span class=\"number\">-1</span> ; s[i] == <span class=\"string\">&#x27; &#x27;</span>; i--&#123;</span><br><span class=\"line\">        right--</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 找到末尾第二轮开始空的字符</span></span><br><span class=\"line\">    left = right</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := right ; s[i] != <span class=\"string\">&#x27; &#x27;</span>; i--&#123;</span><br><span class=\"line\">        left--</span><br><span class=\"line\">        <span class=\"keyword\">if</span> left &lt; <span class=\"number\">0</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> right - left</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"使用数组按位-二进制求和-力扣（LeetCode）\"><a href=\"#使用数组按位-二进制求和-力扣（LeetCode）\" class=\"headerlink\" title=\"使用数组按位 - 二进制求和 - 力扣（LeetCode）\"></a><a href=\"https://leetcode.cn/problems/add-binary/solution/shi-yong-shu-zu-an-wei-by-xing-82s-ris9/\">使用数组按位 - 二进制求和 - 力扣（LeetCode）</a></h3><p>本题目是位计算和字符串转数值计算的典型例子：<br>仅针对字符串的处理有几点需要格外关注：</p>\n<p>string 转 int 按位处理需要借助 byte (当然也可以直接使用strconv.ParseInt(a,2,64),但这样就需要考虑符号位以及其他的因素了)<br>string 的 a[i] ，所获取的值是 byte 类型（补充如果是一整个string转化位 []byte，如果含有中文使用[]rune）<br>得到第 i 位的十进制表示的二进制数方式是： i := int(a[i]-‘0’)<br>字符串的 + 存在先后顺序；换句话说 i+j 与 j+i所获得字符串不相同是ij,ji,这里的注意点是字符串计算不再使用栈来规划顺序，可以直接使用符号位置来表示<br>carry 同时表示了进位和当前位的结果值，这个特点是在位运算当中常见，需要记忆模板，其他题目的类型按照结果归纳，需要归类<br>这里需要计算对齐的是两数的末位，所以需要计算的下标为la-i-1</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">addBinary</span><span class=\"params\">(a <span class=\"type\">string</span>, b <span class=\"type\">string</span>)</span></span> <span class=\"type\">string</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//  按位计算并保存一个进位的结果</span></span><br><span class=\"line\">    <span class=\"comment\">//  1. string 按位计算不能够一步到位直接转化为int，需要借助中间值byte</span></span><br><span class=\"line\">    <span class=\"comment\">//  2. 优化逻辑：O(n)的复杂度，遍历的时间复杂度取决于 最长的字符串的长度</span></span><br><span class=\"line\">    la,lb := <span class=\"built_in\">len</span>(a),<span class=\"built_in\">len</span>(b)</span><br><span class=\"line\">    l := maxi(la,lb)</span><br><span class=\"line\">    res := <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">    carry:= <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; l; i++&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i &lt; la &#123;</span><br><span class=\"line\">            carry += <span class=\"type\">int</span>(a[la-i<span class=\"number\">-1</span>]-<span class=\"string\">&#x27;0&#x27;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i &lt; lb &#123;</span><br><span class=\"line\">            carry += <span class=\"type\">int</span>(b[lb-i<span class=\"number\">-1</span>]-<span class=\"string\">&#x27;0&#x27;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        res = strconv.Itoa(carry%<span class=\"number\">2</span>) + res</span><br><span class=\"line\">        carry /= <span class=\"number\">2</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> carry &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        res = <span class=\"string\">&quot;1&quot;</span> + res</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"字符串转数字比较-重复的DNA序列-力扣（LeetCode）\"><a href=\"#字符串转数字比较-重复的DNA序列-力扣（LeetCode）\" class=\"headerlink\" title=\"字符串转数字比较 - 重复的DNA序列 - 力扣（LeetCode）\"></a><a href=\"https://leetcode.cn/problems/repeated-dna-sequences/solution/zi-fu-chuan-zhuan-shu-zi-bi-jiao-by-xing-lye5/\">字符串转数字比较 - 重复的DNA序列 - 力扣（LeetCode）</a></h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> L = <span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> bmap = <span class=\"keyword\">map</span>[<span class=\"type\">byte</span>]<span class=\"type\">int</span>&#123;<span class=\"string\">&#x27;A&#x27;</span>:<span class=\"number\">0</span>,<span class=\"string\">&#x27;C&#x27;</span>:<span class=\"number\">1</span>,<span class=\"string\">&#x27;G&#x27;</span>:<span class=\"number\">2</span>,<span class=\"string\">&#x27;T&#x27;</span>:<span class=\"number\">3</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">findRepeatedDnaSequences</span><span class=\"params\">(s <span class=\"type\">string</span>)</span></span> (ans []<span class=\"type\">string</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 滑动窗口</span></span><br><span class=\"line\">    <span class=\"comment\">// 需要对边界条件 n 小于窗口大小时候判断,当等于窗口大小的时候，也不满足条件，一定要注意等号的边界条件</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(s) &lt;= L &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    win := <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"comment\">// 初始化窗口，将 L 个字符统计出来</span></span><br><span class=\"line\">    <span class=\"comment\">// 注意点1： string 单取是byte类型,而map 当中所存的应该也是单个字符byte</span></span><br><span class=\"line\">    <span class=\"comment\">// 注意点2： for  range 遍历的时候，并不需要控制中间的i对象，所以可以直接用迭代的 v</span></span><br><span class=\"line\">    <span class=\"comment\">// 注意点3： 这里的初始化只需要将首先的10个数字包含进来就可以</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, v := <span class=\"keyword\">range</span> s[:L<span class=\"number\">-1</span>] &#123;</span><br><span class=\"line\">        win = (win&lt;&lt;<span class=\"number\">2</span>) | bmap[<span class=\"type\">byte</span>(v)]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    res := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">int</span>]<span class=\"type\">int</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"comment\">// 选择低位作为开始是为了解决切片的问题，这样加入到结果的字符串当中，只需要操作 s[i:i+L]</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt;= <span class=\"built_in\">len</span>(s)-L;i++&#123;</span><br><span class=\"line\">        win = ((win&lt;&lt;<span class=\"number\">2</span>) | bmap[s[i+L<span class=\"number\">-1</span>]]) &amp; ((<span class=\"number\">1</span>&lt;&lt;<span class=\"number\">20</span>)<span class=\"number\">-1</span>)</span><br><span class=\"line\">        res[win]++</span><br><span class=\"line\">        <span class=\"comment\">// 这个地方只能判断为 2 但不能够是其他的情况，因为出现多次，只需要大于2就满足条件了，但是这个循环会把大于1的字符串每次都加在结果数组当中一次，这样结果当中就会存在非常多的重复的字符串了</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> res[win] == <span class=\"number\">2</span>  &#123;</span><br><span class=\"line\">            ans = <span class=\"built_in\">append</span>(ans,s[i:i+L])</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"二分法解决这道题目-x-的平方根-力扣（LeetCode）\"><a href=\"#二分法解决这道题目-x-的平方根-力扣（LeetCode）\" class=\"headerlink\" title=\"二分法解决这道题目 - x 的平方根 - 力扣（LeetCode）\"></a><a href=\"https://leetcode.cn/problems/sqrtx/solution/er-fen-fa-jie-jue-zhe-dao-ti-mu-by-xing-pq1tt/\">二分法解决这道题目 - x 的平方根 - 力扣（LeetCode）</a></h3><p>这道题目是用二分法来找到一个近似的大致解，逻辑是二分搜索小于 x 区间上的数，数理逻辑是简单的，因为他的根肯定比他自己小等，且把问题只求整数区间的答案，是完全有限的</p>\n<p>问题在于二分法的边界问题：</p>\n<p>题目的二分区间是 左右均闭区间，所以循环结束条件是二者相相遇时候，而移动指针，则因为判断不满足条件时候要抛弃边界值，所以左右指针都会在mid基础上改变，模板为：</p>\n<pre><code>for left &lt;= right &#123;\n    mid = left + (right-left)/2\n    ValueOfMid = func(mid)\n    if ValueOfMid &lt;= target&#123;\n        res = mid//  因为这里判断的结果边界就是所需要的答案\n        left = mid + 1 // 左闭区间，如果 mid 不是所求答案，则必然小于答案，直接抛弃mid值\n    &#125;else&#123;\n        right = mid - 1 // 右闭区间\n    &#125;\n</code></pre>\n<p>}<br>我做了改动，使其变成 左闭右开区间，但这可情况下忽略了 right == left 以及二者相差为1时候的情况，所以在前面补全，但是这并不意味着这个判断就不好，由于左闭右开，所以右边实际上一直指向的是一个空值（逻辑上），在判断条件最后相遇的情况下，可以明确的就是答案一定不会在 [right, x-1]这个区间范围内，所以查找的循环只会在 left &lt; right；如果二者相遇还没找到答案，那么就代表不存在解。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">mySqrt</span><span class=\"params\">(x <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用二分法来解决</span></span><br><span class=\"line\">    left,right := <span class=\"number\">0</span>,x</span><br><span class=\"line\">    ans := <span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> right - left &lt;= <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> left &lt; right &#123;</span><br><span class=\"line\">        mid := left + (right - left)/<span class=\"number\">2</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> mid*mid &lt;= x &#123;</span><br><span class=\"line\">            ans = mid</span><br><span class=\"line\">            left = mid + <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            right = mid</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"70-爬楼梯-力扣（LeetCode）\"><a href=\"#70-爬楼梯-力扣（LeetCode）\" class=\"headerlink\" title=\"70. 爬楼梯 - 力扣（LeetCode）\"></a><a href=\"https://leetcode.cn/problems/climbing-stairs/submissions/\">70. 爬楼梯 - 力扣（LeetCode）</a></h3><p><img src=\"Y:\\Blog\\blog\\source_posts\\Algorithm\\leetcode\\leet_simple_70.png\" alt=\"image-20230506104126885\"></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">climbStairs</span><span class=\"params\">(n <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用回溯法来解决这个问题</span></span><br><span class=\"line\">    <span class=\"comment\">// 但是递归回溯存在大量的重复判断排列组合的部分</span></span><br><span class=\"line\">    <span class=\"comment\">// res := 0</span></span><br><span class=\"line\">    <span class=\"comment\">// var stepin func(left int)</span></span><br><span class=\"line\">    <span class=\"comment\">// stepin = func(left int)&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//     if left &lt; 0 &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//         return </span></span><br><span class=\"line\">    <span class=\"comment\">//     &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">//     if left == 0 &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//         res++</span></span><br><span class=\"line\">    <span class=\"comment\">//     &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">//     stepin(left-1)</span></span><br><span class=\"line\">    <span class=\"comment\">//     stepin(left-2)</span></span><br><span class=\"line\">    <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">// stepin(n)</span></span><br><span class=\"line\">    <span class=\"comment\">// return res</span></span><br><span class=\"line\">    <span class=\"comment\">// 动态规划</span></span><br><span class=\"line\">    <span class=\"comment\">// dp := make([]int,n+1)</span></span><br><span class=\"line\">    <span class=\"comment\">// dp[0],dp[1] = 1,1</span></span><br><span class=\"line\">    <span class=\"comment\">// for i := 2; i &lt;= n; i++&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//     dp[i] = dp[i-1]+dp[i-2]</span></span><br><span class=\"line\">    <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">// return dp[n]</span></span><br><span class=\"line\">    <span class=\"comment\">// 优化内存的表现</span></span><br><span class=\"line\">    pre, cur ,tmp := <span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; n; i++&#123;</span><br><span class=\"line\">        tmp = pre + cur</span><br><span class=\"line\">        pre = cur</span><br><span class=\"line\">        cur = tmp</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pre</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"合并两个有序数组-合并两个有序数组-力扣（LeetCode）\"><a href=\"#合并两个有序数组-合并两个有序数组-力扣（LeetCode）\" class=\"headerlink\" title=\"合并两个有序数组 - 合并两个有序数组 - 力扣（LeetCode）\"></a><a href=\"https://leetcode.cn/problems/merge-sorted-array/solution/he-bing-liang-ge-you-xu-shu-zu-by-leetco-rrb0/\">合并两个有序数组 - 合并两个有序数组 - 力扣（LeetCode）</a></h3><p>使用双指针的时候，因为创建了新的数组，而返回值使原本的数组切片指针，这个时候要么再来一个for循环修改原num1的底层数组，要么只能深拷贝 copy(nums1,sorted)</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">merge</span><span class=\"params\">(nums1 []<span class=\"type\">int</span>, m <span class=\"type\">int</span>, nums2 []<span class=\"type\">int</span>, n <span class=\"type\">int</span>)</span></span> &#123;</span><br><span class=\"line\">    sorted := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, <span class=\"number\">0</span>, m+n)</span><br><span class=\"line\">    p1, p2 := <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"comment\">// 使用双指针分别指向此时对应的最小值</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 这两个if的判断很典型，当双指针有其中一个到达了边界，证明对方为空</span></span><br><span class=\"line\">        <span class=\"comment\">// 将长的数组剩余全部加入</span></span><br><span class=\"line\">        <span class=\"comment\">// 使用方法是append(sorted,num[p2:]...)</span></span><br><span class=\"line\">        <span class=\"comment\">// 需要记住这个一次性加入多个切片的操作写法:append(target, n[]...)</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> p1 == m &#123;</span><br><span class=\"line\">            sorted = <span class=\"built_in\">append</span>(sorted, nums2[p2:]...)</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> p2 == n &#123;</span><br><span class=\"line\">            sorted = <span class=\"built_in\">append</span>(sorted, nums1[p1:]...)</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> nums1[p1] &lt; nums2[p2] &#123;</span><br><span class=\"line\">            sorted = <span class=\"built_in\">append</span>(sorted, nums1[p1])</span><br><span class=\"line\">            p1++</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            sorted = <span class=\"built_in\">append</span>(sorted, nums2[p2])</span><br><span class=\"line\">            p2++</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 对底层数组的修改，需要尤为注意</span></span><br><span class=\"line\">    <span class=\"comment\">// 只有 copy会把底层数组的值给复制过去，其他使用 = 的情况只是切片对象，也就是一个指针，如果底层数组改变了，那么结果也就改变了</span></span><br><span class=\"line\">    <span class=\"built_in\">copy</span>(nums1, sorted)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"二叉树的最大深度-力扣（LeetCode）\"><a href=\"#二叉树的最大深度-力扣（LeetCode）\" class=\"headerlink\" title=\" 二叉树的最大深度 - 力扣（LeetCode）\"></a><a href=\"https://leetcode.cn/problems/maximum-depth-of-binary-tree/solution/ke-yi-shi-xiao-gai-goyu-yan-zhu-xing-zhu-q5a0/\"> 二叉树的最大深度 - 力扣（LeetCode）</a></h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * type TreeNode struct &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     Val int</span></span><br><span class=\"line\"><span class=\"comment\"> *     Left *TreeNode</span></span><br><span class=\"line\"><span class=\"comment\"> *     Right *TreeNode</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">maxDepth</span><span class=\"params\">(root *TreeNode)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">  \t<span class=\"comment\">//根节点为空，最大深度返回0 </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> root == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"comment\">//记录左子树的最大深度</span></span><br><span class=\"line\">\tleftMax := maxDepth(root.Left)</span><br><span class=\"line\">    <span class=\"comment\">//记录有右子树的最大深度</span></span><br><span class=\"line\">\trightMax := maxDepth(root.Right)</span><br><span class=\"line\">    <span class=\"comment\">//最终的深度=左子树和右子树的max，然就再加上根节点还有的1,</span></span><br><span class=\"line\">\theight := <span class=\"number\">1</span> + max(leftMax, rightMax)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> height</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">max</span><span class=\"params\">(a,b <span class=\"type\">int</span>)</span></span><span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> a&gt;b &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> b </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"将有序数组转换为二叉搜索树-力扣（LeetCode）\"><a href=\"#将有序数组转换为二叉搜索树-力扣（LeetCode）\" class=\"headerlink\" title=\"将有序数组转换为二叉搜索树 - 力扣（LeetCode）\"></a><a href=\"https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/solution/tu-jie-er-cha-sou-suo-shu-gou-zao-di-gui-python-go/\">将有序数组转换为二叉搜索树 - 力扣（LeetCode）</a></h3><p>构造树，不论顺序如何，必定是存在着 <code>node := &amp;TreeNode&#123;val, getTree(right/left), getTree(right/left) &#125;</code>  , 先得把节点构造出来作为根节点，然后再去遍历找其他的节点</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * type TreeNode struct &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     Val int</span></span><br><span class=\"line\"><span class=\"comment\"> *     Left *TreeNode</span></span><br><span class=\"line\"><span class=\"comment\"> *     Right *TreeNode</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">sortedArrayToBST</span><span class=\"params\">(nums []<span class=\"type\">int</span>)</span></span> *TreeNode &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(nums) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    mid := <span class=\"built_in\">len</span>(nums) / <span class=\"number\">2</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    left := nums[:mid]</span><br><span class=\"line\">    right := nums[mid+<span class=\"number\">1</span>:]</span><br><span class=\"line\">    <span class=\"comment\">// 这个递归的设计非常优美，递归的核心是构造了mid值得根节点，然后继续递归传入左右的切片</span></span><br><span class=\"line\">    node := &amp;TreeNode&#123;nums[mid], sortedArrayToBST(left), sortedArrayToBST(right)&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> node</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"二叉树的最小深度-力扣（LeetCode）\"><a href=\"#二叉树的最小深度-力扣（LeetCode）\" class=\"headerlink\" title=\" 二叉树的最小深度 - 力扣（LeetCode）\"></a><a href=\"https://leetcode.cn/problems/minimum-depth-of-binary-tree/solution/ke-yi-shi-xiao-gai-goyu-yan-zhu-xing-zhu-q9ed/\"> 二叉树的最小深度 - 力扣（LeetCode）</a></h3><p>出现特殊情况是因为最小深度，会计算到有一个子树为空的情况，但是另一个子树不一定为空，那么其根节点就不是叶子节点</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * type TreeNode struct &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     Val int</span></span><br><span class=\"line\"><span class=\"comment\"> *     Left *TreeNode</span></span><br><span class=\"line\"><span class=\"comment\"> *     Right *TreeNode</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//tips:利用左右根（后续遍历） 求出的最小高度，也是这棵树的最小深度</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">minDepth</span><span class=\"params\">(root *TreeNode)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> root == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//先求出左右子树的最小深度</span></span><br><span class=\"line\">\tleftMin := minDepth(root.Left)</span><br><span class=\"line\">\trightMin := minDepth(root.Right)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t\t1.但是要考虑特殊情况，根节点的左子树为空，右子树不为空，</span></span><br><span class=\"line\"><span class=\"comment\">        不能直接min(root.Left,root.Right)，</span></span><br><span class=\"line\"><span class=\"comment\">\t\t2.因为不符合题目“根节点到最近叶子节点的最短路径上的节点数量”</span></span><br><span class=\"line\"><span class=\"comment\">        的要求一定要有叶子节点</span></span><br><span class=\"line\"><span class=\"comment\">\t*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> root.Left == <span class=\"literal\">nil</span> &amp;&amp; root.Right != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">1</span> + rightMin</span><br><span class=\"line\">\t\t<span class=\"comment\">//如上</span></span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> root.Left != <span class=\"literal\">nil</span> &amp;&amp; root.Right == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">1</span> + leftMin</span><br><span class=\"line\">\t\t<span class=\"comment\">//如果左右子树都不为空才能用min</span></span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">1</span> + min(leftMin, rightMin)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">min</span><span class=\"params\">(a, b <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> a &lt; b &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> a</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> b</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"118-杨辉三角-力扣（LeetCode）\"><a href=\"#118-杨辉三角-力扣（LeetCode）\" class=\"headerlink\" title=\"118. 杨辉三角 - 力扣（LeetCode）\"></a><a href=\"https://leetcode.cn/problems/pascals-triangle/submissions/\">118. 杨辉三角 - 力扣（LeetCode）</a></h3><p>使用 dp 解题,核心在于杨辉三角的计算过程符合 dp 的问题拆解</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">generate</span><span class=\"params\">(numRows <span class=\"type\">int</span>)</span></span> [][]<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// dp 模板1： 创建dp数组一维或者是二维</span></span><br><span class=\"line\">    dp := <span class=\"built_in\">make</span>([][]<span class=\"type\">int</span>, numRows)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> numRows == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> dp</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"comment\">// dp 数组的初始化，一般来说需要在纸上把这个dp数组画出来，然后观察数组的规律，将那些dp[][]边界值给计算出来</span></span><br><span class=\"line\">    </span><br><span class=\"line\">\t<span class=\"keyword\">for</span> k := <span class=\"keyword\">range</span> dp &#123;</span><br><span class=\"line\">\t\tdp[k] = <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, k+<span class=\"number\">1</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; numRows; i++ &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> j := <span class=\"number\">0</span>; j &lt; i+<span class=\"number\">1</span>; j++ &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> j == <span class=\"number\">0</span> || j == i &#123;</span><br><span class=\"line\">\t\t\t\tdp[i][j] = <span class=\"number\">1</span></span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\tdp[i][j] = dp[i<span class=\"number\">-1</span>][j] + dp[i<span class=\"number\">-1</span>][j<span class=\"number\">-1</span>]</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> dp</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"单调栈，贪心算法，最简单的思路，找到最小值，找到其后最大值，两个相减即可得-买卖股票的最佳时机-力扣（LeetCode）\"><a href=\"#单调栈，贪心算法，最简单的思路，找到最小值，找到其后最大值，两个相减即可得-买卖股票的最佳时机-力扣（LeetCode）\" class=\"headerlink\" title=\"单调栈，贪心算法，最简单的思路，找到最小值，找到其后最大值，两个相减即可得 - 买卖股票的最佳时机 - 力扣（LeetCode）\"></a><a href=\"https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/solution/-by-gracious-vvilson1bb-w8yb/\">单调栈，贪心算法，最简单的思路，找到最小值，找到其后最大值，两个相减即可得 - 买卖股票的最佳时机 - 力扣（LeetCode）</a></h3><p>关键常数，直接背住：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">maxs :=math.MinInt64</span><br><span class=\"line\">mins :=math.MaxInt64</span><br></pre></td></tr></table></figure>\n\n<p>单调栈来一次 O(n^2)遍历一次找到所有的元素向右间距，比较出最大值就可以</p>\n<p>题目做了优化，考虑贪心的方法</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">maxProfit</span><span class=\"params\">(prices []<span class=\"type\">int</span>)</span></span> (s <span class=\"type\">int</span>) &#123;</span><br><span class=\"line\">\tmaxs :=math.MinInt64</span><br><span class=\"line\">\tmins :=math.MaxInt64</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(prices); i++ &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 由于 max 总是在已有的 mins 基础上来计算，相当于这个问题就变成了</span></span><br><span class=\"line\">        <span class=\"comment\">// 遍历先找当前最小的元素</span></span><br><span class=\"line\">        <span class=\"comment\">// 再计算当前元素比之前最小元素大的间距</span></span><br><span class=\"line\">        <span class=\"comment\">// 因为本体的大小关系只局限在数组元素的大小，而不考虑数组下标的间距，所以可以直接寻找最优解</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//记一个最小值</span></span><br><span class=\"line\">\t\tmins =min(mins,prices[i])</span><br><span class=\"line\">\t\t<span class=\"comment\">//记一个最大值</span></span><br><span class=\"line\">\t\tmaxs =max(maxs,prices[i]-mins)</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//返回最大差值</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> maxs</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">max</span><span class=\"params\">(x, y <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> x &gt; y &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> x</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> y</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">min</span><span class=\"params\">(x, y <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> x &gt; y &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> y</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> x</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"dp-丑数-II-丑数-II-力扣（LeetCode）\"><a href=\"#dp-丑数-II-丑数-II-力扣（LeetCode）\" class=\"headerlink\" title=\"dp-丑数 II - 丑数 II - 力扣（LeetCode）\"></a><a href=\"https://leetcode.cn/problems/ugly-number-ii/solution/chou-shu-ii-by-beney-2-0uk5/\">dp-丑数 II - 丑数 II - 力扣（LeetCode）</a></h3><p>关键点1 ： 求因数的计算常规是：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">%n == <span class=\"number\">0</span> 表示n是他的因数</span><br></pre></td></tr></table></figure>\n\n<p>关键点2：第 n  个丑数是前面 某个丑数 *2或者 *3 或者 *5 得来的，且对于同一个数而言他的丑数因数乘以2，3，5肯定不一样（可证），反过来也就是说每一个丑数 乘2乘3乘5所得的丑数不一样</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">nthUglyNumber</span><span class=\"params\">(n <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> n == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">panic</span>(errors.New(<span class=\"string\">&quot;invalid n&quot;</span>))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    m2, m3, m5 := <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">    dp := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, n)</span><br><span class=\"line\">    dp[<span class=\"number\">0</span>] = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">1</span>; i &lt; n; i++ &#123;</span><br><span class=\"line\">        a, b, c := dp[m2]*<span class=\"number\">2</span>, dp[m3]*<span class=\"number\">3</span>, dp[m5]*<span class=\"number\">5</span></span><br><span class=\"line\">        dp[i] = min(a, min(b, c))</span><br><span class=\"line\">        <span class=\"keyword\">if</span> dp[i] == a &#123;</span><br><span class=\"line\">            m2++</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> dp[i] == b &#123;</span><br><span class=\"line\">            m3++</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> dp[i] == c &#123;</span><br><span class=\"line\">            m5++</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[n<span class=\"number\">-1</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">min</span><span class=\"params\">(x, y <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> x &lt; y &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> y</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"验证回文串-验证回文串-力扣（LeetCode）\"><a href=\"#验证回文串-验证回文串-力扣（LeetCode）\" class=\"headerlink\" title=\"验证回文串 - 验证回文串 - 力扣（LeetCode）\"></a><a href=\"https://leetcode.cn/problems/valid-palindrome/solution/yan-zheng-hui-wen-chuan-by-leetcode-solution/\">验证回文串 - 验证回文串 - 力扣（LeetCode）</a></h3><p>关键点在于对输入数据的处理:48,65,97</p>\n<ol>\n<li><p>判断是否是字母数字字符</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">isalnum</span><span class=\"params\">(ch <span class=\"type\">byte</span>)</span></span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (ch &gt;= <span class=\"string\">&#x27;A&#x27;</span> &amp;&amp; ch &lt;= <span class=\"string\">&#x27;Z&#x27;</span>) || (ch &gt;= <span class=\"string\">&#x27;a&#x27;</span> &amp;&amp; ch &lt;= <span class=\"string\">&#x27;z&#x27;</span>) || (ch &gt;= <span class=\"string\">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class=\"string\">&#x27;9&#x27;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>大写转小写</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">strings.ToLower(s)</span><br><span class=\"line\">strings.ToUpper(s)</span><br></pre></td></tr></table></figure>\n\n<p>其他常用提醒：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ol>\n","site":{"data":{}},"cover":"/img/cover/elderring.png","cover_type":"img","excerpt":"","more":"<blockquote>\n<p>考前简单题目遍历：</p>\n</blockquote>\n<h3 id=\"双边判断-最后一个单词的长度-力扣（LeetCode）\"><a href=\"#双边判断-最后一个单词的长度-力扣（LeetCode）\" class=\"headerlink\" title=\"双边判断 - 最后一个单词的长度 - 力扣（LeetCode）\"></a><a href=\"https://leetcode.cn/problems/length-of-last-word/solution/shuang-bian-pan-duan-by-xing-82s-xing/\">双边判断 - 最后一个单词的长度 - 力扣（LeetCode）</a></h3><ul>\n<li>下标 &lt; 0 或者是 下标 &gt; 数组长度-1的情况都需要考虑</li>\n<li>for 循环要善用，一般的结构组成就是 for{if{}}</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">lengthOfLastWord</span><span class=\"params\">(s <span class=\"type\">string</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(s) == <span class=\"number\">1</span> &amp;&amp; s[<span class=\"number\">0</span>] == <span class=\"string\">&#x27; &#x27;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 计算下标--双指针</span></span><br><span class=\"line\">    l := <span class=\"built_in\">len</span>(s)</span><br><span class=\"line\">    left, right := l<span class=\"number\">-1</span>,l<span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"comment\">// 找到末尾第一个非空字符</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := l<span class=\"number\">-1</span> ; s[i] == <span class=\"string\">&#x27; &#x27;</span>; i--&#123;</span><br><span class=\"line\">        right--</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 找到末尾第二轮开始空的字符</span></span><br><span class=\"line\">    left = right</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := right ; s[i] != <span class=\"string\">&#x27; &#x27;</span>; i--&#123;</span><br><span class=\"line\">        left--</span><br><span class=\"line\">        <span class=\"keyword\">if</span> left &lt; <span class=\"number\">0</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> right - left</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"使用数组按位-二进制求和-力扣（LeetCode）\"><a href=\"#使用数组按位-二进制求和-力扣（LeetCode）\" class=\"headerlink\" title=\"使用数组按位 - 二进制求和 - 力扣（LeetCode）\"></a><a href=\"https://leetcode.cn/problems/add-binary/solution/shi-yong-shu-zu-an-wei-by-xing-82s-ris9/\">使用数组按位 - 二进制求和 - 力扣（LeetCode）</a></h3><p>本题目是位计算和字符串转数值计算的典型例子：<br>仅针对字符串的处理有几点需要格外关注：</p>\n<p>string 转 int 按位处理需要借助 byte (当然也可以直接使用strconv.ParseInt(a,2,64),但这样就需要考虑符号位以及其他的因素了)<br>string 的 a[i] ，所获取的值是 byte 类型（补充如果是一整个string转化位 []byte，如果含有中文使用[]rune）<br>得到第 i 位的十进制表示的二进制数方式是： i := int(a[i]-‘0’)<br>字符串的 + 存在先后顺序；换句话说 i+j 与 j+i所获得字符串不相同是ij,ji,这里的注意点是字符串计算不再使用栈来规划顺序，可以直接使用符号位置来表示<br>carry 同时表示了进位和当前位的结果值，这个特点是在位运算当中常见，需要记忆模板，其他题目的类型按照结果归纳，需要归类<br>这里需要计算对齐的是两数的末位，所以需要计算的下标为la-i-1</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">addBinary</span><span class=\"params\">(a <span class=\"type\">string</span>, b <span class=\"type\">string</span>)</span></span> <span class=\"type\">string</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//  按位计算并保存一个进位的结果</span></span><br><span class=\"line\">    <span class=\"comment\">//  1. string 按位计算不能够一步到位直接转化为int，需要借助中间值byte</span></span><br><span class=\"line\">    <span class=\"comment\">//  2. 优化逻辑：O(n)的复杂度，遍历的时间复杂度取决于 最长的字符串的长度</span></span><br><span class=\"line\">    la,lb := <span class=\"built_in\">len</span>(a),<span class=\"built_in\">len</span>(b)</span><br><span class=\"line\">    l := maxi(la,lb)</span><br><span class=\"line\">    res := <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">    carry:= <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; l; i++&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i &lt; la &#123;</span><br><span class=\"line\">            carry += <span class=\"type\">int</span>(a[la-i<span class=\"number\">-1</span>]-<span class=\"string\">&#x27;0&#x27;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i &lt; lb &#123;</span><br><span class=\"line\">            carry += <span class=\"type\">int</span>(b[lb-i<span class=\"number\">-1</span>]-<span class=\"string\">&#x27;0&#x27;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        res = strconv.Itoa(carry%<span class=\"number\">2</span>) + res</span><br><span class=\"line\">        carry /= <span class=\"number\">2</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> carry &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        res = <span class=\"string\">&quot;1&quot;</span> + res</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"字符串转数字比较-重复的DNA序列-力扣（LeetCode）\"><a href=\"#字符串转数字比较-重复的DNA序列-力扣（LeetCode）\" class=\"headerlink\" title=\"字符串转数字比较 - 重复的DNA序列 - 力扣（LeetCode）\"></a><a href=\"https://leetcode.cn/problems/repeated-dna-sequences/solution/zi-fu-chuan-zhuan-shu-zi-bi-jiao-by-xing-lye5/\">字符串转数字比较 - 重复的DNA序列 - 力扣（LeetCode）</a></h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> L = <span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> bmap = <span class=\"keyword\">map</span>[<span class=\"type\">byte</span>]<span class=\"type\">int</span>&#123;<span class=\"string\">&#x27;A&#x27;</span>:<span class=\"number\">0</span>,<span class=\"string\">&#x27;C&#x27;</span>:<span class=\"number\">1</span>,<span class=\"string\">&#x27;G&#x27;</span>:<span class=\"number\">2</span>,<span class=\"string\">&#x27;T&#x27;</span>:<span class=\"number\">3</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">findRepeatedDnaSequences</span><span class=\"params\">(s <span class=\"type\">string</span>)</span></span> (ans []<span class=\"type\">string</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 滑动窗口</span></span><br><span class=\"line\">    <span class=\"comment\">// 需要对边界条件 n 小于窗口大小时候判断,当等于窗口大小的时候，也不满足条件，一定要注意等号的边界条件</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(s) &lt;= L &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    win := <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"comment\">// 初始化窗口，将 L 个字符统计出来</span></span><br><span class=\"line\">    <span class=\"comment\">// 注意点1： string 单取是byte类型,而map 当中所存的应该也是单个字符byte</span></span><br><span class=\"line\">    <span class=\"comment\">// 注意点2： for  range 遍历的时候，并不需要控制中间的i对象，所以可以直接用迭代的 v</span></span><br><span class=\"line\">    <span class=\"comment\">// 注意点3： 这里的初始化只需要将首先的10个数字包含进来就可以</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, v := <span class=\"keyword\">range</span> s[:L<span class=\"number\">-1</span>] &#123;</span><br><span class=\"line\">        win = (win&lt;&lt;<span class=\"number\">2</span>) | bmap[<span class=\"type\">byte</span>(v)]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    res := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">int</span>]<span class=\"type\">int</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"comment\">// 选择低位作为开始是为了解决切片的问题，这样加入到结果的字符串当中，只需要操作 s[i:i+L]</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt;= <span class=\"built_in\">len</span>(s)-L;i++&#123;</span><br><span class=\"line\">        win = ((win&lt;&lt;<span class=\"number\">2</span>) | bmap[s[i+L<span class=\"number\">-1</span>]]) &amp; ((<span class=\"number\">1</span>&lt;&lt;<span class=\"number\">20</span>)<span class=\"number\">-1</span>)</span><br><span class=\"line\">        res[win]++</span><br><span class=\"line\">        <span class=\"comment\">// 这个地方只能判断为 2 但不能够是其他的情况，因为出现多次，只需要大于2就满足条件了，但是这个循环会把大于1的字符串每次都加在结果数组当中一次，这样结果当中就会存在非常多的重复的字符串了</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> res[win] == <span class=\"number\">2</span>  &#123;</span><br><span class=\"line\">            ans = <span class=\"built_in\">append</span>(ans,s[i:i+L])</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"二分法解决这道题目-x-的平方根-力扣（LeetCode）\"><a href=\"#二分法解决这道题目-x-的平方根-力扣（LeetCode）\" class=\"headerlink\" title=\"二分法解决这道题目 - x 的平方根 - 力扣（LeetCode）\"></a><a href=\"https://leetcode.cn/problems/sqrtx/solution/er-fen-fa-jie-jue-zhe-dao-ti-mu-by-xing-pq1tt/\">二分法解决这道题目 - x 的平方根 - 力扣（LeetCode）</a></h3><p>这道题目是用二分法来找到一个近似的大致解，逻辑是二分搜索小于 x 区间上的数，数理逻辑是简单的，因为他的根肯定比他自己小等，且把问题只求整数区间的答案，是完全有限的</p>\n<p>问题在于二分法的边界问题：</p>\n<p>题目的二分区间是 左右均闭区间，所以循环结束条件是二者相相遇时候，而移动指针，则因为判断不满足条件时候要抛弃边界值，所以左右指针都会在mid基础上改变，模板为：</p>\n<pre><code>for left &lt;= right &#123;\n    mid = left + (right-left)/2\n    ValueOfMid = func(mid)\n    if ValueOfMid &lt;= target&#123;\n        res = mid//  因为这里判断的结果边界就是所需要的答案\n        left = mid + 1 // 左闭区间，如果 mid 不是所求答案，则必然小于答案，直接抛弃mid值\n    &#125;else&#123;\n        right = mid - 1 // 右闭区间\n    &#125;\n</code></pre>\n<p>}<br>我做了改动，使其变成 左闭右开区间，但这可情况下忽略了 right == left 以及二者相差为1时候的情况，所以在前面补全，但是这并不意味着这个判断就不好，由于左闭右开，所以右边实际上一直指向的是一个空值（逻辑上），在判断条件最后相遇的情况下，可以明确的就是答案一定不会在 [right, x-1]这个区间范围内，所以查找的循环只会在 left &lt; right；如果二者相遇还没找到答案，那么就代表不存在解。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">mySqrt</span><span class=\"params\">(x <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用二分法来解决</span></span><br><span class=\"line\">    left,right := <span class=\"number\">0</span>,x</span><br><span class=\"line\">    ans := <span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> right - left &lt;= <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> left &lt; right &#123;</span><br><span class=\"line\">        mid := left + (right - left)/<span class=\"number\">2</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> mid*mid &lt;= x &#123;</span><br><span class=\"line\">            ans = mid</span><br><span class=\"line\">            left = mid + <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            right = mid</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"70-爬楼梯-力扣（LeetCode）\"><a href=\"#70-爬楼梯-力扣（LeetCode）\" class=\"headerlink\" title=\"70. 爬楼梯 - 力扣（LeetCode）\"></a><a href=\"https://leetcode.cn/problems/climbing-stairs/submissions/\">70. 爬楼梯 - 力扣（LeetCode）</a></h3><p><img src=\"Y:\\Blog\\blog\\source_posts\\Algorithm\\leetcode\\leet_simple_70.png\" alt=\"image-20230506104126885\"></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">climbStairs</span><span class=\"params\">(n <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用回溯法来解决这个问题</span></span><br><span class=\"line\">    <span class=\"comment\">// 但是递归回溯存在大量的重复判断排列组合的部分</span></span><br><span class=\"line\">    <span class=\"comment\">// res := 0</span></span><br><span class=\"line\">    <span class=\"comment\">// var stepin func(left int)</span></span><br><span class=\"line\">    <span class=\"comment\">// stepin = func(left int)&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//     if left &lt; 0 &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//         return </span></span><br><span class=\"line\">    <span class=\"comment\">//     &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">//     if left == 0 &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//         res++</span></span><br><span class=\"line\">    <span class=\"comment\">//     &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">//     stepin(left-1)</span></span><br><span class=\"line\">    <span class=\"comment\">//     stepin(left-2)</span></span><br><span class=\"line\">    <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">// stepin(n)</span></span><br><span class=\"line\">    <span class=\"comment\">// return res</span></span><br><span class=\"line\">    <span class=\"comment\">// 动态规划</span></span><br><span class=\"line\">    <span class=\"comment\">// dp := make([]int,n+1)</span></span><br><span class=\"line\">    <span class=\"comment\">// dp[0],dp[1] = 1,1</span></span><br><span class=\"line\">    <span class=\"comment\">// for i := 2; i &lt;= n; i++&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//     dp[i] = dp[i-1]+dp[i-2]</span></span><br><span class=\"line\">    <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">// return dp[n]</span></span><br><span class=\"line\">    <span class=\"comment\">// 优化内存的表现</span></span><br><span class=\"line\">    pre, cur ,tmp := <span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; n; i++&#123;</span><br><span class=\"line\">        tmp = pre + cur</span><br><span class=\"line\">        pre = cur</span><br><span class=\"line\">        cur = tmp</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pre</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"合并两个有序数组-合并两个有序数组-力扣（LeetCode）\"><a href=\"#合并两个有序数组-合并两个有序数组-力扣（LeetCode）\" class=\"headerlink\" title=\"合并两个有序数组 - 合并两个有序数组 - 力扣（LeetCode）\"></a><a href=\"https://leetcode.cn/problems/merge-sorted-array/solution/he-bing-liang-ge-you-xu-shu-zu-by-leetco-rrb0/\">合并两个有序数组 - 合并两个有序数组 - 力扣（LeetCode）</a></h3><p>使用双指针的时候，因为创建了新的数组，而返回值使原本的数组切片指针，这个时候要么再来一个for循环修改原num1的底层数组，要么只能深拷贝 copy(nums1,sorted)</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">merge</span><span class=\"params\">(nums1 []<span class=\"type\">int</span>, m <span class=\"type\">int</span>, nums2 []<span class=\"type\">int</span>, n <span class=\"type\">int</span>)</span></span> &#123;</span><br><span class=\"line\">    sorted := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, <span class=\"number\">0</span>, m+n)</span><br><span class=\"line\">    p1, p2 := <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"comment\">// 使用双指针分别指向此时对应的最小值</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 这两个if的判断很典型，当双指针有其中一个到达了边界，证明对方为空</span></span><br><span class=\"line\">        <span class=\"comment\">// 将长的数组剩余全部加入</span></span><br><span class=\"line\">        <span class=\"comment\">// 使用方法是append(sorted,num[p2:]...)</span></span><br><span class=\"line\">        <span class=\"comment\">// 需要记住这个一次性加入多个切片的操作写法:append(target, n[]...)</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> p1 == m &#123;</span><br><span class=\"line\">            sorted = <span class=\"built_in\">append</span>(sorted, nums2[p2:]...)</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> p2 == n &#123;</span><br><span class=\"line\">            sorted = <span class=\"built_in\">append</span>(sorted, nums1[p1:]...)</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> nums1[p1] &lt; nums2[p2] &#123;</span><br><span class=\"line\">            sorted = <span class=\"built_in\">append</span>(sorted, nums1[p1])</span><br><span class=\"line\">            p1++</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            sorted = <span class=\"built_in\">append</span>(sorted, nums2[p2])</span><br><span class=\"line\">            p2++</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 对底层数组的修改，需要尤为注意</span></span><br><span class=\"line\">    <span class=\"comment\">// 只有 copy会把底层数组的值给复制过去，其他使用 = 的情况只是切片对象，也就是一个指针，如果底层数组改变了，那么结果也就改变了</span></span><br><span class=\"line\">    <span class=\"built_in\">copy</span>(nums1, sorted)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"二叉树的最大深度-力扣（LeetCode）\"><a href=\"#二叉树的最大深度-力扣（LeetCode）\" class=\"headerlink\" title=\" 二叉树的最大深度 - 力扣（LeetCode）\"></a><a href=\"https://leetcode.cn/problems/maximum-depth-of-binary-tree/solution/ke-yi-shi-xiao-gai-goyu-yan-zhu-xing-zhu-q5a0/\"> 二叉树的最大深度 - 力扣（LeetCode）</a></h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * type TreeNode struct &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     Val int</span></span><br><span class=\"line\"><span class=\"comment\"> *     Left *TreeNode</span></span><br><span class=\"line\"><span class=\"comment\"> *     Right *TreeNode</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">maxDepth</span><span class=\"params\">(root *TreeNode)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">  \t<span class=\"comment\">//根节点为空，最大深度返回0 </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> root == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"comment\">//记录左子树的最大深度</span></span><br><span class=\"line\">\tleftMax := maxDepth(root.Left)</span><br><span class=\"line\">    <span class=\"comment\">//记录有右子树的最大深度</span></span><br><span class=\"line\">\trightMax := maxDepth(root.Right)</span><br><span class=\"line\">    <span class=\"comment\">//最终的深度=左子树和右子树的max，然就再加上根节点还有的1,</span></span><br><span class=\"line\">\theight := <span class=\"number\">1</span> + max(leftMax, rightMax)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> height</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">max</span><span class=\"params\">(a,b <span class=\"type\">int</span>)</span></span><span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> a&gt;b &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> b </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"将有序数组转换为二叉搜索树-力扣（LeetCode）\"><a href=\"#将有序数组转换为二叉搜索树-力扣（LeetCode）\" class=\"headerlink\" title=\"将有序数组转换为二叉搜索树 - 力扣（LeetCode）\"></a><a href=\"https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/solution/tu-jie-er-cha-sou-suo-shu-gou-zao-di-gui-python-go/\">将有序数组转换为二叉搜索树 - 力扣（LeetCode）</a></h3><p>构造树，不论顺序如何，必定是存在着 <code>node := &amp;TreeNode&#123;val, getTree(right/left), getTree(right/left) &#125;</code>  , 先得把节点构造出来作为根节点，然后再去遍历找其他的节点</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * type TreeNode struct &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     Val int</span></span><br><span class=\"line\"><span class=\"comment\"> *     Left *TreeNode</span></span><br><span class=\"line\"><span class=\"comment\"> *     Right *TreeNode</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">sortedArrayToBST</span><span class=\"params\">(nums []<span class=\"type\">int</span>)</span></span> *TreeNode &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(nums) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    mid := <span class=\"built_in\">len</span>(nums) / <span class=\"number\">2</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    left := nums[:mid]</span><br><span class=\"line\">    right := nums[mid+<span class=\"number\">1</span>:]</span><br><span class=\"line\">    <span class=\"comment\">// 这个递归的设计非常优美，递归的核心是构造了mid值得根节点，然后继续递归传入左右的切片</span></span><br><span class=\"line\">    node := &amp;TreeNode&#123;nums[mid], sortedArrayToBST(left), sortedArrayToBST(right)&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> node</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"二叉树的最小深度-力扣（LeetCode）\"><a href=\"#二叉树的最小深度-力扣（LeetCode）\" class=\"headerlink\" title=\" 二叉树的最小深度 - 力扣（LeetCode）\"></a><a href=\"https://leetcode.cn/problems/minimum-depth-of-binary-tree/solution/ke-yi-shi-xiao-gai-goyu-yan-zhu-xing-zhu-q9ed/\"> 二叉树的最小深度 - 力扣（LeetCode）</a></h3><p>出现特殊情况是因为最小深度，会计算到有一个子树为空的情况，但是另一个子树不一定为空，那么其根节点就不是叶子节点</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * type TreeNode struct &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     Val int</span></span><br><span class=\"line\"><span class=\"comment\"> *     Left *TreeNode</span></span><br><span class=\"line\"><span class=\"comment\"> *     Right *TreeNode</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//tips:利用左右根（后续遍历） 求出的最小高度，也是这棵树的最小深度</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">minDepth</span><span class=\"params\">(root *TreeNode)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> root == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//先求出左右子树的最小深度</span></span><br><span class=\"line\">\tleftMin := minDepth(root.Left)</span><br><span class=\"line\">\trightMin := minDepth(root.Right)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t\t1.但是要考虑特殊情况，根节点的左子树为空，右子树不为空，</span></span><br><span class=\"line\"><span class=\"comment\">        不能直接min(root.Left,root.Right)，</span></span><br><span class=\"line\"><span class=\"comment\">\t\t2.因为不符合题目“根节点到最近叶子节点的最短路径上的节点数量”</span></span><br><span class=\"line\"><span class=\"comment\">        的要求一定要有叶子节点</span></span><br><span class=\"line\"><span class=\"comment\">\t*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> root.Left == <span class=\"literal\">nil</span> &amp;&amp; root.Right != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">1</span> + rightMin</span><br><span class=\"line\">\t\t<span class=\"comment\">//如上</span></span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> root.Left != <span class=\"literal\">nil</span> &amp;&amp; root.Right == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">1</span> + leftMin</span><br><span class=\"line\">\t\t<span class=\"comment\">//如果左右子树都不为空才能用min</span></span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">1</span> + min(leftMin, rightMin)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">min</span><span class=\"params\">(a, b <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> a &lt; b &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> a</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> b</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"118-杨辉三角-力扣（LeetCode）\"><a href=\"#118-杨辉三角-力扣（LeetCode）\" class=\"headerlink\" title=\"118. 杨辉三角 - 力扣（LeetCode）\"></a><a href=\"https://leetcode.cn/problems/pascals-triangle/submissions/\">118. 杨辉三角 - 力扣（LeetCode）</a></h3><p>使用 dp 解题,核心在于杨辉三角的计算过程符合 dp 的问题拆解</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">generate</span><span class=\"params\">(numRows <span class=\"type\">int</span>)</span></span> [][]<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// dp 模板1： 创建dp数组一维或者是二维</span></span><br><span class=\"line\">    dp := <span class=\"built_in\">make</span>([][]<span class=\"type\">int</span>, numRows)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> numRows == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> dp</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"comment\">// dp 数组的初始化，一般来说需要在纸上把这个dp数组画出来，然后观察数组的规律，将那些dp[][]边界值给计算出来</span></span><br><span class=\"line\">    </span><br><span class=\"line\">\t<span class=\"keyword\">for</span> k := <span class=\"keyword\">range</span> dp &#123;</span><br><span class=\"line\">\t\tdp[k] = <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, k+<span class=\"number\">1</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; numRows; i++ &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> j := <span class=\"number\">0</span>; j &lt; i+<span class=\"number\">1</span>; j++ &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> j == <span class=\"number\">0</span> || j == i &#123;</span><br><span class=\"line\">\t\t\t\tdp[i][j] = <span class=\"number\">1</span></span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\tdp[i][j] = dp[i<span class=\"number\">-1</span>][j] + dp[i<span class=\"number\">-1</span>][j<span class=\"number\">-1</span>]</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> dp</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"单调栈，贪心算法，最简单的思路，找到最小值，找到其后最大值，两个相减即可得-买卖股票的最佳时机-力扣（LeetCode）\"><a href=\"#单调栈，贪心算法，最简单的思路，找到最小值，找到其后最大值，两个相减即可得-买卖股票的最佳时机-力扣（LeetCode）\" class=\"headerlink\" title=\"单调栈，贪心算法，最简单的思路，找到最小值，找到其后最大值，两个相减即可得 - 买卖股票的最佳时机 - 力扣（LeetCode）\"></a><a href=\"https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/solution/-by-gracious-vvilson1bb-w8yb/\">单调栈，贪心算法，最简单的思路，找到最小值，找到其后最大值，两个相减即可得 - 买卖股票的最佳时机 - 力扣（LeetCode）</a></h3><p>关键常数，直接背住：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">maxs :=math.MinInt64</span><br><span class=\"line\">mins :=math.MaxInt64</span><br></pre></td></tr></table></figure>\n\n<p>单调栈来一次 O(n^2)遍历一次找到所有的元素向右间距，比较出最大值就可以</p>\n<p>题目做了优化，考虑贪心的方法</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">maxProfit</span><span class=\"params\">(prices []<span class=\"type\">int</span>)</span></span> (s <span class=\"type\">int</span>) &#123;</span><br><span class=\"line\">\tmaxs :=math.MinInt64</span><br><span class=\"line\">\tmins :=math.MaxInt64</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(prices); i++ &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 由于 max 总是在已有的 mins 基础上来计算，相当于这个问题就变成了</span></span><br><span class=\"line\">        <span class=\"comment\">// 遍历先找当前最小的元素</span></span><br><span class=\"line\">        <span class=\"comment\">// 再计算当前元素比之前最小元素大的间距</span></span><br><span class=\"line\">        <span class=\"comment\">// 因为本体的大小关系只局限在数组元素的大小，而不考虑数组下标的间距，所以可以直接寻找最优解</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//记一个最小值</span></span><br><span class=\"line\">\t\tmins =min(mins,prices[i])</span><br><span class=\"line\">\t\t<span class=\"comment\">//记一个最大值</span></span><br><span class=\"line\">\t\tmaxs =max(maxs,prices[i]-mins)</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//返回最大差值</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> maxs</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">max</span><span class=\"params\">(x, y <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> x &gt; y &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> x</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> y</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">min</span><span class=\"params\">(x, y <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> x &gt; y &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> y</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> x</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"dp-丑数-II-丑数-II-力扣（LeetCode）\"><a href=\"#dp-丑数-II-丑数-II-力扣（LeetCode）\" class=\"headerlink\" title=\"dp-丑数 II - 丑数 II - 力扣（LeetCode）\"></a><a href=\"https://leetcode.cn/problems/ugly-number-ii/solution/chou-shu-ii-by-beney-2-0uk5/\">dp-丑数 II - 丑数 II - 力扣（LeetCode）</a></h3><p>关键点1 ： 求因数的计算常规是：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">%n == <span class=\"number\">0</span> 表示n是他的因数</span><br></pre></td></tr></table></figure>\n\n<p>关键点2：第 n  个丑数是前面 某个丑数 *2或者 *3 或者 *5 得来的，且对于同一个数而言他的丑数因数乘以2，3，5肯定不一样（可证），反过来也就是说每一个丑数 乘2乘3乘5所得的丑数不一样</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">nthUglyNumber</span><span class=\"params\">(n <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> n == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">panic</span>(errors.New(<span class=\"string\">&quot;invalid n&quot;</span>))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    m2, m3, m5 := <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">    dp := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, n)</span><br><span class=\"line\">    dp[<span class=\"number\">0</span>] = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">1</span>; i &lt; n; i++ &#123;</span><br><span class=\"line\">        a, b, c := dp[m2]*<span class=\"number\">2</span>, dp[m3]*<span class=\"number\">3</span>, dp[m5]*<span class=\"number\">5</span></span><br><span class=\"line\">        dp[i] = min(a, min(b, c))</span><br><span class=\"line\">        <span class=\"keyword\">if</span> dp[i] == a &#123;</span><br><span class=\"line\">            m2++</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> dp[i] == b &#123;</span><br><span class=\"line\">            m3++</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> dp[i] == c &#123;</span><br><span class=\"line\">            m5++</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[n<span class=\"number\">-1</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">min</span><span class=\"params\">(x, y <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> x &lt; y &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> y</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"验证回文串-验证回文串-力扣（LeetCode）\"><a href=\"#验证回文串-验证回文串-力扣（LeetCode）\" class=\"headerlink\" title=\"验证回文串 - 验证回文串 - 力扣（LeetCode）\"></a><a href=\"https://leetcode.cn/problems/valid-palindrome/solution/yan-zheng-hui-wen-chuan-by-leetcode-solution/\">验证回文串 - 验证回文串 - 力扣（LeetCode）</a></h3><p>关键点在于对输入数据的处理:48,65,97</p>\n<ol>\n<li><p>判断是否是字母数字字符</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">isalnum</span><span class=\"params\">(ch <span class=\"type\">byte</span>)</span></span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (ch &gt;= <span class=\"string\">&#x27;A&#x27;</span> &amp;&amp; ch &lt;= <span class=\"string\">&#x27;Z&#x27;</span>) || (ch &gt;= <span class=\"string\">&#x27;a&#x27;</span> &amp;&amp; ch &lt;= <span class=\"string\">&#x27;z&#x27;</span>) || (ch &gt;= <span class=\"string\">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class=\"string\">&#x27;9&#x27;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>大写转小写</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">strings.ToLower(s)</span><br><span class=\"line\">strings.ToUpper(s)</span><br></pre></td></tr></table></figure>\n\n<p>其他常用提醒：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ol>\n"},{"title":"算法代码通用模板思考","catalog":true,"date":"2023-03-29T17:25:25.000Z","subtitle":null,"header-img":null,"published":0,"_content":"\n# 文档前言\n\n当我完成了许多的算法题目以及其扩展题目之后，总是在那几天对于解决这类性特征的问题有着较多的见解，而且发现同类型特征的问题往往有着相似的解法，尤其是在我回顾一些问题却发现他们异常陌生的时候，我察觉到自己不能通过简单的肌肉记忆来提高解决问题的能力，重复和已经解决思考的部分应当有浓缩和归类的操作\n\n本文档的主要内容将主要包含两个部分：\n* 基础简单算法的模式化归纳：忽略代码实现的细节和边界条件，将算法当中最主要的公式和代码片段摘出\n* 特征问题的通解归纳，将具有特征特点的问题归纳出一个通用的范式\n\n# 二叉树\n\n## 二叉树的遍历\n在树的**深度优先**遍历算法当中（包括前序、中序、后序），常常使用的是递归的方式，也就是：\n\n* <font color ='red'>前序遍历：中、左、右 </font>\n* <font color ='red'>中序遍历：左、中、右 </font>\n* <font color ='red'>后序遍历：左、右、中 </font>\n\n\n### 颜色标记法\n\n受到(henry)[https://leetcode.cn/problems/binary-tree-inorder-traversal/solution/yan-se-biao-ji-fa-yi-chong-tong-yong-qie-jian-ming/] 解题方法的启发\n\n将树的遍历问题放到栈的逻辑下面，其实有几点问题：\n* 入栈的元素只有两种： 指向节点的指针和空指针，类似于：`[1,null,2,null,3,null,4,null,5,null,6]`\n* 出栈的时候操作的必定是一个有指向地址的指针，那么出栈操作代表些什么\n* 怎样才能够区别出左子树和右子树呢？\n\n栈是先进后出的数据结构，与递归和函数调用类似，越是靠近栈底的元素他在树的结构上就越高。而栈的这个特性保证了树的结构，也就是说左/右子树必定是在右/左子树之前弹出，换句话说除了当前遍历的节点node，他的左右在遍历过程其实中代表的是一棵树，继续向栈里推入元素就是在不断地展开他的树节点，而这样的顺序必定是被中间的Node所标志的，如图中所示\n\n\n<div style=\"display:flex;flex-direction:row;\"r>\n    <img src='./tree_stack1.jpg' width=\"400\" height=\"200\" style=\"margin-right:10px;\"/>\n    <img src='./tree_stack2.jpg' width=\"400\" height=\"200\" style=\"margin-left:10px;\"/>\n</div>\n\n\\\n回到上述三个问题来理解就会容易一些\n1. 因为栈存储的是树，而不是节点，所以一些叶节点没有左右子树，这部分依旧还是会以逻辑形式入栈 \n2. 出栈入栈是对应的，所以理解上也应该要对应起来说，第一次入栈只要该节点不是root，那么他必定是以某个节点的左右节点身份入栈的，此时的入栈操作标识的是当前节点为root 的子树，所以第一次出栈是用来将其从树的身份转化为节点，通过将其标记为 1 [有颜色，标志为确实为一个节点]，然后再入栈表示为遍历，当把整棵树放入栈中后，出栈操作则对应节点，此时栈中所有标记为1的部分就是实际遍历的节点，而且按照入栈的顺序表示出中、后、前序.\n那么按照这样的思路，我们来编写一下对二叉树的中序遍历：\n\n``` golang \ntype TreeNode struct{\n    Right *TreeNode\n    Left  *TreeNode\n    Val  int\n}\n\n//\nfunc traversal(root *TreeNode) []interface{}{\n    // 颜色点，用于标记出入栈\n    type node struct{\n        Color int\n        Node *TreeNode\n    }\n\n    stack := make([]*node,0)\n    stack = append(stack,node{0，root})\n\n    // 需要的结果函数\n    //result := make([]interface,0)\n    res := make([]int,0)\n\n    for len(stack) > 0{\n        // 每次都取出栈顶元素进行判定\n        n := stack[len(stack)-1]\n        stack = stack[:len(stack)-1]\n\n        if n.Node == nil {\n            continue\n        }\n\n        if n.Color == 0{\n            stack = append(stack,node{0,n.Node.Right})\n            stack = append(stack,node{1,n.Node})\n            stack = append(stack,node{0,n.Node.Left})\n        }else{\n            res = append(res, n.Node.Val)\n        }\n    }\n    return res\n}\n\n```\n\n在这段代码当中，由于标记方式的存在和入栈方式是两次入栈，所以几乎可以是模板样式来解决问题，而且好记忆\n\n在代码当中可以修改的地方只有两处：\n``` golang\n    if n.Color == 0{\n        【第一处】\n        可以修改为不同的深度遍历顺序\n        【前序遍历】：\n        ···\n            stack = append(stack,node{0,n.Node.Right})\n            stack = append(stack,node{0,n.Node.Left}) \n            stack = append(stack,node{1,n.Node})   \n        ···\n        【中序遍历】\n        ···\n            stack = append(stack,node{0,n.Node.Right})\n            stack = append(stack,node{1,n.Node})  \n            stack = append(stack,node{0,n.Node.Left}) \n        ···\n        【后序遍历】\n        ···\n            stack = append(stack,node{1,n.Node})  \n            stack = append(stack,node{0,n.Node.Right})\n            stack = append(stack,node{0,n.Node.Left}) \n        ···\n    }else{\n        【第二处】\n        添加对当前node值的修改函数\n    }\n```\n\n### 递归方法\n\n使用递归最关键还是两条：\n* 递归结束的条件\n* 递归函数的结构\n\n普通的前序遍历数组的代码：\n```golang\n\n\n```\n\n# 常见运算标识\n\n## 最大最小值\n\n以下这两个都是可以接受多个变量参数的求最大最小值\n``` golang\n    func max(args ...int)int{\n        m := args[0]\n        for _,val := range args{\n            if val > m{\n                m = val\n            }\n        }\n        return m\n    }\n\n    func min(args ...int)int{\n        m := args[0]\n        for _,val := range args{\n            if val < m{\n                m = val\n            }\n        }\n        return m\n    }\n```\n\n## 异或，同或\n```golang\nfunc xor(a, b bool) bool {\n    return (a || b) && !(a && b)\n}\n```\n```golang\nfunc xnor(a, b bool) bool {\n    return (a && b) || (!a && !b)\n}\n```\n\n\n## 位运算\n\n### 两数相加\n```golang\nfunc getSum(a int, b int) int {\n    // 异或+与运算:时间复杂度O(logSum) | 空间复杂度O(1)\n    a, b = a ^ b, (a & b) << 1\n    for b != 0 {\n        a, b = a ^ b, (a & b) << 1\n    }\n    return a\n}\n```\n\n### 两数相除\n```golang\nfunc divide(dividend int, divisor int) int {\n    if dividend==0 {return 0}\n    if dividend==math.MinInt32 && divisor==-1 {return math.MaxInt32}\n\n    diffSign:=false\n    if (dividend<0)!=(divisor<0) {\n        diffSign=true\n    }\n\n    i,j,sum := 0,0,0\n    for {\n        tmp:=0\n        if diffSign {\n            tmp=sum-divisor<<j\n        }else{\n            tmp=sum+divisor<<j\n        }\n        if (dividend>0 && tmp>dividend) || (dividend<0 && tmp<dividend) {\n            if j==0 {break}\n            j-- //步长减半\n            continue\n        }\n        sum=tmp\n        i+=1<<j\n        j++ //步长加倍\n    }\n\n    if diffSign {\n        return -i\n    }\n    return i\n}\n```\n\n\n\n## 二维矩阵转置\n``` golang\nfunc transposeMatrix(matrix [][]int) [][]int {\n    // 获取矩阵的行数和列数\n    rows, cols := len(matrix), len(matrix[0])\n    // 定义一个新的二维数组，用于存储转置后的矩阵\n    transposed := make([][]int, cols)\n    for i := range transposed {\n        transposed[i] = make([]int, rows)\n    }\n    // 遍历原矩阵，将其每个元素放置在转置矩阵中的相应位置\n    for i := 0; i < rows; i++ {\n        for j := 0; j < cols; j++ {\n            transposed[j][i] = matrix[i][j]\n        }\n    }\n    return transposed\n}\n```","source":"_posts/Algorithm/script/算法代码通用模板思考/算法代码通用模板思考.md","raw":"---\ntitle: 算法代码通用模板思考\ncatalog: true\ndate: 2023-03-30 01:25:25\nsubtitle:\nheader-img:\ntags: Working\ncategories: 算法 \npublished: false\n---\n\n# 文档前言\n\n当我完成了许多的算法题目以及其扩展题目之后，总是在那几天对于解决这类性特征的问题有着较多的见解，而且发现同类型特征的问题往往有着相似的解法，尤其是在我回顾一些问题却发现他们异常陌生的时候，我察觉到自己不能通过简单的肌肉记忆来提高解决问题的能力，重复和已经解决思考的部分应当有浓缩和归类的操作\n\n本文档的主要内容将主要包含两个部分：\n* 基础简单算法的模式化归纳：忽略代码实现的细节和边界条件，将算法当中最主要的公式和代码片段摘出\n* 特征问题的通解归纳，将具有特征特点的问题归纳出一个通用的范式\n\n# 二叉树\n\n## 二叉树的遍历\n在树的**深度优先**遍历算法当中（包括前序、中序、后序），常常使用的是递归的方式，也就是：\n\n* <font color ='red'>前序遍历：中、左、右 </font>\n* <font color ='red'>中序遍历：左、中、右 </font>\n* <font color ='red'>后序遍历：左、右、中 </font>\n\n\n### 颜色标记法\n\n受到(henry)[https://leetcode.cn/problems/binary-tree-inorder-traversal/solution/yan-se-biao-ji-fa-yi-chong-tong-yong-qie-jian-ming/] 解题方法的启发\n\n将树的遍历问题放到栈的逻辑下面，其实有几点问题：\n* 入栈的元素只有两种： 指向节点的指针和空指针，类似于：`[1,null,2,null,3,null,4,null,5,null,6]`\n* 出栈的时候操作的必定是一个有指向地址的指针，那么出栈操作代表些什么\n* 怎样才能够区别出左子树和右子树呢？\n\n栈是先进后出的数据结构，与递归和函数调用类似，越是靠近栈底的元素他在树的结构上就越高。而栈的这个特性保证了树的结构，也就是说左/右子树必定是在右/左子树之前弹出，换句话说除了当前遍历的节点node，他的左右在遍历过程其实中代表的是一棵树，继续向栈里推入元素就是在不断地展开他的树节点，而这样的顺序必定是被中间的Node所标志的，如图中所示\n\n\n<div style=\"display:flex;flex-direction:row;\"r>\n    <img src='./tree_stack1.jpg' width=\"400\" height=\"200\" style=\"margin-right:10px;\"/>\n    <img src='./tree_stack2.jpg' width=\"400\" height=\"200\" style=\"margin-left:10px;\"/>\n</div>\n\n\\\n回到上述三个问题来理解就会容易一些\n1. 因为栈存储的是树，而不是节点，所以一些叶节点没有左右子树，这部分依旧还是会以逻辑形式入栈 \n2. 出栈入栈是对应的，所以理解上也应该要对应起来说，第一次入栈只要该节点不是root，那么他必定是以某个节点的左右节点身份入栈的，此时的入栈操作标识的是当前节点为root 的子树，所以第一次出栈是用来将其从树的身份转化为节点，通过将其标记为 1 [有颜色，标志为确实为一个节点]，然后再入栈表示为遍历，当把整棵树放入栈中后，出栈操作则对应节点，此时栈中所有标记为1的部分就是实际遍历的节点，而且按照入栈的顺序表示出中、后、前序.\n那么按照这样的思路，我们来编写一下对二叉树的中序遍历：\n\n``` golang \ntype TreeNode struct{\n    Right *TreeNode\n    Left  *TreeNode\n    Val  int\n}\n\n//\nfunc traversal(root *TreeNode) []interface{}{\n    // 颜色点，用于标记出入栈\n    type node struct{\n        Color int\n        Node *TreeNode\n    }\n\n    stack := make([]*node,0)\n    stack = append(stack,node{0，root})\n\n    // 需要的结果函数\n    //result := make([]interface,0)\n    res := make([]int,0)\n\n    for len(stack) > 0{\n        // 每次都取出栈顶元素进行判定\n        n := stack[len(stack)-1]\n        stack = stack[:len(stack)-1]\n\n        if n.Node == nil {\n            continue\n        }\n\n        if n.Color == 0{\n            stack = append(stack,node{0,n.Node.Right})\n            stack = append(stack,node{1,n.Node})\n            stack = append(stack,node{0,n.Node.Left})\n        }else{\n            res = append(res, n.Node.Val)\n        }\n    }\n    return res\n}\n\n```\n\n在这段代码当中，由于标记方式的存在和入栈方式是两次入栈，所以几乎可以是模板样式来解决问题，而且好记忆\n\n在代码当中可以修改的地方只有两处：\n``` golang\n    if n.Color == 0{\n        【第一处】\n        可以修改为不同的深度遍历顺序\n        【前序遍历】：\n        ···\n            stack = append(stack,node{0,n.Node.Right})\n            stack = append(stack,node{0,n.Node.Left}) \n            stack = append(stack,node{1,n.Node})   \n        ···\n        【中序遍历】\n        ···\n            stack = append(stack,node{0,n.Node.Right})\n            stack = append(stack,node{1,n.Node})  \n            stack = append(stack,node{0,n.Node.Left}) \n        ···\n        【后序遍历】\n        ···\n            stack = append(stack,node{1,n.Node})  \n            stack = append(stack,node{0,n.Node.Right})\n            stack = append(stack,node{0,n.Node.Left}) \n        ···\n    }else{\n        【第二处】\n        添加对当前node值的修改函数\n    }\n```\n\n### 递归方法\n\n使用递归最关键还是两条：\n* 递归结束的条件\n* 递归函数的结构\n\n普通的前序遍历数组的代码：\n```golang\n\n\n```\n\n# 常见运算标识\n\n## 最大最小值\n\n以下这两个都是可以接受多个变量参数的求最大最小值\n``` golang\n    func max(args ...int)int{\n        m := args[0]\n        for _,val := range args{\n            if val > m{\n                m = val\n            }\n        }\n        return m\n    }\n\n    func min(args ...int)int{\n        m := args[0]\n        for _,val := range args{\n            if val < m{\n                m = val\n            }\n        }\n        return m\n    }\n```\n\n## 异或，同或\n```golang\nfunc xor(a, b bool) bool {\n    return (a || b) && !(a && b)\n}\n```\n```golang\nfunc xnor(a, b bool) bool {\n    return (a && b) || (!a && !b)\n}\n```\n\n\n## 位运算\n\n### 两数相加\n```golang\nfunc getSum(a int, b int) int {\n    // 异或+与运算:时间复杂度O(logSum) | 空间复杂度O(1)\n    a, b = a ^ b, (a & b) << 1\n    for b != 0 {\n        a, b = a ^ b, (a & b) << 1\n    }\n    return a\n}\n```\n\n### 两数相除\n```golang\nfunc divide(dividend int, divisor int) int {\n    if dividend==0 {return 0}\n    if dividend==math.MinInt32 && divisor==-1 {return math.MaxInt32}\n\n    diffSign:=false\n    if (dividend<0)!=(divisor<0) {\n        diffSign=true\n    }\n\n    i,j,sum := 0,0,0\n    for {\n        tmp:=0\n        if diffSign {\n            tmp=sum-divisor<<j\n        }else{\n            tmp=sum+divisor<<j\n        }\n        if (dividend>0 && tmp>dividend) || (dividend<0 && tmp<dividend) {\n            if j==0 {break}\n            j-- //步长减半\n            continue\n        }\n        sum=tmp\n        i+=1<<j\n        j++ //步长加倍\n    }\n\n    if diffSign {\n        return -i\n    }\n    return i\n}\n```\n\n\n\n## 二维矩阵转置\n``` golang\nfunc transposeMatrix(matrix [][]int) [][]int {\n    // 获取矩阵的行数和列数\n    rows, cols := len(matrix), len(matrix[0])\n    // 定义一个新的二维数组，用于存储转置后的矩阵\n    transposed := make([][]int, cols)\n    for i := range transposed {\n        transposed[i] = make([]int, rows)\n    }\n    // 遍历原矩阵，将其每个元素放置在转置矩阵中的相应位置\n    for i := 0; i < rows; i++ {\n        for j := 0; j < cols; j++ {\n            transposed[j][i] = matrix[i][j]\n        }\n    }\n    return transposed\n}\n```","slug":"Algorithm/script/算法代码通用模板思考/算法代码通用模板思考","updated":"2023-04-22T13:24:02.176Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli796r17002gbyjx995s7lph","content":"<h1 id=\"文档前言\"><a href=\"#文档前言\" class=\"headerlink\" title=\"文档前言\"></a>文档前言</h1><p>当我完成了许多的算法题目以及其扩展题目之后，总是在那几天对于解决这类性特征的问题有着较多的见解，而且发现同类型特征的问题往往有着相似的解法，尤其是在我回顾一些问题却发现他们异常陌生的时候，我察觉到自己不能通过简单的肌肉记忆来提高解决问题的能力，重复和已经解决思考的部分应当有浓缩和归类的操作</p>\n<p>本文档的主要内容将主要包含两个部分：</p>\n<ul>\n<li>基础简单算法的模式化归纳：忽略代码实现的细节和边界条件，将算法当中最主要的公式和代码片段摘出</li>\n<li>特征问题的通解归纳，将具有特征特点的问题归纳出一个通用的范式</li>\n</ul>\n<h1 id=\"二叉树\"><a href=\"#二叉树\" class=\"headerlink\" title=\"二叉树\"></a>二叉树</h1><h2 id=\"二叉树的遍历\"><a href=\"#二叉树的遍历\" class=\"headerlink\" title=\"二叉树的遍历\"></a>二叉树的遍历</h2><p>在树的<strong>深度优先</strong>遍历算法当中（包括前序、中序、后序），常常使用的是递归的方式，也就是：</p>\n<ul>\n<li><font color ='red'>前序遍历：中、左、右 </font></li>\n<li><font color ='red'>中序遍历：左、中、右 </font></li>\n<li><font color ='red'>后序遍历：左、右、中 </font></li>\n</ul>\n<h3 id=\"颜色标记法\"><a href=\"#颜色标记法\" class=\"headerlink\" title=\"颜色标记法\"></a>颜色标记法</h3><p>受到(henry)[<a href=\"https://leetcode.cn/problems/binary-tree-inorder-traversal/solution/yan-se-biao-ji-fa-yi-chong-tong-yong-qie-jian-ming/]\">https://leetcode.cn/problems/binary-tree-inorder-traversal/solution/yan-se-biao-ji-fa-yi-chong-tong-yong-qie-jian-ming/]</a> 解题方法的启发</p>\n<p>将树的遍历问题放到栈的逻辑下面，其实有几点问题：</p>\n<ul>\n<li>入栈的元素只有两种： 指向节点的指针和空指针，类似于：<code>[1,null,2,null,3,null,4,null,5,null,6]</code></li>\n<li>出栈的时候操作的必定是一个有指向地址的指针，那么出栈操作代表些什么</li>\n<li>怎样才能够区别出左子树和右子树呢？</li>\n</ul>\n<p>栈是先进后出的数据结构，与递归和函数调用类似，越是靠近栈底的元素他在树的结构上就越高。而栈的这个特性保证了树的结构，也就是说左/右子树必定是在右/左子树之前弹出，换句话说除了当前遍历的节点node，他的左右在遍历过程其实中代表的是一棵树，继续向栈里推入元素就是在不断地展开他的树节点，而这样的顺序必定是被中间的Node所标志的，如图中所示</p>\n<div style=\"display:flex;flex-direction:row;\"r>\n    <img src='./tree_stack1.jpg' width=\"400\" height=\"200\" style=\"margin-right:10px;\"/>\n    <img src='./tree_stack2.jpg' width=\"400\" height=\"200\" style=\"margin-left:10px;\"/>\n</div>\n\n<p><br>回到上述三个问题来理解就会容易一些</p>\n<ol>\n<li>因为栈存储的是树，而不是节点，所以一些叶节点没有左右子树，这部分依旧还是会以逻辑形式入栈 </li>\n<li>出栈入栈是对应的，所以理解上也应该要对应起来说，第一次入栈只要该节点不是root，那么他必定是以某个节点的左右节点身份入栈的，此时的入栈操作标识的是当前节点为root 的子树，所以第一次出栈是用来将其从树的身份转化为节点，通过将其标记为 1 [有颜色，标志为确实为一个节点]，然后再入栈表示为遍历，当把整棵树放入栈中后，出栈操作则对应节点，此时栈中所有标记为1的部分就是实际遍历的节点，而且按照入栈的顺序表示出中、后、前序.<br>那么按照这样的思路，我们来编写一下对二叉树的中序遍历：</li>\n</ol>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> TreeNode <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">    Right *TreeNode</span><br><span class=\"line\">    Left  *TreeNode</span><br><span class=\"line\">    Val  <span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">traversal</span><span class=\"params\">(root *TreeNode)</span></span> []<span class=\"keyword\">interface</span>&#123;&#125;&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 颜色点，用于标记出入栈</span></span><br><span class=\"line\">    <span class=\"keyword\">type</span> node <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">        Color <span class=\"type\">int</span></span><br><span class=\"line\">        Node *TreeNode</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    stack := <span class=\"built_in\">make</span>([]*node,<span class=\"number\">0</span>)</span><br><span class=\"line\">    stack = <span class=\"built_in\">append</span>(stack,node&#123;<span class=\"number\">0</span>，root&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 需要的结果函数</span></span><br><span class=\"line\">    <span class=\"comment\">//result := make([]interface,0)</span></span><br><span class=\"line\">    res := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"built_in\">len</span>(stack) &gt; <span class=\"number\">0</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 每次都取出栈顶元素进行判定</span></span><br><span class=\"line\">        n := stack[<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>]</span><br><span class=\"line\">        stack = stack[:<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> n.Node == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> n.Color == <span class=\"number\">0</span>&#123;</span><br><span class=\"line\">            stack = <span class=\"built_in\">append</span>(stack,node&#123;<span class=\"number\">0</span>,n.Node.Right&#125;)</span><br><span class=\"line\">            stack = <span class=\"built_in\">append</span>(stack,node&#123;<span class=\"number\">1</span>,n.Node&#125;)</span><br><span class=\"line\">            stack = <span class=\"built_in\">append</span>(stack,node&#123;<span class=\"number\">0</span>,n.Node.Left&#125;)</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            res = <span class=\"built_in\">append</span>(res, n.Node.Val)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>在这段代码当中，由于标记方式的存在和入栈方式是两次入栈，所以几乎可以是模板样式来解决问题，而且好记忆</p>\n<p>在代码当中可以修改的地方只有两处：</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> n.Color == <span class=\"number\">0</span>&#123;</span><br><span class=\"line\">    【第一处】</span><br><span class=\"line\">    可以修改为不同的深度遍历顺序</span><br><span class=\"line\">    【前序遍历】：</span><br><span class=\"line\">    ···</span><br><span class=\"line\">        stack = <span class=\"built_in\">append</span>(stack,node&#123;<span class=\"number\">0</span>,n.Node.Right&#125;)</span><br><span class=\"line\">        stack = <span class=\"built_in\">append</span>(stack,node&#123;<span class=\"number\">0</span>,n.Node.Left&#125;) </span><br><span class=\"line\">        stack = <span class=\"built_in\">append</span>(stack,node&#123;<span class=\"number\">1</span>,n.Node&#125;)   </span><br><span class=\"line\">    ···</span><br><span class=\"line\">    【中序遍历】</span><br><span class=\"line\">    ···</span><br><span class=\"line\">        stack = <span class=\"built_in\">append</span>(stack,node&#123;<span class=\"number\">0</span>,n.Node.Right&#125;)</span><br><span class=\"line\">        stack = <span class=\"built_in\">append</span>(stack,node&#123;<span class=\"number\">1</span>,n.Node&#125;)  </span><br><span class=\"line\">        stack = <span class=\"built_in\">append</span>(stack,node&#123;<span class=\"number\">0</span>,n.Node.Left&#125;) </span><br><span class=\"line\">    ···</span><br><span class=\"line\">    【后序遍历】</span><br><span class=\"line\">    ···</span><br><span class=\"line\">        stack = <span class=\"built_in\">append</span>(stack,node&#123;<span class=\"number\">1</span>,n.Node&#125;)  </span><br><span class=\"line\">        stack = <span class=\"built_in\">append</span>(stack,node&#123;<span class=\"number\">0</span>,n.Node.Right&#125;)</span><br><span class=\"line\">        stack = <span class=\"built_in\">append</span>(stack,node&#123;<span class=\"number\">0</span>,n.Node.Left&#125;) </span><br><span class=\"line\">    ···</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    【第二处】</span><br><span class=\"line\">    添加对当前node值的修改函数</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"递归方法\"><a href=\"#递归方法\" class=\"headerlink\" title=\"递归方法\"></a>递归方法</h3><p>使用递归最关键还是两条：</p>\n<ul>\n<li>递归结束的条件</li>\n<li>递归函数的结构</li>\n</ul>\n<p>普通的前序遍历数组的代码：</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"常见运算标识\"><a href=\"#常见运算标识\" class=\"headerlink\" title=\"常见运算标识\"></a>常见运算标识</h1><h2 id=\"最大最小值\"><a href=\"#最大最小值\" class=\"headerlink\" title=\"最大最小值\"></a>最大最小值</h2><p>以下这两个都是可以接受多个变量参数的求最大最小值</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">max</span><span class=\"params\">(args ...<span class=\"type\">int</span>)</span></span><span class=\"type\">int</span>&#123;</span><br><span class=\"line\">    m := args[<span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _,val := <span class=\"keyword\">range</span> args&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> val &gt; m&#123;</span><br><span class=\"line\">            m = val</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">min</span><span class=\"params\">(args ...<span class=\"type\">int</span>)</span></span><span class=\"type\">int</span>&#123;</span><br><span class=\"line\">    m := args[<span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _,val := <span class=\"keyword\">range</span> args&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> val &lt; m&#123;</span><br><span class=\"line\">            m = val</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"异或，同或\"><a href=\"#异或，同或\" class=\"headerlink\" title=\"异或，同或\"></a>异或，同或</h2><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">xor</span><span class=\"params\">(a, b <span class=\"type\">bool</span>)</span></span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (a || b) &amp;&amp; !(a &amp;&amp; b)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">xnor</span><span class=\"params\">(a, b <span class=\"type\">bool</span>)</span></span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (a &amp;&amp; b) || (!a &amp;&amp; !b)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"位运算\"><a href=\"#位运算\" class=\"headerlink\" title=\"位运算\"></a>位运算</h2><h3 id=\"两数相加\"><a href=\"#两数相加\" class=\"headerlink\" title=\"两数相加\"></a>两数相加</h3><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">getSum</span><span class=\"params\">(a <span class=\"type\">int</span>, b <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 异或+与运算:时间复杂度O(logSum) | 空间复杂度O(1)</span></span><br><span class=\"line\">    a, b = a ^ b, (a &amp; b) &lt;&lt; <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> b != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        a, b = a ^ b, (a &amp; b) &lt;&lt; <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"两数相除\"><a href=\"#两数相除\" class=\"headerlink\" title=\"两数相除\"></a>两数相除</h3><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">divide</span><span class=\"params\">(dividend <span class=\"type\">int</span>, divisor <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> dividend==<span class=\"number\">0</span> &#123;<span class=\"keyword\">return</span> <span class=\"number\">0</span>&#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> dividend==math.MinInt32 &amp;&amp; divisor==<span class=\"number\">-1</span> &#123;<span class=\"keyword\">return</span> math.MaxInt32&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    diffSign:=<span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dividend&lt;<span class=\"number\">0</span>)!=(divisor&lt;<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        diffSign=<span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    i,j,sum := <span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">        tmp:=<span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> diffSign &#123;</span><br><span class=\"line\">            tmp=sum-divisor&lt;&lt;j</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            tmp=sum+divisor&lt;&lt;j</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dividend&gt;<span class=\"number\">0</span> &amp;&amp; tmp&gt;dividend) || (dividend&lt;<span class=\"number\">0</span> &amp;&amp; tmp&lt;dividend) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> j==<span class=\"number\">0</span> &#123;<span class=\"keyword\">break</span>&#125;</span><br><span class=\"line\">            j-- <span class=\"comment\">//步长减半</span></span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sum=tmp</span><br><span class=\"line\">        i+=<span class=\"number\">1</span>&lt;&lt;j</span><br><span class=\"line\">        j++ <span class=\"comment\">//步长加倍</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> diffSign &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -i</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> i</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"二维矩阵转置\"><a href=\"#二维矩阵转置\" class=\"headerlink\" title=\"二维矩阵转置\"></a>二维矩阵转置</h2><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">transposeMatrix</span><span class=\"params\">(matrix [][]<span class=\"type\">int</span>)</span></span> [][]<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取矩阵的行数和列数</span></span><br><span class=\"line\">    rows, cols := <span class=\"built_in\">len</span>(matrix), <span class=\"built_in\">len</span>(matrix[<span class=\"number\">0</span>])</span><br><span class=\"line\">    <span class=\"comment\">// 定义一个新的二维数组，用于存储转置后的矩阵</span></span><br><span class=\"line\">    transposed := <span class=\"built_in\">make</span>([][]<span class=\"type\">int</span>, cols)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> transposed &#123;</span><br><span class=\"line\">        transposed[i] = <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, rows)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 遍历原矩阵，将其每个元素放置在转置矩阵中的相应位置</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; rows; i++ &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j := <span class=\"number\">0</span>; j &lt; cols; j++ &#123;</span><br><span class=\"line\">            transposed[j][i] = matrix[i][j]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> transposed</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"cover":"/img/cover/sky4.png","cover_type":"img","excerpt":"","more":"<h1 id=\"文档前言\"><a href=\"#文档前言\" class=\"headerlink\" title=\"文档前言\"></a>文档前言</h1><p>当我完成了许多的算法题目以及其扩展题目之后，总是在那几天对于解决这类性特征的问题有着较多的见解，而且发现同类型特征的问题往往有着相似的解法，尤其是在我回顾一些问题却发现他们异常陌生的时候，我察觉到自己不能通过简单的肌肉记忆来提高解决问题的能力，重复和已经解决思考的部分应当有浓缩和归类的操作</p>\n<p>本文档的主要内容将主要包含两个部分：</p>\n<ul>\n<li>基础简单算法的模式化归纳：忽略代码实现的细节和边界条件，将算法当中最主要的公式和代码片段摘出</li>\n<li>特征问题的通解归纳，将具有特征特点的问题归纳出一个通用的范式</li>\n</ul>\n<h1 id=\"二叉树\"><a href=\"#二叉树\" class=\"headerlink\" title=\"二叉树\"></a>二叉树</h1><h2 id=\"二叉树的遍历\"><a href=\"#二叉树的遍历\" class=\"headerlink\" title=\"二叉树的遍历\"></a>二叉树的遍历</h2><p>在树的<strong>深度优先</strong>遍历算法当中（包括前序、中序、后序），常常使用的是递归的方式，也就是：</p>\n<ul>\n<li><font color ='red'>前序遍历：中、左、右 </font></li>\n<li><font color ='red'>中序遍历：左、中、右 </font></li>\n<li><font color ='red'>后序遍历：左、右、中 </font></li>\n</ul>\n<h3 id=\"颜色标记法\"><a href=\"#颜色标记法\" class=\"headerlink\" title=\"颜色标记法\"></a>颜色标记法</h3><p>受到(henry)[<a href=\"https://leetcode.cn/problems/binary-tree-inorder-traversal/solution/yan-se-biao-ji-fa-yi-chong-tong-yong-qie-jian-ming/]\">https://leetcode.cn/problems/binary-tree-inorder-traversal/solution/yan-se-biao-ji-fa-yi-chong-tong-yong-qie-jian-ming/]</a> 解题方法的启发</p>\n<p>将树的遍历问题放到栈的逻辑下面，其实有几点问题：</p>\n<ul>\n<li>入栈的元素只有两种： 指向节点的指针和空指针，类似于：<code>[1,null,2,null,3,null,4,null,5,null,6]</code></li>\n<li>出栈的时候操作的必定是一个有指向地址的指针，那么出栈操作代表些什么</li>\n<li>怎样才能够区别出左子树和右子树呢？</li>\n</ul>\n<p>栈是先进后出的数据结构，与递归和函数调用类似，越是靠近栈底的元素他在树的结构上就越高。而栈的这个特性保证了树的结构，也就是说左/右子树必定是在右/左子树之前弹出，换句话说除了当前遍历的节点node，他的左右在遍历过程其实中代表的是一棵树，继续向栈里推入元素就是在不断地展开他的树节点，而这样的顺序必定是被中间的Node所标志的，如图中所示</p>\n<div style=\"display:flex;flex-direction:row;\"r>\n    <img src='./tree_stack1.jpg' width=\"400\" height=\"200\" style=\"margin-right:10px;\"/>\n    <img src='./tree_stack2.jpg' width=\"400\" height=\"200\" style=\"margin-left:10px;\"/>\n</div>\n\n<p><br>回到上述三个问题来理解就会容易一些</p>\n<ol>\n<li>因为栈存储的是树，而不是节点，所以一些叶节点没有左右子树，这部分依旧还是会以逻辑形式入栈 </li>\n<li>出栈入栈是对应的，所以理解上也应该要对应起来说，第一次入栈只要该节点不是root，那么他必定是以某个节点的左右节点身份入栈的，此时的入栈操作标识的是当前节点为root 的子树，所以第一次出栈是用来将其从树的身份转化为节点，通过将其标记为 1 [有颜色，标志为确实为一个节点]，然后再入栈表示为遍历，当把整棵树放入栈中后，出栈操作则对应节点，此时栈中所有标记为1的部分就是实际遍历的节点，而且按照入栈的顺序表示出中、后、前序.<br>那么按照这样的思路，我们来编写一下对二叉树的中序遍历：</li>\n</ol>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> TreeNode <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">    Right *TreeNode</span><br><span class=\"line\">    Left  *TreeNode</span><br><span class=\"line\">    Val  <span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">traversal</span><span class=\"params\">(root *TreeNode)</span></span> []<span class=\"keyword\">interface</span>&#123;&#125;&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 颜色点，用于标记出入栈</span></span><br><span class=\"line\">    <span class=\"keyword\">type</span> node <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">        Color <span class=\"type\">int</span></span><br><span class=\"line\">        Node *TreeNode</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    stack := <span class=\"built_in\">make</span>([]*node,<span class=\"number\">0</span>)</span><br><span class=\"line\">    stack = <span class=\"built_in\">append</span>(stack,node&#123;<span class=\"number\">0</span>，root&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 需要的结果函数</span></span><br><span class=\"line\">    <span class=\"comment\">//result := make([]interface,0)</span></span><br><span class=\"line\">    res := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"built_in\">len</span>(stack) &gt; <span class=\"number\">0</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 每次都取出栈顶元素进行判定</span></span><br><span class=\"line\">        n := stack[<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>]</span><br><span class=\"line\">        stack = stack[:<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> n.Node == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> n.Color == <span class=\"number\">0</span>&#123;</span><br><span class=\"line\">            stack = <span class=\"built_in\">append</span>(stack,node&#123;<span class=\"number\">0</span>,n.Node.Right&#125;)</span><br><span class=\"line\">            stack = <span class=\"built_in\">append</span>(stack,node&#123;<span class=\"number\">1</span>,n.Node&#125;)</span><br><span class=\"line\">            stack = <span class=\"built_in\">append</span>(stack,node&#123;<span class=\"number\">0</span>,n.Node.Left&#125;)</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            res = <span class=\"built_in\">append</span>(res, n.Node.Val)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>在这段代码当中，由于标记方式的存在和入栈方式是两次入栈，所以几乎可以是模板样式来解决问题，而且好记忆</p>\n<p>在代码当中可以修改的地方只有两处：</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> n.Color == <span class=\"number\">0</span>&#123;</span><br><span class=\"line\">    【第一处】</span><br><span class=\"line\">    可以修改为不同的深度遍历顺序</span><br><span class=\"line\">    【前序遍历】：</span><br><span class=\"line\">    ···</span><br><span class=\"line\">        stack = <span class=\"built_in\">append</span>(stack,node&#123;<span class=\"number\">0</span>,n.Node.Right&#125;)</span><br><span class=\"line\">        stack = <span class=\"built_in\">append</span>(stack,node&#123;<span class=\"number\">0</span>,n.Node.Left&#125;) </span><br><span class=\"line\">        stack = <span class=\"built_in\">append</span>(stack,node&#123;<span class=\"number\">1</span>,n.Node&#125;)   </span><br><span class=\"line\">    ···</span><br><span class=\"line\">    【中序遍历】</span><br><span class=\"line\">    ···</span><br><span class=\"line\">        stack = <span class=\"built_in\">append</span>(stack,node&#123;<span class=\"number\">0</span>,n.Node.Right&#125;)</span><br><span class=\"line\">        stack = <span class=\"built_in\">append</span>(stack,node&#123;<span class=\"number\">1</span>,n.Node&#125;)  </span><br><span class=\"line\">        stack = <span class=\"built_in\">append</span>(stack,node&#123;<span class=\"number\">0</span>,n.Node.Left&#125;) </span><br><span class=\"line\">    ···</span><br><span class=\"line\">    【后序遍历】</span><br><span class=\"line\">    ···</span><br><span class=\"line\">        stack = <span class=\"built_in\">append</span>(stack,node&#123;<span class=\"number\">1</span>,n.Node&#125;)  </span><br><span class=\"line\">        stack = <span class=\"built_in\">append</span>(stack,node&#123;<span class=\"number\">0</span>,n.Node.Right&#125;)</span><br><span class=\"line\">        stack = <span class=\"built_in\">append</span>(stack,node&#123;<span class=\"number\">0</span>,n.Node.Left&#125;) </span><br><span class=\"line\">    ···</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    【第二处】</span><br><span class=\"line\">    添加对当前node值的修改函数</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"递归方法\"><a href=\"#递归方法\" class=\"headerlink\" title=\"递归方法\"></a>递归方法</h3><p>使用递归最关键还是两条：</p>\n<ul>\n<li>递归结束的条件</li>\n<li>递归函数的结构</li>\n</ul>\n<p>普通的前序遍历数组的代码：</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"常见运算标识\"><a href=\"#常见运算标识\" class=\"headerlink\" title=\"常见运算标识\"></a>常见运算标识</h1><h2 id=\"最大最小值\"><a href=\"#最大最小值\" class=\"headerlink\" title=\"最大最小值\"></a>最大最小值</h2><p>以下这两个都是可以接受多个变量参数的求最大最小值</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">max</span><span class=\"params\">(args ...<span class=\"type\">int</span>)</span></span><span class=\"type\">int</span>&#123;</span><br><span class=\"line\">    m := args[<span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _,val := <span class=\"keyword\">range</span> args&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> val &gt; m&#123;</span><br><span class=\"line\">            m = val</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">min</span><span class=\"params\">(args ...<span class=\"type\">int</span>)</span></span><span class=\"type\">int</span>&#123;</span><br><span class=\"line\">    m := args[<span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _,val := <span class=\"keyword\">range</span> args&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> val &lt; m&#123;</span><br><span class=\"line\">            m = val</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"异或，同或\"><a href=\"#异或，同或\" class=\"headerlink\" title=\"异或，同或\"></a>异或，同或</h2><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">xor</span><span class=\"params\">(a, b <span class=\"type\">bool</span>)</span></span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (a || b) &amp;&amp; !(a &amp;&amp; b)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">xnor</span><span class=\"params\">(a, b <span class=\"type\">bool</span>)</span></span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (a &amp;&amp; b) || (!a &amp;&amp; !b)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"位运算\"><a href=\"#位运算\" class=\"headerlink\" title=\"位运算\"></a>位运算</h2><h3 id=\"两数相加\"><a href=\"#两数相加\" class=\"headerlink\" title=\"两数相加\"></a>两数相加</h3><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">getSum</span><span class=\"params\">(a <span class=\"type\">int</span>, b <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 异或+与运算:时间复杂度O(logSum) | 空间复杂度O(1)</span></span><br><span class=\"line\">    a, b = a ^ b, (a &amp; b) &lt;&lt; <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> b != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        a, b = a ^ b, (a &amp; b) &lt;&lt; <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"两数相除\"><a href=\"#两数相除\" class=\"headerlink\" title=\"两数相除\"></a>两数相除</h3><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">divide</span><span class=\"params\">(dividend <span class=\"type\">int</span>, divisor <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> dividend==<span class=\"number\">0</span> &#123;<span class=\"keyword\">return</span> <span class=\"number\">0</span>&#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> dividend==math.MinInt32 &amp;&amp; divisor==<span class=\"number\">-1</span> &#123;<span class=\"keyword\">return</span> math.MaxInt32&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    diffSign:=<span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dividend&lt;<span class=\"number\">0</span>)!=(divisor&lt;<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        diffSign=<span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    i,j,sum := <span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">        tmp:=<span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> diffSign &#123;</span><br><span class=\"line\">            tmp=sum-divisor&lt;&lt;j</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            tmp=sum+divisor&lt;&lt;j</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dividend&gt;<span class=\"number\">0</span> &amp;&amp; tmp&gt;dividend) || (dividend&lt;<span class=\"number\">0</span> &amp;&amp; tmp&lt;dividend) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> j==<span class=\"number\">0</span> &#123;<span class=\"keyword\">break</span>&#125;</span><br><span class=\"line\">            j-- <span class=\"comment\">//步长减半</span></span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sum=tmp</span><br><span class=\"line\">        i+=<span class=\"number\">1</span>&lt;&lt;j</span><br><span class=\"line\">        j++ <span class=\"comment\">//步长加倍</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> diffSign &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -i</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> i</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"二维矩阵转置\"><a href=\"#二维矩阵转置\" class=\"headerlink\" title=\"二维矩阵转置\"></a>二维矩阵转置</h2><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">transposeMatrix</span><span class=\"params\">(matrix [][]<span class=\"type\">int</span>)</span></span> [][]<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取矩阵的行数和列数</span></span><br><span class=\"line\">    rows, cols := <span class=\"built_in\">len</span>(matrix), <span class=\"built_in\">len</span>(matrix[<span class=\"number\">0</span>])</span><br><span class=\"line\">    <span class=\"comment\">// 定义一个新的二维数组，用于存储转置后的矩阵</span></span><br><span class=\"line\">    transposed := <span class=\"built_in\">make</span>([][]<span class=\"type\">int</span>, cols)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> transposed &#123;</span><br><span class=\"line\">        transposed[i] = <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, rows)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 遍历原矩阵，将其每个元素放置在转置矩阵中的相应位置</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; rows; i++ &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j := <span class=\"number\">0</span>; j &lt; cols; j++ &#123;</span><br><span class=\"line\">            transposed[j][i] = matrix[i][j]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> transposed</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"算法简要汇总","catalog":true,"date":"2023-03-27T20:52:12.000Z","subtitle":"南开大学 苏明老师课程讲解","header-img":null,"published":0,"_content":"\n# 算法\n> the art of data\n\n# [第一节课] 课程背景\n> The theoretical study of computer-program performance and resource usage\n## 为什么研究算法\n\n1. 对性能的研究 --> 告知哪些是可以做到的，哪些是不可能实现的\n\n2. 对算法性能的抽象可以推广到其他计算资源上\n\n3. 程序[逻辑推演]通用一套逻辑\n\n\n## 算法关注的焦点\n\n1. 忽略在哪里实现： 与平台无关\n\n2. 忽略实例的不同：与实例无关\n\n3. 注意问题的增长规模\n\n以排序算法为例：\n算法最为关心其中元素的比较、移动次数\n* 最坏情况: 插入排序当中，如果序列是倒序，解决需要的时间与问题规模呈现 n^2 级别增长 \n* 平均情况: 插入排序当中，最快是序列就是顺序的，平均情况是和最坏情况取平均值\n\n如果要对这个排序算法做优化的话，可以怎么想呢？\n以一个合并排序作为例子来讲解：\n\n通过将问题分解之后，使得合并排序比起插入排序有更快的速度，但却消耗了更多的空间。\n\n学习算法的目标：\n* 灵活运用合适数据结构来解决实际问题\n* 碰到具体的问题，能够分析问题的关键点并进行规划，编写代码输出正确结果\n* 清晰的算法复杂度概念，采用正确的算法是的编写的代码运行更有效率\n* 全面提高编写代码的逻辑\n\n## [第二节课] 引言： 某些特定的问题\n\n### 第一个问题： 稳定匹配\n> College Admission and the Stability of Marriage\n\n#### 双向选择\n> 比如交朋友，南开大学 X 和天津大学 Y 学生相互之间选择，存在一个需求是： X 对于 Y 可能满足或者不满足，Y 对于 X 可能满足或者不满足\n> 关键在于找到一个 **稳定** 的方案尽可能不与 X/Y 的特性和意愿产生矛盾\n\n\n**<font color ='red'> 问题的形式化: 提出本质的、相对简单的问题模型： n 个 X 类型对象中的每一个对 m 个 Y 类型对象提出申请，而每个 Y 类型对象只要单一个 X 对象</font>**\n\n那么**稳定的对象** 就是一个匹配 （X,Y），每一个 X,Y 应该只出现在其中一个组合当中，完美的匹配就是满足所有的 X， Y 对象的需求。\n\n--> 对每组优先表是否存在一个稳定的匹配呢\n--> 给定一组优先表，如果存在稳定匹配，能够有效构造出来吗\n--> 如果存在稳定匹配会有很多吗？\n\n那么是否对于每一类优先列表都存在一个通用的选择方法嘛？\n\n邀请拒绝算法--> 找到 **稳定匹配符合直觉** 的算法\n\n**评价算法的正确性**\n\n* 正确性： 是否满足题目要求\n* 有穷性： 有while循环，是否能够正确退出\n* 输出  ： 输出结构是否符合题目要求\n\n那么如何才能够在代码上实现这个算法呢？\n要点：\n* 要用两个数组记录约会的对象\n\n\n> 小技巧：在多层循环当中，尽量降低内层循环的计算复杂度","source":"_posts/Algorithm/script/算法课程-南开苏明老师/算法简要汇总.md","raw":"---\ntitle: 算法简要汇总\ncatalog: true\ndate: 2023-03-28 04:52:12\nsubtitle: 南开大学 苏明老师课程讲解\nheader-img:\ntags: 算法， 南开大学，Golang, working\ncategories: 算法[Algrithm]\npublished: false\n---\n\n# 算法\n> the art of data\n\n# [第一节课] 课程背景\n> The theoretical study of computer-program performance and resource usage\n## 为什么研究算法\n\n1. 对性能的研究 --> 告知哪些是可以做到的，哪些是不可能实现的\n\n2. 对算法性能的抽象可以推广到其他计算资源上\n\n3. 程序[逻辑推演]通用一套逻辑\n\n\n## 算法关注的焦点\n\n1. 忽略在哪里实现： 与平台无关\n\n2. 忽略实例的不同：与实例无关\n\n3. 注意问题的增长规模\n\n以排序算法为例：\n算法最为关心其中元素的比较、移动次数\n* 最坏情况: 插入排序当中，如果序列是倒序，解决需要的时间与问题规模呈现 n^2 级别增长 \n* 平均情况: 插入排序当中，最快是序列就是顺序的，平均情况是和最坏情况取平均值\n\n如果要对这个排序算法做优化的话，可以怎么想呢？\n以一个合并排序作为例子来讲解：\n\n通过将问题分解之后，使得合并排序比起插入排序有更快的速度，但却消耗了更多的空间。\n\n学习算法的目标：\n* 灵活运用合适数据结构来解决实际问题\n* 碰到具体的问题，能够分析问题的关键点并进行规划，编写代码输出正确结果\n* 清晰的算法复杂度概念，采用正确的算法是的编写的代码运行更有效率\n* 全面提高编写代码的逻辑\n\n## [第二节课] 引言： 某些特定的问题\n\n### 第一个问题： 稳定匹配\n> College Admission and the Stability of Marriage\n\n#### 双向选择\n> 比如交朋友，南开大学 X 和天津大学 Y 学生相互之间选择，存在一个需求是： X 对于 Y 可能满足或者不满足，Y 对于 X 可能满足或者不满足\n> 关键在于找到一个 **稳定** 的方案尽可能不与 X/Y 的特性和意愿产生矛盾\n\n\n**<font color ='red'> 问题的形式化: 提出本质的、相对简单的问题模型： n 个 X 类型对象中的每一个对 m 个 Y 类型对象提出申请，而每个 Y 类型对象只要单一个 X 对象</font>**\n\n那么**稳定的对象** 就是一个匹配 （X,Y），每一个 X,Y 应该只出现在其中一个组合当中，完美的匹配就是满足所有的 X， Y 对象的需求。\n\n--> 对每组优先表是否存在一个稳定的匹配呢\n--> 给定一组优先表，如果存在稳定匹配，能够有效构造出来吗\n--> 如果存在稳定匹配会有很多吗？\n\n那么是否对于每一类优先列表都存在一个通用的选择方法嘛？\n\n邀请拒绝算法--> 找到 **稳定匹配符合直觉** 的算法\n\n**评价算法的正确性**\n\n* 正确性： 是否满足题目要求\n* 有穷性： 有while循环，是否能够正确退出\n* 输出  ： 输出结构是否符合题目要求\n\n那么如何才能够在代码上实现这个算法呢？\n要点：\n* 要用两个数组记录约会的对象\n\n\n> 小技巧：在多层循环当中，尽量降低内层循环的计算复杂度","slug":"Algorithm/script/算法课程-南开苏明老师/算法简要汇总","updated":"2023-05-03T01:57:54.330Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli796r18002kbyjx7ywncfo6","content":"<h1 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h1><blockquote>\n<p>the art of data</p>\n</blockquote>\n<h1 id=\"第一节课-课程背景\"><a href=\"#第一节课-课程背景\" class=\"headerlink\" title=\"[第一节课] 课程背景\"></a>[第一节课] 课程背景</h1><blockquote>\n<p>The theoretical study of computer-program performance and resource usage</p>\n</blockquote>\n<h2 id=\"为什么研究算法\"><a href=\"#为什么研究算法\" class=\"headerlink\" title=\"为什么研究算法\"></a>为什么研究算法</h2><ol>\n<li><p>对性能的研究 –&gt; 告知哪些是可以做到的，哪些是不可能实现的</p>\n</li>\n<li><p>对算法性能的抽象可以推广到其他计算资源上</p>\n</li>\n<li><p>程序[逻辑推演]通用一套逻辑</p>\n</li>\n</ol>\n<h2 id=\"算法关注的焦点\"><a href=\"#算法关注的焦点\" class=\"headerlink\" title=\"算法关注的焦点\"></a>算法关注的焦点</h2><ol>\n<li><p>忽略在哪里实现： 与平台无关</p>\n</li>\n<li><p>忽略实例的不同：与实例无关</p>\n</li>\n<li><p>注意问题的增长规模</p>\n</li>\n</ol>\n<p>以排序算法为例：<br>算法最为关心其中元素的比较、移动次数</p>\n<ul>\n<li>最坏情况: 插入排序当中，如果序列是倒序，解决需要的时间与问题规模呈现 n^2 级别增长 </li>\n<li>平均情况: 插入排序当中，最快是序列就是顺序的，平均情况是和最坏情况取平均值</li>\n</ul>\n<p>如果要对这个排序算法做优化的话，可以怎么想呢？<br>以一个合并排序作为例子来讲解：</p>\n<p>通过将问题分解之后，使得合并排序比起插入排序有更快的速度，但却消耗了更多的空间。</p>\n<p>学习算法的目标：</p>\n<ul>\n<li>灵活运用合适数据结构来解决实际问题</li>\n<li>碰到具体的问题，能够分析问题的关键点并进行规划，编写代码输出正确结果</li>\n<li>清晰的算法复杂度概念，采用正确的算法是的编写的代码运行更有效率</li>\n<li>全面提高编写代码的逻辑</li>\n</ul>\n<h2 id=\"第二节课-引言：-某些特定的问题\"><a href=\"#第二节课-引言：-某些特定的问题\" class=\"headerlink\" title=\"[第二节课] 引言： 某些特定的问题\"></a>[第二节课] 引言： 某些特定的问题</h2><h3 id=\"第一个问题：-稳定匹配\"><a href=\"#第一个问题：-稳定匹配\" class=\"headerlink\" title=\"第一个问题： 稳定匹配\"></a>第一个问题： 稳定匹配</h3><blockquote>\n<p>College Admission and the Stability of Marriage</p>\n</blockquote>\n<h4 id=\"双向选择\"><a href=\"#双向选择\" class=\"headerlink\" title=\"双向选择\"></a>双向选择</h4><blockquote>\n<p>比如交朋友，南开大学 X 和天津大学 Y 学生相互之间选择，存在一个需求是： X 对于 Y 可能满足或者不满足，Y 对于 X 可能满足或者不满足<br>关键在于找到一个 <strong>稳定</strong> 的方案尽可能不与 X/Y 的特性和意愿产生矛盾</p>\n</blockquote>\n<p><strong><font color ='red'> 问题的形式化: 提出本质的、相对简单的问题模型： n 个 X 类型对象中的每一个对 m 个 Y 类型对象提出申请，而每个 Y 类型对象只要单一个 X 对象</font></strong></p>\n<p>那么<strong>稳定的对象</strong> 就是一个匹配 （X,Y），每一个 X,Y 应该只出现在其中一个组合当中，完美的匹配就是满足所有的 X， Y 对象的需求。</p>\n<p>–&gt; 对每组优先表是否存在一个稳定的匹配呢<br>–&gt; 给定一组优先表，如果存在稳定匹配，能够有效构造出来吗<br>–&gt; 如果存在稳定匹配会有很多吗？</p>\n<p>那么是否对于每一类优先列表都存在一个通用的选择方法嘛？</p>\n<p>邀请拒绝算法–&gt; 找到 <strong>稳定匹配符合直觉</strong> 的算法</p>\n<p><strong>评价算法的正确性</strong></p>\n<ul>\n<li>正确性： 是否满足题目要求</li>\n<li>有穷性： 有while循环，是否能够正确退出</li>\n<li>输出  ： 输出结构是否符合题目要求</li>\n</ul>\n<p>那么如何才能够在代码上实现这个算法呢？<br>要点：</p>\n<ul>\n<li>要用两个数组记录约会的对象</li>\n</ul>\n<blockquote>\n<p>小技巧：在多层循环当中，尽量降低内层循环的计算复杂度</p>\n</blockquote>\n","site":{"data":{}},"cover":"/img/cover/sky.png","cover_type":"img","excerpt":"","more":"<h1 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h1><blockquote>\n<p>the art of data</p>\n</blockquote>\n<h1 id=\"第一节课-课程背景\"><a href=\"#第一节课-课程背景\" class=\"headerlink\" title=\"[第一节课] 课程背景\"></a>[第一节课] 课程背景</h1><blockquote>\n<p>The theoretical study of computer-program performance and resource usage</p>\n</blockquote>\n<h2 id=\"为什么研究算法\"><a href=\"#为什么研究算法\" class=\"headerlink\" title=\"为什么研究算法\"></a>为什么研究算法</h2><ol>\n<li><p>对性能的研究 –&gt; 告知哪些是可以做到的，哪些是不可能实现的</p>\n</li>\n<li><p>对算法性能的抽象可以推广到其他计算资源上</p>\n</li>\n<li><p>程序[逻辑推演]通用一套逻辑</p>\n</li>\n</ol>\n<h2 id=\"算法关注的焦点\"><a href=\"#算法关注的焦点\" class=\"headerlink\" title=\"算法关注的焦点\"></a>算法关注的焦点</h2><ol>\n<li><p>忽略在哪里实现： 与平台无关</p>\n</li>\n<li><p>忽略实例的不同：与实例无关</p>\n</li>\n<li><p>注意问题的增长规模</p>\n</li>\n</ol>\n<p>以排序算法为例：<br>算法最为关心其中元素的比较、移动次数</p>\n<ul>\n<li>最坏情况: 插入排序当中，如果序列是倒序，解决需要的时间与问题规模呈现 n^2 级别增长 </li>\n<li>平均情况: 插入排序当中，最快是序列就是顺序的，平均情况是和最坏情况取平均值</li>\n</ul>\n<p>如果要对这个排序算法做优化的话，可以怎么想呢？<br>以一个合并排序作为例子来讲解：</p>\n<p>通过将问题分解之后，使得合并排序比起插入排序有更快的速度，但却消耗了更多的空间。</p>\n<p>学习算法的目标：</p>\n<ul>\n<li>灵活运用合适数据结构来解决实际问题</li>\n<li>碰到具体的问题，能够分析问题的关键点并进行规划，编写代码输出正确结果</li>\n<li>清晰的算法复杂度概念，采用正确的算法是的编写的代码运行更有效率</li>\n<li>全面提高编写代码的逻辑</li>\n</ul>\n<h2 id=\"第二节课-引言：-某些特定的问题\"><a href=\"#第二节课-引言：-某些特定的问题\" class=\"headerlink\" title=\"[第二节课] 引言： 某些特定的问题\"></a>[第二节课] 引言： 某些特定的问题</h2><h3 id=\"第一个问题：-稳定匹配\"><a href=\"#第一个问题：-稳定匹配\" class=\"headerlink\" title=\"第一个问题： 稳定匹配\"></a>第一个问题： 稳定匹配</h3><blockquote>\n<p>College Admission and the Stability of Marriage</p>\n</blockquote>\n<h4 id=\"双向选择\"><a href=\"#双向选择\" class=\"headerlink\" title=\"双向选择\"></a>双向选择</h4><blockquote>\n<p>比如交朋友，南开大学 X 和天津大学 Y 学生相互之间选择，存在一个需求是： X 对于 Y 可能满足或者不满足，Y 对于 X 可能满足或者不满足<br>关键在于找到一个 <strong>稳定</strong> 的方案尽可能不与 X/Y 的特性和意愿产生矛盾</p>\n</blockquote>\n<p><strong><font color ='red'> 问题的形式化: 提出本质的、相对简单的问题模型： n 个 X 类型对象中的每一个对 m 个 Y 类型对象提出申请，而每个 Y 类型对象只要单一个 X 对象</font></strong></p>\n<p>那么<strong>稳定的对象</strong> 就是一个匹配 （X,Y），每一个 X,Y 应该只出现在其中一个组合当中，完美的匹配就是满足所有的 X， Y 对象的需求。</p>\n<p>–&gt; 对每组优先表是否存在一个稳定的匹配呢<br>–&gt; 给定一组优先表，如果存在稳定匹配，能够有效构造出来吗<br>–&gt; 如果存在稳定匹配会有很多吗？</p>\n<p>那么是否对于每一类优先列表都存在一个通用的选择方法嘛？</p>\n<p>邀请拒绝算法–&gt; 找到 <strong>稳定匹配符合直觉</strong> 的算法</p>\n<p><strong>评价算法的正确性</strong></p>\n<ul>\n<li>正确性： 是否满足题目要求</li>\n<li>有穷性： 有while循环，是否能够正确退出</li>\n<li>输出  ： 输出结构是否符合题目要求</li>\n</ul>\n<p>那么如何才能够在代码上实现这个算法呢？<br>要点：</p>\n<ul>\n<li>要用两个数组记录约会的对象</li>\n</ul>\n<blockquote>\n<p>小技巧：在多层循环当中，尽量降低内层循环的计算复杂度</p>\n</blockquote>\n"},{"title":"Golang moudle","catalog":true,"date":"2023-04-09T17:47:36.000Z","subtitle":null,"header-img":null,"published":0,"_content":"\n\n# \n\n## strconv\n[strconv](/source/_posts/cn/Go/Golang-moudle/strconv.md)","source":"_posts/Go/script/Golang-moudle/Golang-moudle.md","raw":"---\ntitle: Golang moudle\ncatalog: true\ndate: 2023-04-10 01:47:36\nsubtitle:\nheader-img:\ntags:\ncategories: index\npublished: false\n---\n\n\n# \n\n## strconv\n[strconv](/source/_posts/cn/Go/Golang-moudle/strconv.md)","slug":"Go/script/Golang-moudle/Golang-moudle","updated":"2023-04-22T13:24:02.216Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli796r19002nbyjx2vqt5i1h","content":"<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h1><h2 id=\"strconv\"><a href=\"#strconv\" class=\"headerlink\" title=\"strconv\"></a>strconv</h2><p><a href=\"/source/_posts/cn/Go/Golang-moudle/strconv.md\">strconv</a></p>\n","site":{"data":{}},"cover":"/img/cover/sky2.png","cover_type":"img","excerpt":"","more":"<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h1><h2 id=\"strconv\"><a href=\"#strconv\" class=\"headerlink\" title=\"strconv\"></a>strconv</h2><p><a href=\"/source/_posts/cn/Go/Golang-moudle/strconv.md\">strconv</a></p>\n"},{"title":"strconv","catalog":true,"date":"2023-04-09T17:47:36.000Z","subtitle":null,"header-img":null,"published":0,"_content":"\n# Strconv 常用方法汇总\n> 主要参考官方文章：[strconv](https://pkg.go.dev/strconv#pkg-index)\n> \n## 类型转换\n\n``` golang\n// 字符串到整数的转换\n    fmt.Println(strconv.Atoi(\"123\")) // 123\n        // 整数到字符串的转换\n    fmt.Println(strconv.Itoa(12345)) // \"12345\"\n\n    // 字符串转其他进制的整数\n    fmt.Println(strconv.ParseInt(\"1100100\", 2, 0))  // 100\n    fmt.Println(strconv.ParseInt(\"7D0\", 16, 0))    // 2000\n    fmt.Println(strconv.ParseInt(\"2147483648\", 10, 64))   // 2147483648\n    fmt.Println(strconv.ParseUint(\"FFFFFFFFFFFFFFFF\", 16, 64)) // 18446744073709551615\n\n    // 其他进制的整数转字符串\n    fmt.Println(strconv.FormatInt(100, 2)) // \"1100100\"\n    fmt.Println(strconv.FormatInt(2000, 16)) // \"7d0\"\n    fmt.Println(strconv.FormatUint(2147483648, 10)) // \"2147483648\"\n\n    // 字符串到浮点数的转换\n    fmt.Println(strconv.ParseFloat(\"3.1415\", 64)) // 3.1415\n\n    // 浮点数到字符串的转换\n    fmt.Println(strconv.FormatFloat(3.1415, 'E', -1, 64)) // 3.141500E+00\n\n    // 输出类型为 bool 的数值字符串\n    fmt.Println(strconv.ParseBool(\"true\"))  // true\n    fmt.Println(strconv.ParseBool(\"False\")) // false\n\n    // 布尔型到字符串的转换\n    fmt.Println(strconv.FormatBool(true)) // \"true\"\n    fmt.Println(strconv.FormatBool(false)) // \"false\"\n```\n\n## 进制转化\n\n``` golang\n    // 十进制转二进制\n    fmt.Printf(\"%b\", 17) // 10001\n\n    // 十进制转十六进制\n    fmt.Printf(\"%x\", 17) // 11\n\n    // 十六进制转十进制\n    i, _ := strconv.ParseInt(\"11\", 16, 0)\n    fmt.Println(i) // 17\n\n    // 十六进制转二进制\n    i, _ = strconv.ParseInt(\"11\", 16, 0)\n    fmt.Printf(\"%b\", i) // 10001\n\n    // 二进制转十进制\n    i, _ = strconv.ParseInt(\"10001\", 2, 0)\n    fmt.Println(i) // 17\n\n    // 二进制转十六进制\n    i, _ = strconv.ParseInt(\"10001\", 2, 0)\n    fmt.Printf(\"%x\", i) // 11\n```","source":"_posts/Go/script/Golang-moudle/strconv.md","raw":"---\ntitle: strconv\ncatalog: true\ndate: 2023-04-10 01:47:36\nsubtitle:\nheader-img:\ntags:\ncategories: index\npublished: false\n---\n\n# Strconv 常用方法汇总\n> 主要参考官方文章：[strconv](https://pkg.go.dev/strconv#pkg-index)\n> \n## 类型转换\n\n``` golang\n// 字符串到整数的转换\n    fmt.Println(strconv.Atoi(\"123\")) // 123\n        // 整数到字符串的转换\n    fmt.Println(strconv.Itoa(12345)) // \"12345\"\n\n    // 字符串转其他进制的整数\n    fmt.Println(strconv.ParseInt(\"1100100\", 2, 0))  // 100\n    fmt.Println(strconv.ParseInt(\"7D0\", 16, 0))    // 2000\n    fmt.Println(strconv.ParseInt(\"2147483648\", 10, 64))   // 2147483648\n    fmt.Println(strconv.ParseUint(\"FFFFFFFFFFFFFFFF\", 16, 64)) // 18446744073709551615\n\n    // 其他进制的整数转字符串\n    fmt.Println(strconv.FormatInt(100, 2)) // \"1100100\"\n    fmt.Println(strconv.FormatInt(2000, 16)) // \"7d0\"\n    fmt.Println(strconv.FormatUint(2147483648, 10)) // \"2147483648\"\n\n    // 字符串到浮点数的转换\n    fmt.Println(strconv.ParseFloat(\"3.1415\", 64)) // 3.1415\n\n    // 浮点数到字符串的转换\n    fmt.Println(strconv.FormatFloat(3.1415, 'E', -1, 64)) // 3.141500E+00\n\n    // 输出类型为 bool 的数值字符串\n    fmt.Println(strconv.ParseBool(\"true\"))  // true\n    fmt.Println(strconv.ParseBool(\"False\")) // false\n\n    // 布尔型到字符串的转换\n    fmt.Println(strconv.FormatBool(true)) // \"true\"\n    fmt.Println(strconv.FormatBool(false)) // \"false\"\n```\n\n## 进制转化\n\n``` golang\n    // 十进制转二进制\n    fmt.Printf(\"%b\", 17) // 10001\n\n    // 十进制转十六进制\n    fmt.Printf(\"%x\", 17) // 11\n\n    // 十六进制转十进制\n    i, _ := strconv.ParseInt(\"11\", 16, 0)\n    fmt.Println(i) // 17\n\n    // 十六进制转二进制\n    i, _ = strconv.ParseInt(\"11\", 16, 0)\n    fmt.Printf(\"%b\", i) // 10001\n\n    // 二进制转十进制\n    i, _ = strconv.ParseInt(\"10001\", 2, 0)\n    fmt.Println(i) // 17\n\n    // 二进制转十六进制\n    i, _ = strconv.ParseInt(\"10001\", 2, 0)\n    fmt.Printf(\"%x\", i) // 11\n```","slug":"Go/script/Golang-moudle/strconv","updated":"2023-04-22T13:24:02.216Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli796r1a002rbyjx184p0f41","content":"<h1 id=\"Strconv-常用方法汇总\"><a href=\"#Strconv-常用方法汇总\" class=\"headerlink\" title=\"Strconv 常用方法汇总\"></a>Strconv 常用方法汇总</h1><blockquote>\n<p>主要参考官方文章：<a href=\"https://pkg.go.dev/strconv#pkg-index\">strconv</a></p>\n</blockquote>\n<h2 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h2><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 字符串到整数的转换</span></span><br><span class=\"line\">    fmt.Println(strconv.Atoi(<span class=\"string\">&quot;123&quot;</span>)) <span class=\"comment\">// 123</span></span><br><span class=\"line\">        <span class=\"comment\">// 整数到字符串的转换</span></span><br><span class=\"line\">    fmt.Println(strconv.Itoa(<span class=\"number\">12345</span>)) <span class=\"comment\">// &quot;12345&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 字符串转其他进制的整数</span></span><br><span class=\"line\">    fmt.Println(strconv.ParseInt(<span class=\"string\">&quot;1100100&quot;</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>))  <span class=\"comment\">// 100</span></span><br><span class=\"line\">    fmt.Println(strconv.ParseInt(<span class=\"string\">&quot;7D0&quot;</span>, <span class=\"number\">16</span>, <span class=\"number\">0</span>))    <span class=\"comment\">// 2000</span></span><br><span class=\"line\">    fmt.Println(strconv.ParseInt(<span class=\"string\">&quot;2147483648&quot;</span>, <span class=\"number\">10</span>, <span class=\"number\">64</span>))   <span class=\"comment\">// 2147483648</span></span><br><span class=\"line\">    fmt.Println(strconv.ParseUint(<span class=\"string\">&quot;FFFFFFFFFFFFFFFF&quot;</span>, <span class=\"number\">16</span>, <span class=\"number\">64</span>)) <span class=\"comment\">// 18446744073709551615</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 其他进制的整数转字符串</span></span><br><span class=\"line\">    fmt.Println(strconv.FormatInt(<span class=\"number\">100</span>, <span class=\"number\">2</span>)) <span class=\"comment\">// &quot;1100100&quot;</span></span><br><span class=\"line\">    fmt.Println(strconv.FormatInt(<span class=\"number\">2000</span>, <span class=\"number\">16</span>)) <span class=\"comment\">// &quot;7d0&quot;</span></span><br><span class=\"line\">    fmt.Println(strconv.FormatUint(<span class=\"number\">2147483648</span>, <span class=\"number\">10</span>)) <span class=\"comment\">// &quot;2147483648&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 字符串到浮点数的转换</span></span><br><span class=\"line\">    fmt.Println(strconv.ParseFloat(<span class=\"string\">&quot;3.1415&quot;</span>, <span class=\"number\">64</span>)) <span class=\"comment\">// 3.1415</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 浮点数到字符串的转换</span></span><br><span class=\"line\">    fmt.Println(strconv.FormatFloat(<span class=\"number\">3.1415</span>, <span class=\"string\">&#x27;E&#x27;</span>, <span class=\"number\">-1</span>, <span class=\"number\">64</span>)) <span class=\"comment\">// 3.141500E+00</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 输出类型为 bool 的数值字符串</span></span><br><span class=\"line\">    fmt.Println(strconv.ParseBool(<span class=\"string\">&quot;true&quot;</span>))  <span class=\"comment\">// true</span></span><br><span class=\"line\">    fmt.Println(strconv.ParseBool(<span class=\"string\">&quot;False&quot;</span>)) <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 布尔型到字符串的转换</span></span><br><span class=\"line\">    fmt.Println(strconv.FormatBool(<span class=\"literal\">true</span>)) <span class=\"comment\">// &quot;true&quot;</span></span><br><span class=\"line\">    fmt.Println(strconv.FormatBool(<span class=\"literal\">false</span>)) <span class=\"comment\">// &quot;false&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"进制转化\"><a href=\"#进制转化\" class=\"headerlink\" title=\"进制转化\"></a>进制转化</h2><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 十进制转二进制</span></span><br><span class=\"line\">fmt.Printf(<span class=\"string\">&quot;%b&quot;</span>, <span class=\"number\">17</span>) <span class=\"comment\">// 10001</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 十进制转十六进制</span></span><br><span class=\"line\">fmt.Printf(<span class=\"string\">&quot;%x&quot;</span>, <span class=\"number\">17</span>) <span class=\"comment\">// 11</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 十六进制转十进制</span></span><br><span class=\"line\">i, _ := strconv.ParseInt(<span class=\"string\">&quot;11&quot;</span>, <span class=\"number\">16</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">fmt.Println(i) <span class=\"comment\">// 17</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 十六进制转二进制</span></span><br><span class=\"line\">i, _ = strconv.ParseInt(<span class=\"string\">&quot;11&quot;</span>, <span class=\"number\">16</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">&quot;%b&quot;</span>, i) <span class=\"comment\">// 10001</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 二进制转十进制</span></span><br><span class=\"line\">i, _ = strconv.ParseInt(<span class=\"string\">&quot;10001&quot;</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">fmt.Println(i) <span class=\"comment\">// 17</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 二进制转十六进制</span></span><br><span class=\"line\">i, _ = strconv.ParseInt(<span class=\"string\">&quot;10001&quot;</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">&quot;%x&quot;</span>, i) <span class=\"comment\">// 11</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"cover":"/img/cover/2077_city.png","cover_type":"img","excerpt":"","more":"<h1 id=\"Strconv-常用方法汇总\"><a href=\"#Strconv-常用方法汇总\" class=\"headerlink\" title=\"Strconv 常用方法汇总\"></a>Strconv 常用方法汇总</h1><blockquote>\n<p>主要参考官方文章：<a href=\"https://pkg.go.dev/strconv#pkg-index\">strconv</a></p>\n</blockquote>\n<h2 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h2><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 字符串到整数的转换</span></span><br><span class=\"line\">    fmt.Println(strconv.Atoi(<span class=\"string\">&quot;123&quot;</span>)) <span class=\"comment\">// 123</span></span><br><span class=\"line\">        <span class=\"comment\">// 整数到字符串的转换</span></span><br><span class=\"line\">    fmt.Println(strconv.Itoa(<span class=\"number\">12345</span>)) <span class=\"comment\">// &quot;12345&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 字符串转其他进制的整数</span></span><br><span class=\"line\">    fmt.Println(strconv.ParseInt(<span class=\"string\">&quot;1100100&quot;</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>))  <span class=\"comment\">// 100</span></span><br><span class=\"line\">    fmt.Println(strconv.ParseInt(<span class=\"string\">&quot;7D0&quot;</span>, <span class=\"number\">16</span>, <span class=\"number\">0</span>))    <span class=\"comment\">// 2000</span></span><br><span class=\"line\">    fmt.Println(strconv.ParseInt(<span class=\"string\">&quot;2147483648&quot;</span>, <span class=\"number\">10</span>, <span class=\"number\">64</span>))   <span class=\"comment\">// 2147483648</span></span><br><span class=\"line\">    fmt.Println(strconv.ParseUint(<span class=\"string\">&quot;FFFFFFFFFFFFFFFF&quot;</span>, <span class=\"number\">16</span>, <span class=\"number\">64</span>)) <span class=\"comment\">// 18446744073709551615</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 其他进制的整数转字符串</span></span><br><span class=\"line\">    fmt.Println(strconv.FormatInt(<span class=\"number\">100</span>, <span class=\"number\">2</span>)) <span class=\"comment\">// &quot;1100100&quot;</span></span><br><span class=\"line\">    fmt.Println(strconv.FormatInt(<span class=\"number\">2000</span>, <span class=\"number\">16</span>)) <span class=\"comment\">// &quot;7d0&quot;</span></span><br><span class=\"line\">    fmt.Println(strconv.FormatUint(<span class=\"number\">2147483648</span>, <span class=\"number\">10</span>)) <span class=\"comment\">// &quot;2147483648&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 字符串到浮点数的转换</span></span><br><span class=\"line\">    fmt.Println(strconv.ParseFloat(<span class=\"string\">&quot;3.1415&quot;</span>, <span class=\"number\">64</span>)) <span class=\"comment\">// 3.1415</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 浮点数到字符串的转换</span></span><br><span class=\"line\">    fmt.Println(strconv.FormatFloat(<span class=\"number\">3.1415</span>, <span class=\"string\">&#x27;E&#x27;</span>, <span class=\"number\">-1</span>, <span class=\"number\">64</span>)) <span class=\"comment\">// 3.141500E+00</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 输出类型为 bool 的数值字符串</span></span><br><span class=\"line\">    fmt.Println(strconv.ParseBool(<span class=\"string\">&quot;true&quot;</span>))  <span class=\"comment\">// true</span></span><br><span class=\"line\">    fmt.Println(strconv.ParseBool(<span class=\"string\">&quot;False&quot;</span>)) <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 布尔型到字符串的转换</span></span><br><span class=\"line\">    fmt.Println(strconv.FormatBool(<span class=\"literal\">true</span>)) <span class=\"comment\">// &quot;true&quot;</span></span><br><span class=\"line\">    fmt.Println(strconv.FormatBool(<span class=\"literal\">false</span>)) <span class=\"comment\">// &quot;false&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"进制转化\"><a href=\"#进制转化\" class=\"headerlink\" title=\"进制转化\"></a>进制转化</h2><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 十进制转二进制</span></span><br><span class=\"line\">fmt.Printf(<span class=\"string\">&quot;%b&quot;</span>, <span class=\"number\">17</span>) <span class=\"comment\">// 10001</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 十进制转十六进制</span></span><br><span class=\"line\">fmt.Printf(<span class=\"string\">&quot;%x&quot;</span>, <span class=\"number\">17</span>) <span class=\"comment\">// 11</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 十六进制转十进制</span></span><br><span class=\"line\">i, _ := strconv.ParseInt(<span class=\"string\">&quot;11&quot;</span>, <span class=\"number\">16</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">fmt.Println(i) <span class=\"comment\">// 17</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 十六进制转二进制</span></span><br><span class=\"line\">i, _ = strconv.ParseInt(<span class=\"string\">&quot;11&quot;</span>, <span class=\"number\">16</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">&quot;%b&quot;</span>, i) <span class=\"comment\">// 10001</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 二进制转十进制</span></span><br><span class=\"line\">i, _ = strconv.ParseInt(<span class=\"string\">&quot;10001&quot;</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">fmt.Println(i) <span class=\"comment\">// 17</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 二进制转十六进制</span></span><br><span class=\"line\">i, _ = strconv.ParseInt(<span class=\"string\">&quot;10001&quot;</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">&quot;%x&quot;</span>, i) <span class=\"comment\">// 11</span></span><br></pre></td></tr></table></figure>"},{"title":"Golang 使用链表","catalog":true,"date":"2023-03-27T16:34:11.000Z","subtitle":null,"header-img":null,"published":0,"_content":"\n# Golang 链表的使用\n\n链表是通过指针串联在一起的线性结构，每一个节点都包含两个部分的内容：指针域和数据域；指针域用于存储指向其他节点的指针变量\n\n对于链表而言有俩个最重要的概念：\n* head\n* head.Next\n\n在操作链表的时候非常容易将移动指针和操作节点内容弄混，首先 Head *ListNode 是一个指向节点的指针，本身是一个地址；Head.Next 是节点内的指针变量用于指向其他的节点。当我们在遍历链表结构的时候不断移动的是 Head 变量，而如果要对链表的结构进行改动，就需要修改 Head.Next 的值为其他的节点地址。\n\n但有一个非常简单的方法可以识别出对指针的操作以及他的身份: \n1. Next/Pre(节点内值) 变量在**等号左边**必定是增删修改节点位置，一定要想清楚当前使用Next的节点是哪一个; 在**等号右边**一般就是移动指针的位置，但没有改变链表的结构 \n2. Head 在**等号左边**必定是改变指针位置，移动到其他的节点； 在**等号右边**一般是改变链表的结构或者是让其他的节点指向当前节点。  \n\n所以要改变链表的结构，Head.Next的值一定会改变且在循环中出现在等号的左边，Head 本身应该理解为一个地址指针用于指向要操作内容的节点\n\n\n\n# Golang 链表算法使用\n> leetcode 题目汇总：\n> [1] [https://leetcode.cn/problems/remove-nth-node-from-end-of-list/solution/shan-chu-lian-biao-de-dao-shu-di-nge-jie-dian-b-61/ ]\n>\n\n\n","source":"_posts/Go/script/Golang-使用链表/Golang-使用链表.md","raw":"---\ntitle: Golang 使用链表\ncatalog: true\ndate: 2023-03-28 00:34:11\nsubtitle:\nheader-img:\ntags: Golang, List\ncategories:\npublished: false\n---\n\n# Golang 链表的使用\n\n链表是通过指针串联在一起的线性结构，每一个节点都包含两个部分的内容：指针域和数据域；指针域用于存储指向其他节点的指针变量\n\n对于链表而言有俩个最重要的概念：\n* head\n* head.Next\n\n在操作链表的时候非常容易将移动指针和操作节点内容弄混，首先 Head *ListNode 是一个指向节点的指针，本身是一个地址；Head.Next 是节点内的指针变量用于指向其他的节点。当我们在遍历链表结构的时候不断移动的是 Head 变量，而如果要对链表的结构进行改动，就需要修改 Head.Next 的值为其他的节点地址。\n\n但有一个非常简单的方法可以识别出对指针的操作以及他的身份: \n1. Next/Pre(节点内值) 变量在**等号左边**必定是增删修改节点位置，一定要想清楚当前使用Next的节点是哪一个; 在**等号右边**一般就是移动指针的位置，但没有改变链表的结构 \n2. Head 在**等号左边**必定是改变指针位置，移动到其他的节点； 在**等号右边**一般是改变链表的结构或者是让其他的节点指向当前节点。  \n\n所以要改变链表的结构，Head.Next的值一定会改变且在循环中出现在等号的左边，Head 本身应该理解为一个地址指针用于指向要操作内容的节点\n\n\n\n# Golang 链表算法使用\n> leetcode 题目汇总：\n> [1] [https://leetcode.cn/problems/remove-nth-node-from-end-of-list/solution/shan-chu-lian-biao-de-dao-shu-di-nge-jie-dian-b-61/ ]\n>\n\n\n","slug":"Go/script/Golang-使用链表/Golang-使用链表","updated":"2023-04-22T13:24:02.236Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli796r1b002sbyjxbjsa9kv7","content":"<h1 id=\"Golang-链表的使用\"><a href=\"#Golang-链表的使用\" class=\"headerlink\" title=\"Golang 链表的使用\"></a>Golang 链表的使用</h1><p>链表是通过指针串联在一起的线性结构，每一个节点都包含两个部分的内容：指针域和数据域；指针域用于存储指向其他节点的指针变量</p>\n<p>对于链表而言有俩个最重要的概念：</p>\n<ul>\n<li>head</li>\n<li>head.Next</li>\n</ul>\n<p>在操作链表的时候非常容易将移动指针和操作节点内容弄混，首先 Head *ListNode 是一个指向节点的指针，本身是一个地址；Head.Next 是节点内的指针变量用于指向其他的节点。当我们在遍历链表结构的时候不断移动的是 Head 变量，而如果要对链表的结构进行改动，就需要修改 Head.Next 的值为其他的节点地址。</p>\n<p>但有一个非常简单的方法可以识别出对指针的操作以及他的身份: </p>\n<ol>\n<li>Next/Pre(节点内值) 变量在<strong>等号左边</strong>必定是增删修改节点位置，一定要想清楚当前使用Next的节点是哪一个; 在<strong>等号右边</strong>一般就是移动指针的位置，但没有改变链表的结构 </li>\n<li>Head 在<strong>等号左边</strong>必定是改变指针位置，移动到其他的节点； 在<strong>等号右边</strong>一般是改变链表的结构或者是让其他的节点指向当前节点。  </li>\n</ol>\n<p>所以要改变链表的结构，Head.Next的值一定会改变且在循环中出现在等号的左边，Head 本身应该理解为一个地址指针用于指向要操作内容的节点</p>\n<h1 id=\"Golang-链表算法使用\"><a href=\"#Golang-链表算法使用\" class=\"headerlink\" title=\"Golang 链表算法使用\"></a>Golang 链表算法使用</h1><blockquote>\n<p>leetcode 题目汇总：<br>[1] [<a href=\"https://leetcode.cn/problems/remove-nth-node-from-end-of-list/solution/shan-chu-lian-biao-de-dao-shu-di-nge-jie-dian-b-61/\">https://leetcode.cn/problems/remove-nth-node-from-end-of-list/solution/shan-chu-lian-biao-de-dao-shu-di-nge-jie-dian-b-61/</a> ]</p>\n</blockquote>\n","site":{"data":{}},"cover":"/img/cover/sky.png","cover_type":"img","excerpt":"","more":"<h1 id=\"Golang-链表的使用\"><a href=\"#Golang-链表的使用\" class=\"headerlink\" title=\"Golang 链表的使用\"></a>Golang 链表的使用</h1><p>链表是通过指针串联在一起的线性结构，每一个节点都包含两个部分的内容：指针域和数据域；指针域用于存储指向其他节点的指针变量</p>\n<p>对于链表而言有俩个最重要的概念：</p>\n<ul>\n<li>head</li>\n<li>head.Next</li>\n</ul>\n<p>在操作链表的时候非常容易将移动指针和操作节点内容弄混，首先 Head *ListNode 是一个指向节点的指针，本身是一个地址；Head.Next 是节点内的指针变量用于指向其他的节点。当我们在遍历链表结构的时候不断移动的是 Head 变量，而如果要对链表的结构进行改动，就需要修改 Head.Next 的值为其他的节点地址。</p>\n<p>但有一个非常简单的方法可以识别出对指针的操作以及他的身份: </p>\n<ol>\n<li>Next/Pre(节点内值) 变量在<strong>等号左边</strong>必定是增删修改节点位置，一定要想清楚当前使用Next的节点是哪一个; 在<strong>等号右边</strong>一般就是移动指针的位置，但没有改变链表的结构 </li>\n<li>Head 在<strong>等号左边</strong>必定是改变指针位置，移动到其他的节点； 在<strong>等号右边</strong>一般是改变链表的结构或者是让其他的节点指向当前节点。  </li>\n</ol>\n<p>所以要改变链表的结构，Head.Next的值一定会改变且在循环中出现在等号的左边，Head 本身应该理解为一个地址指针用于指向要操作内容的节点</p>\n<h1 id=\"Golang-链表算法使用\"><a href=\"#Golang-链表算法使用\" class=\"headerlink\" title=\"Golang 链表算法使用\"></a>Golang 链表算法使用</h1><blockquote>\n<p>leetcode 题目汇总：<br>[1] [<a href=\"https://leetcode.cn/problems/remove-nth-node-from-end-of-list/solution/shan-chu-lian-biao-de-dao-shu-di-nge-jie-dian-b-61/\">https://leetcode.cn/problems/remove-nth-node-from-end-of-list/solution/shan-chu-lian-biao-de-dao-shu-di-nge-jie-dian-b-61/</a> ]</p>\n</blockquote>\n"},{"title":"Golang 协程底层原理解析","catalog":true,"date":"2023-03-26T17:09:50.000Z","subtitle":null,"header-img":null,"published":0,"_content":"","source":"_posts/Go/script/Golang-协程底层原理解析/Golang-协程底层原理解析.md","raw":"---\ntitle: Golang 协程底层原理解析\ncatalog: true\ndate: 2023-03-27 01:09:50\nsubtitle:\nheader-img:\ntags:\ncategories:\npublished: false\n---\n","slug":"Go/script/Golang-协程底层原理解析/Golang-协程底层原理解析","updated":"2023-04-22T13:24:02.216Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli796r1c002xbyjxby2dd4kd","content":"","site":{"data":{}},"cover":"/img/cover/sky.png","cover_type":"img","excerpt":"","more":""},{"title":"Golang 双指针","catalog":true,"date":"2023-04-01T16:46:21.000Z","subtitle":null,"header-img":null,"published":0,"_content":"## 题目特点\n\n* 计数：有多少种方法、可能\n* 最大最小值\n* 可能性\n\n\n\n## 六部解题法\n\n1. 找到最后一步，如何能够找到最后一种可能\n\n   归纳出子问题和 dp数组\n\n2. 初始条件和边界\n\n3. 计算顺序\n\n3","source":"_posts/Algorithm/Alg_Basic/Golang-基础算法/Golang- DP/Golang-DP.md","raw":"---\ntitle: Golang 双指针\ncatalog: true\ndate: 2023-04-02 00:46:21\nsubtitle:\nheader-img:\ntags: 双指针, 算法\ncategories: 算法，Golang\npublished: false\n---\n## 题目特点\n\n* 计数：有多少种方法、可能\n* 最大最小值\n* 可能性\n\n\n\n## 六部解题法\n\n1. 找到最后一步，如何能够找到最后一种可能\n\n   归纳出子问题和 dp数组\n\n2. 初始条件和边界\n\n3. 计算顺序\n\n3","slug":"Algorithm/Alg_Basic/Golang-基础算法/Golang- DP/Golang-DP","updated":"2023-05-28T09:51:00.103Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli796r1c002ybyjx259p8vxl","content":"<h2 id=\"题目特点\"><a href=\"#题目特点\" class=\"headerlink\" title=\"题目特点\"></a>题目特点</h2><ul>\n<li>计数：有多少种方法、可能</li>\n<li>最大最小值</li>\n<li>可能性</li>\n</ul>\n<h2 id=\"六部解题法\"><a href=\"#六部解题法\" class=\"headerlink\" title=\"六部解题法\"></a>六部解题法</h2><ol>\n<li><p>找到最后一步，如何能够找到最后一种可能</p>\n<p>归纳出子问题和 dp数组</p>\n</li>\n<li><p>初始条件和边界</p>\n</li>\n<li><p>计算顺序</p>\n</li>\n</ol>\n<p>3</p>\n","site":{"data":{}},"cover":"/img/cover/elderring.png","cover_type":"img","excerpt":"","more":"<h2 id=\"题目特点\"><a href=\"#题目特点\" class=\"headerlink\" title=\"题目特点\"></a>题目特点</h2><ul>\n<li>计数：有多少种方法、可能</li>\n<li>最大最小值</li>\n<li>可能性</li>\n</ul>\n<h2 id=\"六部解题法\"><a href=\"#六部解题法\" class=\"headerlink\" title=\"六部解题法\"></a>六部解题法</h2><ol>\n<li><p>找到最后一步，如何能够找到最后一种可能</p>\n<p>归纳出子问题和 dp数组</p>\n</li>\n<li><p>初始条件和边界</p>\n</li>\n<li><p>计算顺序</p>\n</li>\n</ol>\n<p>3</p>\n"},{"title":"Golang 双指针","catalog":true,"date":"2023-04-01T16:46:21.000Z","subtitle":null,"header-img":null,"_content":"\n# 双指针：如何掌握最长、定长、最短区间问题的解题诀窍\n> 通常是明明用两个指针在数组/链表上遍历，然后解决满足某种性质的问题\n> 解决问题：\n> **最长区间**\n> **定长区间**\n> **最短区间**\n> <font color = 'red'>1. 弄清楚题目要的是什么样的区间，是上述三种中的哪一类</font>\n> <font color = 'red'>2. 区间需要满足的条件是什么</font>\n\n## **1** &ensp; 区间特性\n\n### 单调性 & 最优\n> 使用双指针需要保证区间的单调性\n\n1. 单调性的定义：\n   区间的单调性： 固定了划分区间的条件之后，遍历区间内的元素，按照一定顺序的时候，区间内的元素应该是都满足某一个条件，且存在问题定义上的大小单调变化。\n   比如： 在一个完全都是正整数的区间里面，划分子集的标准是固定子集右端元素（最右端元素只能是A[i]），集合内元素的和从下标为-1到i-1,均大于某个数，且这个和逐步减少（$\\because 元素都是正数，减少了就变小了$）\n\n2. 快速判断区间属性是否满足单调性的办法\n   <font color = 'red'> 往区间里面添加元素的时候，区间的约束条件可以变化，但不能出现波折</font>\n   理解为： 添加一个元素之后，要么依旧满足条件，符合单调性；要么出现一会不满足一会满足的情况，不符合单调性\n\n> 遍历区间的所有子集可以使用这样的方式： 固定子集的最右边元素为固定元素：\n> 固定右区间集合，把A[i]元素固定为区间的右端点，之变动区间的左边界形成的所有区间，并且按照区间长度需要从长到短排列\n>\n3. 找到最优解\n   <font color = 'red'> 从左向右遍历区间右端固定元素集合中的每个区间，找到一个满足条件的解就停止（因为单调性继续调整依旧满足条件）</font>\n\n### 模板\n1. 寻找以A[i]为有边界的最优解，分为以下三步\n``` golang\nStep 1 :\n将A[i] 加入到区间中，形成新的区间 （left,i]\nroom = append(room,A[i])\n\nStep 2：\n遍历A[i]的固定右区间集，直到找到以A[i]为右端点的最优解\nfor left < i && (left,i] 区间不满足要求 {\n    left++\n} \n\nStep 3:\n此时要么得到一个满足要求的解，要么没有满足单调性的区间\n(left,i]区间满足要求\n```\n2. 题目须具备的条件\n   * 给定一个条件\n   * 求最长区间/最长字串\n   * 题目给出的区间需要具备的单调性\n\n3. 必杀技\n   * left，right 指针\n   * 只有在不满足条件的时候才向右移动left指针\n  \n4. 最长区间的代码模板\n``` golang\nfunc maxLength(A []int) int{\n    // 创建左指针和结果\n    left, ans := -1, 0\n\n    // 从左向右遍历区间\n    for i:= 0; i< len(A); i++{\n        // Assert 在加入 A[i] 之前，(left,i-1] 是一个合法有效的区间，在最开始的时候left = -1，i-1=-1，是空区间，满足条件\n        // Step1 : 直接将A[i]加到区间中，形成(left,i]\n        // step2 : 将A[I]加入之后，依据left的惰性yuanze\n        // TODO: check检查区间状态是否满足条件\n        for check(left,i) {\n            left++// 如果不满足条件，移动左指针\n            // TODO： 修改区间的状态\n        }\n        // assert 此时的(left,i] 必然满足条件\n        ans = max(ans,i-left)\n    }\n    // 返回最优解\n    return ans\n}\n```\n\n时间复杂度为 O(n)\n\n## **2** &ensp; 例题: 区间长度类型\n\n### 不含重复字符的最长区间\n> 单调性： 当找到一个没有重复字符的区间时候，减少区间内元素，新的区间依旧满足没有重复元素\n> https://leetcode.cn/problems/longest-substring-without-repeating-characters/\n>\n``` golang\nfunc lengthOfLongestSubstring(s string) int {\n    // 双指针解决\n    left, ans := -1,0\n    // 存储区间内元素的映射\n    m := make(map[byte]int,0)\n    for i := 0; i <len(s); i++ {\n        m[s[i]] += 1\n        for m[s[i]] > 1 {\n            left++\n            m[s[left]]--\n        }\n        ans = max(ans, i-left)\n    }\n    return ans\n}\n\nfunc max(args ...int)int{\n    m := args[0]\n    for _, val := range args{\n        if val > m {\n            m = val\n        }\n    }\n    return m\n}\n```\n\n### 替换后的最长重复字符\n> 给你一个字符串 s 和一个整数 k 。你可以选择字符串中的任一字符，并将其更改为任何其他大写英文字符。该操作最多可执行 k 次。\n> https://leetcode.cn/problems/longest-repeating-character-replacement/\n> \n在执行上述操作后，返回包含相同字母的最长子字符串的长度。\n示例 1：\n输入：s = \"ABAB\", k = 2\n输出：4\n解释：用两个'A'替换为两个'B',反之亦然。\n示例 2：\n输入：s = \"AABABBA\", k = 1\n输出：4\n解释：\n将中间的一个'A'替换为'B',字符串变为 \"AABBBBA\"。\n子串 \"BBBB\" 有最长重复字母, 答案为 4。\n 提示：\n1 <= s.length <= 105\ns 仅由大写英文字母组成\n0 <= k <= s.length\n\n\n``` golang\nfunc characterReplacement(s string, k int) int {\n    // \n    left, ans := -1,0\n    max_repeat := 0\n    m := make(map[byte]int,0)\n    for i := 0; i < len(s); i++{\n        m[s[i]]++\n\n        max_repeat = max(m[s[i]],max_repeat)\n        for i-left-max_repeat > k{\n            left++\n            m[s[left]]--\n        } \n        ans = max(ans,i-left)\n    }\n    return ans\n}\nfunc max(args ...int)int{\n    m := args[0]\n    for _, val := range args{\n        if val > m {\n            m = val\n        }\n    }\n    return m\n}\n```\n\n\n### 字符流中第一个只出现一次的字符\n> 请实现一个函数用来找出字符流中第一个只出现一次的字符。\n> https://www.acwing.com/problem/content/60/\n例如，当从字符流中只读出前两个字符 go 时，第一个只出现一次的字符是 g。\n当从该字符流中读出前六个字符 google 时，第一个只出现一次的字符是 l。\n如果当前字符流没有存在出现一次的字符，返回 # 字符。\n数据范围\n字符流读入字符数量 [0,1000]\n\n样例\n输入：\"google\"\n输出：\"ggg#ll\"\n解释：每当字符流读入一个字符，就进行一次判断并输出当前的第一个只出现一次的字符。\n\n```golang\ntype Solution struct {\n    left int // 最左侧字符位置\n    cnt  [256]int // 字符个数计数器\n    s    string // 保存输入的字符串\n}\n\nvar s Solution\n\nfunc insert(ch byte) {\n    s.cnt[ch]++ // 将该字符出现次数加1\n    s.s += string(ch) // 将该字符加入到字符串s中\n    // 如果最左侧的字符出现次数大于1，则将最左侧字符的位置向右移动，直到最左侧字符出现次数为1或者left >= right\n    for s.left < len(s.s) && s.cnt[s.s[s.left]] > 1 {\n        s.left++\n    }\n}\n\nfunc firstAppearingOnce() byte {\n    // 如果最左侧字符位置left大于等于字符串s的长度，则返回'#'\n    if s.left >= len(s.s) {\n        return '#'\n    }\n    // 返回最左侧的字符\n    return s.s[s.left]\n}\n```\n\n### 最多有k个不同字符的最长子字符串\n> 给定字符串S，找到最多有k个不同字符的最长子串T。\n> https://www.lintcode.com/problem/386/\n样例\n样例 1:\n\n输入: S = \"eceba\" 并且 k = 3\n输出: 4\n解释: T = \"eceb\"\n样例 2:\n\n输入: S = \"WORLD\" 并且 k = 4\n输出: 4\n解释: T = \"WORL\" 或 \"ORLD\"\n挑战\nO(n) 时间复杂度\n``` golang\n/**\n * @param s: A string\n * @param k: An integer\n * @return: An integer\n */\nfunc LengthOfLongestSubstringKDistinct(s string, k int) int {\n    //\n    left, count,l := -1,0,0\n\n    m := make(map[byte]int,0)\n    for i:=0; i< len(s); i++{\n        if m[s[i]] == 0 {\n            count++\n        }\n        m[s[i]]++\n        for count > k {\n            left++\n            m[s[left]]--\n            if m[s[left]] == 0 {\n                count--\n            }\n        }\n        l = max(l,i-left)\n    }\n    return l\n}\n\nfunc max(args ...int) int{\n    m := args[0]\n    for _, val := range args{\n        if val > m {\n            m = val\n        }\n    }\n    return m\n}\n```\n\n###  数组中的最长山脉\n> https://leetcode.cn/problems/longest-mountain-in-array/description/\n>\n把符合下列属性的数组 arr 称为 山脉数组 ：\n\narr.length >= 3\n存在下标 i（0 < i < arr.length - 1），满足\narr[0] < arr[1] < ... < arr[i - 1] < arr[i]\narr[i] > arr[i + 1] > ... > arr[arr.length - 1]\n给出一个整数数组 arr，返回最长山脉子数组的长度。如果不存在山脉子数组，返回 0 。\n示例 1：\n输入：arr = [2,1,4,7,3,2,5]\n输出：5\n解释：最长的山脉子数组是 [1,4,7,3,2]，长度为 5。\n示例 2：\n\n输入：arr = [2,2,2]\n输出：0\n解释：不存在山脉子数组。\n提示：\n1 <= arr.length <= 104\n0 <= arr[i] <= 104\n\n进阶：\n你可以仅用一趟扫描解决此问题吗？\n你可以用 O(1) 空间解决此问题吗？\n\n``` golang\nfunc longestMountain(A []int) int {\n    N := len(A)\n    if N < 3 {\n        return 0\n    }\n\n    left := -1\n    // -1表示只有一个元素\n    // 0表示正上升\n    // 1表示正下降\n    status := -1\n    preValue := A[0]\n    ans := 0\n\n    // 题目要求必须至少有3个元素，所以不可能从0开始\n    for i := 1; i < N; i++ {\n        x := A[i]\n\n        // 如果要把x加进来\n        // 如果里面还只有一个元素\n        if status == -1 {\n            if x > preValue {\n                // 那么状态改为上升\n                status = 0\n            } else {\n                // 如果相等，或者变小，那么区间只能再变成只有一个元素的了\n                // 状态依然更新为只有一个元素\n                status = -1\n                // 区间更新为(left, i]\n                left = i - 1\n            }\n        }\n        // 如果正在上升\n        if status == 0 {\n            if x > preValue {\n                // nothing\n            } else if x == preValue {\n                // 如果相等，那么区间只能再变成只有一个元素的状态了\n                status = -1\n                left = i - 1\n            } else {\n                // 下降了\n                status = 1\n            }\n        }\n        // 如果正在下降\n        if status == 1 {\n            if x < preValue {\n                // nothing\n            } else if x == preValue {\n                status = -1\n                left = i - 1\n            } else {\n                // 如果正在上升\n                status = 0\n                // 注意这里left要变成(i - 2, i]\n                // 这里已经有两个元素了\n                left = i - 2\n            }\n        }\n\n        preValue = x\n        if status == 1 {\n            ans = max(ans, i-left)\n        }\n    }\n\n    if ans >= 3 {\n        return ans\n    }\n    return 0\n}\n\n\nfunc max(args ...int)int{\n    m := args[0]\n    for _, val := range args{\n        if val > m {\n             m = val\n        }\n    }\n    return m\n}\n```\n\n---\n\n## **3**  &ensp; 例题：区间计数\n\n### 区间计数\n> 区间最优原则表示：当按照区间最右边元素划分区间，并找到最优解之后，left继续向有移动形成的短区间都满足条件\n\n#### 代码模板\n> 在求最长区间代码模板上变式\n```golang\nfunc rangeCounter(A []int){\n    // 区间的左指针\n    left,ans := -1,0\n    // 不变式0： 最开始的区间为(-1，-1] 是一个空区间\n    //          我们认为空区间总是满足条件\n    for i:=0; i<len(A); i++{\n        // 不变式1： 在加入A[i]之前，(left,i-1]是一个合法的有效区间\n        // 需要改变的部分为下：\n        // Step1： 直接将A[i]加入到区间中，形成(left,i]\n        // Step2:  将A[i] 加入之后，依据多性原则判断Left是否移动且移动多少\n        /** TODO: 设计check函数，检查区间是否满足条件\n        */\n        for check(left,i] {\n            // 如果不满足条件，则移动左指针\n            left++\n            /**\n            TODO: 修改区间的状态或者改变区间的性质\n            */\n        }\n        // 不变式2： 此时(left,i]必然合法\n        // 累计区间个数: 以A[i]为有边界的子区间总共有i-left个\n        ans = ans + i-left\n    }\n    return ans\n}\n```\n\n\n\n### 改变区间\n\n> [27. 移除元素 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-element/submissions/)\n\n### 解题思路\n核心还是双指针，\n这道题目关键点有三处：\n* 规整数组的方式：找到数组中与val相同的数时候，让他与数组的右边起第一个不是val的数字交换，这样遍历一次数组之后，所有值等于val的都被移动到了数组的右边\n* for 和 if 的嵌套控制：因为是 O(N)复杂度\n    建议按照 \n    ```go\n        for {\n            if {\n                continue\n            }\n        }\n\n### \t代码\n\n```golang\nfunc removeElement(nums []int, val int) int {\n    right,left := len(nums)-1,0\n    if right == -1 {\n        return 0\n    }\n    for left < right {\n        if nums[right] == val {\n            right--\n            continue\n        }\n        if nums[left] == val {\n            nums[left], nums[right] = nums[right],nums[left]\n            left++\n            right--\n            continue\n        }\n        left++\n    }\n    if nums[left] != val {\n        left++\n    }\n    nums = nums[:left]\n    return len(nums)\n}\n```","source":"_posts/Algorithm/Alg_Basic/Golang-基础算法/Golang-双指针/Golang-双指针.md","raw":"---\ntitle: Golang 双指针\ncatalog: true\ndate: 2023-04-02 00:46:21\nsubtitle:\nheader-img:\ntags: 双指针, 算法\ncategories: 算法，Golang\n---\n\n# 双指针：如何掌握最长、定长、最短区间问题的解题诀窍\n> 通常是明明用两个指针在数组/链表上遍历，然后解决满足某种性质的问题\n> 解决问题：\n> **最长区间**\n> **定长区间**\n> **最短区间**\n> <font color = 'red'>1. 弄清楚题目要的是什么样的区间，是上述三种中的哪一类</font>\n> <font color = 'red'>2. 区间需要满足的条件是什么</font>\n\n## **1** &ensp; 区间特性\n\n### 单调性 & 最优\n> 使用双指针需要保证区间的单调性\n\n1. 单调性的定义：\n   区间的单调性： 固定了划分区间的条件之后，遍历区间内的元素，按照一定顺序的时候，区间内的元素应该是都满足某一个条件，且存在问题定义上的大小单调变化。\n   比如： 在一个完全都是正整数的区间里面，划分子集的标准是固定子集右端元素（最右端元素只能是A[i]），集合内元素的和从下标为-1到i-1,均大于某个数，且这个和逐步减少（$\\because 元素都是正数，减少了就变小了$）\n\n2. 快速判断区间属性是否满足单调性的办法\n   <font color = 'red'> 往区间里面添加元素的时候，区间的约束条件可以变化，但不能出现波折</font>\n   理解为： 添加一个元素之后，要么依旧满足条件，符合单调性；要么出现一会不满足一会满足的情况，不符合单调性\n\n> 遍历区间的所有子集可以使用这样的方式： 固定子集的最右边元素为固定元素：\n> 固定右区间集合，把A[i]元素固定为区间的右端点，之变动区间的左边界形成的所有区间，并且按照区间长度需要从长到短排列\n>\n3. 找到最优解\n   <font color = 'red'> 从左向右遍历区间右端固定元素集合中的每个区间，找到一个满足条件的解就停止（因为单调性继续调整依旧满足条件）</font>\n\n### 模板\n1. 寻找以A[i]为有边界的最优解，分为以下三步\n``` golang\nStep 1 :\n将A[i] 加入到区间中，形成新的区间 （left,i]\nroom = append(room,A[i])\n\nStep 2：\n遍历A[i]的固定右区间集，直到找到以A[i]为右端点的最优解\nfor left < i && (left,i] 区间不满足要求 {\n    left++\n} \n\nStep 3:\n此时要么得到一个满足要求的解，要么没有满足单调性的区间\n(left,i]区间满足要求\n```\n2. 题目须具备的条件\n   * 给定一个条件\n   * 求最长区间/最长字串\n   * 题目给出的区间需要具备的单调性\n\n3. 必杀技\n   * left，right 指针\n   * 只有在不满足条件的时候才向右移动left指针\n  \n4. 最长区间的代码模板\n``` golang\nfunc maxLength(A []int) int{\n    // 创建左指针和结果\n    left, ans := -1, 0\n\n    // 从左向右遍历区间\n    for i:= 0; i< len(A); i++{\n        // Assert 在加入 A[i] 之前，(left,i-1] 是一个合法有效的区间，在最开始的时候left = -1，i-1=-1，是空区间，满足条件\n        // Step1 : 直接将A[i]加到区间中，形成(left,i]\n        // step2 : 将A[I]加入之后，依据left的惰性yuanze\n        // TODO: check检查区间状态是否满足条件\n        for check(left,i) {\n            left++// 如果不满足条件，移动左指针\n            // TODO： 修改区间的状态\n        }\n        // assert 此时的(left,i] 必然满足条件\n        ans = max(ans,i-left)\n    }\n    // 返回最优解\n    return ans\n}\n```\n\n时间复杂度为 O(n)\n\n## **2** &ensp; 例题: 区间长度类型\n\n### 不含重复字符的最长区间\n> 单调性： 当找到一个没有重复字符的区间时候，减少区间内元素，新的区间依旧满足没有重复元素\n> https://leetcode.cn/problems/longest-substring-without-repeating-characters/\n>\n``` golang\nfunc lengthOfLongestSubstring(s string) int {\n    // 双指针解决\n    left, ans := -1,0\n    // 存储区间内元素的映射\n    m := make(map[byte]int,0)\n    for i := 0; i <len(s); i++ {\n        m[s[i]] += 1\n        for m[s[i]] > 1 {\n            left++\n            m[s[left]]--\n        }\n        ans = max(ans, i-left)\n    }\n    return ans\n}\n\nfunc max(args ...int)int{\n    m := args[0]\n    for _, val := range args{\n        if val > m {\n            m = val\n        }\n    }\n    return m\n}\n```\n\n### 替换后的最长重复字符\n> 给你一个字符串 s 和一个整数 k 。你可以选择字符串中的任一字符，并将其更改为任何其他大写英文字符。该操作最多可执行 k 次。\n> https://leetcode.cn/problems/longest-repeating-character-replacement/\n> \n在执行上述操作后，返回包含相同字母的最长子字符串的长度。\n示例 1：\n输入：s = \"ABAB\", k = 2\n输出：4\n解释：用两个'A'替换为两个'B',反之亦然。\n示例 2：\n输入：s = \"AABABBA\", k = 1\n输出：4\n解释：\n将中间的一个'A'替换为'B',字符串变为 \"AABBBBA\"。\n子串 \"BBBB\" 有最长重复字母, 答案为 4。\n 提示：\n1 <= s.length <= 105\ns 仅由大写英文字母组成\n0 <= k <= s.length\n\n\n``` golang\nfunc characterReplacement(s string, k int) int {\n    // \n    left, ans := -1,0\n    max_repeat := 0\n    m := make(map[byte]int,0)\n    for i := 0; i < len(s); i++{\n        m[s[i]]++\n\n        max_repeat = max(m[s[i]],max_repeat)\n        for i-left-max_repeat > k{\n            left++\n            m[s[left]]--\n        } \n        ans = max(ans,i-left)\n    }\n    return ans\n}\nfunc max(args ...int)int{\n    m := args[0]\n    for _, val := range args{\n        if val > m {\n            m = val\n        }\n    }\n    return m\n}\n```\n\n\n### 字符流中第一个只出现一次的字符\n> 请实现一个函数用来找出字符流中第一个只出现一次的字符。\n> https://www.acwing.com/problem/content/60/\n例如，当从字符流中只读出前两个字符 go 时，第一个只出现一次的字符是 g。\n当从该字符流中读出前六个字符 google 时，第一个只出现一次的字符是 l。\n如果当前字符流没有存在出现一次的字符，返回 # 字符。\n数据范围\n字符流读入字符数量 [0,1000]\n\n样例\n输入：\"google\"\n输出：\"ggg#ll\"\n解释：每当字符流读入一个字符，就进行一次判断并输出当前的第一个只出现一次的字符。\n\n```golang\ntype Solution struct {\n    left int // 最左侧字符位置\n    cnt  [256]int // 字符个数计数器\n    s    string // 保存输入的字符串\n}\n\nvar s Solution\n\nfunc insert(ch byte) {\n    s.cnt[ch]++ // 将该字符出现次数加1\n    s.s += string(ch) // 将该字符加入到字符串s中\n    // 如果最左侧的字符出现次数大于1，则将最左侧字符的位置向右移动，直到最左侧字符出现次数为1或者left >= right\n    for s.left < len(s.s) && s.cnt[s.s[s.left]] > 1 {\n        s.left++\n    }\n}\n\nfunc firstAppearingOnce() byte {\n    // 如果最左侧字符位置left大于等于字符串s的长度，则返回'#'\n    if s.left >= len(s.s) {\n        return '#'\n    }\n    // 返回最左侧的字符\n    return s.s[s.left]\n}\n```\n\n### 最多有k个不同字符的最长子字符串\n> 给定字符串S，找到最多有k个不同字符的最长子串T。\n> https://www.lintcode.com/problem/386/\n样例\n样例 1:\n\n输入: S = \"eceba\" 并且 k = 3\n输出: 4\n解释: T = \"eceb\"\n样例 2:\n\n输入: S = \"WORLD\" 并且 k = 4\n输出: 4\n解释: T = \"WORL\" 或 \"ORLD\"\n挑战\nO(n) 时间复杂度\n``` golang\n/**\n * @param s: A string\n * @param k: An integer\n * @return: An integer\n */\nfunc LengthOfLongestSubstringKDistinct(s string, k int) int {\n    //\n    left, count,l := -1,0,0\n\n    m := make(map[byte]int,0)\n    for i:=0; i< len(s); i++{\n        if m[s[i]] == 0 {\n            count++\n        }\n        m[s[i]]++\n        for count > k {\n            left++\n            m[s[left]]--\n            if m[s[left]] == 0 {\n                count--\n            }\n        }\n        l = max(l,i-left)\n    }\n    return l\n}\n\nfunc max(args ...int) int{\n    m := args[0]\n    for _, val := range args{\n        if val > m {\n            m = val\n        }\n    }\n    return m\n}\n```\n\n###  数组中的最长山脉\n> https://leetcode.cn/problems/longest-mountain-in-array/description/\n>\n把符合下列属性的数组 arr 称为 山脉数组 ：\n\narr.length >= 3\n存在下标 i（0 < i < arr.length - 1），满足\narr[0] < arr[1] < ... < arr[i - 1] < arr[i]\narr[i] > arr[i + 1] > ... > arr[arr.length - 1]\n给出一个整数数组 arr，返回最长山脉子数组的长度。如果不存在山脉子数组，返回 0 。\n示例 1：\n输入：arr = [2,1,4,7,3,2,5]\n输出：5\n解释：最长的山脉子数组是 [1,4,7,3,2]，长度为 5。\n示例 2：\n\n输入：arr = [2,2,2]\n输出：0\n解释：不存在山脉子数组。\n提示：\n1 <= arr.length <= 104\n0 <= arr[i] <= 104\n\n进阶：\n你可以仅用一趟扫描解决此问题吗？\n你可以用 O(1) 空间解决此问题吗？\n\n``` golang\nfunc longestMountain(A []int) int {\n    N := len(A)\n    if N < 3 {\n        return 0\n    }\n\n    left := -1\n    // -1表示只有一个元素\n    // 0表示正上升\n    // 1表示正下降\n    status := -1\n    preValue := A[0]\n    ans := 0\n\n    // 题目要求必须至少有3个元素，所以不可能从0开始\n    for i := 1; i < N; i++ {\n        x := A[i]\n\n        // 如果要把x加进来\n        // 如果里面还只有一个元素\n        if status == -1 {\n            if x > preValue {\n                // 那么状态改为上升\n                status = 0\n            } else {\n                // 如果相等，或者变小，那么区间只能再变成只有一个元素的了\n                // 状态依然更新为只有一个元素\n                status = -1\n                // 区间更新为(left, i]\n                left = i - 1\n            }\n        }\n        // 如果正在上升\n        if status == 0 {\n            if x > preValue {\n                // nothing\n            } else if x == preValue {\n                // 如果相等，那么区间只能再变成只有一个元素的状态了\n                status = -1\n                left = i - 1\n            } else {\n                // 下降了\n                status = 1\n            }\n        }\n        // 如果正在下降\n        if status == 1 {\n            if x < preValue {\n                // nothing\n            } else if x == preValue {\n                status = -1\n                left = i - 1\n            } else {\n                // 如果正在上升\n                status = 0\n                // 注意这里left要变成(i - 2, i]\n                // 这里已经有两个元素了\n                left = i - 2\n            }\n        }\n\n        preValue = x\n        if status == 1 {\n            ans = max(ans, i-left)\n        }\n    }\n\n    if ans >= 3 {\n        return ans\n    }\n    return 0\n}\n\n\nfunc max(args ...int)int{\n    m := args[0]\n    for _, val := range args{\n        if val > m {\n             m = val\n        }\n    }\n    return m\n}\n```\n\n---\n\n## **3**  &ensp; 例题：区间计数\n\n### 区间计数\n> 区间最优原则表示：当按照区间最右边元素划分区间，并找到最优解之后，left继续向有移动形成的短区间都满足条件\n\n#### 代码模板\n> 在求最长区间代码模板上变式\n```golang\nfunc rangeCounter(A []int){\n    // 区间的左指针\n    left,ans := -1,0\n    // 不变式0： 最开始的区间为(-1，-1] 是一个空区间\n    //          我们认为空区间总是满足条件\n    for i:=0; i<len(A); i++{\n        // 不变式1： 在加入A[i]之前，(left,i-1]是一个合法的有效区间\n        // 需要改变的部分为下：\n        // Step1： 直接将A[i]加入到区间中，形成(left,i]\n        // Step2:  将A[i] 加入之后，依据多性原则判断Left是否移动且移动多少\n        /** TODO: 设计check函数，检查区间是否满足条件\n        */\n        for check(left,i] {\n            // 如果不满足条件，则移动左指针\n            left++\n            /**\n            TODO: 修改区间的状态或者改变区间的性质\n            */\n        }\n        // 不变式2： 此时(left,i]必然合法\n        // 累计区间个数: 以A[i]为有边界的子区间总共有i-left个\n        ans = ans + i-left\n    }\n    return ans\n}\n```\n\n\n\n### 改变区间\n\n> [27. 移除元素 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-element/submissions/)\n\n### 解题思路\n核心还是双指针，\n这道题目关键点有三处：\n* 规整数组的方式：找到数组中与val相同的数时候，让他与数组的右边起第一个不是val的数字交换，这样遍历一次数组之后，所有值等于val的都被移动到了数组的右边\n* for 和 if 的嵌套控制：因为是 O(N)复杂度\n    建议按照 \n    ```go\n        for {\n            if {\n                continue\n            }\n        }\n\n### \t代码\n\n```golang\nfunc removeElement(nums []int, val int) int {\n    right,left := len(nums)-1,0\n    if right == -1 {\n        return 0\n    }\n    for left < right {\n        if nums[right] == val {\n            right--\n            continue\n        }\n        if nums[left] == val {\n            nums[left], nums[right] = nums[right],nums[left]\n            left++\n            right--\n            continue\n        }\n        left++\n    }\n    if nums[left] != val {\n        left++\n    }\n    nums = nums[:left]\n    return len(nums)\n}\n```","slug":"Algorithm/Alg_Basic/Golang-基础算法/Golang-双指针/Golang-双指针","published":1,"updated":"2023-05-01T08:45:04.326Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli796r1k003jbyjxfvkx5je7","content":"<h1 id=\"双指针：如何掌握最长、定长、最短区间问题的解题诀窍\"><a href=\"#双指针：如何掌握最长、定长、最短区间问题的解题诀窍\" class=\"headerlink\" title=\"双指针：如何掌握最长、定长、最短区间问题的解题诀窍\"></a>双指针：如何掌握最长、定长、最短区间问题的解题诀窍</h1><blockquote>\n<p>通常是明明用两个指针在数组/链表上遍历，然后解决满足某种性质的问题<br>解决问题：<br><strong>最长区间</strong><br><strong>定长区间</strong><br><strong>最短区间</strong><br><font color = 'red'>1. 弄清楚题目要的是什么样的区间，是上述三种中的哪一类</font><br><font color = 'red'>2. 区间需要满足的条件是什么</font></p>\n</blockquote>\n<h2 id=\"1-ensp-区间特性\"><a href=\"#1-ensp-区间特性\" class=\"headerlink\" title=\"1 &ensp; 区间特性\"></a><strong>1</strong> &ensp; 区间特性</h2><h3 id=\"单调性-amp-最优\"><a href=\"#单调性-amp-最优\" class=\"headerlink\" title=\"单调性 &amp; 最优\"></a>单调性 &amp; 最优</h3><blockquote>\n<p>使用双指针需要保证区间的单调性</p>\n</blockquote>\n<ol>\n<li><p>单调性的定义：<br>区间的单调性： 固定了划分区间的条件之后，遍历区间内的元素，按照一定顺序的时候，区间内的元素应该是都满足某一个条件，且存在问题定义上的大小单调变化。<br>比如： 在一个完全都是正整数的区间里面，划分子集的标准是固定子集右端元素（最右端元素只能是A[i]），集合内元素的和从下标为-1到i-1,均大于某个数，且这个和逐步减少（$\\because 元素都是正数，减少了就变小了$）</p>\n</li>\n<li><p>快速判断区间属性是否满足单调性的办法<br><font color = 'red'> 往区间里面添加元素的时候，区间的约束条件可以变化，但不能出现波折</font><br>理解为： 添加一个元素之后，要么依旧满足条件，符合单调性；要么出现一会不满足一会满足的情况，不符合单调性</p>\n</li>\n</ol>\n<blockquote>\n<p>遍历区间的所有子集可以使用这样的方式： 固定子集的最右边元素为固定元素：<br>固定右区间集合，把A[i]元素固定为区间的右端点，之变动区间的左边界形成的所有区间，并且按照区间长度需要从长到短排列</p>\n</blockquote>\n<ol start=\"3\">\n<li>找到最优解<br><font color = 'red'> 从左向右遍历区间右端固定元素集合中的每个区间，找到一个满足条件的解就停止（因为单调性继续调整依旧满足条件）</font></li>\n</ol>\n<h3 id=\"模板\"><a href=\"#模板\" class=\"headerlink\" title=\"模板\"></a>模板</h3><ol>\n<li><p>寻找以A[i]为有边界的最优解，分为以下三步</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Step <span class=\"number\">1</span> :</span><br><span class=\"line\">将A[i] 加入到区间中，形成新的区间 （left,i]</span><br><span class=\"line\">room = <span class=\"built_in\">append</span>(room,A[i])</span><br><span class=\"line\"></span><br><span class=\"line\">Step <span class=\"number\">2</span>：</span><br><span class=\"line\">遍历A[i]的固定右区间集，直到找到以A[i]为右端点的最优解</span><br><span class=\"line\"><span class=\"keyword\">for</span> left &lt; i &amp;&amp; (left,i] 区间不满足要求 &#123;</span><br><span class=\"line\">    left++</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\">Step <span class=\"number\">3</span>:</span><br><span class=\"line\">此时要么得到一个满足要求的解，要么没有满足单调性的区间</span><br><span class=\"line\">(left,i]区间满足要求</span><br></pre></td></tr></table></figure></li>\n<li><p>题目须具备的条件</p>\n<ul>\n<li>给定一个条件</li>\n<li>求最长区间/最长字串</li>\n<li>题目给出的区间需要具备的单调性</li>\n</ul>\n</li>\n<li><p>必杀技</p>\n<ul>\n<li>left，right 指针</li>\n<li>只有在不满足条件的时候才向右移动left指针</li>\n</ul>\n</li>\n<li><p>最长区间的代码模板</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">maxLength</span><span class=\"params\">(A []<span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建左指针和结果</span></span><br><span class=\"line\">    left, ans := <span class=\"number\">-1</span>, <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 从左向右遍历区间</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i:= <span class=\"number\">0</span>; i&lt; <span class=\"built_in\">len</span>(A); i++&#123;</span><br><span class=\"line\">        <span class=\"comment\">// Assert 在加入 A[i] 之前，(left,i-1] 是一个合法有效的区间，在最开始的时候left = -1，i-1=-1，是空区间，满足条件</span></span><br><span class=\"line\">        <span class=\"comment\">// Step1 : 直接将A[i]加到区间中，形成(left,i]</span></span><br><span class=\"line\">        <span class=\"comment\">// step2 : 将A[I]加入之后，依据left的惰性yuanze</span></span><br><span class=\"line\">        <span class=\"comment\">// <span class=\"doctag\">TODO:</span> check检查区间状态是否满足条件</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> check(left,i) &#123;</span><br><span class=\"line\">            left++<span class=\"comment\">// 如果不满足条件，移动左指针</span></span><br><span class=\"line\">            <span class=\"comment\">// TODO： 修改区间的状态</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// assert 此时的(left,i] 必然满足条件</span></span><br><span class=\"line\">        ans = max(ans,i-left)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 返回最优解</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>时间复杂度为 O(n)</p>\n<h2 id=\"2-ensp-例题-区间长度类型\"><a href=\"#2-ensp-例题-区间长度类型\" class=\"headerlink\" title=\"2 &ensp; 例题: 区间长度类型\"></a><strong>2</strong> &ensp; 例题: 区间长度类型</h2><h3 id=\"不含重复字符的最长区间\"><a href=\"#不含重复字符的最长区间\" class=\"headerlink\" title=\"不含重复字符的最长区间\"></a>不含重复字符的最长区间</h3><blockquote>\n<p>单调性： 当找到一个没有重复字符的区间时候，减少区间内元素，新的区间依旧满足没有重复元素<br><a href=\"https://leetcode.cn/problems/longest-substring-without-repeating-characters/\">https://leetcode.cn/problems/longest-substring-without-repeating-characters/</a></p>\n</blockquote>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(s <span class=\"type\">string</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 双指针解决</span></span><br><span class=\"line\">    left, ans := <span class=\"number\">-1</span>,<span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"comment\">// 存储区间内元素的映射</span></span><br><span class=\"line\">    m := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">byte</span>]<span class=\"type\">int</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt;<span class=\"built_in\">len</span>(s); i++ &#123;</span><br><span class=\"line\">        m[s[i]] += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> m[s[i]] &gt; <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">            left++</span><br><span class=\"line\">            m[s[left]]--</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ans = max(ans, i-left)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">max</span><span class=\"params\">(args ...<span class=\"type\">int</span>)</span></span><span class=\"type\">int</span>&#123;</span><br><span class=\"line\">    m := args[<span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, val := <span class=\"keyword\">range</span> args&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> val &gt; m &#123;</span><br><span class=\"line\">            m = val</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"替换后的最长重复字符\"><a href=\"#替换后的最长重复字符\" class=\"headerlink\" title=\"替换后的最长重复字符\"></a>替换后的最长重复字符</h3><blockquote>\n<p>给你一个字符串 s 和一个整数 k 。你可以选择字符串中的任一字符，并将其更改为任何其他大写英文字符。该操作最多可执行 k 次。<br><a href=\"https://leetcode.cn/problems/longest-repeating-character-replacement/\">https://leetcode.cn/problems/longest-repeating-character-replacement/</a></p>\n</blockquote>\n<p>在执行上述操作后，返回包含相同字母的最长子字符串的长度。<br>示例 1：<br>输入：s = “ABAB”, k = 2<br>输出：4<br>解释：用两个’A’替换为两个’B’,反之亦然。<br>示例 2：<br>输入：s = “AABABBA”, k = 1<br>输出：4<br>解释：<br>将中间的一个’A’替换为’B’,字符串变为 “AABBBBA”。<br>子串 “BBBB” 有最长重复字母, 答案为 4。<br> 提示：<br>1 &lt;= s.length &lt;= 105<br>s 仅由大写英文字母组成<br>0 &lt;= k &lt;= s.length</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">characterReplacement</span><span class=\"params\">(s <span class=\"type\">string</span>, k <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// </span></span><br><span class=\"line\">    left, ans := <span class=\"number\">-1</span>,<span class=\"number\">0</span></span><br><span class=\"line\">    max_repeat := <span class=\"number\">0</span></span><br><span class=\"line\">    m := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">byte</span>]<span class=\"type\">int</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(s); i++&#123;</span><br><span class=\"line\">        m[s[i]]++</span><br><span class=\"line\"></span><br><span class=\"line\">        max_repeat = max(m[s[i]],max_repeat)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i-left-max_repeat &gt; k&#123;</span><br><span class=\"line\">            left++</span><br><span class=\"line\">            m[s[left]]--</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        ans = max(ans,i-left)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">max</span><span class=\"params\">(args ...<span class=\"type\">int</span>)</span></span><span class=\"type\">int</span>&#123;</span><br><span class=\"line\">    m := args[<span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, val := <span class=\"keyword\">range</span> args&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> val &gt; m &#123;</span><br><span class=\"line\">            m = val</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"字符流中第一个只出现一次的字符\"><a href=\"#字符流中第一个只出现一次的字符\" class=\"headerlink\" title=\"字符流中第一个只出现一次的字符\"></a>字符流中第一个只出现一次的字符</h3><blockquote>\n<p>请实现一个函数用来找出字符流中第一个只出现一次的字符。<br><a href=\"https://www.acwing.com/problem/content/60/\">https://www.acwing.com/problem/content/60/</a><br>例如，当从字符流中只读出前两个字符 go 时，第一个只出现一次的字符是 g。<br>当从该字符流中读出前六个字符 google 时，第一个只出现一次的字符是 l。<br>如果当前字符流没有存在出现一次的字符，返回 # 字符。<br>数据范围<br>字符流读入字符数量 [0,1000]</p>\n</blockquote>\n<p>样例<br>输入：”google”<br>输出：”ggg#ll”<br>解释：每当字符流读入一个字符，就进行一次判断并输出当前的第一个只出现一次的字符。</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Solution <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    left <span class=\"type\">int</span> <span class=\"comment\">// 最左侧字符位置</span></span><br><span class=\"line\">    cnt  [<span class=\"number\">256</span>]<span class=\"type\">int</span> <span class=\"comment\">// 字符个数计数器</span></span><br><span class=\"line\">    s    <span class=\"type\">string</span> <span class=\"comment\">// 保存输入的字符串</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> s Solution</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">insert</span><span class=\"params\">(ch <span class=\"type\">byte</span>)</span></span> &#123;</span><br><span class=\"line\">    s.cnt[ch]++ <span class=\"comment\">// 将该字符出现次数加1</span></span><br><span class=\"line\">    s.s += <span class=\"type\">string</span>(ch) <span class=\"comment\">// 将该字符加入到字符串s中</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果最左侧的字符出现次数大于1，则将最左侧字符的位置向右移动，直到最左侧字符出现次数为1或者left &gt;= right</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> s.left &lt; <span class=\"built_in\">len</span>(s.s) &amp;&amp; s.cnt[s.s[s.left]] &gt; <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">        s.left++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">firstAppearingOnce</span><span class=\"params\">()</span></span> <span class=\"type\">byte</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果最左侧字符位置left大于等于字符串s的长度，则返回&#x27;#&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> s.left &gt;= <span class=\"built_in\">len</span>(s.s) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&#x27;#&#x27;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 返回最左侧的字符</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> s.s[s.left]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"最多有k个不同字符的最长子字符串\"><a href=\"#最多有k个不同字符的最长子字符串\" class=\"headerlink\" title=\"最多有k个不同字符的最长子字符串\"></a>最多有k个不同字符的最长子字符串</h3><blockquote>\n<p>给定字符串S，找到最多有k个不同字符的最长子串T。<br><a href=\"https://www.lintcode.com/problem/386/\">https://www.lintcode.com/problem/386/</a><br>样例<br>样例 1:</p>\n</blockquote>\n<p>输入: S = “eceba” 并且 k = 3<br>输出: 4<br>解释: T = “eceb”<br>样例 2:</p>\n<p>输入: S = “WORLD” 并且 k = 4<br>输出: 4<br>解释: T = “WORL” 或 “ORLD”<br>挑战<br>O(n) 时间复杂度</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @param s: A string</span></span><br><span class=\"line\"><span class=\"comment\"> * @param k: An integer</span></span><br><span class=\"line\"><span class=\"comment\"> * @return: An integer</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">LengthOfLongestSubstringKDistinct</span><span class=\"params\">(s <span class=\"type\">string</span>, k <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">    left, count,l := <span class=\"number\">-1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    m := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">byte</span>]<span class=\"type\">int</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i:=<span class=\"number\">0</span>; i&lt; <span class=\"built_in\">len</span>(s); i++&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> m[s[i]] == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">            count++</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        m[s[i]]++</span><br><span class=\"line\">        <span class=\"keyword\">for</span> count &gt; k &#123;</span><br><span class=\"line\">            left++</span><br><span class=\"line\">            m[s[left]]--</span><br><span class=\"line\">            <span class=\"keyword\">if</span> m[s[left]] == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">                count--</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        l = max(l,i-left)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> l</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">max</span><span class=\"params\">(args ...<span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span>&#123;</span><br><span class=\"line\">    m := args[<span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, val := <span class=\"keyword\">range</span> args&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> val &gt; m &#123;</span><br><span class=\"line\">            m = val</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"数组中的最长山脉\"><a href=\"#数组中的最长山脉\" class=\"headerlink\" title=\"数组中的最长山脉\"></a>数组中的最长山脉</h3><blockquote>\n<p><a href=\"https://leetcode.cn/problems/longest-mountain-in-array/description/\">https://leetcode.cn/problems/longest-mountain-in-array/description/</a></p>\n</blockquote>\n<p>把符合下列属性的数组 arr 称为 山脉数组 ：</p>\n<p>arr.length &gt;= 3<br>存在下标 i（0 &lt; i &lt; arr.length - 1），满足<br>arr[0] &lt; arr[1] &lt; … &lt; arr[i - 1] &lt; arr[i]<br>arr[i] &gt; arr[i + 1] &gt; … &gt; arr[arr.length - 1]<br>给出一个整数数组 arr，返回最长山脉子数组的长度。如果不存在山脉子数组，返回 0 。<br>示例 1：<br>输入：arr = [2,1,4,7,3,2,5]<br>输出：5<br>解释：最长的山脉子数组是 [1,4,7,3,2]，长度为 5。<br>示例 2：</p>\n<p>输入：arr = [2,2,2]<br>输出：0<br>解释：不存在山脉子数组。<br>提示：<br>1 &lt;= arr.length &lt;= 104<br>0 &lt;= arr[i] &lt;= 104</p>\n<p>进阶：<br>你可以仅用一趟扫描解决此问题吗？<br>你可以用 O(1) 空间解决此问题吗？</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">longestMountain</span><span class=\"params\">(A []<span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    N := <span class=\"built_in\">len</span>(A)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> N &lt; <span class=\"number\">3</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    left := <span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"comment\">// -1表示只有一个元素</span></span><br><span class=\"line\">    <span class=\"comment\">// 0表示正上升</span></span><br><span class=\"line\">    <span class=\"comment\">// 1表示正下降</span></span><br><span class=\"line\">    status := <span class=\"number\">-1</span></span><br><span class=\"line\">    preValue := A[<span class=\"number\">0</span>]</span><br><span class=\"line\">    ans := <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 题目要求必须至少有3个元素，所以不可能从0开始</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">1</span>; i &lt; N; i++ &#123;</span><br><span class=\"line\">        x := A[i]</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 如果要把x加进来</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果里面还只有一个元素</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> status == <span class=\"number\">-1</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> x &gt; preValue &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 那么状态改为上升</span></span><br><span class=\"line\">                status = <span class=\"number\">0</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 如果相等，或者变小，那么区间只能再变成只有一个元素的了</span></span><br><span class=\"line\">                <span class=\"comment\">// 状态依然更新为只有一个元素</span></span><br><span class=\"line\">                status = <span class=\"number\">-1</span></span><br><span class=\"line\">                <span class=\"comment\">// 区间更新为(left, i]</span></span><br><span class=\"line\">                left = i - <span class=\"number\">1</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 如果正在上升</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> status == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> x &gt; preValue &#123;</span><br><span class=\"line\">                <span class=\"comment\">// nothing</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> x == preValue &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 如果相等，那么区间只能再变成只有一个元素的状态了</span></span><br><span class=\"line\">                status = <span class=\"number\">-1</span></span><br><span class=\"line\">                left = i - <span class=\"number\">1</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 下降了</span></span><br><span class=\"line\">                status = <span class=\"number\">1</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 如果正在下降</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> status == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> x &lt; preValue &#123;</span><br><span class=\"line\">                <span class=\"comment\">// nothing</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> x == preValue &#123;</span><br><span class=\"line\">                status = <span class=\"number\">-1</span></span><br><span class=\"line\">                left = i - <span class=\"number\">1</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 如果正在上升</span></span><br><span class=\"line\">                status = <span class=\"number\">0</span></span><br><span class=\"line\">                <span class=\"comment\">// 注意这里left要变成(i - 2, i]</span></span><br><span class=\"line\">                <span class=\"comment\">// 这里已经有两个元素了</span></span><br><span class=\"line\">                left = i - <span class=\"number\">2</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        preValue = x</span><br><span class=\"line\">        <span class=\"keyword\">if</span> status == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">            ans = max(ans, i-left)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ans &gt;= <span class=\"number\">3</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">max</span><span class=\"params\">(args ...<span class=\"type\">int</span>)</span></span><span class=\"type\">int</span>&#123;</span><br><span class=\"line\">    m := args[<span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, val := <span class=\"keyword\">range</span> args&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> val &gt; m &#123;</span><br><span class=\"line\">             m = val</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"3-ensp-例题：区间计数\"><a href=\"#3-ensp-例题：区间计数\" class=\"headerlink\" title=\"3  &ensp; 例题：区间计数\"></a><strong>3</strong>  &ensp; 例题：区间计数</h2><h3 id=\"区间计数\"><a href=\"#区间计数\" class=\"headerlink\" title=\"区间计数\"></a>区间计数</h3><blockquote>\n<p>区间最优原则表示：当按照区间最右边元素划分区间，并找到最优解之后，left继续向有移动形成的短区间都满足条件</p>\n</blockquote>\n<h4 id=\"代码模板\"><a href=\"#代码模板\" class=\"headerlink\" title=\"代码模板\"></a>代码模板</h4><blockquote>\n<p>在求最长区间代码模板上变式</p>\n</blockquote>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">rangeCounter</span><span class=\"params\">(A []<span class=\"type\">int</span>)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 区间的左指针</span></span><br><span class=\"line\">    left,ans := <span class=\"number\">-1</span>,<span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"comment\">// 不变式0： 最开始的区间为(-1，-1] 是一个空区间</span></span><br><span class=\"line\">    <span class=\"comment\">//          我们认为空区间总是满足条件</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i:=<span class=\"number\">0</span>; i&lt;<span class=\"built_in\">len</span>(A); i++&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 不变式1： 在加入A[i]之前，(left,i-1]是一个合法的有效区间</span></span><br><span class=\"line\">        <span class=\"comment\">// 需要改变的部分为下：</span></span><br><span class=\"line\">        <span class=\"comment\">// Step1： 直接将A[i]加入到区间中，形成(left,i]</span></span><br><span class=\"line\">        <span class=\"comment\">// Step2:  将A[i] 加入之后，依据多性原则判断Left是否移动且移动多少</span></span><br><span class=\"line\">        <span class=\"comment\">/** <span class=\"doctag\">TODO:</span> 设计check函数，检查区间是否满足条件</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> check(left,i] &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果不满足条件，则移动左指针</span></span><br><span class=\"line\">            left++</span><br><span class=\"line\">            <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">            <span class=\"doctag\">TODO:</span> 修改区间的状态或者改变区间的性质</span></span><br><span class=\"line\"><span class=\"comment\">            */</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 不变式2： 此时(left,i]必然合法</span></span><br><span class=\"line\">        <span class=\"comment\">// 累计区间个数: 以A[i]为有边界的子区间总共有i-left个</span></span><br><span class=\"line\">        ans = ans + i-left</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"改变区间\"><a href=\"#改变区间\" class=\"headerlink\" title=\"改变区间\"></a>改变区间</h3><blockquote>\n<p><a href=\"https://leetcode.cn/problems/remove-element/submissions/\">27. 移除元素 - 力扣（LeetCode）</a></p>\n</blockquote>\n<h3 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>核心还是双指针，<br>这道题目关键点有三处：</p>\n<ul>\n<li>规整数组的方式：找到数组中与val相同的数时候，让他与数组的右边起第一个不是val的数字交换，这样遍历一次数组之后，所有值等于val的都被移动到了数组的右边</li>\n<li>for 和 if 的嵌套控制：因为是 O(N)复杂度<br>  建议按照   <figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">        <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">### \t代码</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`golang</span></span><br><span class=\"line\"><span class=\"string\">func removeElement(nums []int, val int) int &#123;</span></span><br><span class=\"line\"><span class=\"string\">    right,left := len(nums)-1,0</span></span><br><span class=\"line\"><span class=\"string\">    if right == -1 &#123;</span></span><br><span class=\"line\"><span class=\"string\">        return 0</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">    for left &lt; right &#123;</span></span><br><span class=\"line\"><span class=\"string\">        if nums[right] == val &#123;</span></span><br><span class=\"line\"><span class=\"string\">            right--</span></span><br><span class=\"line\"><span class=\"string\">            continue</span></span><br><span class=\"line\"><span class=\"string\">        &#125;</span></span><br><span class=\"line\"><span class=\"string\">        if nums[left] == val &#123;</span></span><br><span class=\"line\"><span class=\"string\">            nums[left], nums[right] = nums[right],nums[left]</span></span><br><span class=\"line\"><span class=\"string\">            left++</span></span><br><span class=\"line\"><span class=\"string\">            right--</span></span><br><span class=\"line\"><span class=\"string\">            continue</span></span><br><span class=\"line\"><span class=\"string\">        &#125;</span></span><br><span class=\"line\"><span class=\"string\">        left++</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">    if nums[left] != val &#123;</span></span><br><span class=\"line\"><span class=\"string\">        left++</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">    nums = nums[:left]</span></span><br><span class=\"line\"><span class=\"string\">    return len(nums)</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n","site":{"data":{}},"cover":"/img/cover/elderring.png","cover_type":"img","excerpt":"","more":"<h1 id=\"双指针：如何掌握最长、定长、最短区间问题的解题诀窍\"><a href=\"#双指针：如何掌握最长、定长、最短区间问题的解题诀窍\" class=\"headerlink\" title=\"双指针：如何掌握最长、定长、最短区间问题的解题诀窍\"></a>双指针：如何掌握最长、定长、最短区间问题的解题诀窍</h1><blockquote>\n<p>通常是明明用两个指针在数组/链表上遍历，然后解决满足某种性质的问题<br>解决问题：<br><strong>最长区间</strong><br><strong>定长区间</strong><br><strong>最短区间</strong><br><font color = 'red'>1. 弄清楚题目要的是什么样的区间，是上述三种中的哪一类</font><br><font color = 'red'>2. 区间需要满足的条件是什么</font></p>\n</blockquote>\n<h2 id=\"1-ensp-区间特性\"><a href=\"#1-ensp-区间特性\" class=\"headerlink\" title=\"1 &ensp; 区间特性\"></a><strong>1</strong> &ensp; 区间特性</h2><h3 id=\"单调性-amp-最优\"><a href=\"#单调性-amp-最优\" class=\"headerlink\" title=\"单调性 &amp; 最优\"></a>单调性 &amp; 最优</h3><blockquote>\n<p>使用双指针需要保证区间的单调性</p>\n</blockquote>\n<ol>\n<li><p>单调性的定义：<br>区间的单调性： 固定了划分区间的条件之后，遍历区间内的元素，按照一定顺序的时候，区间内的元素应该是都满足某一个条件，且存在问题定义上的大小单调变化。<br>比如： 在一个完全都是正整数的区间里面，划分子集的标准是固定子集右端元素（最右端元素只能是A[i]），集合内元素的和从下标为-1到i-1,均大于某个数，且这个和逐步减少（$\\because 元素都是正数，减少了就变小了$）</p>\n</li>\n<li><p>快速判断区间属性是否满足单调性的办法<br><font color = 'red'> 往区间里面添加元素的时候，区间的约束条件可以变化，但不能出现波折</font><br>理解为： 添加一个元素之后，要么依旧满足条件，符合单调性；要么出现一会不满足一会满足的情况，不符合单调性</p>\n</li>\n</ol>\n<blockquote>\n<p>遍历区间的所有子集可以使用这样的方式： 固定子集的最右边元素为固定元素：<br>固定右区间集合，把A[i]元素固定为区间的右端点，之变动区间的左边界形成的所有区间，并且按照区间长度需要从长到短排列</p>\n</blockquote>\n<ol start=\"3\">\n<li>找到最优解<br><font color = 'red'> 从左向右遍历区间右端固定元素集合中的每个区间，找到一个满足条件的解就停止（因为单调性继续调整依旧满足条件）</font></li>\n</ol>\n<h3 id=\"模板\"><a href=\"#模板\" class=\"headerlink\" title=\"模板\"></a>模板</h3><ol>\n<li><p>寻找以A[i]为有边界的最优解，分为以下三步</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Step <span class=\"number\">1</span> :</span><br><span class=\"line\">将A[i] 加入到区间中，形成新的区间 （left,i]</span><br><span class=\"line\">room = <span class=\"built_in\">append</span>(room,A[i])</span><br><span class=\"line\"></span><br><span class=\"line\">Step <span class=\"number\">2</span>：</span><br><span class=\"line\">遍历A[i]的固定右区间集，直到找到以A[i]为右端点的最优解</span><br><span class=\"line\"><span class=\"keyword\">for</span> left &lt; i &amp;&amp; (left,i] 区间不满足要求 &#123;</span><br><span class=\"line\">    left++</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\">Step <span class=\"number\">3</span>:</span><br><span class=\"line\">此时要么得到一个满足要求的解，要么没有满足单调性的区间</span><br><span class=\"line\">(left,i]区间满足要求</span><br></pre></td></tr></table></figure></li>\n<li><p>题目须具备的条件</p>\n<ul>\n<li>给定一个条件</li>\n<li>求最长区间/最长字串</li>\n<li>题目给出的区间需要具备的单调性</li>\n</ul>\n</li>\n<li><p>必杀技</p>\n<ul>\n<li>left，right 指针</li>\n<li>只有在不满足条件的时候才向右移动left指针</li>\n</ul>\n</li>\n<li><p>最长区间的代码模板</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">maxLength</span><span class=\"params\">(A []<span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建左指针和结果</span></span><br><span class=\"line\">    left, ans := <span class=\"number\">-1</span>, <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 从左向右遍历区间</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i:= <span class=\"number\">0</span>; i&lt; <span class=\"built_in\">len</span>(A); i++&#123;</span><br><span class=\"line\">        <span class=\"comment\">// Assert 在加入 A[i] 之前，(left,i-1] 是一个合法有效的区间，在最开始的时候left = -1，i-1=-1，是空区间，满足条件</span></span><br><span class=\"line\">        <span class=\"comment\">// Step1 : 直接将A[i]加到区间中，形成(left,i]</span></span><br><span class=\"line\">        <span class=\"comment\">// step2 : 将A[I]加入之后，依据left的惰性yuanze</span></span><br><span class=\"line\">        <span class=\"comment\">// <span class=\"doctag\">TODO:</span> check检查区间状态是否满足条件</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> check(left,i) &#123;</span><br><span class=\"line\">            left++<span class=\"comment\">// 如果不满足条件，移动左指针</span></span><br><span class=\"line\">            <span class=\"comment\">// TODO： 修改区间的状态</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// assert 此时的(left,i] 必然满足条件</span></span><br><span class=\"line\">        ans = max(ans,i-left)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 返回最优解</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>时间复杂度为 O(n)</p>\n<h2 id=\"2-ensp-例题-区间长度类型\"><a href=\"#2-ensp-例题-区间长度类型\" class=\"headerlink\" title=\"2 &ensp; 例题: 区间长度类型\"></a><strong>2</strong> &ensp; 例题: 区间长度类型</h2><h3 id=\"不含重复字符的最长区间\"><a href=\"#不含重复字符的最长区间\" class=\"headerlink\" title=\"不含重复字符的最长区间\"></a>不含重复字符的最长区间</h3><blockquote>\n<p>单调性： 当找到一个没有重复字符的区间时候，减少区间内元素，新的区间依旧满足没有重复元素<br><a href=\"https://leetcode.cn/problems/longest-substring-without-repeating-characters/\">https://leetcode.cn/problems/longest-substring-without-repeating-characters/</a></p>\n</blockquote>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(s <span class=\"type\">string</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 双指针解决</span></span><br><span class=\"line\">    left, ans := <span class=\"number\">-1</span>,<span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"comment\">// 存储区间内元素的映射</span></span><br><span class=\"line\">    m := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">byte</span>]<span class=\"type\">int</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt;<span class=\"built_in\">len</span>(s); i++ &#123;</span><br><span class=\"line\">        m[s[i]] += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> m[s[i]] &gt; <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">            left++</span><br><span class=\"line\">            m[s[left]]--</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ans = max(ans, i-left)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">max</span><span class=\"params\">(args ...<span class=\"type\">int</span>)</span></span><span class=\"type\">int</span>&#123;</span><br><span class=\"line\">    m := args[<span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, val := <span class=\"keyword\">range</span> args&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> val &gt; m &#123;</span><br><span class=\"line\">            m = val</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"替换后的最长重复字符\"><a href=\"#替换后的最长重复字符\" class=\"headerlink\" title=\"替换后的最长重复字符\"></a>替换后的最长重复字符</h3><blockquote>\n<p>给你一个字符串 s 和一个整数 k 。你可以选择字符串中的任一字符，并将其更改为任何其他大写英文字符。该操作最多可执行 k 次。<br><a href=\"https://leetcode.cn/problems/longest-repeating-character-replacement/\">https://leetcode.cn/problems/longest-repeating-character-replacement/</a></p>\n</blockquote>\n<p>在执行上述操作后，返回包含相同字母的最长子字符串的长度。<br>示例 1：<br>输入：s = “ABAB”, k = 2<br>输出：4<br>解释：用两个’A’替换为两个’B’,反之亦然。<br>示例 2：<br>输入：s = “AABABBA”, k = 1<br>输出：4<br>解释：<br>将中间的一个’A’替换为’B’,字符串变为 “AABBBBA”。<br>子串 “BBBB” 有最长重复字母, 答案为 4。<br> 提示：<br>1 &lt;= s.length &lt;= 105<br>s 仅由大写英文字母组成<br>0 &lt;= k &lt;= s.length</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">characterReplacement</span><span class=\"params\">(s <span class=\"type\">string</span>, k <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// </span></span><br><span class=\"line\">    left, ans := <span class=\"number\">-1</span>,<span class=\"number\">0</span></span><br><span class=\"line\">    max_repeat := <span class=\"number\">0</span></span><br><span class=\"line\">    m := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">byte</span>]<span class=\"type\">int</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(s); i++&#123;</span><br><span class=\"line\">        m[s[i]]++</span><br><span class=\"line\"></span><br><span class=\"line\">        max_repeat = max(m[s[i]],max_repeat)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i-left-max_repeat &gt; k&#123;</span><br><span class=\"line\">            left++</span><br><span class=\"line\">            m[s[left]]--</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        ans = max(ans,i-left)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">max</span><span class=\"params\">(args ...<span class=\"type\">int</span>)</span></span><span class=\"type\">int</span>&#123;</span><br><span class=\"line\">    m := args[<span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, val := <span class=\"keyword\">range</span> args&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> val &gt; m &#123;</span><br><span class=\"line\">            m = val</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"字符流中第一个只出现一次的字符\"><a href=\"#字符流中第一个只出现一次的字符\" class=\"headerlink\" title=\"字符流中第一个只出现一次的字符\"></a>字符流中第一个只出现一次的字符</h3><blockquote>\n<p>请实现一个函数用来找出字符流中第一个只出现一次的字符。<br><a href=\"https://www.acwing.com/problem/content/60/\">https://www.acwing.com/problem/content/60/</a><br>例如，当从字符流中只读出前两个字符 go 时，第一个只出现一次的字符是 g。<br>当从该字符流中读出前六个字符 google 时，第一个只出现一次的字符是 l。<br>如果当前字符流没有存在出现一次的字符，返回 # 字符。<br>数据范围<br>字符流读入字符数量 [0,1000]</p>\n</blockquote>\n<p>样例<br>输入：”google”<br>输出：”ggg#ll”<br>解释：每当字符流读入一个字符，就进行一次判断并输出当前的第一个只出现一次的字符。</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Solution <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    left <span class=\"type\">int</span> <span class=\"comment\">// 最左侧字符位置</span></span><br><span class=\"line\">    cnt  [<span class=\"number\">256</span>]<span class=\"type\">int</span> <span class=\"comment\">// 字符个数计数器</span></span><br><span class=\"line\">    s    <span class=\"type\">string</span> <span class=\"comment\">// 保存输入的字符串</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> s Solution</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">insert</span><span class=\"params\">(ch <span class=\"type\">byte</span>)</span></span> &#123;</span><br><span class=\"line\">    s.cnt[ch]++ <span class=\"comment\">// 将该字符出现次数加1</span></span><br><span class=\"line\">    s.s += <span class=\"type\">string</span>(ch) <span class=\"comment\">// 将该字符加入到字符串s中</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果最左侧的字符出现次数大于1，则将最左侧字符的位置向右移动，直到最左侧字符出现次数为1或者left &gt;= right</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> s.left &lt; <span class=\"built_in\">len</span>(s.s) &amp;&amp; s.cnt[s.s[s.left]] &gt; <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">        s.left++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">firstAppearingOnce</span><span class=\"params\">()</span></span> <span class=\"type\">byte</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果最左侧字符位置left大于等于字符串s的长度，则返回&#x27;#&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> s.left &gt;= <span class=\"built_in\">len</span>(s.s) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&#x27;#&#x27;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 返回最左侧的字符</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> s.s[s.left]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"最多有k个不同字符的最长子字符串\"><a href=\"#最多有k个不同字符的最长子字符串\" class=\"headerlink\" title=\"最多有k个不同字符的最长子字符串\"></a>最多有k个不同字符的最长子字符串</h3><blockquote>\n<p>给定字符串S，找到最多有k个不同字符的最长子串T。<br><a href=\"https://www.lintcode.com/problem/386/\">https://www.lintcode.com/problem/386/</a><br>样例<br>样例 1:</p>\n</blockquote>\n<p>输入: S = “eceba” 并且 k = 3<br>输出: 4<br>解释: T = “eceb”<br>样例 2:</p>\n<p>输入: S = “WORLD” 并且 k = 4<br>输出: 4<br>解释: T = “WORL” 或 “ORLD”<br>挑战<br>O(n) 时间复杂度</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @param s: A string</span></span><br><span class=\"line\"><span class=\"comment\"> * @param k: An integer</span></span><br><span class=\"line\"><span class=\"comment\"> * @return: An integer</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">LengthOfLongestSubstringKDistinct</span><span class=\"params\">(s <span class=\"type\">string</span>, k <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">    left, count,l := <span class=\"number\">-1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    m := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">byte</span>]<span class=\"type\">int</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i:=<span class=\"number\">0</span>; i&lt; <span class=\"built_in\">len</span>(s); i++&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> m[s[i]] == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">            count++</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        m[s[i]]++</span><br><span class=\"line\">        <span class=\"keyword\">for</span> count &gt; k &#123;</span><br><span class=\"line\">            left++</span><br><span class=\"line\">            m[s[left]]--</span><br><span class=\"line\">            <span class=\"keyword\">if</span> m[s[left]] == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">                count--</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        l = max(l,i-left)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> l</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">max</span><span class=\"params\">(args ...<span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span>&#123;</span><br><span class=\"line\">    m := args[<span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, val := <span class=\"keyword\">range</span> args&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> val &gt; m &#123;</span><br><span class=\"line\">            m = val</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"数组中的最长山脉\"><a href=\"#数组中的最长山脉\" class=\"headerlink\" title=\"数组中的最长山脉\"></a>数组中的最长山脉</h3><blockquote>\n<p><a href=\"https://leetcode.cn/problems/longest-mountain-in-array/description/\">https://leetcode.cn/problems/longest-mountain-in-array/description/</a></p>\n</blockquote>\n<p>把符合下列属性的数组 arr 称为 山脉数组 ：</p>\n<p>arr.length &gt;= 3<br>存在下标 i（0 &lt; i &lt; arr.length - 1），满足<br>arr[0] &lt; arr[1] &lt; … &lt; arr[i - 1] &lt; arr[i]<br>arr[i] &gt; arr[i + 1] &gt; … &gt; arr[arr.length - 1]<br>给出一个整数数组 arr，返回最长山脉子数组的长度。如果不存在山脉子数组，返回 0 。<br>示例 1：<br>输入：arr = [2,1,4,7,3,2,5]<br>输出：5<br>解释：最长的山脉子数组是 [1,4,7,3,2]，长度为 5。<br>示例 2：</p>\n<p>输入：arr = [2,2,2]<br>输出：0<br>解释：不存在山脉子数组。<br>提示：<br>1 &lt;= arr.length &lt;= 104<br>0 &lt;= arr[i] &lt;= 104</p>\n<p>进阶：<br>你可以仅用一趟扫描解决此问题吗？<br>你可以用 O(1) 空间解决此问题吗？</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">longestMountain</span><span class=\"params\">(A []<span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    N := <span class=\"built_in\">len</span>(A)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> N &lt; <span class=\"number\">3</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    left := <span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"comment\">// -1表示只有一个元素</span></span><br><span class=\"line\">    <span class=\"comment\">// 0表示正上升</span></span><br><span class=\"line\">    <span class=\"comment\">// 1表示正下降</span></span><br><span class=\"line\">    status := <span class=\"number\">-1</span></span><br><span class=\"line\">    preValue := A[<span class=\"number\">0</span>]</span><br><span class=\"line\">    ans := <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 题目要求必须至少有3个元素，所以不可能从0开始</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">1</span>; i &lt; N; i++ &#123;</span><br><span class=\"line\">        x := A[i]</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 如果要把x加进来</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果里面还只有一个元素</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> status == <span class=\"number\">-1</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> x &gt; preValue &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 那么状态改为上升</span></span><br><span class=\"line\">                status = <span class=\"number\">0</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 如果相等，或者变小，那么区间只能再变成只有一个元素的了</span></span><br><span class=\"line\">                <span class=\"comment\">// 状态依然更新为只有一个元素</span></span><br><span class=\"line\">                status = <span class=\"number\">-1</span></span><br><span class=\"line\">                <span class=\"comment\">// 区间更新为(left, i]</span></span><br><span class=\"line\">                left = i - <span class=\"number\">1</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 如果正在上升</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> status == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> x &gt; preValue &#123;</span><br><span class=\"line\">                <span class=\"comment\">// nothing</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> x == preValue &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 如果相等，那么区间只能再变成只有一个元素的状态了</span></span><br><span class=\"line\">                status = <span class=\"number\">-1</span></span><br><span class=\"line\">                left = i - <span class=\"number\">1</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 下降了</span></span><br><span class=\"line\">                status = <span class=\"number\">1</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 如果正在下降</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> status == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> x &lt; preValue &#123;</span><br><span class=\"line\">                <span class=\"comment\">// nothing</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> x == preValue &#123;</span><br><span class=\"line\">                status = <span class=\"number\">-1</span></span><br><span class=\"line\">                left = i - <span class=\"number\">1</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 如果正在上升</span></span><br><span class=\"line\">                status = <span class=\"number\">0</span></span><br><span class=\"line\">                <span class=\"comment\">// 注意这里left要变成(i - 2, i]</span></span><br><span class=\"line\">                <span class=\"comment\">// 这里已经有两个元素了</span></span><br><span class=\"line\">                left = i - <span class=\"number\">2</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        preValue = x</span><br><span class=\"line\">        <span class=\"keyword\">if</span> status == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">            ans = max(ans, i-left)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ans &gt;= <span class=\"number\">3</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">max</span><span class=\"params\">(args ...<span class=\"type\">int</span>)</span></span><span class=\"type\">int</span>&#123;</span><br><span class=\"line\">    m := args[<span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, val := <span class=\"keyword\">range</span> args&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> val &gt; m &#123;</span><br><span class=\"line\">             m = val</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"3-ensp-例题：区间计数\"><a href=\"#3-ensp-例题：区间计数\" class=\"headerlink\" title=\"3  &ensp; 例题：区间计数\"></a><strong>3</strong>  &ensp; 例题：区间计数</h2><h3 id=\"区间计数\"><a href=\"#区间计数\" class=\"headerlink\" title=\"区间计数\"></a>区间计数</h3><blockquote>\n<p>区间最优原则表示：当按照区间最右边元素划分区间，并找到最优解之后，left继续向有移动形成的短区间都满足条件</p>\n</blockquote>\n<h4 id=\"代码模板\"><a href=\"#代码模板\" class=\"headerlink\" title=\"代码模板\"></a>代码模板</h4><blockquote>\n<p>在求最长区间代码模板上变式</p>\n</blockquote>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">rangeCounter</span><span class=\"params\">(A []<span class=\"type\">int</span>)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 区间的左指针</span></span><br><span class=\"line\">    left,ans := <span class=\"number\">-1</span>,<span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"comment\">// 不变式0： 最开始的区间为(-1，-1] 是一个空区间</span></span><br><span class=\"line\">    <span class=\"comment\">//          我们认为空区间总是满足条件</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i:=<span class=\"number\">0</span>; i&lt;<span class=\"built_in\">len</span>(A); i++&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 不变式1： 在加入A[i]之前，(left,i-1]是一个合法的有效区间</span></span><br><span class=\"line\">        <span class=\"comment\">// 需要改变的部分为下：</span></span><br><span class=\"line\">        <span class=\"comment\">// Step1： 直接将A[i]加入到区间中，形成(left,i]</span></span><br><span class=\"line\">        <span class=\"comment\">// Step2:  将A[i] 加入之后，依据多性原则判断Left是否移动且移动多少</span></span><br><span class=\"line\">        <span class=\"comment\">/** <span class=\"doctag\">TODO:</span> 设计check函数，检查区间是否满足条件</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> check(left,i] &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果不满足条件，则移动左指针</span></span><br><span class=\"line\">            left++</span><br><span class=\"line\">            <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">            <span class=\"doctag\">TODO:</span> 修改区间的状态或者改变区间的性质</span></span><br><span class=\"line\"><span class=\"comment\">            */</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 不变式2： 此时(left,i]必然合法</span></span><br><span class=\"line\">        <span class=\"comment\">// 累计区间个数: 以A[i]为有边界的子区间总共有i-left个</span></span><br><span class=\"line\">        ans = ans + i-left</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"改变区间\"><a href=\"#改变区间\" class=\"headerlink\" title=\"改变区间\"></a>改变区间</h3><blockquote>\n<p><a href=\"https://leetcode.cn/problems/remove-element/submissions/\">27. 移除元素 - 力扣（LeetCode）</a></p>\n</blockquote>\n<h3 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h3><p>核心还是双指针，<br>这道题目关键点有三处：</p>\n<ul>\n<li>规整数组的方式：找到数组中与val相同的数时候，让他与数组的右边起第一个不是val的数字交换，这样遍历一次数组之后，所有值等于val的都被移动到了数组的右边</li>\n<li>for 和 if 的嵌套控制：因为是 O(N)复杂度<br>  建议按照   <figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">        <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">### \t代码</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`golang</span></span><br><span class=\"line\"><span class=\"string\">func removeElement(nums []int, val int) int &#123;</span></span><br><span class=\"line\"><span class=\"string\">    right,left := len(nums)-1,0</span></span><br><span class=\"line\"><span class=\"string\">    if right == -1 &#123;</span></span><br><span class=\"line\"><span class=\"string\">        return 0</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">    for left &lt; right &#123;</span></span><br><span class=\"line\"><span class=\"string\">        if nums[right] == val &#123;</span></span><br><span class=\"line\"><span class=\"string\">            right--</span></span><br><span class=\"line\"><span class=\"string\">            continue</span></span><br><span class=\"line\"><span class=\"string\">        &#125;</span></span><br><span class=\"line\"><span class=\"string\">        if nums[left] == val &#123;</span></span><br><span class=\"line\"><span class=\"string\">            nums[left], nums[right] = nums[right],nums[left]</span></span><br><span class=\"line\"><span class=\"string\">            left++</span></span><br><span class=\"line\"><span class=\"string\">            right--</span></span><br><span class=\"line\"><span class=\"string\">            continue</span></span><br><span class=\"line\"><span class=\"string\">        &#125;</span></span><br><span class=\"line\"><span class=\"string\">        left++</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">    if nums[left] != val &#123;</span></span><br><span class=\"line\"><span class=\"string\">        left++</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">    nums = nums[:left]</span></span><br><span class=\"line\"><span class=\"string\">    return len(nums)</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n"},{"title":"Golang-数据结构-链表","catalog":true,"date":"2023-04-01T16:46:21.000Z","subtitle":null,"header-img":null,"_content":"\n# Golang  操作链表\n\n> 越是简单的内容越需要熟练的掌握，自己做自己的 chatgpt,\n>\n> 越是基础的内容越需要细细的追究，避免重复造轮子\n\n链表常见的使用场景和问题：\n\n```mermaid\ngraph TD\nA[链表]-->B[内核消息队列]\nA-->C[缓存管理]\nA-->D[跳表]\nA-->E[B+ 树]\n```\n\n由于链表的非连续性和一定程度上的方向性，在边界问题以及实际应用当中的细微问题较多，暴力的解法往往容易全盘皆错，且实际应用当中也会存在不少的问题。\n\n本文将关注如何做到规范化解决链表问题，在部分解决类型上结合 Golang 的特性来做特有的实现。\n\n\n\n## 链表的基础结构模板\n\n链表节点需要包含一个值和一个指向下一个节点的指针，简单的示例如下\n\n``` golang\ntype ListNode struct{\n    Val int\n    Next *ListeNode\n}\n```\n\n当想要实现双向链表的时候则需要添加一个指向前一个结点的指针\n\n```go\ntype ListNode struct{\n    Val int\n    Pre *ListNode\n    Next *ListNode\n}\n\ntype linkList struct{\n    head *ListNode\n    tail *ListNode\n    l int\n}\n```\n\n简单，但在边界问题和实际使用时侯容易弄错一些地方，在此告诫\n\n1. **ListNode 是 value type**, 在 Golang 当中 struct 对象是一种值类型（value type），而不是指针类型（pointer type）。这意味着，当定义并初始化一个 struct 变量时，它实际上拥有自己的内存空间，而不是仅仅是指向某个内存地址的指针。当按值传递 struct 变量时，函数会复制一份该变量的副本，而不是传递变量的指针。\n\n   但是 ListNode 内部变量需要的是指针类型，指向链表节点分配的地址，所以在初始化上需要注意几个形式：\n\n   ```go\n   // l 获得一个指针\n   l := new(ListNode{})\n   l := &ListNode{}\n   \n   // l 获得一个对象\n   l := ListNode{}\n   // 三者输出的结果为：\n   // l is {0 <nil>}\n   // l is &{0 <nil>}\n   // l is &{0 <nil>}\n   \n   // 自己构造函数返回的是一个指针类型, 这个函数是一个模板\n   func newListNode() *ListNode{\n       return &ListNode{\n           val: 0,\n           next: nil,\n       }\n   }\n   // 返回结果：l is &{0 <nil>}\n   ```\n\n   只理解到这里作为平时使用是足够的，但是应用时候一部分人可能因为不知道Go编译器的自动解引用，而导致指针类型和值类型混用时候分不清。\n   \n   比如以下的情况是不会报错的：\n   \n   ```go\n   \tl := ListNode{}\n   \tl1 := &ListNode{}\n   \tfmt.Printf(\"l is %v\\n\", l.val)\n   \tfmt.Printf(\"l1 is %v\\n\", l1.val)\n   /** 输出结果为：\n   l is 0\n   l1 is 0\n   */\n   ```\n   \n   当创建了 &ListNode{} 变量之后，如果需要调用 ListNode  结构的方法和结构体字段，并不需要使用 (*l).val来获取变量，这里其中实际上是发生了自动解引用，编译器会自动将指针解引用并访问结构体字段。\n   \n   其实从使用来说，就对于字段访问并不会体现出很大问题，但是当我们把链表节点转化为interface时候，当定义了方法之后，在调用时候就会出现报错：\n   \n   ```go\n   \ttype StructF interface{}\n   \tfunc (st *StructF) printData() {\n       \tfmt.Println(\"yes\")\n   \t}    \n   \tst1 := StructF{}\n       var it2 InterfaceTest = st1  // 编译出错\n       it2.printData()\n   ```\n   \n   在上述的结构体访问例子当中，指针和对象值调用时候的接收器是默认的，golang 帮我们完成了相对应的解引用和取引用，情况如下：\n   \n   - 用**值类型**的实参调用形参为**值类型**的方法\n   - 用**指针类型**的实参调用形参为**值类型**的方法（会进行“自动解引用”）\n   - 用**值类型**的实参调用形参为**指针类型**的方法（会进行“自动取引用”）\n   - 用**指针类型**的实参调用形参为**指针类型**的方法\n   \n   而上述例子中我们定义的是interface,当我们编写的代码想要对外暴露服务的时候，传入参数是值类型Golang会自动生成一个对应类型指针的函数方法，但是传入参数是指针类型时候，Golang 则不会重新为这个方法生成值类型的方法。\n   \n   在这里需要明确的是：\n   \n   >* go语言只有值传递，指针也是值传递。\n   >\n   >* 对于一个类来说，其**值类型**的方法会自动生成相应的**指针类型**的方法，而指针类型的方法**不会**自动生成相应的值类型的方法\n   >* 结构体类型对于值和指针不加区别（对外暴露使用），但是使用接口对外暴露的时候，值类型会兼容指针类型，但是指针类型不兼容值类型，从而实现对指针的保护，同时实现指针类型的容错。\n   \n   算是一类语法糖\n\n### 链表操作基础模板\n\n这里考虑使用假头/假尾的方式来实现，实际上也有参考 k+1 循环队列思想，可以以这样的方式避免很多的空指针问题,不过循环队列是使用取模的方式计算下标，链表则在空间上有更多的自由性。\n\n假头通常也叫做 \" Dummy Head\" 或者 \"哑头\"，是在链表前面，加上一个额外的节点。\n\n> 非常推荐以后在写项目或者是接口方法时候，先定义出它对应的 interface,确定输入输出，尽可能保证方法之间是正交的。\n\n```golang\ntype ListNode struct{\n    Val int\n    Next *ListNode\n}\n\ntype list struct{\n    head *ListNode\n    tail *ListNode\n    l int\n}\n\n// 常见的链表操作定义\ntype linkList interface{\n    /** 初始化 \n    ** new 出一个链表节点并使head和tail都指向这个节点，长度值设置为0\n    */\n    newList() *List\n    \n    //查找结点，input key get val\n    /** 一般返回所查找结点的前一个节点，如果没有查找到这个节点，应该返回head\n    ** 1. 初始化 front， back指针，分别指向一前一后\n    ** 2. 在查找的时候， front 总是和 back 一起走\n    ** 3. 返回前置节点（自己实现的查找函数）\n    ** 4. 服务要求的查找函数调用获取到前置节点地址，则目标节点为 p.Next\n    */\n    get(key int)value int\n    \n    /** 在尾部追加节点, input val\n    ** 1. 在尾部添加一个新的节点\n    ** 2. 移动tail指针\n    ** 3. 链表的长度加1\n    */\n    addAtEnd(val int)\n    /** 在头部插入节点, input val\n    ** 1. 新节点 p.Next 指向 head.Next\n    ** 2. head.Next 指向 p\n    ** 3. 如果原来的 tail 指向 head 所指向节点，那么就将 tail 指向 p\n    */\n    addAtHead(val int)  \n    \n    // 在指定位置前插入, input key & val\n    /** 一般返回所查找结点的前一个节点，如果没有查找到这个节点，应该返回head\n    ** 一般存在四种情况：\n    ** 1. 如果 index 大于链表长度，则不会插入节点；\n    ** 2. 如果 index 等于链表长度，则将该结点附加到链表的末尾 \n    ** 3. 如果 index 小于 0 ，则在头部插入节点 \n    ** 4. 否则在指定位置前面插入节点\n    ** \t4.1  得到 index 之前的节点 pre --> 使用 get 函数\n    **  4.2  在 pre 后面添加新的节点\n    **  4.3  修改 list 的长度\n    ** [插入节点的时候，一定先把pre的next值赋值给p的Next，然后再把pre的next指向p，否则后半链表就无了]\n    */\n    addAtIndex(key int, val int)\n    // 删除节点， input key\n    /** \n    ** 1. 判断 index 是否有效： index < 0 || index >= l 就直接返回[因为index应该是计算的从0-n-1才对]\n    ** 2. 如果 index 合法\n    ** \t找到 index 前面的节点\n    **  如果要删除的节点是最后一个，那么需要修改tail指针\n    **  执行删除操作，并修改链表的长度\n    */\n    deleteAtIndex(key int)   \n}\n```\n\n具体实现\n\n```golang\npackage linklist\n\nimport (\n\t\"fmt\"\n)\n\n// 链表节点定义\ntype linkNode struct {\n\tval  int\n\tnext *linkNode\n}\n\n// 链表定义\ntype MyLinkedList struct {\n\thead   *linkNode\n\ttail   *linkNode\n\tlength int\n}\n\n// 链表构造函数定义，\n// 初始化 dummy head 的时候，val设置为-1，指针指向 nil\nfunc Constructor() MyLinkedList {\n    // 一定注意使用 &linknode{}获取地址，return 值按题目要求来创建\n\tnode := &linkNode{\n\t\tval:  -1,\n\t\tnext: nil,\n\t}\n\treturn MyLinkedList{\n\t\thead:   node,\n\t\ttail:   node,\n\t\tlength: 0,\n\t}\n}\n\n// 创建新的节点并加入在假头节点之后\nfunc (list *MyLinkedList) AddAtHead(val int) {\n    // 不判断边界条件\n\tnode := &linkNode{\n\t\tval:  val,\n\t\tnext: nil,\n\t}\n\tnode.next = list.head.next\n\tlist.head.next = node\n    // 关注点1 ： 一定要判断是否当前tail等于head，\n\tif list.head == list.tail {\n\t\tlist.tail = node\n\t}\n    // 关注点2： 一定记得维护链表的长度属性\n\tlist.length++\n}\n\n// 创建新的节点并加在尾指针之后\nfunc (list *MyLinkedList) AddAtTail(val int) {\n    // 不需要判断条件\n\tlist.tail.next = &linkNode{\n\t\tval:  val,\n\t\tnext: nil,\n\t}\n\tlist.tail = list.tail.next\n    // 关注点2： 一定记得维护链表的长度属性\n\tlist.length++\n}\n\n// 获取 index 节点的前一个节点\nfunc (list *MyLinkedList) GetPre(index int) *linkNode {\n    // 不需要判断，因为边界条件在调用的时候都是特殊情况\n\tnow := list.head.next\n\tpre := list.head\n    // 注意点4： 不要弄反了 now 和 pre 的位置\n\tfor i := 0; i < index; i++ {\n\t\tpre = now\n\t\tnow = now.next\n\t}\n\treturn pre\n}\n\n// 获取 index 位置节点的值\nfunc (list *MyLinkedList) Get(index int) int {\n    // 判断边界条件： index < 0 和 index > list.length都是超出的链表的范围\n\tif index < 0 || index >= list.length {\n\t\treturn -1\n\t}\n\tpre := list.GetPre(index)\n\treturn pre.next.val\n}\n\n\n// 在 index 位置的前一个位置插入节点\nfunc (list *MyLinkedList) AddAtIndex(index int, val int) {\n\tif index > list.length {\n\t\treturn\n\t}\n\tif index == list.length {\n\t\tlist.AddAtTail(val)\n\t\treturn\n\t}\n\tif index <= 0 {\n\t\tlist.AddAtHead(val)\n\t\treturn\n\t}\n\tpre := list.GetPre(index)\n\tnode := &linkNode{\n\t\tval:  val,\n\t\tnext: nil,\n\t}\n\tnode.next = pre.next\n\tpre.next = node\n    // 注意点2： 维护链表的属性\n\tlist.length++\n}\n\nfunc (list *MyLinkedList) DeleteAtIndex(index int) {\n\tif index < 0 || index >= list.length {\n\t\treturn\n\t}\n\tpre := list.GetPre(index)\n    // 注意点3： 删除时候需要考虑最后一个结点的情况\n\tif list.tail == pre.next {\n\t\tlist.tail = pre\n\t}\n\tpre.next = pre.next.next\n\tlist.length--\n}\n\nfunc (list *MyLinkedList) PrintList() {\n\tnow := list.head.next\n\tfor now != nil {\n\t\tif now == list.tail {\n\t\t\tfmt.Printf(\"%d=\\n\", now.val)\n\t\t\tbreak\n\t\t}\n\t\tfmt.Printf(\"%d=\", now.val)\n\t\tnow = now.next\n\t}\n}\n```\n\n### 链表操作参考\n\n参考 `container/list` 的实现\n\n```golang\n// Package list implements a doubly linked list.\n//\n// To iterate over a list (where l is a *List):\n//\n//\tfor e := l.Front(); e != nil; e = e.Next() {\n//\t\t// do something with e.Value\n//\t}\npackage list\n\n// Element is an element of a linked list.\ntype Element struct {\n\t// Next and previous pointers in the doubly-linked list of elements.\n\t// To simplify the implementation, internally a list l is implemented\n\t// as a ring, such that &l.root is both the next element of the last\n\t// list element (l.Back()) and the previous element of the first list\n\t// element (l.Front()).\n\tnext, prev *Element\n\n\t// The list to which this element belongs.\n\tlist *List\n\n\t// The value stored with this element.\n\tValue any\n}\n\n// Next returns the next list element or nil.\nfunc (e *Element) Next() *Element {\n\tif p := e.next; e.list != nil && p != &e.list.root {\n\t\treturn p\n\t}\n\treturn nil\n}\n\n// Prev returns the previous list element or nil.\nfunc (e *Element) Prev() *Element {\n\tif p := e.prev; e.list != nil && p != &e.list.root {\n\t\treturn p\n\t}\n\treturn nil\n}\n\n// List represents a doubly linked list.\n// The zero value for List is an empty list ready to use.\ntype List struct {\n\troot Element // sentinel list element, only &root, root.prev, and root.next are used\n\tlen  int     // current list length excluding (this) sentinel element\n}\n\n// Init initializes or clears list l.\nfunc (l *List) Init() *List {\n\tl.root.next = &l.root\n\tl.root.prev = &l.root\n\tl.len = 0\n\treturn l\n}\n\n// New returns an initialized list.\nfunc New() *List { return new(List).Init() }\n\n// Len returns the number of elements of list l.\n// The complexity is O(1).\nfunc (l *List) Len() int { return l.len }\n\n// Front returns the first element of list l or nil if the list is empty.\nfunc (l *List) Front() *Element {\n\tif l.len == 0 {\n\t\treturn nil\n\t}\n\treturn l.root.next\n}\n\n// Back returns the last element of list l or nil if the list is empty.\nfunc (l *List) Back() *Element {\n\tif l.len == 0 {\n\t\treturn nil\n\t}\n\treturn l.root.prev\n}\n\n// lazyInit lazily initializes a zero List value.\nfunc (l *List) lazyInit() {\n\tif l.root.next == nil {\n\t\tl.Init()\n\t}\n}\n\n// insert inserts e after at, increments l.len, and returns e.\nfunc (l *List) insert(e, at *Element) *Element {\n\te.prev = at\n\te.next = at.next\n\te.prev.next = e\n\te.next.prev = e\n\te.list = l\n\tl.len++\n\treturn e\n}\n\n// insertValue is a convenience wrapper for insert(&Element{Value: v}, at).\nfunc (l *List) insertValue(v any, at *Element) *Element {\n\treturn l.insert(&Element{Value: v}, at)\n}\n\n// remove removes e from its list, decrements l.len\nfunc (l *List) remove(e *Element) {\n\te.prev.next = e.next\n\te.next.prev = e.prev\n\te.next = nil // avoid memory leaks\n\te.prev = nil // avoid memory leaks\n\te.list = nil\n\tl.len--\n}\n\n// move moves e to next to at.\nfunc (l *List) move(e, at *Element) {\n\tif e == at {\n\t\treturn\n\t}\n\te.prev.next = e.next\n\te.next.prev = e.prev\n\n\te.prev = at\n\te.next = at.next\n\te.prev.next = e\n\te.next.prev = e\n}\n\n// Remove removes e from l if e is an element of list l.\n// It returns the element value e.Value.\n// The element must not be nil.\nfunc (l *List) Remove(e *Element) any {\n\tif e.list == l {\n\t\t// if e.list == l, l must have been initialized when e was inserted\n\t\t// in l or l == nil (e is a zero Element) and l.remove will crash\n\t\tl.remove(e)\n\t}\n\treturn e.Value\n}\n\n// PushFront inserts a new element e with value v at the front of list l and returns e.\nfunc (l *List) PushFront(v any) *Element {\n\tl.lazyInit()\n\treturn l.insertValue(v, &l.root)\n}\n\n// PushBack inserts a new element e with value v at the back of list l and returns e.\nfunc (l *List) PushBack(v any) *Element {\n\tl.lazyInit()\n\treturn l.insertValue(v, l.root.prev)\n}\n\n// InsertBefore inserts a new element e with value v immediately before mark and returns e.\n// If mark is not an element of l, the list is not modified.\n// The mark must not be nil.\nfunc (l *List) InsertBefore(v any, mark *Element) *Element {\n\tif mark.list != l {\n\t\treturn nil\n\t}\n\t// see comment in List.Remove about initialization of l\n\treturn l.insertValue(v, mark.prev)\n}\n\n// InsertAfter inserts a new element e with value v immediately after mark and returns e.\n// If mark is not an element of l, the list is not modified.\n// The mark must not be nil.\nfunc (l *List) InsertAfter(v any, mark *Element) *Element {\n\tif mark.list != l {\n\t\treturn nil\n\t}\n\t// see comment in List.Remove about initialization of l\n\treturn l.insertValue(v, mark)\n}\n\n// MoveToFront moves element e to the front of list l.\n// If e is not an element of l, the list is not modified.\n// The element must not be nil.\nfunc (l *List) MoveToFront(e *Element) {\n\tif e.list != l || l.root.next == e {\n\t\treturn\n\t}\n\t// see comment in List.Remove about initialization of l\n\tl.move(e, &l.root)\n}\n\n// MoveToBack moves element e to the back of list l.\n// If e is not an element of l, the list is not modified.\n// The element must not be nil.\nfunc (l *List) MoveToBack(e *Element) {\n\tif e.list != l || l.root.prev == e {\n\t\treturn\n\t}\n\t// see comment in List.Remove about initialization of l\n\tl.move(e, l.root.prev)\n}\n\n// MoveBefore moves element e to its new position before mark.\n// If e or mark is not an element of l, or e == mark, the list is not modified.\n// The element and mark must not be nil.\nfunc (l *List) MoveBefore(e, mark *Element) {\n\tif e.list != l || e == mark || mark.list != l {\n\t\treturn\n\t}\n\tl.move(e, mark.prev)\n}\n\n// MoveAfter moves element e to its new position after mark.\n// If e or mark is not an element of l, or e == mark, the list is not modified.\n// The element and mark must not be nil.\nfunc (l *List) MoveAfter(e, mark *Element) {\n\tif e.list != l || e == mark || mark.list != l {\n\t\treturn\n\t}\n\tl.move(e, mark)\n}\n\n// PushBackList inserts a copy of another list at the back of list l.\n// The lists l and other may be the same. They must not be nil.\nfunc (l *List) PushBackList(other *List) {\n\tl.lazyInit()\n\tfor i, e := other.Len(), other.Front(); i > 0; i, e = i-1, e.Next() {\n\t\tl.insertValue(e.Value, l.root.prev)\n\t}\n}\n\n// PushFrontList inserts a copy of another list at the front of list l.\n// The lists l and other may be the same. They must not be nil.\nfunc (l *List) PushFrontList(other *List) {\n\tl.lazyInit()\n\tfor i, e := other.Len(), other.Back(); i > 0; i, e = i-1, e.Prev() {\n\t\tl.insertValue(e.Value, &l.root)\n\t}\n}\n```\n\n附加双向链表的实现,在双向链表的实现当中添加了一个`pre` 指针，这样指定节点就可以找到他的前一个节点，时间复杂度是O(1)，同时也多了一些需要判断 `nil`的情况：\n\n* 为避免空指针的问题，还是必须要使用getPre\n* `head` 的 `pre` 一直为空\n\n为能够解决空指针带来的问题，双向链表应该在单向链表设计的基础上，将`tail` 指针指向一个假尾，这样就可以避免 `nil`带来的问题\n\n```go\n\n```\n\n双向链表也给了一个教训： 对指针的操作最好不要超过两层。也就是说，如果不使用假尾来解决链表空指针的问题，那就会导致访存时候要多考虑空指针带来的问题，代码就会变得比较复杂如下所示：\n\n```go\ntype node struct {\n\tval  int\n\tnext *node\n\tpre  *node\n}\n\ntype MyLinkedList struct {\n\thead *node\n\ttail *node\n\tl    int\n}\n\nfunc Constructor() MyLinkedList {\n\tp := &node{\n\t\tval:  -1,\n\t\tnext: nil,\n\t\tpre:  nil,\n\t}\n\treturn MyLinkedList{\n\t\thead: p,\n\t\ttail: p,\n\t\tl:    0,\n\t}\n}\n\nfunc (list *MyLinkedList) GetPre(index int) *node {\n\tnow := list.head.next\n\tpre := list.head\n\tfor i := 0; i < index; i++ {\n\t\tpre = now\n\t\tnow = now.next\n\t}\n\treturn pre\n}\n\nfunc (list *MyLinkedList) Get(index int) int {\n\tif index < 0 || index >= list.l {\n\t\treturn -1\n\t}\n\tnow := list.head.next\n\tfor i := 0; i < index; i++ {\n\t\tnow = now.next\n\t}\n\treturn now.val\n}\n\nfunc (list *MyLinkedList) AddAtHead(val int) {\n\tp := &node{\n\t\tval:  val,\n\t\tnext: list.head.next,\n\t\tpre:  list.head,\n\t}\n\tif list.head == list.tail {\n\t\tlist.tail = p\n\t}\n\tlist.head.next = p\n\tlist.l++\n}\n\nfunc (list *MyLinkedList) AddAtTail(val int) {\n\tp := &node{\n\t\tval:  val,\n\t\tnext: nil,\n\t\tpre:  list.tail,\n\t}\n\tlist.tail.next = p\n\tlist.tail = p\n\tlist.l++\n}\n\nfunc (list *MyLinkedList) AddAtIndex(index int, val int) {\n\tif index > list.l {\n\t\treturn\n\t}\n\tif index == list.l {\n\t\tlist.AddAtTail(val)\n\t\treturn\n\t}\n\tif index <= 0 {\n\t\tlist.AddAtHead(val)\n\t\treturn\n\t}\n\tp := list.GetPre(index)\n\tn := &node{\n\t\tval:  val,\n\t\tnext: p.next,\n\t\tpre:  p,\n\t}\n\tp.next = n\n\tn.next.pre = n\n\tlist.l++\n\treturn\n}\n\nfunc (list *MyLinkedList) DeleteAtIndex(index int) {\n\tif index < 0 || index >= list.l {\n\t\treturn\n\t}\n\tp := list.GetPre(index)\n\tif p.next == list.tail {\n\t\tlist.tail = p\n\t\tlist.l--\n\t\treturn\n\t}\n\tp.next = p.next.next\n    // 注意点1：之前的if 仅仅能够判断尾节点的情况，但是尾节点的前一个删除时候，会导致后面尾节点的后一个的pre为空，要排除这个情况\n\tif p.next.next != nil {\n\t\tp.next.next.pre = p\n\t}\n\tlist.l--\n}\n```\n\n\n\n## 链表结构操作应用例子\n\n万变不离其宗，能够完全理解上述的代码流程和操作逻辑之后，其余的使用链表实现的结构或者是使用链表的算法就可以通过对以上的各项方法做修改得到。\n\n### 1. 环形链表\n\n> 给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。\n>\n> 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。\n>\n> 不允许修改 链表。\n\n环形链表就等于快慢指针，这是一个定式，\n\n快慢指针的使用在于，规定出移动速度呈现 $m(m>1, m \\in N)$ 倍关系的两个指针，如果链表当中存在环，那么由于链表的单向性，移动快的指针一定会在移动过程当中与移动慢的指针相遇，此时移动快的指针已完成距离为：$a+n(b+c)+c$  ；移动慢的指针移动了：$a + c$ \n\n> 这里为什么移动慢的指针没有转圈圈呢？可以通过反证来说明，如果移动慢的指针在还没有被移动快的指针追上前转了一圈,那么移动快的指针就应该也在相同时间内转了 m 圈, $\\because m \\in N, \\therefore $ 移动快的指针必定已经和慢的指针相遇过 m 次，所以可以反推他们的第一次相遇必定是在慢指针第一次转圈过程当中 \n\n然后需要记住的数学方面的规律一共有三条：\n\n* 快慢指针相遇表示链表有环\n\n* 如果设 m = 2, 那么依据相遇时候所走路程相同可以得到以下推演：\n  $$\n  如果快慢指针在圈内相遇，我们可以将这段路程划分为 a ,b, c\n  \\\\\n  由于快指针的路程任何时候都是慢指针的两倍，可以得到： a + n(b+c) + c = 2*(a + c)\n  \\\\\n  展开移项之后可以得到： a = n(b+c)-c,由于移动方向不存在后退，为理解上清楚,进行变式:\n  \\\\\n  a = (n-1)(b+c)+b\n  \\\\ \n   这个式子的数学含义是，当快慢指针相遇的时候，从起点到链表入环点的距离 a 等于 链表环长度的n-1倍加b\n  \\\\\n  在数学当中，绕圈和三角函数一样，但满足一个周期的时候就可以在空间维度上将其丢弃，因为完成一个周期你还是回到了原地址\n  \\\\这个特性是非常有用的，在处理环问题上可以利用这个空间属性获得不相同时间属性上的相同关系\n  \\\\ 假设此时，慢指针A在相遇点出发，起点同时也出发新的一个慢指针B，那么当 A 转了n 圈之后，\n  \\\\ 此时,A在相遇点，B所处位置是：a-n(b+c)=b,也就是说新的B指针此时距离链表入环点的长度为b\n  \\\\ 此时再走b距离，二者在入环点相遇 \n  $$\n  所得结论为： 当快慢指针相遇后，起点重新启动一个慢指针，新旧慢指针第一次相遇位置为链表入环点\n\n* 以上结论和方法可以通过回溯剪枝运用到有向图当中环的数学代码问题\n\n  具体的数学逻辑情况如下图所示：\n\n  ![double](Y:\\Blog\\blog\\source\\_posts\\Algorithm\\Golang-数据结构\\img\\linklist_double.jpg)\n\n快慢指针是最能够体现链表遍历特性的一道题目，简单一句话 可以理解为，遍历链表是线性的。\n\n> [142. 环形链表 II - 力扣（LeetCode）](https://leetcode.cn/problems/linked-list-cycle-ii/submissions/)\n\n``` go\nfunc detectCycle(head *ListNode) *ListNode {\n    // 使用快慢指针解决这个问题\n    if head == nil || head.Next == nil{\n        return nil\n    }\n    if head.Next == head {\n        return head\n    }\n    pre, cur:= head, head\n    for true {\n        if cur == nil || cur.Next == nil{\n            return nil\n        }\n        cur = cur.Next.Next\n        pre = pre.Next\n        if cur == pre {\n            break\n        }\n    }\n    // 重新再跑一次\n    cur = head\n    for cur != pre {\n        pre = pre.Next\n        cur =cur.Next\n    }\n    return pre\n}\n```\n\n\n\n### 2. LRU 缓存\n\nLRU 其实更多指的是 LRU 算法：**最久未使用算法（LRU, Least Recently Used）**，LRU算法是依据各块使用的情况， 总是选择那个最长时间未被使用的块替换。这种方法比较好地反映了程序局部性规律。\n\n其实际应用是在操作系统当中的实现，博文后面也会参考，但如何能够实现一个 LRU 呢？核心关键还是在于 LRU 的核心特征： \n\n* 访问和修改的时间复杂度为 O(1)\n* 需要时常维护结构，使得最常使用和最不常使用的数据位置访问时间复杂度为 O(1)\n\n对于第一个要求，首先想到的就是哈希表；第二个要求需要维护数据的结构性，使得这个结构性可以表征使用的时间特性，比如将最常使用的数据放在结构的前面，最不常使用的放在结构后面，当数据总量超过限制时候需要删除最后面的数据，具有这样特征的结构可以是： 1. 链表，2. 环形队列；但如果需要保证访问时间复杂度为 O(1)，链表就需要使用双向链表；而在维护结构特征中，二者对于去旧迎新的操作都满足要求，但是如果查找了结构当中的数据并把它转移到前头时候，队列的操作就无法满足O(1) 时间复杂度，故选用以下方案：\n\n* 双向链表\n* 哈希表\n\n代码思路：\n\n对一个Cache的操作无非三种：插入(insert)、替换(replace)、查找（lookup）。\n\nLRU 在此之上需要在做到：\n\n* 让刚访问、插入、替换的节点放到链表头，使得末尾节点数据总是最不常访问的\n* 超过cache限制的时候，需要删除最末尾的数据\n* 维护一张哈希表访问节点，需要对哈希表做增删改查\n\n对于以上行为做抽象总结可以得到以下设计：\n\n```go\ntype LRUCache interface{\n    // 构造LRUCache 函数,传入的参数只是设置LRUCache的缓存大小\n    Construt(capacity int) LRUCache\n    // 共用的操作 [对于复杂的结构，需要实现的底层操作]\n    // 在头部插入节点,表示刚使用的数据\n    // 传入指针是为了复用原本链表内的节点，减少存储的负担\n    AddAtHead(node *node) bool\n    // 删除节点，删除操作在多个情况下复用，不能只考虑删除tail的情况\n    // 清除尾部最不常用节点或者是删除链表内被重新插入到head后面的节点\n    DeleteNode(node *node) bool\n    // 接下来的方法都是对上述方法的排列组\n    // 应该先把该节点从链表内删除，然后将这个节点移动到链表头\n    // 注意点1 ： 删除链表节点实质是更改节点前后的链表节点指针，并没有修改或者是释放该节点对应对象的存储，所以只要还存有该节点的指针就可以继续操作，不需要考虑深浅拷贝的问题\n    MoveToHead(node *node)\n    // 依据 key 值查询链表节点，\n    // 首先查找map中对应的地址，然后将这个节点 MoveToHead\n    // 如果不存在，返回-1\n    Get(key int) int\n    // 依据 key 值更改或者添加节点\n    // 当 key 存在时，更新该 key 对应的 value，并且将该 k-v 放置头部；\n\t// 当 key 不存在时，如果缓存没达到容量，则在map中和链表中插入k-v；\n\t// 当 key 不存在时且缓存容量已满时，则删除链表尾部的 node 以及 map 中的 k-v，然后在链表头部插入node，并在 map 中插入新的 k-v；\n    Put(key int, value int)\n}\n```\n\n按照这个想法，我们来实现以下代码：\n\n```go\ntype node struct{\n    key int\n    val int\n    next *node\n    pre *node\n}\n\ntype LRUCache struct {\n    head *node\n    tail *node\n    cap int\n    m map[int]*node\n}\n\n\nfunc Constructor(capacity int) LRUCache {\n    head := &node{key: -1, val: -1, next:nil, pre: nil,}\n    tail := &node{key: -1, val: -1, next:nil, pre: nil,}\n    l :=  LRUCache{\n        head: head,\n        tail: tail,\n        cap: capacity,\n        m: make(map[int]*node),\n    }\n    l.head.next = tail\n    l.tail.pre = head\n    return l\n}\n\n// 基础函数不要设置过多的边界条件判断，让其他调用它的函数来处理边界条件\n// 设定前提为该节点已存在\nfunc (l *LRUCache)AddAtHead(n *node){\n    head := l.head\n    n.next,head.next.pre = head.next,n\n    head.next,n.pre = n,head\n}\n\n// 设定前提为该节点已存在\nfunc (l *LRUCache)DeleteNode(n *node){\n    pre, next := n.pre,n.next\n    pre.next,next.pre = next,pre\n    \n}\n\nfunc (l *LRUCache)MoveToHead(n *node){\n    l.DeleteNode(n)\n    l.AddAtHead(n)\n}\n\nfunc (l *LRUCache) Get(key int) int {\n    if l.cap <= 0 {\n        return -1\n    }\n    if n,ok := l.m[key];ok {\n        l.MoveToHead(n)\n        return n.val\n    }else{\n        return -1\n    }\n}\n\n\nfunc (l *LRUCache) Put(key int, value int)  {\n    if n,ok := l.m[key];ok{\n        n.val = value\n        l.MoveToHead(n)\n    }else{\n        node := &node{\n            key: key,\n            val: value,\n            next: nil,\n            pre: nil,\n        }\n        if l.cap <= len(l.m){\n            dn := l.tail.pre\n            l.DeleteNode(dn)\n            delete(l.m,dn.key)\n            l.AddAtHead(node)\n        }else{\n            l.AddAtHead(node)\n        }\n        // 注意点： 一定是最后来添加 map 当中的值，如果在 if 之前判断加那么map的值增长了，l.cap 的判断就有问题 \n        l.m[key] = node\n    }\n}\n```\n\n> [面试题 16.25. LRU 缓存 - 力扣（LeetCode）](https://leetcode.cn/problems/lru-cache-lcci/submissions/)\n\n借鉴一个表示更加简介的版本：\n\n```go\ntype LinkNode struct{\n    key, value int\n    pre, next *LinkNode\n}\n\ntype LRUCache struct {\n    m map[int]*LinkNode\n    capacity int\n    head, tail *LinkNode\n}\n\nfunc Constructor(capacity int) LRUCache {\n    head := &LinkNode{-1, -1, nil, nil}\n    tail := &LinkNode{-1, -1, nil, nil}\n    head.next = tail\n    tail.pre = head\n    cache := LRUCache{make(map[int]*LinkNode), capacity, head, tail}\n    return cache\n}\n\nfunc (this *LRUCache) AddNode(node *LinkNode) {\n    node.pre = this.head\n    node.next = this.head.next\n    this.head.next = node\n    node.next.pre = node\n}\n\nfunc (this *LRUCache) RemoveNode(node *LinkNode) {\n    node.pre.next = node.next\n    node.next.pre = node.pre\n}\n\nfunc (this *LRUCache) MoveToHead(node *LinkNode) {\n    this.RemoveNode(node)\n    this.AddNode(node)\n}\n\nfunc (this *LRUCache) Get(key int) int {\n    m := this.m\n    if node, ok := m[key]; ok {\n        this.MoveToHead(node)\n        return node.value\n    } else {\n        return -1\n    }\n}\n\nfunc (this *LRUCache) Put(key int, value int)  {\n    m := this.m\n    if node, ok := m[key]; ok {\n        node.value = value\n        this.MoveToHead(node)\n    } else {\n        n := &LinkNode{key, value, nil, nil}\n        if len(m) >= this.capacity {\n            delete(m, this.tail.pre.key)\n            this.RemoveNode(this.tail.pre)\n        }\n        m[key] = n\n        this.AddNode(n)\n    }\n}\n\n\ntype LinkNode struct{\n    key, value int\n    pre, next *LinkNode\n}\n\ntype LRUCache struct {\n    m map[int]*LinkNode\n    capacity int\n    head, tail *LinkNode\n}\n\nfunc Constructor(capacity int) LRUCache {\n    head := &LinkNode{-1, -1, nil, nil}\n    tail := &LinkNode{-1, -1, nil, nil}\n    head.next = tail\n    tail.pre = head\n    cache := LRUCache{make(map[int]*LinkNode), capacity, head, tail}\n    return cache\n}\n\nfunc (this *LRUCache) AddNode(node *LinkNode) {\n    node.pre = this.head\n    node.next = this.head.next\n    this.head.next = node\n    node.next.pre = node\n}\n\nfunc (this *LRUCache) RemoveNode(node *LinkNode) {\n    node.pre.next = node.next\n    node.next.pre = node.pre\n}\n\nfunc (this *LRUCache) MoveToHead(node *LinkNode) {\n    this.RemoveNode(node)\n    this.AddNode(node)\n}\n\nfunc (this *LRUCache) Get(key int) int {\n    m := this.m\n    if node, ok := m[key]; ok {\n        this.MoveToHead(node)\n        return node.value\n    } else {\n        return -1\n    }\n}\n\nfunc (this *LRUCache) Put(key int, value int)  {\n    m := this.m\n    if node, ok := m[key]; ok {\n        node.value = value\n        this.MoveToHead(node)\n    } else {\n        n := &LinkNode{key, value, nil, nil}\n        if len(m) >= this.capacity {\n            delete(m, this.tail.pre.key)\n            this.RemoveNode(this.tail.pre)\n        }\n        m[key] = n\n        this.AddNode(n)\n    }\n}\n// 作者：pengtuo\n// 链接：https://leetcode.cn/problems/lru-cache-lcci/solution/goshuang-xiang-lian-biao-map-shi-xian-lru-by-pengt/\n```\n\n","source":"_posts/Algorithm/Alg_Basic/Golang-数据结构/linklist/Golang-数据结构-链表.md","raw":"---\ntitle: Golang-数据结构-链表\ncatalog: true\ndate: 2023-04-02 00:46:21\nsubtitle:\nheader-img:\ntags: 链表, 算法, 数据结构\ncategories: 算法\n---\n\n# Golang  操作链表\n\n> 越是简单的内容越需要熟练的掌握，自己做自己的 chatgpt,\n>\n> 越是基础的内容越需要细细的追究，避免重复造轮子\n\n链表常见的使用场景和问题：\n\n```mermaid\ngraph TD\nA[链表]-->B[内核消息队列]\nA-->C[缓存管理]\nA-->D[跳表]\nA-->E[B+ 树]\n```\n\n由于链表的非连续性和一定程度上的方向性，在边界问题以及实际应用当中的细微问题较多，暴力的解法往往容易全盘皆错，且实际应用当中也会存在不少的问题。\n\n本文将关注如何做到规范化解决链表问题，在部分解决类型上结合 Golang 的特性来做特有的实现。\n\n\n\n## 链表的基础结构模板\n\n链表节点需要包含一个值和一个指向下一个节点的指针，简单的示例如下\n\n``` golang\ntype ListNode struct{\n    Val int\n    Next *ListeNode\n}\n```\n\n当想要实现双向链表的时候则需要添加一个指向前一个结点的指针\n\n```go\ntype ListNode struct{\n    Val int\n    Pre *ListNode\n    Next *ListNode\n}\n\ntype linkList struct{\n    head *ListNode\n    tail *ListNode\n    l int\n}\n```\n\n简单，但在边界问题和实际使用时侯容易弄错一些地方，在此告诫\n\n1. **ListNode 是 value type**, 在 Golang 当中 struct 对象是一种值类型（value type），而不是指针类型（pointer type）。这意味着，当定义并初始化一个 struct 变量时，它实际上拥有自己的内存空间，而不是仅仅是指向某个内存地址的指针。当按值传递 struct 变量时，函数会复制一份该变量的副本，而不是传递变量的指针。\n\n   但是 ListNode 内部变量需要的是指针类型，指向链表节点分配的地址，所以在初始化上需要注意几个形式：\n\n   ```go\n   // l 获得一个指针\n   l := new(ListNode{})\n   l := &ListNode{}\n   \n   // l 获得一个对象\n   l := ListNode{}\n   // 三者输出的结果为：\n   // l is {0 <nil>}\n   // l is &{0 <nil>}\n   // l is &{0 <nil>}\n   \n   // 自己构造函数返回的是一个指针类型, 这个函数是一个模板\n   func newListNode() *ListNode{\n       return &ListNode{\n           val: 0,\n           next: nil,\n       }\n   }\n   // 返回结果：l is &{0 <nil>}\n   ```\n\n   只理解到这里作为平时使用是足够的，但是应用时候一部分人可能因为不知道Go编译器的自动解引用，而导致指针类型和值类型混用时候分不清。\n   \n   比如以下的情况是不会报错的：\n   \n   ```go\n   \tl := ListNode{}\n   \tl1 := &ListNode{}\n   \tfmt.Printf(\"l is %v\\n\", l.val)\n   \tfmt.Printf(\"l1 is %v\\n\", l1.val)\n   /** 输出结果为：\n   l is 0\n   l1 is 0\n   */\n   ```\n   \n   当创建了 &ListNode{} 变量之后，如果需要调用 ListNode  结构的方法和结构体字段，并不需要使用 (*l).val来获取变量，这里其中实际上是发生了自动解引用，编译器会自动将指针解引用并访问结构体字段。\n   \n   其实从使用来说，就对于字段访问并不会体现出很大问题，但是当我们把链表节点转化为interface时候，当定义了方法之后，在调用时候就会出现报错：\n   \n   ```go\n   \ttype StructF interface{}\n   \tfunc (st *StructF) printData() {\n       \tfmt.Println(\"yes\")\n   \t}    \n   \tst1 := StructF{}\n       var it2 InterfaceTest = st1  // 编译出错\n       it2.printData()\n   ```\n   \n   在上述的结构体访问例子当中，指针和对象值调用时候的接收器是默认的，golang 帮我们完成了相对应的解引用和取引用，情况如下：\n   \n   - 用**值类型**的实参调用形参为**值类型**的方法\n   - 用**指针类型**的实参调用形参为**值类型**的方法（会进行“自动解引用”）\n   - 用**值类型**的实参调用形参为**指针类型**的方法（会进行“自动取引用”）\n   - 用**指针类型**的实参调用形参为**指针类型**的方法\n   \n   而上述例子中我们定义的是interface,当我们编写的代码想要对外暴露服务的时候，传入参数是值类型Golang会自动生成一个对应类型指针的函数方法，但是传入参数是指针类型时候，Golang 则不会重新为这个方法生成值类型的方法。\n   \n   在这里需要明确的是：\n   \n   >* go语言只有值传递，指针也是值传递。\n   >\n   >* 对于一个类来说，其**值类型**的方法会自动生成相应的**指针类型**的方法，而指针类型的方法**不会**自动生成相应的值类型的方法\n   >* 结构体类型对于值和指针不加区别（对外暴露使用），但是使用接口对外暴露的时候，值类型会兼容指针类型，但是指针类型不兼容值类型，从而实现对指针的保护，同时实现指针类型的容错。\n   \n   算是一类语法糖\n\n### 链表操作基础模板\n\n这里考虑使用假头/假尾的方式来实现，实际上也有参考 k+1 循环队列思想，可以以这样的方式避免很多的空指针问题,不过循环队列是使用取模的方式计算下标，链表则在空间上有更多的自由性。\n\n假头通常也叫做 \" Dummy Head\" 或者 \"哑头\"，是在链表前面，加上一个额外的节点。\n\n> 非常推荐以后在写项目或者是接口方法时候，先定义出它对应的 interface,确定输入输出，尽可能保证方法之间是正交的。\n\n```golang\ntype ListNode struct{\n    Val int\n    Next *ListNode\n}\n\ntype list struct{\n    head *ListNode\n    tail *ListNode\n    l int\n}\n\n// 常见的链表操作定义\ntype linkList interface{\n    /** 初始化 \n    ** new 出一个链表节点并使head和tail都指向这个节点，长度值设置为0\n    */\n    newList() *List\n    \n    //查找结点，input key get val\n    /** 一般返回所查找结点的前一个节点，如果没有查找到这个节点，应该返回head\n    ** 1. 初始化 front， back指针，分别指向一前一后\n    ** 2. 在查找的时候， front 总是和 back 一起走\n    ** 3. 返回前置节点（自己实现的查找函数）\n    ** 4. 服务要求的查找函数调用获取到前置节点地址，则目标节点为 p.Next\n    */\n    get(key int)value int\n    \n    /** 在尾部追加节点, input val\n    ** 1. 在尾部添加一个新的节点\n    ** 2. 移动tail指针\n    ** 3. 链表的长度加1\n    */\n    addAtEnd(val int)\n    /** 在头部插入节点, input val\n    ** 1. 新节点 p.Next 指向 head.Next\n    ** 2. head.Next 指向 p\n    ** 3. 如果原来的 tail 指向 head 所指向节点，那么就将 tail 指向 p\n    */\n    addAtHead(val int)  \n    \n    // 在指定位置前插入, input key & val\n    /** 一般返回所查找结点的前一个节点，如果没有查找到这个节点，应该返回head\n    ** 一般存在四种情况：\n    ** 1. 如果 index 大于链表长度，则不会插入节点；\n    ** 2. 如果 index 等于链表长度，则将该结点附加到链表的末尾 \n    ** 3. 如果 index 小于 0 ，则在头部插入节点 \n    ** 4. 否则在指定位置前面插入节点\n    ** \t4.1  得到 index 之前的节点 pre --> 使用 get 函数\n    **  4.2  在 pre 后面添加新的节点\n    **  4.3  修改 list 的长度\n    ** [插入节点的时候，一定先把pre的next值赋值给p的Next，然后再把pre的next指向p，否则后半链表就无了]\n    */\n    addAtIndex(key int, val int)\n    // 删除节点， input key\n    /** \n    ** 1. 判断 index 是否有效： index < 0 || index >= l 就直接返回[因为index应该是计算的从0-n-1才对]\n    ** 2. 如果 index 合法\n    ** \t找到 index 前面的节点\n    **  如果要删除的节点是最后一个，那么需要修改tail指针\n    **  执行删除操作，并修改链表的长度\n    */\n    deleteAtIndex(key int)   \n}\n```\n\n具体实现\n\n```golang\npackage linklist\n\nimport (\n\t\"fmt\"\n)\n\n// 链表节点定义\ntype linkNode struct {\n\tval  int\n\tnext *linkNode\n}\n\n// 链表定义\ntype MyLinkedList struct {\n\thead   *linkNode\n\ttail   *linkNode\n\tlength int\n}\n\n// 链表构造函数定义，\n// 初始化 dummy head 的时候，val设置为-1，指针指向 nil\nfunc Constructor() MyLinkedList {\n    // 一定注意使用 &linknode{}获取地址，return 值按题目要求来创建\n\tnode := &linkNode{\n\t\tval:  -1,\n\t\tnext: nil,\n\t}\n\treturn MyLinkedList{\n\t\thead:   node,\n\t\ttail:   node,\n\t\tlength: 0,\n\t}\n}\n\n// 创建新的节点并加入在假头节点之后\nfunc (list *MyLinkedList) AddAtHead(val int) {\n    // 不判断边界条件\n\tnode := &linkNode{\n\t\tval:  val,\n\t\tnext: nil,\n\t}\n\tnode.next = list.head.next\n\tlist.head.next = node\n    // 关注点1 ： 一定要判断是否当前tail等于head，\n\tif list.head == list.tail {\n\t\tlist.tail = node\n\t}\n    // 关注点2： 一定记得维护链表的长度属性\n\tlist.length++\n}\n\n// 创建新的节点并加在尾指针之后\nfunc (list *MyLinkedList) AddAtTail(val int) {\n    // 不需要判断条件\n\tlist.tail.next = &linkNode{\n\t\tval:  val,\n\t\tnext: nil,\n\t}\n\tlist.tail = list.tail.next\n    // 关注点2： 一定记得维护链表的长度属性\n\tlist.length++\n}\n\n// 获取 index 节点的前一个节点\nfunc (list *MyLinkedList) GetPre(index int) *linkNode {\n    // 不需要判断，因为边界条件在调用的时候都是特殊情况\n\tnow := list.head.next\n\tpre := list.head\n    // 注意点4： 不要弄反了 now 和 pre 的位置\n\tfor i := 0; i < index; i++ {\n\t\tpre = now\n\t\tnow = now.next\n\t}\n\treturn pre\n}\n\n// 获取 index 位置节点的值\nfunc (list *MyLinkedList) Get(index int) int {\n    // 判断边界条件： index < 0 和 index > list.length都是超出的链表的范围\n\tif index < 0 || index >= list.length {\n\t\treturn -1\n\t}\n\tpre := list.GetPre(index)\n\treturn pre.next.val\n}\n\n\n// 在 index 位置的前一个位置插入节点\nfunc (list *MyLinkedList) AddAtIndex(index int, val int) {\n\tif index > list.length {\n\t\treturn\n\t}\n\tif index == list.length {\n\t\tlist.AddAtTail(val)\n\t\treturn\n\t}\n\tif index <= 0 {\n\t\tlist.AddAtHead(val)\n\t\treturn\n\t}\n\tpre := list.GetPre(index)\n\tnode := &linkNode{\n\t\tval:  val,\n\t\tnext: nil,\n\t}\n\tnode.next = pre.next\n\tpre.next = node\n    // 注意点2： 维护链表的属性\n\tlist.length++\n}\n\nfunc (list *MyLinkedList) DeleteAtIndex(index int) {\n\tif index < 0 || index >= list.length {\n\t\treturn\n\t}\n\tpre := list.GetPre(index)\n    // 注意点3： 删除时候需要考虑最后一个结点的情况\n\tif list.tail == pre.next {\n\t\tlist.tail = pre\n\t}\n\tpre.next = pre.next.next\n\tlist.length--\n}\n\nfunc (list *MyLinkedList) PrintList() {\n\tnow := list.head.next\n\tfor now != nil {\n\t\tif now == list.tail {\n\t\t\tfmt.Printf(\"%d=\\n\", now.val)\n\t\t\tbreak\n\t\t}\n\t\tfmt.Printf(\"%d=\", now.val)\n\t\tnow = now.next\n\t}\n}\n```\n\n### 链表操作参考\n\n参考 `container/list` 的实现\n\n```golang\n// Package list implements a doubly linked list.\n//\n// To iterate over a list (where l is a *List):\n//\n//\tfor e := l.Front(); e != nil; e = e.Next() {\n//\t\t// do something with e.Value\n//\t}\npackage list\n\n// Element is an element of a linked list.\ntype Element struct {\n\t// Next and previous pointers in the doubly-linked list of elements.\n\t// To simplify the implementation, internally a list l is implemented\n\t// as a ring, such that &l.root is both the next element of the last\n\t// list element (l.Back()) and the previous element of the first list\n\t// element (l.Front()).\n\tnext, prev *Element\n\n\t// The list to which this element belongs.\n\tlist *List\n\n\t// The value stored with this element.\n\tValue any\n}\n\n// Next returns the next list element or nil.\nfunc (e *Element) Next() *Element {\n\tif p := e.next; e.list != nil && p != &e.list.root {\n\t\treturn p\n\t}\n\treturn nil\n}\n\n// Prev returns the previous list element or nil.\nfunc (e *Element) Prev() *Element {\n\tif p := e.prev; e.list != nil && p != &e.list.root {\n\t\treturn p\n\t}\n\treturn nil\n}\n\n// List represents a doubly linked list.\n// The zero value for List is an empty list ready to use.\ntype List struct {\n\troot Element // sentinel list element, only &root, root.prev, and root.next are used\n\tlen  int     // current list length excluding (this) sentinel element\n}\n\n// Init initializes or clears list l.\nfunc (l *List) Init() *List {\n\tl.root.next = &l.root\n\tl.root.prev = &l.root\n\tl.len = 0\n\treturn l\n}\n\n// New returns an initialized list.\nfunc New() *List { return new(List).Init() }\n\n// Len returns the number of elements of list l.\n// The complexity is O(1).\nfunc (l *List) Len() int { return l.len }\n\n// Front returns the first element of list l or nil if the list is empty.\nfunc (l *List) Front() *Element {\n\tif l.len == 0 {\n\t\treturn nil\n\t}\n\treturn l.root.next\n}\n\n// Back returns the last element of list l or nil if the list is empty.\nfunc (l *List) Back() *Element {\n\tif l.len == 0 {\n\t\treturn nil\n\t}\n\treturn l.root.prev\n}\n\n// lazyInit lazily initializes a zero List value.\nfunc (l *List) lazyInit() {\n\tif l.root.next == nil {\n\t\tl.Init()\n\t}\n}\n\n// insert inserts e after at, increments l.len, and returns e.\nfunc (l *List) insert(e, at *Element) *Element {\n\te.prev = at\n\te.next = at.next\n\te.prev.next = e\n\te.next.prev = e\n\te.list = l\n\tl.len++\n\treturn e\n}\n\n// insertValue is a convenience wrapper for insert(&Element{Value: v}, at).\nfunc (l *List) insertValue(v any, at *Element) *Element {\n\treturn l.insert(&Element{Value: v}, at)\n}\n\n// remove removes e from its list, decrements l.len\nfunc (l *List) remove(e *Element) {\n\te.prev.next = e.next\n\te.next.prev = e.prev\n\te.next = nil // avoid memory leaks\n\te.prev = nil // avoid memory leaks\n\te.list = nil\n\tl.len--\n}\n\n// move moves e to next to at.\nfunc (l *List) move(e, at *Element) {\n\tif e == at {\n\t\treturn\n\t}\n\te.prev.next = e.next\n\te.next.prev = e.prev\n\n\te.prev = at\n\te.next = at.next\n\te.prev.next = e\n\te.next.prev = e\n}\n\n// Remove removes e from l if e is an element of list l.\n// It returns the element value e.Value.\n// The element must not be nil.\nfunc (l *List) Remove(e *Element) any {\n\tif e.list == l {\n\t\t// if e.list == l, l must have been initialized when e was inserted\n\t\t// in l or l == nil (e is a zero Element) and l.remove will crash\n\t\tl.remove(e)\n\t}\n\treturn e.Value\n}\n\n// PushFront inserts a new element e with value v at the front of list l and returns e.\nfunc (l *List) PushFront(v any) *Element {\n\tl.lazyInit()\n\treturn l.insertValue(v, &l.root)\n}\n\n// PushBack inserts a new element e with value v at the back of list l and returns e.\nfunc (l *List) PushBack(v any) *Element {\n\tl.lazyInit()\n\treturn l.insertValue(v, l.root.prev)\n}\n\n// InsertBefore inserts a new element e with value v immediately before mark and returns e.\n// If mark is not an element of l, the list is not modified.\n// The mark must not be nil.\nfunc (l *List) InsertBefore(v any, mark *Element) *Element {\n\tif mark.list != l {\n\t\treturn nil\n\t}\n\t// see comment in List.Remove about initialization of l\n\treturn l.insertValue(v, mark.prev)\n}\n\n// InsertAfter inserts a new element e with value v immediately after mark and returns e.\n// If mark is not an element of l, the list is not modified.\n// The mark must not be nil.\nfunc (l *List) InsertAfter(v any, mark *Element) *Element {\n\tif mark.list != l {\n\t\treturn nil\n\t}\n\t// see comment in List.Remove about initialization of l\n\treturn l.insertValue(v, mark)\n}\n\n// MoveToFront moves element e to the front of list l.\n// If e is not an element of l, the list is not modified.\n// The element must not be nil.\nfunc (l *List) MoveToFront(e *Element) {\n\tif e.list != l || l.root.next == e {\n\t\treturn\n\t}\n\t// see comment in List.Remove about initialization of l\n\tl.move(e, &l.root)\n}\n\n// MoveToBack moves element e to the back of list l.\n// If e is not an element of l, the list is not modified.\n// The element must not be nil.\nfunc (l *List) MoveToBack(e *Element) {\n\tif e.list != l || l.root.prev == e {\n\t\treturn\n\t}\n\t// see comment in List.Remove about initialization of l\n\tl.move(e, l.root.prev)\n}\n\n// MoveBefore moves element e to its new position before mark.\n// If e or mark is not an element of l, or e == mark, the list is not modified.\n// The element and mark must not be nil.\nfunc (l *List) MoveBefore(e, mark *Element) {\n\tif e.list != l || e == mark || mark.list != l {\n\t\treturn\n\t}\n\tl.move(e, mark.prev)\n}\n\n// MoveAfter moves element e to its new position after mark.\n// If e or mark is not an element of l, or e == mark, the list is not modified.\n// The element and mark must not be nil.\nfunc (l *List) MoveAfter(e, mark *Element) {\n\tif e.list != l || e == mark || mark.list != l {\n\t\treturn\n\t}\n\tl.move(e, mark)\n}\n\n// PushBackList inserts a copy of another list at the back of list l.\n// The lists l and other may be the same. They must not be nil.\nfunc (l *List) PushBackList(other *List) {\n\tl.lazyInit()\n\tfor i, e := other.Len(), other.Front(); i > 0; i, e = i-1, e.Next() {\n\t\tl.insertValue(e.Value, l.root.prev)\n\t}\n}\n\n// PushFrontList inserts a copy of another list at the front of list l.\n// The lists l and other may be the same. They must not be nil.\nfunc (l *List) PushFrontList(other *List) {\n\tl.lazyInit()\n\tfor i, e := other.Len(), other.Back(); i > 0; i, e = i-1, e.Prev() {\n\t\tl.insertValue(e.Value, &l.root)\n\t}\n}\n```\n\n附加双向链表的实现,在双向链表的实现当中添加了一个`pre` 指针，这样指定节点就可以找到他的前一个节点，时间复杂度是O(1)，同时也多了一些需要判断 `nil`的情况：\n\n* 为避免空指针的问题，还是必须要使用getPre\n* `head` 的 `pre` 一直为空\n\n为能够解决空指针带来的问题，双向链表应该在单向链表设计的基础上，将`tail` 指针指向一个假尾，这样就可以避免 `nil`带来的问题\n\n```go\n\n```\n\n双向链表也给了一个教训： 对指针的操作最好不要超过两层。也就是说，如果不使用假尾来解决链表空指针的问题，那就会导致访存时候要多考虑空指针带来的问题，代码就会变得比较复杂如下所示：\n\n```go\ntype node struct {\n\tval  int\n\tnext *node\n\tpre  *node\n}\n\ntype MyLinkedList struct {\n\thead *node\n\ttail *node\n\tl    int\n}\n\nfunc Constructor() MyLinkedList {\n\tp := &node{\n\t\tval:  -1,\n\t\tnext: nil,\n\t\tpre:  nil,\n\t}\n\treturn MyLinkedList{\n\t\thead: p,\n\t\ttail: p,\n\t\tl:    0,\n\t}\n}\n\nfunc (list *MyLinkedList) GetPre(index int) *node {\n\tnow := list.head.next\n\tpre := list.head\n\tfor i := 0; i < index; i++ {\n\t\tpre = now\n\t\tnow = now.next\n\t}\n\treturn pre\n}\n\nfunc (list *MyLinkedList) Get(index int) int {\n\tif index < 0 || index >= list.l {\n\t\treturn -1\n\t}\n\tnow := list.head.next\n\tfor i := 0; i < index; i++ {\n\t\tnow = now.next\n\t}\n\treturn now.val\n}\n\nfunc (list *MyLinkedList) AddAtHead(val int) {\n\tp := &node{\n\t\tval:  val,\n\t\tnext: list.head.next,\n\t\tpre:  list.head,\n\t}\n\tif list.head == list.tail {\n\t\tlist.tail = p\n\t}\n\tlist.head.next = p\n\tlist.l++\n}\n\nfunc (list *MyLinkedList) AddAtTail(val int) {\n\tp := &node{\n\t\tval:  val,\n\t\tnext: nil,\n\t\tpre:  list.tail,\n\t}\n\tlist.tail.next = p\n\tlist.tail = p\n\tlist.l++\n}\n\nfunc (list *MyLinkedList) AddAtIndex(index int, val int) {\n\tif index > list.l {\n\t\treturn\n\t}\n\tif index == list.l {\n\t\tlist.AddAtTail(val)\n\t\treturn\n\t}\n\tif index <= 0 {\n\t\tlist.AddAtHead(val)\n\t\treturn\n\t}\n\tp := list.GetPre(index)\n\tn := &node{\n\t\tval:  val,\n\t\tnext: p.next,\n\t\tpre:  p,\n\t}\n\tp.next = n\n\tn.next.pre = n\n\tlist.l++\n\treturn\n}\n\nfunc (list *MyLinkedList) DeleteAtIndex(index int) {\n\tif index < 0 || index >= list.l {\n\t\treturn\n\t}\n\tp := list.GetPre(index)\n\tif p.next == list.tail {\n\t\tlist.tail = p\n\t\tlist.l--\n\t\treturn\n\t}\n\tp.next = p.next.next\n    // 注意点1：之前的if 仅仅能够判断尾节点的情况，但是尾节点的前一个删除时候，会导致后面尾节点的后一个的pre为空，要排除这个情况\n\tif p.next.next != nil {\n\t\tp.next.next.pre = p\n\t}\n\tlist.l--\n}\n```\n\n\n\n## 链表结构操作应用例子\n\n万变不离其宗，能够完全理解上述的代码流程和操作逻辑之后，其余的使用链表实现的结构或者是使用链表的算法就可以通过对以上的各项方法做修改得到。\n\n### 1. 环形链表\n\n> 给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。\n>\n> 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。\n>\n> 不允许修改 链表。\n\n环形链表就等于快慢指针，这是一个定式，\n\n快慢指针的使用在于，规定出移动速度呈现 $m(m>1, m \\in N)$ 倍关系的两个指针，如果链表当中存在环，那么由于链表的单向性，移动快的指针一定会在移动过程当中与移动慢的指针相遇，此时移动快的指针已完成距离为：$a+n(b+c)+c$  ；移动慢的指针移动了：$a + c$ \n\n> 这里为什么移动慢的指针没有转圈圈呢？可以通过反证来说明，如果移动慢的指针在还没有被移动快的指针追上前转了一圈,那么移动快的指针就应该也在相同时间内转了 m 圈, $\\because m \\in N, \\therefore $ 移动快的指针必定已经和慢的指针相遇过 m 次，所以可以反推他们的第一次相遇必定是在慢指针第一次转圈过程当中 \n\n然后需要记住的数学方面的规律一共有三条：\n\n* 快慢指针相遇表示链表有环\n\n* 如果设 m = 2, 那么依据相遇时候所走路程相同可以得到以下推演：\n  $$\n  如果快慢指针在圈内相遇，我们可以将这段路程划分为 a ,b, c\n  \\\\\n  由于快指针的路程任何时候都是慢指针的两倍，可以得到： a + n(b+c) + c = 2*(a + c)\n  \\\\\n  展开移项之后可以得到： a = n(b+c)-c,由于移动方向不存在后退，为理解上清楚,进行变式:\n  \\\\\n  a = (n-1)(b+c)+b\n  \\\\ \n   这个式子的数学含义是，当快慢指针相遇的时候，从起点到链表入环点的距离 a 等于 链表环长度的n-1倍加b\n  \\\\\n  在数学当中，绕圈和三角函数一样，但满足一个周期的时候就可以在空间维度上将其丢弃，因为完成一个周期你还是回到了原地址\n  \\\\这个特性是非常有用的，在处理环问题上可以利用这个空间属性获得不相同时间属性上的相同关系\n  \\\\ 假设此时，慢指针A在相遇点出发，起点同时也出发新的一个慢指针B，那么当 A 转了n 圈之后，\n  \\\\ 此时,A在相遇点，B所处位置是：a-n(b+c)=b,也就是说新的B指针此时距离链表入环点的长度为b\n  \\\\ 此时再走b距离，二者在入环点相遇 \n  $$\n  所得结论为： 当快慢指针相遇后，起点重新启动一个慢指针，新旧慢指针第一次相遇位置为链表入环点\n\n* 以上结论和方法可以通过回溯剪枝运用到有向图当中环的数学代码问题\n\n  具体的数学逻辑情况如下图所示：\n\n  ![double](Y:\\Blog\\blog\\source\\_posts\\Algorithm\\Golang-数据结构\\img\\linklist_double.jpg)\n\n快慢指针是最能够体现链表遍历特性的一道题目，简单一句话 可以理解为，遍历链表是线性的。\n\n> [142. 环形链表 II - 力扣（LeetCode）](https://leetcode.cn/problems/linked-list-cycle-ii/submissions/)\n\n``` go\nfunc detectCycle(head *ListNode) *ListNode {\n    // 使用快慢指针解决这个问题\n    if head == nil || head.Next == nil{\n        return nil\n    }\n    if head.Next == head {\n        return head\n    }\n    pre, cur:= head, head\n    for true {\n        if cur == nil || cur.Next == nil{\n            return nil\n        }\n        cur = cur.Next.Next\n        pre = pre.Next\n        if cur == pre {\n            break\n        }\n    }\n    // 重新再跑一次\n    cur = head\n    for cur != pre {\n        pre = pre.Next\n        cur =cur.Next\n    }\n    return pre\n}\n```\n\n\n\n### 2. LRU 缓存\n\nLRU 其实更多指的是 LRU 算法：**最久未使用算法（LRU, Least Recently Used）**，LRU算法是依据各块使用的情况， 总是选择那个最长时间未被使用的块替换。这种方法比较好地反映了程序局部性规律。\n\n其实际应用是在操作系统当中的实现，博文后面也会参考，但如何能够实现一个 LRU 呢？核心关键还是在于 LRU 的核心特征： \n\n* 访问和修改的时间复杂度为 O(1)\n* 需要时常维护结构，使得最常使用和最不常使用的数据位置访问时间复杂度为 O(1)\n\n对于第一个要求，首先想到的就是哈希表；第二个要求需要维护数据的结构性，使得这个结构性可以表征使用的时间特性，比如将最常使用的数据放在结构的前面，最不常使用的放在结构后面，当数据总量超过限制时候需要删除最后面的数据，具有这样特征的结构可以是： 1. 链表，2. 环形队列；但如果需要保证访问时间复杂度为 O(1)，链表就需要使用双向链表；而在维护结构特征中，二者对于去旧迎新的操作都满足要求，但是如果查找了结构当中的数据并把它转移到前头时候，队列的操作就无法满足O(1) 时间复杂度，故选用以下方案：\n\n* 双向链表\n* 哈希表\n\n代码思路：\n\n对一个Cache的操作无非三种：插入(insert)、替换(replace)、查找（lookup）。\n\nLRU 在此之上需要在做到：\n\n* 让刚访问、插入、替换的节点放到链表头，使得末尾节点数据总是最不常访问的\n* 超过cache限制的时候，需要删除最末尾的数据\n* 维护一张哈希表访问节点，需要对哈希表做增删改查\n\n对于以上行为做抽象总结可以得到以下设计：\n\n```go\ntype LRUCache interface{\n    // 构造LRUCache 函数,传入的参数只是设置LRUCache的缓存大小\n    Construt(capacity int) LRUCache\n    // 共用的操作 [对于复杂的结构，需要实现的底层操作]\n    // 在头部插入节点,表示刚使用的数据\n    // 传入指针是为了复用原本链表内的节点，减少存储的负担\n    AddAtHead(node *node) bool\n    // 删除节点，删除操作在多个情况下复用，不能只考虑删除tail的情况\n    // 清除尾部最不常用节点或者是删除链表内被重新插入到head后面的节点\n    DeleteNode(node *node) bool\n    // 接下来的方法都是对上述方法的排列组\n    // 应该先把该节点从链表内删除，然后将这个节点移动到链表头\n    // 注意点1 ： 删除链表节点实质是更改节点前后的链表节点指针，并没有修改或者是释放该节点对应对象的存储，所以只要还存有该节点的指针就可以继续操作，不需要考虑深浅拷贝的问题\n    MoveToHead(node *node)\n    // 依据 key 值查询链表节点，\n    // 首先查找map中对应的地址，然后将这个节点 MoveToHead\n    // 如果不存在，返回-1\n    Get(key int) int\n    // 依据 key 值更改或者添加节点\n    // 当 key 存在时，更新该 key 对应的 value，并且将该 k-v 放置头部；\n\t// 当 key 不存在时，如果缓存没达到容量，则在map中和链表中插入k-v；\n\t// 当 key 不存在时且缓存容量已满时，则删除链表尾部的 node 以及 map 中的 k-v，然后在链表头部插入node，并在 map 中插入新的 k-v；\n    Put(key int, value int)\n}\n```\n\n按照这个想法，我们来实现以下代码：\n\n```go\ntype node struct{\n    key int\n    val int\n    next *node\n    pre *node\n}\n\ntype LRUCache struct {\n    head *node\n    tail *node\n    cap int\n    m map[int]*node\n}\n\n\nfunc Constructor(capacity int) LRUCache {\n    head := &node{key: -1, val: -1, next:nil, pre: nil,}\n    tail := &node{key: -1, val: -1, next:nil, pre: nil,}\n    l :=  LRUCache{\n        head: head,\n        tail: tail,\n        cap: capacity,\n        m: make(map[int]*node),\n    }\n    l.head.next = tail\n    l.tail.pre = head\n    return l\n}\n\n// 基础函数不要设置过多的边界条件判断，让其他调用它的函数来处理边界条件\n// 设定前提为该节点已存在\nfunc (l *LRUCache)AddAtHead(n *node){\n    head := l.head\n    n.next,head.next.pre = head.next,n\n    head.next,n.pre = n,head\n}\n\n// 设定前提为该节点已存在\nfunc (l *LRUCache)DeleteNode(n *node){\n    pre, next := n.pre,n.next\n    pre.next,next.pre = next,pre\n    \n}\n\nfunc (l *LRUCache)MoveToHead(n *node){\n    l.DeleteNode(n)\n    l.AddAtHead(n)\n}\n\nfunc (l *LRUCache) Get(key int) int {\n    if l.cap <= 0 {\n        return -1\n    }\n    if n,ok := l.m[key];ok {\n        l.MoveToHead(n)\n        return n.val\n    }else{\n        return -1\n    }\n}\n\n\nfunc (l *LRUCache) Put(key int, value int)  {\n    if n,ok := l.m[key];ok{\n        n.val = value\n        l.MoveToHead(n)\n    }else{\n        node := &node{\n            key: key,\n            val: value,\n            next: nil,\n            pre: nil,\n        }\n        if l.cap <= len(l.m){\n            dn := l.tail.pre\n            l.DeleteNode(dn)\n            delete(l.m,dn.key)\n            l.AddAtHead(node)\n        }else{\n            l.AddAtHead(node)\n        }\n        // 注意点： 一定是最后来添加 map 当中的值，如果在 if 之前判断加那么map的值增长了，l.cap 的判断就有问题 \n        l.m[key] = node\n    }\n}\n```\n\n> [面试题 16.25. LRU 缓存 - 力扣（LeetCode）](https://leetcode.cn/problems/lru-cache-lcci/submissions/)\n\n借鉴一个表示更加简介的版本：\n\n```go\ntype LinkNode struct{\n    key, value int\n    pre, next *LinkNode\n}\n\ntype LRUCache struct {\n    m map[int]*LinkNode\n    capacity int\n    head, tail *LinkNode\n}\n\nfunc Constructor(capacity int) LRUCache {\n    head := &LinkNode{-1, -1, nil, nil}\n    tail := &LinkNode{-1, -1, nil, nil}\n    head.next = tail\n    tail.pre = head\n    cache := LRUCache{make(map[int]*LinkNode), capacity, head, tail}\n    return cache\n}\n\nfunc (this *LRUCache) AddNode(node *LinkNode) {\n    node.pre = this.head\n    node.next = this.head.next\n    this.head.next = node\n    node.next.pre = node\n}\n\nfunc (this *LRUCache) RemoveNode(node *LinkNode) {\n    node.pre.next = node.next\n    node.next.pre = node.pre\n}\n\nfunc (this *LRUCache) MoveToHead(node *LinkNode) {\n    this.RemoveNode(node)\n    this.AddNode(node)\n}\n\nfunc (this *LRUCache) Get(key int) int {\n    m := this.m\n    if node, ok := m[key]; ok {\n        this.MoveToHead(node)\n        return node.value\n    } else {\n        return -1\n    }\n}\n\nfunc (this *LRUCache) Put(key int, value int)  {\n    m := this.m\n    if node, ok := m[key]; ok {\n        node.value = value\n        this.MoveToHead(node)\n    } else {\n        n := &LinkNode{key, value, nil, nil}\n        if len(m) >= this.capacity {\n            delete(m, this.tail.pre.key)\n            this.RemoveNode(this.tail.pre)\n        }\n        m[key] = n\n        this.AddNode(n)\n    }\n}\n\n\ntype LinkNode struct{\n    key, value int\n    pre, next *LinkNode\n}\n\ntype LRUCache struct {\n    m map[int]*LinkNode\n    capacity int\n    head, tail *LinkNode\n}\n\nfunc Constructor(capacity int) LRUCache {\n    head := &LinkNode{-1, -1, nil, nil}\n    tail := &LinkNode{-1, -1, nil, nil}\n    head.next = tail\n    tail.pre = head\n    cache := LRUCache{make(map[int]*LinkNode), capacity, head, tail}\n    return cache\n}\n\nfunc (this *LRUCache) AddNode(node *LinkNode) {\n    node.pre = this.head\n    node.next = this.head.next\n    this.head.next = node\n    node.next.pre = node\n}\n\nfunc (this *LRUCache) RemoveNode(node *LinkNode) {\n    node.pre.next = node.next\n    node.next.pre = node.pre\n}\n\nfunc (this *LRUCache) MoveToHead(node *LinkNode) {\n    this.RemoveNode(node)\n    this.AddNode(node)\n}\n\nfunc (this *LRUCache) Get(key int) int {\n    m := this.m\n    if node, ok := m[key]; ok {\n        this.MoveToHead(node)\n        return node.value\n    } else {\n        return -1\n    }\n}\n\nfunc (this *LRUCache) Put(key int, value int)  {\n    m := this.m\n    if node, ok := m[key]; ok {\n        node.value = value\n        this.MoveToHead(node)\n    } else {\n        n := &LinkNode{key, value, nil, nil}\n        if len(m) >= this.capacity {\n            delete(m, this.tail.pre.key)\n            this.RemoveNode(this.tail.pre)\n        }\n        m[key] = n\n        this.AddNode(n)\n    }\n}\n// 作者：pengtuo\n// 链接：https://leetcode.cn/problems/lru-cache-lcci/solution/goshuang-xiang-lian-biao-map-shi-xian-lru-by-pengt/\n```\n\n","slug":"Algorithm/Alg_Basic/Golang-数据结构/linklist/Golang-数据结构-链表","published":1,"updated":"2023-04-29T15:03:43.665Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cli796r1l003kbyjxbhkr5en3","content":"<h1 id=\"Golang-操作链表\"><a href=\"#Golang-操作链表\" class=\"headerlink\" title=\"Golang  操作链表\"></a>Golang  操作链表</h1><blockquote>\n<p>越是简单的内容越需要熟练的掌握，自己做自己的 chatgpt,</p>\n<p>越是基础的内容越需要细细的追究，避免重复造轮子</p>\n</blockquote>\n<p>链表常见的使用场景和问题：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph TD</span><br><span class=\"line\">A[链表]--&gt;B[内核消息队列]</span><br><span class=\"line\">A--&gt;C[缓存管理]</span><br><span class=\"line\">A--&gt;D[跳表]</span><br><span class=\"line\">A--&gt;E[B+ 树]</span><br></pre></td></tr></table></figure>\n\n<p>由于链表的非连续性和一定程度上的方向性，在边界问题以及实际应用当中的细微问题较多，暴力的解法往往容易全盘皆错，且实际应用当中也会存在不少的问题。</p>\n<p>本文将关注如何做到规范化解决链表问题，在部分解决类型上结合 Golang 的特性来做特有的实现。</p>\n<h2 id=\"链表的基础结构模板\"><a href=\"#链表的基础结构模板\" class=\"headerlink\" title=\"链表的基础结构模板\"></a>链表的基础结构模板</h2><p>链表节点需要包含一个值和一个指向下一个节点的指针，简单的示例如下</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> ListNode <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">    Val <span class=\"type\">int</span></span><br><span class=\"line\">    Next *ListeNode</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当想要实现双向链表的时候则需要添加一个指向前一个结点的指针</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> ListNode <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">    Val <span class=\"type\">int</span></span><br><span class=\"line\">    Pre *ListNode</span><br><span class=\"line\">    Next *ListNode</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> linkList <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">    head *ListNode</span><br><span class=\"line\">    tail *ListNode</span><br><span class=\"line\">    l <span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>简单，但在边界问题和实际使用时侯容易弄错一些地方，在此告诫</p>\n<ol>\n<li><p><strong>ListNode 是 value type</strong>, 在 Golang 当中 struct 对象是一种值类型（value type），而不是指针类型（pointer type）。这意味着，当定义并初始化一个 struct 变量时，它实际上拥有自己的内存空间，而不是仅仅是指向某个内存地址的指针。当按值传递 struct 变量时，函数会复制一份该变量的副本，而不是传递变量的指针。</p>\n<p>但是 ListNode 内部变量需要的是指针类型，指向链表节点分配的地址，所以在初始化上需要注意几个形式：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// l 获得一个指针</span></span><br><span class=\"line\">l := <span class=\"built_in\">new</span>(ListNode&#123;&#125;)</span><br><span class=\"line\">l := &amp;ListNode&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// l 获得一个对象</span></span><br><span class=\"line\">l := ListNode&#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">// 三者输出的结果为：</span></span><br><span class=\"line\"><span class=\"comment\">// l is &#123;0 &lt;nil&gt;&#125;</span></span><br><span class=\"line\"><span class=\"comment\">// l is &amp;&#123;0 &lt;nil&gt;&#125;</span></span><br><span class=\"line\"><span class=\"comment\">// l is &amp;&#123;0 &lt;nil&gt;&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 自己构造函数返回的是一个指针类型, 这个函数是一个模板</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">newListNode</span><span class=\"params\">()</span></span> *ListNode&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;ListNode&#123;</span><br><span class=\"line\">        val: <span class=\"number\">0</span>,</span><br><span class=\"line\">        next: <span class=\"literal\">nil</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 返回结果：l is &amp;&#123;0 &lt;nil&gt;&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>只理解到这里作为平时使用是足够的，但是应用时候一部分人可能因为不知道Go编译器的自动解引用，而导致指针类型和值类型混用时候分不清。</p>\n<p>比如以下的情况是不会报错的：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\tl := ListNode&#123;&#125;</span><br><span class=\"line\">\tl1 := &amp;ListNode&#123;&#125;</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;l is %v\\n&quot;</span>, l.val)</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;l1 is %v\\n&quot;</span>, l1.val)</span><br><span class=\"line\"><span class=\"comment\">/** 输出结果为：</span></span><br><span class=\"line\"><span class=\"comment\">l is 0</span></span><br><span class=\"line\"><span class=\"comment\">l1 is 0</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<p>当创建了 &amp;ListNode{} 变量之后，如果需要调用 ListNode  结构的方法和结构体字段，并不需要使用 (*l).val来获取变量，这里其中实际上是发生了自动解引用，编译器会自动将指针解引用并访问结构体字段。</p>\n<p>其实从使用来说，就对于字段访问并不会体现出很大问题，但是当我们把链表节点转化为interface时候，当定义了方法之后，在调用时候就会出现报错：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> StructF <span class=\"keyword\">interface</span>&#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(st *StructF)</span></span> printData() &#123;</span><br><span class=\"line\">   \tfmt.Println(<span class=\"string\">&quot;yes&quot;</span>)</span><br><span class=\"line\">&#125;    </span><br><span class=\"line\">st1 := StructF&#123;&#125;</span><br><span class=\"line\">   <span class=\"keyword\">var</span> it2 InterfaceTest = st1  <span class=\"comment\">// 编译出错</span></span><br><span class=\"line\">   it2.printData()</span><br></pre></td></tr></table></figure>\n\n<p>在上述的结构体访问例子当中，指针和对象值调用时候的接收器是默认的，golang 帮我们完成了相对应的解引用和取引用，情况如下：</p>\n<ul>\n<li>用<strong>值类型</strong>的实参调用形参为<strong>值类型</strong>的方法</li>\n<li>用<strong>指针类型</strong>的实参调用形参为<strong>值类型</strong>的方法（会进行“自动解引用”）</li>\n<li>用<strong>值类型</strong>的实参调用形参为<strong>指针类型</strong>的方法（会进行“自动取引用”）</li>\n<li>用<strong>指针类型</strong>的实参调用形参为<strong>指针类型</strong>的方法</li>\n</ul>\n<p>而上述例子中我们定义的是interface,当我们编写的代码想要对外暴露服务的时候，传入参数是值类型Golang会自动生成一个对应类型指针的函数方法，但是传入参数是指针类型时候，Golang 则不会重新为这个方法生成值类型的方法。</p>\n<p>在这里需要明确的是：</p>\n<blockquote>\n<ul>\n<li><p>go语言只有值传递，指针也是值传递。</p>\n</li>\n<li><p>对于一个类来说，其<strong>值类型</strong>的方法会自动生成相应的<strong>指针类型</strong>的方法，而指针类型的方法<strong>不会</strong>自动生成相应的值类型的方法</p>\n</li>\n<li><p>结构体类型对于值和指针不加区别（对外暴露使用），但是使用接口对外暴露的时候，值类型会兼容指针类型，但是指针类型不兼容值类型，从而实现对指针的保护，同时实现指针类型的容错。</p>\n</li>\n</ul>\n</blockquote>\n<p>算是一类语法糖</p>\n</li>\n</ol>\n<h3 id=\"链表操作基础模板\"><a href=\"#链表操作基础模板\" class=\"headerlink\" title=\"链表操作基础模板\"></a>链表操作基础模板</h3><p>这里考虑使用假头/假尾的方式来实现，实际上也有参考 k+1 循环队列思想，可以以这样的方式避免很多的空指针问题,不过循环队列是使用取模的方式计算下标，链表则在空间上有更多的自由性。</p>\n<p>假头通常也叫做 “ Dummy Head” 或者 “哑头”，是在链表前面，加上一个额外的节点。</p>\n<blockquote>\n<p>非常推荐以后在写项目或者是接口方法时候，先定义出它对应的 interface,确定输入输出，尽可能保证方法之间是正交的。</p>\n</blockquote>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> ListNode <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">    Val <span class=\"type\">int</span></span><br><span class=\"line\">    Next *ListNode</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> list <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">    head *ListNode</span><br><span class=\"line\">    tail *ListNode</span><br><span class=\"line\">    l <span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 常见的链表操作定义</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> linkList <span class=\"keyword\">interface</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/** 初始化 </span></span><br><span class=\"line\"><span class=\"comment\">    ** new 出一个链表节点并使head和tail都指向这个节点，长度值设置为0</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    newList() *List</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//查找结点，input key get val</span></span><br><span class=\"line\">    <span class=\"comment\">/** 一般返回所查找结点的前一个节点，如果没有查找到这个节点，应该返回head</span></span><br><span class=\"line\"><span class=\"comment\">    ** 1. 初始化 front， back指针，分别指向一前一后</span></span><br><span class=\"line\"><span class=\"comment\">    ** 2. 在查找的时候， front 总是和 back 一起走</span></span><br><span class=\"line\"><span class=\"comment\">    ** 3. 返回前置节点（自己实现的查找函数）</span></span><br><span class=\"line\"><span class=\"comment\">    ** 4. 服务要求的查找函数调用获取到前置节点地址，则目标节点为 p.Next</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    get(key <span class=\"type\">int</span>)value <span class=\"type\">int</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** 在尾部追加节点, input val</span></span><br><span class=\"line\"><span class=\"comment\">    ** 1. 在尾部添加一个新的节点</span></span><br><span class=\"line\"><span class=\"comment\">    ** 2. 移动tail指针</span></span><br><span class=\"line\"><span class=\"comment\">    ** 3. 链表的长度加1</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    addAtEnd(val <span class=\"type\">int</span>)</span><br><span class=\"line\">    <span class=\"comment\">/** 在头部插入节点, input val</span></span><br><span class=\"line\"><span class=\"comment\">    ** 1. 新节点 p.Next 指向 head.Next</span></span><br><span class=\"line\"><span class=\"comment\">    ** 2. head.Next 指向 p</span></span><br><span class=\"line\"><span class=\"comment\">    ** 3. 如果原来的 tail 指向 head 所指向节点，那么就将 tail 指向 p</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    addAtHead(val <span class=\"type\">int</span>)  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 在指定位置前插入, input key &amp; val</span></span><br><span class=\"line\">    <span class=\"comment\">/** 一般返回所查找结点的前一个节点，如果没有查找到这个节点，应该返回head</span></span><br><span class=\"line\"><span class=\"comment\">    ** 一般存在四种情况：</span></span><br><span class=\"line\"><span class=\"comment\">    ** 1. 如果 index 大于链表长度，则不会插入节点；</span></span><br><span class=\"line\"><span class=\"comment\">    ** 2. 如果 index 等于链表长度，则将该结点附加到链表的末尾 </span></span><br><span class=\"line\"><span class=\"comment\">    ** 3. 如果 index 小于 0 ，则在头部插入节点 </span></span><br><span class=\"line\"><span class=\"comment\">    ** 4. 否则在指定位置前面插入节点</span></span><br><span class=\"line\"><span class=\"comment\">    ** \t4.1  得到 index 之前的节点 pre --&gt; 使用 get 函数</span></span><br><span class=\"line\"><span class=\"comment\">    **  4.2  在 pre 后面添加新的节点</span></span><br><span class=\"line\"><span class=\"comment\">    **  4.3  修改 list 的长度</span></span><br><span class=\"line\"><span class=\"comment\">    ** [插入节点的时候，一定先把pre的next值赋值给p的Next，然后再把pre的next指向p，否则后半链表就无了]</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    addAtIndex(key <span class=\"type\">int</span>, val <span class=\"type\">int</span>)</span><br><span class=\"line\">    <span class=\"comment\">// 删除节点， input key</span></span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">    ** 1. 判断 index 是否有效： index &lt; 0 || index &gt;= l 就直接返回[因为index应该是计算的从0-n-1才对]</span></span><br><span class=\"line\"><span class=\"comment\">    ** 2. 如果 index 合法</span></span><br><span class=\"line\"><span class=\"comment\">    ** \t找到 index 前面的节点</span></span><br><span class=\"line\"><span class=\"comment\">    **  如果要删除的节点是最后一个，那么需要修改tail指针</span></span><br><span class=\"line\"><span class=\"comment\">    **  执行删除操作，并修改链表的长度</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    deleteAtIndex(key <span class=\"type\">int</span>)   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>具体实现</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> linklist</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 链表节点定义</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> linkNode <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tval  <span class=\"type\">int</span></span><br><span class=\"line\">\tnext *linkNode</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 链表定义</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> MyLinkedList <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\thead   *linkNode</span><br><span class=\"line\">\ttail   *linkNode</span><br><span class=\"line\">\tlength <span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 链表构造函数定义，</span></span><br><span class=\"line\"><span class=\"comment\">// 初始化 dummy head 的时候，val设置为-1，指针指向 nil</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Constructor</span><span class=\"params\">()</span></span> MyLinkedList &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 一定注意使用 &amp;linknode&#123;&#125;获取地址，return 值按题目要求来创建</span></span><br><span class=\"line\">\tnode := &amp;linkNode&#123;</span><br><span class=\"line\">\t\tval:  <span class=\"number\">-1</span>,</span><br><span class=\"line\">\t\tnext: <span class=\"literal\">nil</span>,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> MyLinkedList&#123;</span><br><span class=\"line\">\t\thead:   node,</span><br><span class=\"line\">\t\ttail:   node,</span><br><span class=\"line\">\t\tlength: <span class=\"number\">0</span>,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建新的节点并加入在假头节点之后</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(list *MyLinkedList)</span></span> AddAtHead(val <span class=\"type\">int</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 不判断边界条件</span></span><br><span class=\"line\">\tnode := &amp;linkNode&#123;</span><br><span class=\"line\">\t\tval:  val,</span><br><span class=\"line\">\t\tnext: <span class=\"literal\">nil</span>,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tnode.next = list.head.next</span><br><span class=\"line\">\tlist.head.next = node</span><br><span class=\"line\">    <span class=\"comment\">// 关注点1 ： 一定要判断是否当前tail等于head，</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> list.head == list.tail &#123;</span><br><span class=\"line\">\t\tlist.tail = node</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"comment\">// 关注点2： 一定记得维护链表的长度属性</span></span><br><span class=\"line\">\tlist.length++</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建新的节点并加在尾指针之后</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(list *MyLinkedList)</span></span> AddAtTail(val <span class=\"type\">int</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 不需要判断条件</span></span><br><span class=\"line\">\tlist.tail.next = &amp;linkNode&#123;</span><br><span class=\"line\">\t\tval:  val,</span><br><span class=\"line\">\t\tnext: <span class=\"literal\">nil</span>,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tlist.tail = list.tail.next</span><br><span class=\"line\">    <span class=\"comment\">// 关注点2： 一定记得维护链表的长度属性</span></span><br><span class=\"line\">\tlist.length++</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取 index 节点的前一个节点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(list *MyLinkedList)</span></span> GetPre(index <span class=\"type\">int</span>) *linkNode &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 不需要判断，因为边界条件在调用的时候都是特殊情况</span></span><br><span class=\"line\">\tnow := list.head.next</span><br><span class=\"line\">\tpre := list.head</span><br><span class=\"line\">    <span class=\"comment\">// 注意点4： 不要弄反了 now 和 pre 的位置</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; index; i++ &#123;</span><br><span class=\"line\">\t\tpre = now</span><br><span class=\"line\">\t\tnow = now.next</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> pre</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取 index 位置节点的值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(list *MyLinkedList)</span></span> Get(index <span class=\"type\">int</span>) <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 判断边界条件： index &lt; 0 和 index &gt; list.length都是超出的链表的范围</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> index &lt; <span class=\"number\">0</span> || index &gt;= list.length &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tpre := list.GetPre(index)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> pre.next.val</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在 index 位置的前一个位置插入节点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(list *MyLinkedList)</span></span> AddAtIndex(index <span class=\"type\">int</span>, val <span class=\"type\">int</span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> index &gt; list.length &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> index == list.length &#123;</span><br><span class=\"line\">\t\tlist.AddAtTail(val)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> index &lt;= <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tlist.AddAtHead(val)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tpre := list.GetPre(index)</span><br><span class=\"line\">\tnode := &amp;linkNode&#123;</span><br><span class=\"line\">\t\tval:  val,</span><br><span class=\"line\">\t\tnext: <span class=\"literal\">nil</span>,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tnode.next = pre.next</span><br><span class=\"line\">\tpre.next = node</span><br><span class=\"line\">    <span class=\"comment\">// 注意点2： 维护链表的属性</span></span><br><span class=\"line\">\tlist.length++</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(list *MyLinkedList)</span></span> DeleteAtIndex(index <span class=\"type\">int</span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> index &lt; <span class=\"number\">0</span> || index &gt;= list.length &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tpre := list.GetPre(index)</span><br><span class=\"line\">    <span class=\"comment\">// 注意点3： 删除时候需要考虑最后一个结点的情况</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> list.tail == pre.next &#123;</span><br><span class=\"line\">\t\tlist.tail = pre</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tpre.next = pre.next.next</span><br><span class=\"line\">\tlist.length--</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(list *MyLinkedList)</span></span> PrintList() &#123;</span><br><span class=\"line\">\tnow := list.head.next</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> now != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> now == list.tail &#123;</span><br><span class=\"line\">\t\t\tfmt.Printf(<span class=\"string\">&quot;%d=\\n&quot;</span>, now.val)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tfmt.Printf(<span class=\"string\">&quot;%d=&quot;</span>, now.val)</span><br><span class=\"line\">\t\tnow = now.next</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"链表操作参考\"><a href=\"#链表操作参考\" class=\"headerlink\" title=\"链表操作参考\"></a>链表操作参考</h3><p>参考 <code>container/list</code> 的实现</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Package list implements a doubly linked list.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// To iterate over a list (where l is a *List):</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">//\tfor e := l.Front(); e != nil; e = e.Next() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//\t\t// do something with e.Value</span></span><br><span class=\"line\"><span class=\"comment\">//\t&#125;</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> list</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Element is an element of a linked list.</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Element <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// Next and previous pointers in the doubly-linked list of elements.</span></span><br><span class=\"line\">\t<span class=\"comment\">// To simplify the implementation, internally a list l is implemented</span></span><br><span class=\"line\">\t<span class=\"comment\">// as a ring, such that &amp;l.root is both the next element of the last</span></span><br><span class=\"line\">\t<span class=\"comment\">// list element (l.Back()) and the previous element of the first list</span></span><br><span class=\"line\">\t<span class=\"comment\">// element (l.Front()).</span></span><br><span class=\"line\">\tnext, prev *Element</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// The list to which this element belongs.</span></span><br><span class=\"line\">\tlist *List</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// The value stored with this element.</span></span><br><span class=\"line\">\tValue any</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Next returns the next list element or nil.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(e *Element)</span></span> Next() *Element &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> p := e.next; e.list != <span class=\"literal\">nil</span> &amp;&amp; p != &amp;e.list.root &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> p</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Prev returns the previous list element or nil.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(e *Element)</span></span> Prev() *Element &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> p := e.prev; e.list != <span class=\"literal\">nil</span> &amp;&amp; p != &amp;e.list.root &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> p</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// List represents a doubly linked list.</span></span><br><span class=\"line\"><span class=\"comment\">// The zero value for List is an empty list ready to use.</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> List <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\troot Element <span class=\"comment\">// sentinel list element, only &amp;root, root.prev, and root.next are used</span></span><br><span class=\"line\">\t<span class=\"built_in\">len</span>  <span class=\"type\">int</span>     <span class=\"comment\">// current list length excluding (this) sentinel element</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Init initializes or clears list l.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *List)</span></span> Init() *List &#123;</span><br><span class=\"line\">\tl.root.next = &amp;l.root</span><br><span class=\"line\">\tl.root.prev = &amp;l.root</span><br><span class=\"line\">\tl.<span class=\"built_in\">len</span> = <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> l</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// New returns an initialized list.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">New</span><span class=\"params\">()</span></span> *List &#123; <span class=\"keyword\">return</span> <span class=\"built_in\">new</span>(List).Init() &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Len returns the number of elements of list l.</span></span><br><span class=\"line\"><span class=\"comment\">// The complexity is O(1).</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *List)</span></span> Len() <span class=\"type\">int</span> &#123; <span class=\"keyword\">return</span> l.<span class=\"built_in\">len</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Front returns the first element of list l or nil if the list is empty.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *List)</span></span> Front() *Element &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> l.<span class=\"built_in\">len</span> == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> l.root.next</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Back returns the last element of list l or nil if the list is empty.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *List)</span></span> Back() *Element &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> l.<span class=\"built_in\">len</span> == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> l.root.prev</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// lazyInit lazily initializes a zero List value.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *List)</span></span> lazyInit() &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> l.root.next == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tl.Init()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// insert inserts e after at, increments l.len, and returns e.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *List)</span></span> insert(e, at *Element) *Element &#123;</span><br><span class=\"line\">\te.prev = at</span><br><span class=\"line\">\te.next = at.next</span><br><span class=\"line\">\te.prev.next = e</span><br><span class=\"line\">\te.next.prev = e</span><br><span class=\"line\">\te.list = l</span><br><span class=\"line\">\tl.<span class=\"built_in\">len</span>++</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> e</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// insertValue is a convenience wrapper for insert(&amp;Element&#123;Value: v&#125;, at).</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *List)</span></span> insertValue(v any, at *Element) *Element &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> l.insert(&amp;Element&#123;Value: v&#125;, at)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// remove removes e from its list, decrements l.len</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *List)</span></span> remove(e *Element) &#123;</span><br><span class=\"line\">\te.prev.next = e.next</span><br><span class=\"line\">\te.next.prev = e.prev</span><br><span class=\"line\">\te.next = <span class=\"literal\">nil</span> <span class=\"comment\">// avoid memory leaks</span></span><br><span class=\"line\">\te.prev = <span class=\"literal\">nil</span> <span class=\"comment\">// avoid memory leaks</span></span><br><span class=\"line\">\te.list = <span class=\"literal\">nil</span></span><br><span class=\"line\">\tl.<span class=\"built_in\">len</span>--</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// move moves e to next to at.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *List)</span></span> move(e, at *Element) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> e == at &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\te.prev.next = e.next</span><br><span class=\"line\">\te.next.prev = e.prev</span><br><span class=\"line\"></span><br><span class=\"line\">\te.prev = at</span><br><span class=\"line\">\te.next = at.next</span><br><span class=\"line\">\te.prev.next = e</span><br><span class=\"line\">\te.next.prev = e</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Remove removes e from l if e is an element of list l.</span></span><br><span class=\"line\"><span class=\"comment\">// It returns the element value e.Value.</span></span><br><span class=\"line\"><span class=\"comment\">// The element must not be nil.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *List)</span></span> Remove(e *Element) any &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> e.list == l &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// if e.list == l, l must have been initialized when e was inserted</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// in l or l == nil (e is a zero Element) and l.remove will crash</span></span><br><span class=\"line\">\t\tl.remove(e)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> e.Value</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// PushFront inserts a new element e with value v at the front of list l and returns e.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *List)</span></span> PushFront(v any) *Element &#123;</span><br><span class=\"line\">\tl.lazyInit()</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> l.insertValue(v, &amp;l.root)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// PushBack inserts a new element e with value v at the back of list l and returns e.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *List)</span></span> PushBack(v any) *Element &#123;</span><br><span class=\"line\">\tl.lazyInit()</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> l.insertValue(v, l.root.prev)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// InsertBefore inserts a new element e with value v immediately before mark and returns e.</span></span><br><span class=\"line\"><span class=\"comment\">// If mark is not an element of l, the list is not modified.</span></span><br><span class=\"line\"><span class=\"comment\">// The mark must not be nil.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *List)</span></span> InsertBefore(v any, mark *Element) *Element &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> mark.list != l &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// see comment in List.Remove about initialization of l</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> l.insertValue(v, mark.prev)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// InsertAfter inserts a new element e with value v immediately after mark and returns e.</span></span><br><span class=\"line\"><span class=\"comment\">// If mark is not an element of l, the list is not modified.</span></span><br><span class=\"line\"><span class=\"comment\">// The mark must not be nil.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *List)</span></span> InsertAfter(v any, mark *Element) *Element &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> mark.list != l &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// see comment in List.Remove about initialization of l</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> l.insertValue(v, mark)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// MoveToFront moves element e to the front of list l.</span></span><br><span class=\"line\"><span class=\"comment\">// If e is not an element of l, the list is not modified.</span></span><br><span class=\"line\"><span class=\"comment\">// The element must not be nil.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *List)</span></span> MoveToFront(e *Element) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> e.list != l || l.root.next == e &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// see comment in List.Remove about initialization of l</span></span><br><span class=\"line\">\tl.move(e, &amp;l.root)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// MoveToBack moves element e to the back of list l.</span></span><br><span class=\"line\"><span class=\"comment\">// If e is not an element of l, the list is not modified.</span></span><br><span class=\"line\"><span class=\"comment\">// The element must not be nil.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *List)</span></span> MoveToBack(e *Element) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> e.list != l || l.root.prev == e &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// see comment in List.Remove about initialization of l</span></span><br><span class=\"line\">\tl.move(e, l.root.prev)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// MoveBefore moves element e to its new position before mark.</span></span><br><span class=\"line\"><span class=\"comment\">// If e or mark is not an element of l, or e == mark, the list is not modified.</span></span><br><span class=\"line\"><span class=\"comment\">// The element and mark must not be nil.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *List)</span></span> MoveBefore(e, mark *Element) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> e.list != l || e == mark || mark.list != l &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tl.move(e, mark.prev)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// MoveAfter moves element e to its new position after mark.</span></span><br><span class=\"line\"><span class=\"comment\">// If e or mark is not an element of l, or e == mark, the list is not modified.</span></span><br><span class=\"line\"><span class=\"comment\">// The element and mark must not be nil.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *List)</span></span> MoveAfter(e, mark *Element) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> e.list != l || e == mark || mark.list != l &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tl.move(e, mark)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// PushBackList inserts a copy of another list at the back of list l.</span></span><br><span class=\"line\"><span class=\"comment\">// The lists l and other may be the same. They must not be nil.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *List)</span></span> PushBackList(other *List) &#123;</span><br><span class=\"line\">\tl.lazyInit()</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i, e := other.Len(), other.Front(); i &gt; <span class=\"number\">0</span>; i, e = i<span class=\"number\">-1</span>, e.Next() &#123;</span><br><span class=\"line\">\t\tl.insertValue(e.Value, l.root.prev)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// PushFrontList inserts a copy of another list at the front of list l.</span></span><br><span class=\"line\"><span class=\"comment\">// The lists l and other may be the same. They must not be nil.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *List)</span></span> PushFrontList(other *List) &#123;</span><br><span class=\"line\">\tl.lazyInit()</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i, e := other.Len(), other.Back(); i &gt; <span class=\"number\">0</span>; i, e = i<span class=\"number\">-1</span>, e.Prev() &#123;</span><br><span class=\"line\">\t\tl.insertValue(e.Value, &amp;l.root)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>附加双向链表的实现,在双向链表的实现当中添加了一个<code>pre</code> 指针，这样指定节点就可以找到他的前一个节点，时间复杂度是O(1)，同时也多了一些需要判断 <code>nil</code>的情况：</p>\n<ul>\n<li>为避免空指针的问题，还是必须要使用getPre</li>\n<li><code>head</code> 的 <code>pre</code> 一直为空</li>\n</ul>\n<p>为能够解决空指针带来的问题，双向链表应该在单向链表设计的基础上，将<code>tail</code> 指针指向一个假尾，这样就可以避免 <code>nil</code>带来的问题</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>双向链表也给了一个教训： 对指针的操作最好不要超过两层。也就是说，如果不使用假尾来解决链表空指针的问题，那就会导致访存时候要多考虑空指针带来的问题，代码就会变得比较复杂如下所示：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> node <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tval  <span class=\"type\">int</span></span><br><span class=\"line\">\tnext *node</span><br><span class=\"line\">\tpre  *node</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> MyLinkedList <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\thead *node</span><br><span class=\"line\">\ttail *node</span><br><span class=\"line\">\tl    <span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Constructor</span><span class=\"params\">()</span></span> MyLinkedList &#123;</span><br><span class=\"line\">\tp := &amp;node&#123;</span><br><span class=\"line\">\t\tval:  <span class=\"number\">-1</span>,</span><br><span class=\"line\">\t\tnext: <span class=\"literal\">nil</span>,</span><br><span class=\"line\">\t\tpre:  <span class=\"literal\">nil</span>,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> MyLinkedList&#123;</span><br><span class=\"line\">\t\thead: p,</span><br><span class=\"line\">\t\ttail: p,</span><br><span class=\"line\">\t\tl:    <span class=\"number\">0</span>,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(list *MyLinkedList)</span></span> GetPre(index <span class=\"type\">int</span>) *node &#123;</span><br><span class=\"line\">\tnow := list.head.next</span><br><span class=\"line\">\tpre := list.head</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; index; i++ &#123;</span><br><span class=\"line\">\t\tpre = now</span><br><span class=\"line\">\t\tnow = now.next</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> pre</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(list *MyLinkedList)</span></span> Get(index <span class=\"type\">int</span>) <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> index &lt; <span class=\"number\">0</span> || index &gt;= list.l &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tnow := list.head.next</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; index; i++ &#123;</span><br><span class=\"line\">\t\tnow = now.next</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> now.val</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(list *MyLinkedList)</span></span> AddAtHead(val <span class=\"type\">int</span>) &#123;</span><br><span class=\"line\">\tp := &amp;node&#123;</span><br><span class=\"line\">\t\tval:  val,</span><br><span class=\"line\">\t\tnext: list.head.next,</span><br><span class=\"line\">\t\tpre:  list.head,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> list.head == list.tail &#123;</span><br><span class=\"line\">\t\tlist.tail = p</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tlist.head.next = p</span><br><span class=\"line\">\tlist.l++</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(list *MyLinkedList)</span></span> AddAtTail(val <span class=\"type\">int</span>) &#123;</span><br><span class=\"line\">\tp := &amp;node&#123;</span><br><span class=\"line\">\t\tval:  val,</span><br><span class=\"line\">\t\tnext: <span class=\"literal\">nil</span>,</span><br><span class=\"line\">\t\tpre:  list.tail,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tlist.tail.next = p</span><br><span class=\"line\">\tlist.tail = p</span><br><span class=\"line\">\tlist.l++</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(list *MyLinkedList)</span></span> AddAtIndex(index <span class=\"type\">int</span>, val <span class=\"type\">int</span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> index &gt; list.l &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> index == list.l &#123;</span><br><span class=\"line\">\t\tlist.AddAtTail(val)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> index &lt;= <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tlist.AddAtHead(val)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tp := list.GetPre(index)</span><br><span class=\"line\">\tn := &amp;node&#123;</span><br><span class=\"line\">\t\tval:  val,</span><br><span class=\"line\">\t\tnext: p.next,</span><br><span class=\"line\">\t\tpre:  p,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tp.next = n</span><br><span class=\"line\">\tn.next.pre = n</span><br><span class=\"line\">\tlist.l++</span><br><span class=\"line\">\t<span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(list *MyLinkedList)</span></span> DeleteAtIndex(index <span class=\"type\">int</span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> index &lt; <span class=\"number\">0</span> || index &gt;= list.l &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tp := list.GetPre(index)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> p.next == list.tail &#123;</span><br><span class=\"line\">\t\tlist.tail = p</span><br><span class=\"line\">\t\tlist.l--</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tp.next = p.next.next</span><br><span class=\"line\">    <span class=\"comment\">// 注意点1：之前的if 仅仅能够判断尾节点的情况，但是尾节点的前一个删除时候，会导致后面尾节点的后一个的pre为空，要排除这个情况</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> p.next.next != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tp.next.next.pre = p</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tlist.l--</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"链表结构操作应用例子\"><a href=\"#链表结构操作应用例子\" class=\"headerlink\" title=\"链表结构操作应用例子\"></a>链表结构操作应用例子</h2><p>万变不离其宗，能够完全理解上述的代码流程和操作逻辑之后，其余的使用链表实现的结构或者是使用链表的算法就可以通过对以上的各项方法做修改得到。</p>\n<h3 id=\"1-环形链表\"><a href=\"#1-环形链表\" class=\"headerlink\" title=\"1. 环形链表\"></a>1. 环形链表</h3><blockquote>\n<p>给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>\n<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p>\n<p>不允许修改 链表。</p>\n</blockquote>\n<p>环形链表就等于快慢指针，这是一个定式，</p>\n<p>快慢指针的使用在于，规定出移动速度呈现 $m(m&gt;1, m \\in N)$ 倍关系的两个指针，如果链表当中存在环，那么由于链表的单向性，移动快的指针一定会在移动过程当中与移动慢的指针相遇，此时移动快的指针已完成距离为：$a+n(b+c)+c$  ；移动慢的指针移动了：$a + c$ </p>\n<blockquote>\n<p>这里为什么移动慢的指针没有转圈圈呢？可以通过反证来说明，如果移动慢的指针在还没有被移动快的指针追上前转了一圈,那么移动快的指针就应该也在相同时间内转了 m 圈, $\\because m \\in N, \\therefore $ 移动快的指针必定已经和慢的指针相遇过 m 次，所以可以反推他们的第一次相遇必定是在慢指针第一次转圈过程当中 </p>\n</blockquote>\n<p>然后需要记住的数学方面的规律一共有三条：</p>\n<ul>\n<li><p>快慢指针相遇表示链表有环</p>\n</li>\n<li><p>如果设 m = 2, 那么依据相遇时候所走路程相同可以得到以下推演：<br>$$<br>如果快慢指针在圈内相遇，我们可以将这段路程划分为 a ,b, c<br>\\<br>由于快指针的路程任何时候都是慢指针的两倍，可以得到： a + n(b+c) + c = 2*(a + c)<br>\\<br>展开移项之后可以得到： a = n(b+c)-c,由于移动方向不存在后退，为理解上清楚,进行变式:<br>\\<br>a = (n-1)(b+c)+b<br>\\<br> 这个式子的数学含义是，当快慢指针相遇的时候，从起点到链表入环点的距离 a 等于 链表环长度的n-1倍加b<br>\\<br>在数学当中，绕圈和三角函数一样，但满足一个周期的时候就可以在空间维度上将其丢弃，因为完成一个周期你还是回到了原地址<br>\\这个特性是非常有用的，在处理环问题上可以利用这个空间属性获得不相同时间属性上的相同关系<br>\\ 假设此时，慢指针A在相遇点出发，起点同时也出发新的一个慢指针B，那么当 A 转了n 圈之后，<br>\\ 此时,A在相遇点，B所处位置是：a-n(b+c)=b,也就是说新的B指针此时距离链表入环点的长度为b<br>\\ 此时再走b距离，二者在入环点相遇<br>$$<br>所得结论为： 当快慢指针相遇后，起点重新启动一个慢指针，新旧慢指针第一次相遇位置为链表入环点</p>\n</li>\n<li><p>以上结论和方法可以通过回溯剪枝运用到有向图当中环的数学代码问题</p>\n<p>具体的数学逻辑情况如下图所示：</p>\n<p><img src=\"Y:\\Blog\\blog\\source_posts\\Algorithm\\Golang-数据结构\\img\\linklist_double.jpg\" alt=\"double\"></p>\n</li>\n</ul>\n<p>快慢指针是最能够体现链表遍历特性的一道题目，简单一句话 可以理解为，遍历链表是线性的。</p>\n<blockquote>\n<p><a href=\"https://leetcode.cn/problems/linked-list-cycle-ii/submissions/\">142. 环形链表 II - 力扣（LeetCode）</a></p>\n</blockquote>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">detectCycle</span><span class=\"params\">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用快慢指针解决这个问题</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> head == <span class=\"literal\">nil</span> || head.Next == <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> head.Next == head &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    pre, cur:= head, head</span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"literal\">true</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> cur == <span class=\"literal\">nil</span> || cur.Next == <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cur = cur.Next.Next</span><br><span class=\"line\">        pre = pre.Next</span><br><span class=\"line\">        <span class=\"keyword\">if</span> cur == pre &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 重新再跑一次</span></span><br><span class=\"line\">    cur = head</span><br><span class=\"line\">    <span class=\"keyword\">for</span> cur != pre &#123;</span><br><span class=\"line\">        pre = pre.Next</span><br><span class=\"line\">        cur =cur.Next</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pre</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"2-LRU-缓存\"><a href=\"#2-LRU-缓存\" class=\"headerlink\" title=\"2. LRU 缓存\"></a>2. LRU 缓存</h3><p>LRU 其实更多指的是 LRU 算法：<strong>最久未使用算法（LRU, Least Recently Used）</strong>，LRU算法是依据各块使用的情况， 总是选择那个最长时间未被使用的块替换。这种方法比较好地反映了程序局部性规律。</p>\n<p>其实际应用是在操作系统当中的实现，博文后面也会参考，但如何能够实现一个 LRU 呢？核心关键还是在于 LRU 的核心特征： </p>\n<ul>\n<li>访问和修改的时间复杂度为 O(1)</li>\n<li>需要时常维护结构，使得最常使用和最不常使用的数据位置访问时间复杂度为 O(1)</li>\n</ul>\n<p>对于第一个要求，首先想到的就是哈希表；第二个要求需要维护数据的结构性，使得这个结构性可以表征使用的时间特性，比如将最常使用的数据放在结构的前面，最不常使用的放在结构后面，当数据总量超过限制时候需要删除最后面的数据，具有这样特征的结构可以是： 1. 链表，2. 环形队列；但如果需要保证访问时间复杂度为 O(1)，链表就需要使用双向链表；而在维护结构特征中，二者对于去旧迎新的操作都满足要求，但是如果查找了结构当中的数据并把它转移到前头时候，队列的操作就无法满足O(1) 时间复杂度，故选用以下方案：</p>\n<ul>\n<li>双向链表</li>\n<li>哈希表</li>\n</ul>\n<p>代码思路：</p>\n<p>对一个Cache的操作无非三种：插入(insert)、替换(replace)、查找（lookup）。</p>\n<p>LRU 在此之上需要在做到：</p>\n<ul>\n<li>让刚访问、插入、替换的节点放到链表头，使得末尾节点数据总是最不常访问的</li>\n<li>超过cache限制的时候，需要删除最末尾的数据</li>\n<li>维护一张哈希表访问节点，需要对哈希表做增删改查</li>\n</ul>\n<p>对于以上行为做抽象总结可以得到以下设计：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> LRUCache <span class=\"keyword\">interface</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 构造LRUCache 函数,传入的参数只是设置LRUCache的缓存大小</span></span><br><span class=\"line\">    Construt(capacity <span class=\"type\">int</span>) LRUCache</span><br><span class=\"line\">    <span class=\"comment\">// 共用的操作 [对于复杂的结构，需要实现的底层操作]</span></span><br><span class=\"line\">    <span class=\"comment\">// 在头部插入节点,表示刚使用的数据</span></span><br><span class=\"line\">    <span class=\"comment\">// 传入指针是为了复用原本链表内的节点，减少存储的负担</span></span><br><span class=\"line\">    AddAtHead(node *node) <span class=\"type\">bool</span></span><br><span class=\"line\">    <span class=\"comment\">// 删除节点，删除操作在多个情况下复用，不能只考虑删除tail的情况</span></span><br><span class=\"line\">    <span class=\"comment\">// 清除尾部最不常用节点或者是删除链表内被重新插入到head后面的节点</span></span><br><span class=\"line\">    DeleteNode(node *node) <span class=\"type\">bool</span></span><br><span class=\"line\">    <span class=\"comment\">// 接下来的方法都是对上述方法的排列组</span></span><br><span class=\"line\">    <span class=\"comment\">// 应该先把该节点从链表内删除，然后将这个节点移动到链表头</span></span><br><span class=\"line\">    <span class=\"comment\">// 注意点1 ： 删除链表节点实质是更改节点前后的链表节点指针，并没有修改或者是释放该节点对应对象的存储，所以只要还存有该节点的指针就可以继续操作，不需要考虑深浅拷贝的问题</span></span><br><span class=\"line\">    MoveToHead(node *node)</span><br><span class=\"line\">    <span class=\"comment\">// 依据 key 值查询链表节点，</span></span><br><span class=\"line\">    <span class=\"comment\">// 首先查找map中对应的地址，然后将这个节点 MoveToHead</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果不存在，返回-1</span></span><br><span class=\"line\">    Get(key <span class=\"type\">int</span>) <span class=\"type\">int</span></span><br><span class=\"line\">    <span class=\"comment\">// 依据 key 值更改或者添加节点</span></span><br><span class=\"line\">    <span class=\"comment\">// 当 key 存在时，更新该 key 对应的 value，并且将该 k-v 放置头部；</span></span><br><span class=\"line\">\t<span class=\"comment\">// 当 key 不存在时，如果缓存没达到容量，则在map中和链表中插入k-v；</span></span><br><span class=\"line\">\t<span class=\"comment\">// 当 key 不存在时且缓存容量已满时，则删除链表尾部的 node 以及 map 中的 k-v，然后在链表头部插入node，并在 map 中插入新的 k-v；</span></span><br><span class=\"line\">    Put(key <span class=\"type\">int</span>, value <span class=\"type\">int</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>按照这个想法，我们来实现以下代码：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> node <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">    key <span class=\"type\">int</span></span><br><span class=\"line\">    val <span class=\"type\">int</span></span><br><span class=\"line\">    next *node</span><br><span class=\"line\">    pre *node</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> LRUCache <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    head *node</span><br><span class=\"line\">    tail *node</span><br><span class=\"line\">    <span class=\"built_in\">cap</span> <span class=\"type\">int</span></span><br><span class=\"line\">    m <span class=\"keyword\">map</span>[<span class=\"type\">int</span>]*node</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Constructor</span><span class=\"params\">(capacity <span class=\"type\">int</span>)</span></span> LRUCache &#123;</span><br><span class=\"line\">    head := &amp;node&#123;key: <span class=\"number\">-1</span>, val: <span class=\"number\">-1</span>, next:<span class=\"literal\">nil</span>, pre: <span class=\"literal\">nil</span>,&#125;</span><br><span class=\"line\">    tail := &amp;node&#123;key: <span class=\"number\">-1</span>, val: <span class=\"number\">-1</span>, next:<span class=\"literal\">nil</span>, pre: <span class=\"literal\">nil</span>,&#125;</span><br><span class=\"line\">    l :=  LRUCache&#123;</span><br><span class=\"line\">        head: head,</span><br><span class=\"line\">        tail: tail,</span><br><span class=\"line\">        <span class=\"built_in\">cap</span>: capacity,</span><br><span class=\"line\">        m: <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">int</span>]*node),</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    l.head.next = tail</span><br><span class=\"line\">    l.tail.pre = head</span><br><span class=\"line\">    <span class=\"keyword\">return</span> l</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 基础函数不要设置过多的边界条件判断，让其他调用它的函数来处理边界条件</span></span><br><span class=\"line\"><span class=\"comment\">// 设定前提为该节点已存在</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *LRUCache)</span></span>AddAtHead(n *node)&#123;</span><br><span class=\"line\">    head := l.head</span><br><span class=\"line\">    n.next,head.next.pre = head.next,n</span><br><span class=\"line\">    head.next,n.pre = n,head</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设定前提为该节点已存在</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *LRUCache)</span></span>DeleteNode(n *node)&#123;</span><br><span class=\"line\">    pre, next := n.pre,n.next</span><br><span class=\"line\">    pre.next,next.pre = next,pre</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *LRUCache)</span></span>MoveToHead(n *node)&#123;</span><br><span class=\"line\">    l.DeleteNode(n)</span><br><span class=\"line\">    l.AddAtHead(n)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *LRUCache)</span></span> Get(key <span class=\"type\">int</span>) <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> l.<span class=\"built_in\">cap</span> &lt;= <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> n,ok := l.m[key];ok &#123;</span><br><span class=\"line\">        l.MoveToHead(n)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n.val</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *LRUCache)</span></span> Put(key <span class=\"type\">int</span>, value <span class=\"type\">int</span>)  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> n,ok := l.m[key];ok&#123;</span><br><span class=\"line\">        n.val = value</span><br><span class=\"line\">        l.MoveToHead(n)</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        node := &amp;node&#123;</span><br><span class=\"line\">            key: key,</span><br><span class=\"line\">            val: value,</span><br><span class=\"line\">            next: <span class=\"literal\">nil</span>,</span><br><span class=\"line\">            pre: <span class=\"literal\">nil</span>,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> l.<span class=\"built_in\">cap</span> &lt;= <span class=\"built_in\">len</span>(l.m)&#123;</span><br><span class=\"line\">            dn := l.tail.pre</span><br><span class=\"line\">            l.DeleteNode(dn)</span><br><span class=\"line\">            <span class=\"built_in\">delete</span>(l.m,dn.key)</span><br><span class=\"line\">            l.AddAtHead(node)</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            l.AddAtHead(node)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 注意点： 一定是最后来添加 map 当中的值，如果在 if 之前判断加那么map的值增长了，l.cap 的判断就有问题 </span></span><br><span class=\"line\">        l.m[key] = node</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><a href=\"https://leetcode.cn/problems/lru-cache-lcci/submissions/\">面试题 16.25. LRU 缓存 - 力扣（LeetCode）</a></p>\n</blockquote>\n<p>借鉴一个表示更加简介的版本：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> LinkNode <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">    key, value <span class=\"type\">int</span></span><br><span class=\"line\">    pre, next *LinkNode</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> LRUCache <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    m <span class=\"keyword\">map</span>[<span class=\"type\">int</span>]*LinkNode</span><br><span class=\"line\">    capacity <span class=\"type\">int</span></span><br><span class=\"line\">    head, tail *LinkNode</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Constructor</span><span class=\"params\">(capacity <span class=\"type\">int</span>)</span></span> LRUCache &#123;</span><br><span class=\"line\">    head := &amp;LinkNode&#123;<span class=\"number\">-1</span>, <span class=\"number\">-1</span>, <span class=\"literal\">nil</span>, <span class=\"literal\">nil</span>&#125;</span><br><span class=\"line\">    tail := &amp;LinkNode&#123;<span class=\"number\">-1</span>, <span class=\"number\">-1</span>, <span class=\"literal\">nil</span>, <span class=\"literal\">nil</span>&#125;</span><br><span class=\"line\">    head.next = tail</span><br><span class=\"line\">    tail.pre = head</span><br><span class=\"line\">    cache := LRUCache&#123;<span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">int</span>]*LinkNode), capacity, head, tail&#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cache</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *LRUCache)</span></span> AddNode(node *LinkNode) &#123;</span><br><span class=\"line\">    node.pre = this.head</span><br><span class=\"line\">    node.next = this.head.next</span><br><span class=\"line\">    this.head.next = node</span><br><span class=\"line\">    node.next.pre = node</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *LRUCache)</span></span> RemoveNode(node *LinkNode) &#123;</span><br><span class=\"line\">    node.pre.next = node.next</span><br><span class=\"line\">    node.next.pre = node.pre</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *LRUCache)</span></span> MoveToHead(node *LinkNode) &#123;</span><br><span class=\"line\">    this.RemoveNode(node)</span><br><span class=\"line\">    this.AddNode(node)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *LRUCache)</span></span> Get(key <span class=\"type\">int</span>) <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    m := this.m</span><br><span class=\"line\">    <span class=\"keyword\">if</span> node, ok := m[key]; ok &#123;</span><br><span class=\"line\">        this.MoveToHead(node)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> node.value</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *LRUCache)</span></span> Put(key <span class=\"type\">int</span>, value <span class=\"type\">int</span>)  &#123;</span><br><span class=\"line\">    m := this.m</span><br><span class=\"line\">    <span class=\"keyword\">if</span> node, ok := m[key]; ok &#123;</span><br><span class=\"line\">        node.value = value</span><br><span class=\"line\">        this.MoveToHead(node)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        n := &amp;LinkNode&#123;key, value, <span class=\"literal\">nil</span>, <span class=\"literal\">nil</span>&#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(m) &gt;= this.capacity &#123;</span><br><span class=\"line\">            <span class=\"built_in\">delete</span>(m, this.tail.pre.key)</span><br><span class=\"line\">            this.RemoveNode(this.tail.pre)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        m[key] = n</span><br><span class=\"line\">        this.AddNode(n)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> LinkNode <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">    key, value <span class=\"type\">int</span></span><br><span class=\"line\">    pre, next *LinkNode</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> LRUCache <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    m <span class=\"keyword\">map</span>[<span class=\"type\">int</span>]*LinkNode</span><br><span class=\"line\">    capacity <span class=\"type\">int</span></span><br><span class=\"line\">    head, tail *LinkNode</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Constructor</span><span class=\"params\">(capacity <span class=\"type\">int</span>)</span></span> LRUCache &#123;</span><br><span class=\"line\">    head := &amp;LinkNode&#123;<span class=\"number\">-1</span>, <span class=\"number\">-1</span>, <span class=\"literal\">nil</span>, <span class=\"literal\">nil</span>&#125;</span><br><span class=\"line\">    tail := &amp;LinkNode&#123;<span class=\"number\">-1</span>, <span class=\"number\">-1</span>, <span class=\"literal\">nil</span>, <span class=\"literal\">nil</span>&#125;</span><br><span class=\"line\">    head.next = tail</span><br><span class=\"line\">    tail.pre = head</span><br><span class=\"line\">    cache := LRUCache&#123;<span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">int</span>]*LinkNode), capacity, head, tail&#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cache</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *LRUCache)</span></span> AddNode(node *LinkNode) &#123;</span><br><span class=\"line\">    node.pre = this.head</span><br><span class=\"line\">    node.next = this.head.next</span><br><span class=\"line\">    this.head.next = node</span><br><span class=\"line\">    node.next.pre = node</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *LRUCache)</span></span> RemoveNode(node *LinkNode) &#123;</span><br><span class=\"line\">    node.pre.next = node.next</span><br><span class=\"line\">    node.next.pre = node.pre</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *LRUCache)</span></span> MoveToHead(node *LinkNode) &#123;</span><br><span class=\"line\">    this.RemoveNode(node)</span><br><span class=\"line\">    this.AddNode(node)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *LRUCache)</span></span> Get(key <span class=\"type\">int</span>) <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    m := this.m</span><br><span class=\"line\">    <span class=\"keyword\">if</span> node, ok := m[key]; ok &#123;</span><br><span class=\"line\">        this.MoveToHead(node)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> node.value</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *LRUCache)</span></span> Put(key <span class=\"type\">int</span>, value <span class=\"type\">int</span>)  &#123;</span><br><span class=\"line\">    m := this.m</span><br><span class=\"line\">    <span class=\"keyword\">if</span> node, ok := m[key]; ok &#123;</span><br><span class=\"line\">        node.value = value</span><br><span class=\"line\">        this.MoveToHead(node)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        n := &amp;LinkNode&#123;key, value, <span class=\"literal\">nil</span>, <span class=\"literal\">nil</span>&#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(m) &gt;= this.capacity &#123;</span><br><span class=\"line\">            <span class=\"built_in\">delete</span>(m, this.tail.pre.key)</span><br><span class=\"line\">            this.RemoveNode(this.tail.pre)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        m[key] = n</span><br><span class=\"line\">        this.AddNode(n)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 作者：pengtuo</span></span><br><span class=\"line\"><span class=\"comment\">// 链接：https://leetcode.cn/problems/lru-cache-lcci/solution/goshuang-xiang-lian-biao-map-shi-xian-lru-by-pengt/</span></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"cover":"/img/cover/elderring.png","cover_type":"img","excerpt":"","more":"<h1 id=\"Golang-操作链表\"><a href=\"#Golang-操作链表\" class=\"headerlink\" title=\"Golang  操作链表\"></a>Golang  操作链表</h1><blockquote>\n<p>越是简单的内容越需要熟练的掌握，自己做自己的 chatgpt,</p>\n<p>越是基础的内容越需要细细的追究，避免重复造轮子</p>\n</blockquote>\n<p>链表常见的使用场景和问题：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph TD</span><br><span class=\"line\">A[链表]--&gt;B[内核消息队列]</span><br><span class=\"line\">A--&gt;C[缓存管理]</span><br><span class=\"line\">A--&gt;D[跳表]</span><br><span class=\"line\">A--&gt;E[B+ 树]</span><br></pre></td></tr></table></figure>\n\n<p>由于链表的非连续性和一定程度上的方向性，在边界问题以及实际应用当中的细微问题较多，暴力的解法往往容易全盘皆错，且实际应用当中也会存在不少的问题。</p>\n<p>本文将关注如何做到规范化解决链表问题，在部分解决类型上结合 Golang 的特性来做特有的实现。</p>\n<h2 id=\"链表的基础结构模板\"><a href=\"#链表的基础结构模板\" class=\"headerlink\" title=\"链表的基础结构模板\"></a>链表的基础结构模板</h2><p>链表节点需要包含一个值和一个指向下一个节点的指针，简单的示例如下</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> ListNode <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">    Val <span class=\"type\">int</span></span><br><span class=\"line\">    Next *ListeNode</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当想要实现双向链表的时候则需要添加一个指向前一个结点的指针</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> ListNode <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">    Val <span class=\"type\">int</span></span><br><span class=\"line\">    Pre *ListNode</span><br><span class=\"line\">    Next *ListNode</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> linkList <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">    head *ListNode</span><br><span class=\"line\">    tail *ListNode</span><br><span class=\"line\">    l <span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>简单，但在边界问题和实际使用时侯容易弄错一些地方，在此告诫</p>\n<ol>\n<li><p><strong>ListNode 是 value type</strong>, 在 Golang 当中 struct 对象是一种值类型（value type），而不是指针类型（pointer type）。这意味着，当定义并初始化一个 struct 变量时，它实际上拥有自己的内存空间，而不是仅仅是指向某个内存地址的指针。当按值传递 struct 变量时，函数会复制一份该变量的副本，而不是传递变量的指针。</p>\n<p>但是 ListNode 内部变量需要的是指针类型，指向链表节点分配的地址，所以在初始化上需要注意几个形式：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// l 获得一个指针</span></span><br><span class=\"line\">l := <span class=\"built_in\">new</span>(ListNode&#123;&#125;)</span><br><span class=\"line\">l := &amp;ListNode&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// l 获得一个对象</span></span><br><span class=\"line\">l := ListNode&#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">// 三者输出的结果为：</span></span><br><span class=\"line\"><span class=\"comment\">// l is &#123;0 &lt;nil&gt;&#125;</span></span><br><span class=\"line\"><span class=\"comment\">// l is &amp;&#123;0 &lt;nil&gt;&#125;</span></span><br><span class=\"line\"><span class=\"comment\">// l is &amp;&#123;0 &lt;nil&gt;&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 自己构造函数返回的是一个指针类型, 这个函数是一个模板</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">newListNode</span><span class=\"params\">()</span></span> *ListNode&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;ListNode&#123;</span><br><span class=\"line\">        val: <span class=\"number\">0</span>,</span><br><span class=\"line\">        next: <span class=\"literal\">nil</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 返回结果：l is &amp;&#123;0 &lt;nil&gt;&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>只理解到这里作为平时使用是足够的，但是应用时候一部分人可能因为不知道Go编译器的自动解引用，而导致指针类型和值类型混用时候分不清。</p>\n<p>比如以下的情况是不会报错的：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\tl := ListNode&#123;&#125;</span><br><span class=\"line\">\tl1 := &amp;ListNode&#123;&#125;</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;l is %v\\n&quot;</span>, l.val)</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;l1 is %v\\n&quot;</span>, l1.val)</span><br><span class=\"line\"><span class=\"comment\">/** 输出结果为：</span></span><br><span class=\"line\"><span class=\"comment\">l is 0</span></span><br><span class=\"line\"><span class=\"comment\">l1 is 0</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<p>当创建了 &amp;ListNode{} 变量之后，如果需要调用 ListNode  结构的方法和结构体字段，并不需要使用 (*l).val来获取变量，这里其中实际上是发生了自动解引用，编译器会自动将指针解引用并访问结构体字段。</p>\n<p>其实从使用来说，就对于字段访问并不会体现出很大问题，但是当我们把链表节点转化为interface时候，当定义了方法之后，在调用时候就会出现报错：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> StructF <span class=\"keyword\">interface</span>&#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(st *StructF)</span></span> printData() &#123;</span><br><span class=\"line\">   \tfmt.Println(<span class=\"string\">&quot;yes&quot;</span>)</span><br><span class=\"line\">&#125;    </span><br><span class=\"line\">st1 := StructF&#123;&#125;</span><br><span class=\"line\">   <span class=\"keyword\">var</span> it2 InterfaceTest = st1  <span class=\"comment\">// 编译出错</span></span><br><span class=\"line\">   it2.printData()</span><br></pre></td></tr></table></figure>\n\n<p>在上述的结构体访问例子当中，指针和对象值调用时候的接收器是默认的，golang 帮我们完成了相对应的解引用和取引用，情况如下：</p>\n<ul>\n<li>用<strong>值类型</strong>的实参调用形参为<strong>值类型</strong>的方法</li>\n<li>用<strong>指针类型</strong>的实参调用形参为<strong>值类型</strong>的方法（会进行“自动解引用”）</li>\n<li>用<strong>值类型</strong>的实参调用形参为<strong>指针类型</strong>的方法（会进行“自动取引用”）</li>\n<li>用<strong>指针类型</strong>的实参调用形参为<strong>指针类型</strong>的方法</li>\n</ul>\n<p>而上述例子中我们定义的是interface,当我们编写的代码想要对外暴露服务的时候，传入参数是值类型Golang会自动生成一个对应类型指针的函数方法，但是传入参数是指针类型时候，Golang 则不会重新为这个方法生成值类型的方法。</p>\n<p>在这里需要明确的是：</p>\n<blockquote>\n<ul>\n<li><p>go语言只有值传递，指针也是值传递。</p>\n</li>\n<li><p>对于一个类来说，其<strong>值类型</strong>的方法会自动生成相应的<strong>指针类型</strong>的方法，而指针类型的方法<strong>不会</strong>自动生成相应的值类型的方法</p>\n</li>\n<li><p>结构体类型对于值和指针不加区别（对外暴露使用），但是使用接口对外暴露的时候，值类型会兼容指针类型，但是指针类型不兼容值类型，从而实现对指针的保护，同时实现指针类型的容错。</p>\n</li>\n</ul>\n</blockquote>\n<p>算是一类语法糖</p>\n</li>\n</ol>\n<h3 id=\"链表操作基础模板\"><a href=\"#链表操作基础模板\" class=\"headerlink\" title=\"链表操作基础模板\"></a>链表操作基础模板</h3><p>这里考虑使用假头/假尾的方式来实现，实际上也有参考 k+1 循环队列思想，可以以这样的方式避免很多的空指针问题,不过循环队列是使用取模的方式计算下标，链表则在空间上有更多的自由性。</p>\n<p>假头通常也叫做 “ Dummy Head” 或者 “哑头”，是在链表前面，加上一个额外的节点。</p>\n<blockquote>\n<p>非常推荐以后在写项目或者是接口方法时候，先定义出它对应的 interface,确定输入输出，尽可能保证方法之间是正交的。</p>\n</blockquote>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> ListNode <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">    Val <span class=\"type\">int</span></span><br><span class=\"line\">    Next *ListNode</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> list <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">    head *ListNode</span><br><span class=\"line\">    tail *ListNode</span><br><span class=\"line\">    l <span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 常见的链表操作定义</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> linkList <span class=\"keyword\">interface</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/** 初始化 </span></span><br><span class=\"line\"><span class=\"comment\">    ** new 出一个链表节点并使head和tail都指向这个节点，长度值设置为0</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    newList() *List</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//查找结点，input key get val</span></span><br><span class=\"line\">    <span class=\"comment\">/** 一般返回所查找结点的前一个节点，如果没有查找到这个节点，应该返回head</span></span><br><span class=\"line\"><span class=\"comment\">    ** 1. 初始化 front， back指针，分别指向一前一后</span></span><br><span class=\"line\"><span class=\"comment\">    ** 2. 在查找的时候， front 总是和 back 一起走</span></span><br><span class=\"line\"><span class=\"comment\">    ** 3. 返回前置节点（自己实现的查找函数）</span></span><br><span class=\"line\"><span class=\"comment\">    ** 4. 服务要求的查找函数调用获取到前置节点地址，则目标节点为 p.Next</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    get(key <span class=\"type\">int</span>)value <span class=\"type\">int</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** 在尾部追加节点, input val</span></span><br><span class=\"line\"><span class=\"comment\">    ** 1. 在尾部添加一个新的节点</span></span><br><span class=\"line\"><span class=\"comment\">    ** 2. 移动tail指针</span></span><br><span class=\"line\"><span class=\"comment\">    ** 3. 链表的长度加1</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    addAtEnd(val <span class=\"type\">int</span>)</span><br><span class=\"line\">    <span class=\"comment\">/** 在头部插入节点, input val</span></span><br><span class=\"line\"><span class=\"comment\">    ** 1. 新节点 p.Next 指向 head.Next</span></span><br><span class=\"line\"><span class=\"comment\">    ** 2. head.Next 指向 p</span></span><br><span class=\"line\"><span class=\"comment\">    ** 3. 如果原来的 tail 指向 head 所指向节点，那么就将 tail 指向 p</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    addAtHead(val <span class=\"type\">int</span>)  </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 在指定位置前插入, input key &amp; val</span></span><br><span class=\"line\">    <span class=\"comment\">/** 一般返回所查找结点的前一个节点，如果没有查找到这个节点，应该返回head</span></span><br><span class=\"line\"><span class=\"comment\">    ** 一般存在四种情况：</span></span><br><span class=\"line\"><span class=\"comment\">    ** 1. 如果 index 大于链表长度，则不会插入节点；</span></span><br><span class=\"line\"><span class=\"comment\">    ** 2. 如果 index 等于链表长度，则将该结点附加到链表的末尾 </span></span><br><span class=\"line\"><span class=\"comment\">    ** 3. 如果 index 小于 0 ，则在头部插入节点 </span></span><br><span class=\"line\"><span class=\"comment\">    ** 4. 否则在指定位置前面插入节点</span></span><br><span class=\"line\"><span class=\"comment\">    ** \t4.1  得到 index 之前的节点 pre --&gt; 使用 get 函数</span></span><br><span class=\"line\"><span class=\"comment\">    **  4.2  在 pre 后面添加新的节点</span></span><br><span class=\"line\"><span class=\"comment\">    **  4.3  修改 list 的长度</span></span><br><span class=\"line\"><span class=\"comment\">    ** [插入节点的时候，一定先把pre的next值赋值给p的Next，然后再把pre的next指向p，否则后半链表就无了]</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    addAtIndex(key <span class=\"type\">int</span>, val <span class=\"type\">int</span>)</span><br><span class=\"line\">    <span class=\"comment\">// 删除节点， input key</span></span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">    ** 1. 判断 index 是否有效： index &lt; 0 || index &gt;= l 就直接返回[因为index应该是计算的从0-n-1才对]</span></span><br><span class=\"line\"><span class=\"comment\">    ** 2. 如果 index 合法</span></span><br><span class=\"line\"><span class=\"comment\">    ** \t找到 index 前面的节点</span></span><br><span class=\"line\"><span class=\"comment\">    **  如果要删除的节点是最后一个，那么需要修改tail指针</span></span><br><span class=\"line\"><span class=\"comment\">    **  执行删除操作，并修改链表的长度</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    deleteAtIndex(key <span class=\"type\">int</span>)   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>具体实现</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> linklist</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 链表节点定义</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> linkNode <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tval  <span class=\"type\">int</span></span><br><span class=\"line\">\tnext *linkNode</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 链表定义</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> MyLinkedList <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\thead   *linkNode</span><br><span class=\"line\">\ttail   *linkNode</span><br><span class=\"line\">\tlength <span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 链表构造函数定义，</span></span><br><span class=\"line\"><span class=\"comment\">// 初始化 dummy head 的时候，val设置为-1，指针指向 nil</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Constructor</span><span class=\"params\">()</span></span> MyLinkedList &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 一定注意使用 &amp;linknode&#123;&#125;获取地址，return 值按题目要求来创建</span></span><br><span class=\"line\">\tnode := &amp;linkNode&#123;</span><br><span class=\"line\">\t\tval:  <span class=\"number\">-1</span>,</span><br><span class=\"line\">\t\tnext: <span class=\"literal\">nil</span>,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> MyLinkedList&#123;</span><br><span class=\"line\">\t\thead:   node,</span><br><span class=\"line\">\t\ttail:   node,</span><br><span class=\"line\">\t\tlength: <span class=\"number\">0</span>,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建新的节点并加入在假头节点之后</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(list *MyLinkedList)</span></span> AddAtHead(val <span class=\"type\">int</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 不判断边界条件</span></span><br><span class=\"line\">\tnode := &amp;linkNode&#123;</span><br><span class=\"line\">\t\tval:  val,</span><br><span class=\"line\">\t\tnext: <span class=\"literal\">nil</span>,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tnode.next = list.head.next</span><br><span class=\"line\">\tlist.head.next = node</span><br><span class=\"line\">    <span class=\"comment\">// 关注点1 ： 一定要判断是否当前tail等于head，</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> list.head == list.tail &#123;</span><br><span class=\"line\">\t\tlist.tail = node</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"comment\">// 关注点2： 一定记得维护链表的长度属性</span></span><br><span class=\"line\">\tlist.length++</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建新的节点并加在尾指针之后</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(list *MyLinkedList)</span></span> AddAtTail(val <span class=\"type\">int</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 不需要判断条件</span></span><br><span class=\"line\">\tlist.tail.next = &amp;linkNode&#123;</span><br><span class=\"line\">\t\tval:  val,</span><br><span class=\"line\">\t\tnext: <span class=\"literal\">nil</span>,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tlist.tail = list.tail.next</span><br><span class=\"line\">    <span class=\"comment\">// 关注点2： 一定记得维护链表的长度属性</span></span><br><span class=\"line\">\tlist.length++</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取 index 节点的前一个节点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(list *MyLinkedList)</span></span> GetPre(index <span class=\"type\">int</span>) *linkNode &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 不需要判断，因为边界条件在调用的时候都是特殊情况</span></span><br><span class=\"line\">\tnow := list.head.next</span><br><span class=\"line\">\tpre := list.head</span><br><span class=\"line\">    <span class=\"comment\">// 注意点4： 不要弄反了 now 和 pre 的位置</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; index; i++ &#123;</span><br><span class=\"line\">\t\tpre = now</span><br><span class=\"line\">\t\tnow = now.next</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> pre</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取 index 位置节点的值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(list *MyLinkedList)</span></span> Get(index <span class=\"type\">int</span>) <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 判断边界条件： index &lt; 0 和 index &gt; list.length都是超出的链表的范围</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> index &lt; <span class=\"number\">0</span> || index &gt;= list.length &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tpre := list.GetPre(index)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> pre.next.val</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在 index 位置的前一个位置插入节点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(list *MyLinkedList)</span></span> AddAtIndex(index <span class=\"type\">int</span>, val <span class=\"type\">int</span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> index &gt; list.length &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> index == list.length &#123;</span><br><span class=\"line\">\t\tlist.AddAtTail(val)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> index &lt;= <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tlist.AddAtHead(val)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tpre := list.GetPre(index)</span><br><span class=\"line\">\tnode := &amp;linkNode&#123;</span><br><span class=\"line\">\t\tval:  val,</span><br><span class=\"line\">\t\tnext: <span class=\"literal\">nil</span>,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tnode.next = pre.next</span><br><span class=\"line\">\tpre.next = node</span><br><span class=\"line\">    <span class=\"comment\">// 注意点2： 维护链表的属性</span></span><br><span class=\"line\">\tlist.length++</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(list *MyLinkedList)</span></span> DeleteAtIndex(index <span class=\"type\">int</span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> index &lt; <span class=\"number\">0</span> || index &gt;= list.length &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tpre := list.GetPre(index)</span><br><span class=\"line\">    <span class=\"comment\">// 注意点3： 删除时候需要考虑最后一个结点的情况</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> list.tail == pre.next &#123;</span><br><span class=\"line\">\t\tlist.tail = pre</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tpre.next = pre.next.next</span><br><span class=\"line\">\tlist.length--</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(list *MyLinkedList)</span></span> PrintList() &#123;</span><br><span class=\"line\">\tnow := list.head.next</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> now != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> now == list.tail &#123;</span><br><span class=\"line\">\t\t\tfmt.Printf(<span class=\"string\">&quot;%d=\\n&quot;</span>, now.val)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tfmt.Printf(<span class=\"string\">&quot;%d=&quot;</span>, now.val)</span><br><span class=\"line\">\t\tnow = now.next</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"链表操作参考\"><a href=\"#链表操作参考\" class=\"headerlink\" title=\"链表操作参考\"></a>链表操作参考</h3><p>参考 <code>container/list</code> 的实现</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Package list implements a doubly linked list.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// To iterate over a list (where l is a *List):</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">//\tfor e := l.Front(); e != nil; e = e.Next() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//\t\t// do something with e.Value</span></span><br><span class=\"line\"><span class=\"comment\">//\t&#125;</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> list</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Element is an element of a linked list.</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Element <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// Next and previous pointers in the doubly-linked list of elements.</span></span><br><span class=\"line\">\t<span class=\"comment\">// To simplify the implementation, internally a list l is implemented</span></span><br><span class=\"line\">\t<span class=\"comment\">// as a ring, such that &amp;l.root is both the next element of the last</span></span><br><span class=\"line\">\t<span class=\"comment\">// list element (l.Back()) and the previous element of the first list</span></span><br><span class=\"line\">\t<span class=\"comment\">// element (l.Front()).</span></span><br><span class=\"line\">\tnext, prev *Element</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// The list to which this element belongs.</span></span><br><span class=\"line\">\tlist *List</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// The value stored with this element.</span></span><br><span class=\"line\">\tValue any</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Next returns the next list element or nil.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(e *Element)</span></span> Next() *Element &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> p := e.next; e.list != <span class=\"literal\">nil</span> &amp;&amp; p != &amp;e.list.root &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> p</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Prev returns the previous list element or nil.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(e *Element)</span></span> Prev() *Element &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> p := e.prev; e.list != <span class=\"literal\">nil</span> &amp;&amp; p != &amp;e.list.root &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> p</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// List represents a doubly linked list.</span></span><br><span class=\"line\"><span class=\"comment\">// The zero value for List is an empty list ready to use.</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> List <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\troot Element <span class=\"comment\">// sentinel list element, only &amp;root, root.prev, and root.next are used</span></span><br><span class=\"line\">\t<span class=\"built_in\">len</span>  <span class=\"type\">int</span>     <span class=\"comment\">// current list length excluding (this) sentinel element</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Init initializes or clears list l.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *List)</span></span> Init() *List &#123;</span><br><span class=\"line\">\tl.root.next = &amp;l.root</span><br><span class=\"line\">\tl.root.prev = &amp;l.root</span><br><span class=\"line\">\tl.<span class=\"built_in\">len</span> = <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> l</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// New returns an initialized list.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">New</span><span class=\"params\">()</span></span> *List &#123; <span class=\"keyword\">return</span> <span class=\"built_in\">new</span>(List).Init() &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Len returns the number of elements of list l.</span></span><br><span class=\"line\"><span class=\"comment\">// The complexity is O(1).</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *List)</span></span> Len() <span class=\"type\">int</span> &#123; <span class=\"keyword\">return</span> l.<span class=\"built_in\">len</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Front returns the first element of list l or nil if the list is empty.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *List)</span></span> Front() *Element &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> l.<span class=\"built_in\">len</span> == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> l.root.next</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Back returns the last element of list l or nil if the list is empty.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *List)</span></span> Back() *Element &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> l.<span class=\"built_in\">len</span> == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> l.root.prev</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// lazyInit lazily initializes a zero List value.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *List)</span></span> lazyInit() &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> l.root.next == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tl.Init()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// insert inserts e after at, increments l.len, and returns e.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *List)</span></span> insert(e, at *Element) *Element &#123;</span><br><span class=\"line\">\te.prev = at</span><br><span class=\"line\">\te.next = at.next</span><br><span class=\"line\">\te.prev.next = e</span><br><span class=\"line\">\te.next.prev = e</span><br><span class=\"line\">\te.list = l</span><br><span class=\"line\">\tl.<span class=\"built_in\">len</span>++</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> e</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// insertValue is a convenience wrapper for insert(&amp;Element&#123;Value: v&#125;, at).</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *List)</span></span> insertValue(v any, at *Element) *Element &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> l.insert(&amp;Element&#123;Value: v&#125;, at)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// remove removes e from its list, decrements l.len</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *List)</span></span> remove(e *Element) &#123;</span><br><span class=\"line\">\te.prev.next = e.next</span><br><span class=\"line\">\te.next.prev = e.prev</span><br><span class=\"line\">\te.next = <span class=\"literal\">nil</span> <span class=\"comment\">// avoid memory leaks</span></span><br><span class=\"line\">\te.prev = <span class=\"literal\">nil</span> <span class=\"comment\">// avoid memory leaks</span></span><br><span class=\"line\">\te.list = <span class=\"literal\">nil</span></span><br><span class=\"line\">\tl.<span class=\"built_in\">len</span>--</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// move moves e to next to at.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *List)</span></span> move(e, at *Element) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> e == at &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\te.prev.next = e.next</span><br><span class=\"line\">\te.next.prev = e.prev</span><br><span class=\"line\"></span><br><span class=\"line\">\te.prev = at</span><br><span class=\"line\">\te.next = at.next</span><br><span class=\"line\">\te.prev.next = e</span><br><span class=\"line\">\te.next.prev = e</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Remove removes e from l if e is an element of list l.</span></span><br><span class=\"line\"><span class=\"comment\">// It returns the element value e.Value.</span></span><br><span class=\"line\"><span class=\"comment\">// The element must not be nil.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *List)</span></span> Remove(e *Element) any &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> e.list == l &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// if e.list == l, l must have been initialized when e was inserted</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// in l or l == nil (e is a zero Element) and l.remove will crash</span></span><br><span class=\"line\">\t\tl.remove(e)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> e.Value</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// PushFront inserts a new element e with value v at the front of list l and returns e.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *List)</span></span> PushFront(v any) *Element &#123;</span><br><span class=\"line\">\tl.lazyInit()</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> l.insertValue(v, &amp;l.root)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// PushBack inserts a new element e with value v at the back of list l and returns e.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *List)</span></span> PushBack(v any) *Element &#123;</span><br><span class=\"line\">\tl.lazyInit()</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> l.insertValue(v, l.root.prev)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// InsertBefore inserts a new element e with value v immediately before mark and returns e.</span></span><br><span class=\"line\"><span class=\"comment\">// If mark is not an element of l, the list is not modified.</span></span><br><span class=\"line\"><span class=\"comment\">// The mark must not be nil.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *List)</span></span> InsertBefore(v any, mark *Element) *Element &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> mark.list != l &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// see comment in List.Remove about initialization of l</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> l.insertValue(v, mark.prev)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// InsertAfter inserts a new element e with value v immediately after mark and returns e.</span></span><br><span class=\"line\"><span class=\"comment\">// If mark is not an element of l, the list is not modified.</span></span><br><span class=\"line\"><span class=\"comment\">// The mark must not be nil.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *List)</span></span> InsertAfter(v any, mark *Element) *Element &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> mark.list != l &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// see comment in List.Remove about initialization of l</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> l.insertValue(v, mark)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// MoveToFront moves element e to the front of list l.</span></span><br><span class=\"line\"><span class=\"comment\">// If e is not an element of l, the list is not modified.</span></span><br><span class=\"line\"><span class=\"comment\">// The element must not be nil.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *List)</span></span> MoveToFront(e *Element) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> e.list != l || l.root.next == e &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// see comment in List.Remove about initialization of l</span></span><br><span class=\"line\">\tl.move(e, &amp;l.root)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// MoveToBack moves element e to the back of list l.</span></span><br><span class=\"line\"><span class=\"comment\">// If e is not an element of l, the list is not modified.</span></span><br><span class=\"line\"><span class=\"comment\">// The element must not be nil.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *List)</span></span> MoveToBack(e *Element) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> e.list != l || l.root.prev == e &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// see comment in List.Remove about initialization of l</span></span><br><span class=\"line\">\tl.move(e, l.root.prev)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// MoveBefore moves element e to its new position before mark.</span></span><br><span class=\"line\"><span class=\"comment\">// If e or mark is not an element of l, or e == mark, the list is not modified.</span></span><br><span class=\"line\"><span class=\"comment\">// The element and mark must not be nil.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *List)</span></span> MoveBefore(e, mark *Element) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> e.list != l || e == mark || mark.list != l &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tl.move(e, mark.prev)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// MoveAfter moves element e to its new position after mark.</span></span><br><span class=\"line\"><span class=\"comment\">// If e or mark is not an element of l, or e == mark, the list is not modified.</span></span><br><span class=\"line\"><span class=\"comment\">// The element and mark must not be nil.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *List)</span></span> MoveAfter(e, mark *Element) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> e.list != l || e == mark || mark.list != l &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tl.move(e, mark)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// PushBackList inserts a copy of another list at the back of list l.</span></span><br><span class=\"line\"><span class=\"comment\">// The lists l and other may be the same. They must not be nil.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *List)</span></span> PushBackList(other *List) &#123;</span><br><span class=\"line\">\tl.lazyInit()</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i, e := other.Len(), other.Front(); i &gt; <span class=\"number\">0</span>; i, e = i<span class=\"number\">-1</span>, e.Next() &#123;</span><br><span class=\"line\">\t\tl.insertValue(e.Value, l.root.prev)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// PushFrontList inserts a copy of another list at the front of list l.</span></span><br><span class=\"line\"><span class=\"comment\">// The lists l and other may be the same. They must not be nil.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *List)</span></span> PushFrontList(other *List) &#123;</span><br><span class=\"line\">\tl.lazyInit()</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i, e := other.Len(), other.Back(); i &gt; <span class=\"number\">0</span>; i, e = i<span class=\"number\">-1</span>, e.Prev() &#123;</span><br><span class=\"line\">\t\tl.insertValue(e.Value, &amp;l.root)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>附加双向链表的实现,在双向链表的实现当中添加了一个<code>pre</code> 指针，这样指定节点就可以找到他的前一个节点，时间复杂度是O(1)，同时也多了一些需要判断 <code>nil</code>的情况：</p>\n<ul>\n<li>为避免空指针的问题，还是必须要使用getPre</li>\n<li><code>head</code> 的 <code>pre</code> 一直为空</li>\n</ul>\n<p>为能够解决空指针带来的问题，双向链表应该在单向链表设计的基础上，将<code>tail</code> 指针指向一个假尾，这样就可以避免 <code>nil</code>带来的问题</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>双向链表也给了一个教训： 对指针的操作最好不要超过两层。也就是说，如果不使用假尾来解决链表空指针的问题，那就会导致访存时候要多考虑空指针带来的问题，代码就会变得比较复杂如下所示：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> node <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tval  <span class=\"type\">int</span></span><br><span class=\"line\">\tnext *node</span><br><span class=\"line\">\tpre  *node</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> MyLinkedList <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\thead *node</span><br><span class=\"line\">\ttail *node</span><br><span class=\"line\">\tl    <span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Constructor</span><span class=\"params\">()</span></span> MyLinkedList &#123;</span><br><span class=\"line\">\tp := &amp;node&#123;</span><br><span class=\"line\">\t\tval:  <span class=\"number\">-1</span>,</span><br><span class=\"line\">\t\tnext: <span class=\"literal\">nil</span>,</span><br><span class=\"line\">\t\tpre:  <span class=\"literal\">nil</span>,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> MyLinkedList&#123;</span><br><span class=\"line\">\t\thead: p,</span><br><span class=\"line\">\t\ttail: p,</span><br><span class=\"line\">\t\tl:    <span class=\"number\">0</span>,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(list *MyLinkedList)</span></span> GetPre(index <span class=\"type\">int</span>) *node &#123;</span><br><span class=\"line\">\tnow := list.head.next</span><br><span class=\"line\">\tpre := list.head</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; index; i++ &#123;</span><br><span class=\"line\">\t\tpre = now</span><br><span class=\"line\">\t\tnow = now.next</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> pre</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(list *MyLinkedList)</span></span> Get(index <span class=\"type\">int</span>) <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> index &lt; <span class=\"number\">0</span> || index &gt;= list.l &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tnow := list.head.next</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; index; i++ &#123;</span><br><span class=\"line\">\t\tnow = now.next</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> now.val</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(list *MyLinkedList)</span></span> AddAtHead(val <span class=\"type\">int</span>) &#123;</span><br><span class=\"line\">\tp := &amp;node&#123;</span><br><span class=\"line\">\t\tval:  val,</span><br><span class=\"line\">\t\tnext: list.head.next,</span><br><span class=\"line\">\t\tpre:  list.head,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> list.head == list.tail &#123;</span><br><span class=\"line\">\t\tlist.tail = p</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tlist.head.next = p</span><br><span class=\"line\">\tlist.l++</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(list *MyLinkedList)</span></span> AddAtTail(val <span class=\"type\">int</span>) &#123;</span><br><span class=\"line\">\tp := &amp;node&#123;</span><br><span class=\"line\">\t\tval:  val,</span><br><span class=\"line\">\t\tnext: <span class=\"literal\">nil</span>,</span><br><span class=\"line\">\t\tpre:  list.tail,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tlist.tail.next = p</span><br><span class=\"line\">\tlist.tail = p</span><br><span class=\"line\">\tlist.l++</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(list *MyLinkedList)</span></span> AddAtIndex(index <span class=\"type\">int</span>, val <span class=\"type\">int</span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> index &gt; list.l &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> index == list.l &#123;</span><br><span class=\"line\">\t\tlist.AddAtTail(val)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> index &lt;= <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\tlist.AddAtHead(val)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tp := list.GetPre(index)</span><br><span class=\"line\">\tn := &amp;node&#123;</span><br><span class=\"line\">\t\tval:  val,</span><br><span class=\"line\">\t\tnext: p.next,</span><br><span class=\"line\">\t\tpre:  p,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tp.next = n</span><br><span class=\"line\">\tn.next.pre = n</span><br><span class=\"line\">\tlist.l++</span><br><span class=\"line\">\t<span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(list *MyLinkedList)</span></span> DeleteAtIndex(index <span class=\"type\">int</span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> index &lt; <span class=\"number\">0</span> || index &gt;= list.l &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tp := list.GetPre(index)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> p.next == list.tail &#123;</span><br><span class=\"line\">\t\tlist.tail = p</span><br><span class=\"line\">\t\tlist.l--</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tp.next = p.next.next</span><br><span class=\"line\">    <span class=\"comment\">// 注意点1：之前的if 仅仅能够判断尾节点的情况，但是尾节点的前一个删除时候，会导致后面尾节点的后一个的pre为空，要排除这个情况</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> p.next.next != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tp.next.next.pre = p</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tlist.l--</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"链表结构操作应用例子\"><a href=\"#链表结构操作应用例子\" class=\"headerlink\" title=\"链表结构操作应用例子\"></a>链表结构操作应用例子</h2><p>万变不离其宗，能够完全理解上述的代码流程和操作逻辑之后，其余的使用链表实现的结构或者是使用链表的算法就可以通过对以上的各项方法做修改得到。</p>\n<h3 id=\"1-环形链表\"><a href=\"#1-环形链表\" class=\"headerlink\" title=\"1. 环形链表\"></a>1. 环形链表</h3><blockquote>\n<p>给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>\n<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p>\n<p>不允许修改 链表。</p>\n</blockquote>\n<p>环形链表就等于快慢指针，这是一个定式，</p>\n<p>快慢指针的使用在于，规定出移动速度呈现 $m(m&gt;1, m \\in N)$ 倍关系的两个指针，如果链表当中存在环，那么由于链表的单向性，移动快的指针一定会在移动过程当中与移动慢的指针相遇，此时移动快的指针已完成距离为：$a+n(b+c)+c$  ；移动慢的指针移动了：$a + c$ </p>\n<blockquote>\n<p>这里为什么移动慢的指针没有转圈圈呢？可以通过反证来说明，如果移动慢的指针在还没有被移动快的指针追上前转了一圈,那么移动快的指针就应该也在相同时间内转了 m 圈, $\\because m \\in N, \\therefore $ 移动快的指针必定已经和慢的指针相遇过 m 次，所以可以反推他们的第一次相遇必定是在慢指针第一次转圈过程当中 </p>\n</blockquote>\n<p>然后需要记住的数学方面的规律一共有三条：</p>\n<ul>\n<li><p>快慢指针相遇表示链表有环</p>\n</li>\n<li><p>如果设 m = 2, 那么依据相遇时候所走路程相同可以得到以下推演：<br>$$<br>如果快慢指针在圈内相遇，我们可以将这段路程划分为 a ,b, c<br>\\<br>由于快指针的路程任何时候都是慢指针的两倍，可以得到： a + n(b+c) + c = 2*(a + c)<br>\\<br>展开移项之后可以得到： a = n(b+c)-c,由于移动方向不存在后退，为理解上清楚,进行变式:<br>\\<br>a = (n-1)(b+c)+b<br>\\<br> 这个式子的数学含义是，当快慢指针相遇的时候，从起点到链表入环点的距离 a 等于 链表环长度的n-1倍加b<br>\\<br>在数学当中，绕圈和三角函数一样，但满足一个周期的时候就可以在空间维度上将其丢弃，因为完成一个周期你还是回到了原地址<br>\\这个特性是非常有用的，在处理环问题上可以利用这个空间属性获得不相同时间属性上的相同关系<br>\\ 假设此时，慢指针A在相遇点出发，起点同时也出发新的一个慢指针B，那么当 A 转了n 圈之后，<br>\\ 此时,A在相遇点，B所处位置是：a-n(b+c)=b,也就是说新的B指针此时距离链表入环点的长度为b<br>\\ 此时再走b距离，二者在入环点相遇<br>$$<br>所得结论为： 当快慢指针相遇后，起点重新启动一个慢指针，新旧慢指针第一次相遇位置为链表入环点</p>\n</li>\n<li><p>以上结论和方法可以通过回溯剪枝运用到有向图当中环的数学代码问题</p>\n<p>具体的数学逻辑情况如下图所示：</p>\n<p><img src=\"Y:\\Blog\\blog\\source_posts\\Algorithm\\Golang-数据结构\\img\\linklist_double.jpg\" alt=\"double\"></p>\n</li>\n</ul>\n<p>快慢指针是最能够体现链表遍历特性的一道题目，简单一句话 可以理解为，遍历链表是线性的。</p>\n<blockquote>\n<p><a href=\"https://leetcode.cn/problems/linked-list-cycle-ii/submissions/\">142. 环形链表 II - 力扣（LeetCode）</a></p>\n</blockquote>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">detectCycle</span><span class=\"params\">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用快慢指针解决这个问题</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> head == <span class=\"literal\">nil</span> || head.Next == <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> head.Next == head &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    pre, cur:= head, head</span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"literal\">true</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> cur == <span class=\"literal\">nil</span> || cur.Next == <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cur = cur.Next.Next</span><br><span class=\"line\">        pre = pre.Next</span><br><span class=\"line\">        <span class=\"keyword\">if</span> cur == pre &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 重新再跑一次</span></span><br><span class=\"line\">    cur = head</span><br><span class=\"line\">    <span class=\"keyword\">for</span> cur != pre &#123;</span><br><span class=\"line\">        pre = pre.Next</span><br><span class=\"line\">        cur =cur.Next</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pre</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"2-LRU-缓存\"><a href=\"#2-LRU-缓存\" class=\"headerlink\" title=\"2. LRU 缓存\"></a>2. LRU 缓存</h3><p>LRU 其实更多指的是 LRU 算法：<strong>最久未使用算法（LRU, Least Recently Used）</strong>，LRU算法是依据各块使用的情况， 总是选择那个最长时间未被使用的块替换。这种方法比较好地反映了程序局部性规律。</p>\n<p>其实际应用是在操作系统当中的实现，博文后面也会参考，但如何能够实现一个 LRU 呢？核心关键还是在于 LRU 的核心特征： </p>\n<ul>\n<li>访问和修改的时间复杂度为 O(1)</li>\n<li>需要时常维护结构，使得最常使用和最不常使用的数据位置访问时间复杂度为 O(1)</li>\n</ul>\n<p>对于第一个要求，首先想到的就是哈希表；第二个要求需要维护数据的结构性，使得这个结构性可以表征使用的时间特性，比如将最常使用的数据放在结构的前面，最不常使用的放在结构后面，当数据总量超过限制时候需要删除最后面的数据，具有这样特征的结构可以是： 1. 链表，2. 环形队列；但如果需要保证访问时间复杂度为 O(1)，链表就需要使用双向链表；而在维护结构特征中，二者对于去旧迎新的操作都满足要求，但是如果查找了结构当中的数据并把它转移到前头时候，队列的操作就无法满足O(1) 时间复杂度，故选用以下方案：</p>\n<ul>\n<li>双向链表</li>\n<li>哈希表</li>\n</ul>\n<p>代码思路：</p>\n<p>对一个Cache的操作无非三种：插入(insert)、替换(replace)、查找（lookup）。</p>\n<p>LRU 在此之上需要在做到：</p>\n<ul>\n<li>让刚访问、插入、替换的节点放到链表头，使得末尾节点数据总是最不常访问的</li>\n<li>超过cache限制的时候，需要删除最末尾的数据</li>\n<li>维护一张哈希表访问节点，需要对哈希表做增删改查</li>\n</ul>\n<p>对于以上行为做抽象总结可以得到以下设计：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> LRUCache <span class=\"keyword\">interface</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 构造LRUCache 函数,传入的参数只是设置LRUCache的缓存大小</span></span><br><span class=\"line\">    Construt(capacity <span class=\"type\">int</span>) LRUCache</span><br><span class=\"line\">    <span class=\"comment\">// 共用的操作 [对于复杂的结构，需要实现的底层操作]</span></span><br><span class=\"line\">    <span class=\"comment\">// 在头部插入节点,表示刚使用的数据</span></span><br><span class=\"line\">    <span class=\"comment\">// 传入指针是为了复用原本链表内的节点，减少存储的负担</span></span><br><span class=\"line\">    AddAtHead(node *node) <span class=\"type\">bool</span></span><br><span class=\"line\">    <span class=\"comment\">// 删除节点，删除操作在多个情况下复用，不能只考虑删除tail的情况</span></span><br><span class=\"line\">    <span class=\"comment\">// 清除尾部最不常用节点或者是删除链表内被重新插入到head后面的节点</span></span><br><span class=\"line\">    DeleteNode(node *node) <span class=\"type\">bool</span></span><br><span class=\"line\">    <span class=\"comment\">// 接下来的方法都是对上述方法的排列组</span></span><br><span class=\"line\">    <span class=\"comment\">// 应该先把该节点从链表内删除，然后将这个节点移动到链表头</span></span><br><span class=\"line\">    <span class=\"comment\">// 注意点1 ： 删除链表节点实质是更改节点前后的链表节点指针，并没有修改或者是释放该节点对应对象的存储，所以只要还存有该节点的指针就可以继续操作，不需要考虑深浅拷贝的问题</span></span><br><span class=\"line\">    MoveToHead(node *node)</span><br><span class=\"line\">    <span class=\"comment\">// 依据 key 值查询链表节点，</span></span><br><span class=\"line\">    <span class=\"comment\">// 首先查找map中对应的地址，然后将这个节点 MoveToHead</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果不存在，返回-1</span></span><br><span class=\"line\">    Get(key <span class=\"type\">int</span>) <span class=\"type\">int</span></span><br><span class=\"line\">    <span class=\"comment\">// 依据 key 值更改或者添加节点</span></span><br><span class=\"line\">    <span class=\"comment\">// 当 key 存在时，更新该 key 对应的 value，并且将该 k-v 放置头部；</span></span><br><span class=\"line\">\t<span class=\"comment\">// 当 key 不存在时，如果缓存没达到容量，则在map中和链表中插入k-v；</span></span><br><span class=\"line\">\t<span class=\"comment\">// 当 key 不存在时且缓存容量已满时，则删除链表尾部的 node 以及 map 中的 k-v，然后在链表头部插入node，并在 map 中插入新的 k-v；</span></span><br><span class=\"line\">    Put(key <span class=\"type\">int</span>, value <span class=\"type\">int</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>按照这个想法，我们来实现以下代码：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> node <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">    key <span class=\"type\">int</span></span><br><span class=\"line\">    val <span class=\"type\">int</span></span><br><span class=\"line\">    next *node</span><br><span class=\"line\">    pre *node</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> LRUCache <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    head *node</span><br><span class=\"line\">    tail *node</span><br><span class=\"line\">    <span class=\"built_in\">cap</span> <span class=\"type\">int</span></span><br><span class=\"line\">    m <span class=\"keyword\">map</span>[<span class=\"type\">int</span>]*node</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Constructor</span><span class=\"params\">(capacity <span class=\"type\">int</span>)</span></span> LRUCache &#123;</span><br><span class=\"line\">    head := &amp;node&#123;key: <span class=\"number\">-1</span>, val: <span class=\"number\">-1</span>, next:<span class=\"literal\">nil</span>, pre: <span class=\"literal\">nil</span>,&#125;</span><br><span class=\"line\">    tail := &amp;node&#123;key: <span class=\"number\">-1</span>, val: <span class=\"number\">-1</span>, next:<span class=\"literal\">nil</span>, pre: <span class=\"literal\">nil</span>,&#125;</span><br><span class=\"line\">    l :=  LRUCache&#123;</span><br><span class=\"line\">        head: head,</span><br><span class=\"line\">        tail: tail,</span><br><span class=\"line\">        <span class=\"built_in\">cap</span>: capacity,</span><br><span class=\"line\">        m: <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">int</span>]*node),</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    l.head.next = tail</span><br><span class=\"line\">    l.tail.pre = head</span><br><span class=\"line\">    <span class=\"keyword\">return</span> l</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 基础函数不要设置过多的边界条件判断，让其他调用它的函数来处理边界条件</span></span><br><span class=\"line\"><span class=\"comment\">// 设定前提为该节点已存在</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *LRUCache)</span></span>AddAtHead(n *node)&#123;</span><br><span class=\"line\">    head := l.head</span><br><span class=\"line\">    n.next,head.next.pre = head.next,n</span><br><span class=\"line\">    head.next,n.pre = n,head</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设定前提为该节点已存在</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *LRUCache)</span></span>DeleteNode(n *node)&#123;</span><br><span class=\"line\">    pre, next := n.pre,n.next</span><br><span class=\"line\">    pre.next,next.pre = next,pre</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *LRUCache)</span></span>MoveToHead(n *node)&#123;</span><br><span class=\"line\">    l.DeleteNode(n)</span><br><span class=\"line\">    l.AddAtHead(n)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *LRUCache)</span></span> Get(key <span class=\"type\">int</span>) <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> l.<span class=\"built_in\">cap</span> &lt;= <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> n,ok := l.m[key];ok &#123;</span><br><span class=\"line\">        l.MoveToHead(n)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n.val</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(l *LRUCache)</span></span> Put(key <span class=\"type\">int</span>, value <span class=\"type\">int</span>)  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> n,ok := l.m[key];ok&#123;</span><br><span class=\"line\">        n.val = value</span><br><span class=\"line\">        l.MoveToHead(n)</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        node := &amp;node&#123;</span><br><span class=\"line\">            key: key,</span><br><span class=\"line\">            val: value,</span><br><span class=\"line\">            next: <span class=\"literal\">nil</span>,</span><br><span class=\"line\">            pre: <span class=\"literal\">nil</span>,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> l.<span class=\"built_in\">cap</span> &lt;= <span class=\"built_in\">len</span>(l.m)&#123;</span><br><span class=\"line\">            dn := l.tail.pre</span><br><span class=\"line\">            l.DeleteNode(dn)</span><br><span class=\"line\">            <span class=\"built_in\">delete</span>(l.m,dn.key)</span><br><span class=\"line\">            l.AddAtHead(node)</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            l.AddAtHead(node)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 注意点： 一定是最后来添加 map 当中的值，如果在 if 之前判断加那么map的值增长了，l.cap 的判断就有问题 </span></span><br><span class=\"line\">        l.m[key] = node</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><a href=\"https://leetcode.cn/problems/lru-cache-lcci/submissions/\">面试题 16.25. LRU 缓存 - 力扣（LeetCode）</a></p>\n</blockquote>\n<p>借鉴一个表示更加简介的版本：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> LinkNode <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">    key, value <span class=\"type\">int</span></span><br><span class=\"line\">    pre, next *LinkNode</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> LRUCache <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    m <span class=\"keyword\">map</span>[<span class=\"type\">int</span>]*LinkNode</span><br><span class=\"line\">    capacity <span class=\"type\">int</span></span><br><span class=\"line\">    head, tail *LinkNode</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Constructor</span><span class=\"params\">(capacity <span class=\"type\">int</span>)</span></span> LRUCache &#123;</span><br><span class=\"line\">    head := &amp;LinkNode&#123;<span class=\"number\">-1</span>, <span class=\"number\">-1</span>, <span class=\"literal\">nil</span>, <span class=\"literal\">nil</span>&#125;</span><br><span class=\"line\">    tail := &amp;LinkNode&#123;<span class=\"number\">-1</span>, <span class=\"number\">-1</span>, <span class=\"literal\">nil</span>, <span class=\"literal\">nil</span>&#125;</span><br><span class=\"line\">    head.next = tail</span><br><span class=\"line\">    tail.pre = head</span><br><span class=\"line\">    cache := LRUCache&#123;<span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">int</span>]*LinkNode), capacity, head, tail&#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cache</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *LRUCache)</span></span> AddNode(node *LinkNode) &#123;</span><br><span class=\"line\">    node.pre = this.head</span><br><span class=\"line\">    node.next = this.head.next</span><br><span class=\"line\">    this.head.next = node</span><br><span class=\"line\">    node.next.pre = node</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *LRUCache)</span></span> RemoveNode(node *LinkNode) &#123;</span><br><span class=\"line\">    node.pre.next = node.next</span><br><span class=\"line\">    node.next.pre = node.pre</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *LRUCache)</span></span> MoveToHead(node *LinkNode) &#123;</span><br><span class=\"line\">    this.RemoveNode(node)</span><br><span class=\"line\">    this.AddNode(node)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *LRUCache)</span></span> Get(key <span class=\"type\">int</span>) <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    m := this.m</span><br><span class=\"line\">    <span class=\"keyword\">if</span> node, ok := m[key]; ok &#123;</span><br><span class=\"line\">        this.MoveToHead(node)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> node.value</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *LRUCache)</span></span> Put(key <span class=\"type\">int</span>, value <span class=\"type\">int</span>)  &#123;</span><br><span class=\"line\">    m := this.m</span><br><span class=\"line\">    <span class=\"keyword\">if</span> node, ok := m[key]; ok &#123;</span><br><span class=\"line\">        node.value = value</span><br><span class=\"line\">        this.MoveToHead(node)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        n := &amp;LinkNode&#123;key, value, <span class=\"literal\">nil</span>, <span class=\"literal\">nil</span>&#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(m) &gt;= this.capacity &#123;</span><br><span class=\"line\">            <span class=\"built_in\">delete</span>(m, this.tail.pre.key)</span><br><span class=\"line\">            this.RemoveNode(this.tail.pre)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        m[key] = n</span><br><span class=\"line\">        this.AddNode(n)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> LinkNode <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">    key, value <span class=\"type\">int</span></span><br><span class=\"line\">    pre, next *LinkNode</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> LRUCache <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    m <span class=\"keyword\">map</span>[<span class=\"type\">int</span>]*LinkNode</span><br><span class=\"line\">    capacity <span class=\"type\">int</span></span><br><span class=\"line\">    head, tail *LinkNode</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Constructor</span><span class=\"params\">(capacity <span class=\"type\">int</span>)</span></span> LRUCache &#123;</span><br><span class=\"line\">    head := &amp;LinkNode&#123;<span class=\"number\">-1</span>, <span class=\"number\">-1</span>, <span class=\"literal\">nil</span>, <span class=\"literal\">nil</span>&#125;</span><br><span class=\"line\">    tail := &amp;LinkNode&#123;<span class=\"number\">-1</span>, <span class=\"number\">-1</span>, <span class=\"literal\">nil</span>, <span class=\"literal\">nil</span>&#125;</span><br><span class=\"line\">    head.next = tail</span><br><span class=\"line\">    tail.pre = head</span><br><span class=\"line\">    cache := LRUCache&#123;<span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">int</span>]*LinkNode), capacity, head, tail&#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cache</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *LRUCache)</span></span> AddNode(node *LinkNode) &#123;</span><br><span class=\"line\">    node.pre = this.head</span><br><span class=\"line\">    node.next = this.head.next</span><br><span class=\"line\">    this.head.next = node</span><br><span class=\"line\">    node.next.pre = node</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *LRUCache)</span></span> RemoveNode(node *LinkNode) &#123;</span><br><span class=\"line\">    node.pre.next = node.next</span><br><span class=\"line\">    node.next.pre = node.pre</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *LRUCache)</span></span> MoveToHead(node *LinkNode) &#123;</span><br><span class=\"line\">    this.RemoveNode(node)</span><br><span class=\"line\">    this.AddNode(node)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *LRUCache)</span></span> Get(key <span class=\"type\">int</span>) <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    m := this.m</span><br><span class=\"line\">    <span class=\"keyword\">if</span> node, ok := m[key]; ok &#123;</span><br><span class=\"line\">        this.MoveToHead(node)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> node.value</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *LRUCache)</span></span> Put(key <span class=\"type\">int</span>, value <span class=\"type\">int</span>)  &#123;</span><br><span class=\"line\">    m := this.m</span><br><span class=\"line\">    <span class=\"keyword\">if</span> node, ok := m[key]; ok &#123;</span><br><span class=\"line\">        node.value = value</span><br><span class=\"line\">        this.MoveToHead(node)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        n := &amp;LinkNode&#123;key, value, <span class=\"literal\">nil</span>, <span class=\"literal\">nil</span>&#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(m) &gt;= this.capacity &#123;</span><br><span class=\"line\">            <span class=\"built_in\">delete</span>(m, this.tail.pre.key)</span><br><span class=\"line\">            this.RemoveNode(this.tail.pre)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        m[key] = n</span><br><span class=\"line\">        this.AddNode(n)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 作者：pengtuo</span></span><br><span class=\"line\"><span class=\"comment\">// 链接：https://leetcode.cn/problems/lru-cache-lcci/solution/goshuang-xiang-lian-biao-map-shi-xian-lru-by-pengt/</span></span><br></pre></td></tr></table></figure>\n\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cli796r050001byjx17g59n94","category_id":"cli796r0a0004byjx89p9fxqv","_id":"cli796r0j000ibyjxb88odz0j"},{"post_id":"cli796r090003byjxfvbj3zy1","category_id":"cli796r0g000cbyjx80b76h5x","_id":"cli796r0n000pbyjx3cur5bpc"},{"post_id":"cli796r0d0007byjx72tcf7vi","category_id":"cli796r0g000cbyjx80b76h5x","_id":"cli796r0p000ubyjxbmke0ir4"},{"post_id":"cli796r0f000bbyjxew5wgir7","category_id":"cli796r0n000obyjx37cfazu8","_id":"cli796r0r0010byjxdp3f6en4"},{"post_id":"cli796r0i000hbyjxb4fz1jy3","category_id":"cli796r0p000vbyjx9x6lg2y7","_id":"cli796r0t0017byjx48dyago6"},{"post_id":"cli796r0l000lbyjx63a81eoi","category_id":"cli796r0r0012byjxerrad7r6","_id":"cli796r0v001ebyjxas6veb0c"},{"post_id":"cli796r0n000rbyjx5iaaddjb","category_id":"cli796r0t0019byjx8lho0bew","_id":"cli796r0x001lbyjx0oju65ou"},{"post_id":"cli796r0o000tbyjx1ef60th2","category_id":"cli796r0r0012byjxerrad7r6","_id":"cli796r0z001pbyjx3yq519ni"},{"post_id":"cli796r0p000xbyjx1pjcfd6z","category_id":"cli796r0x001kbyjxczbobr9y","_id":"cli796r10001tbyjxepvo76ke"},{"post_id":"cli796r0t0018byjx39d4bp3q","category_id":"cli796r0z001qbyjxbkcu83h6","_id":"cli796r12001zbyjxaeqcghua"},{"post_id":"cli796r0u001cbyjxaf8pgc8a","category_id":"cli796r0z001qbyjxbkcu83h6","_id":"cli796r140025byjx671a7o3n"},{"post_id":"cli796r0v001dbyjx03z9h8dl","category_id":"cli796r0z001qbyjxbkcu83h6","_id":"cli796r16002abyjxebwe2pdl"},{"post_id":"cli796r0w001hbyjx3t5pf7gl","category_id":"cli796r140024byjx3tun937y","_id":"cli796r18002hbyjxet32hoi7"},{"post_id":"cli796r0y001obyjxdy6eccpj","category_id":"cli796r16002cbyjx43yf5l3s","_id":"cli796r1a002obyjxej2ebnj2"},{"post_id":"cli796r10001sbyjxaa8r48r1","category_id":"cli796r18002jbyjx608ja0a6","_id":"cli796r1b002ubyjxff7ehmm3"},{"post_id":"cli796r11001xbyjx99e63h31","category_id":"cli796r1a002qbyjxdqhx9fzg","_id":"cli796r1d0031byjxcx6han1p"},{"post_id":"cli796r140026byjxae3qg31v","category_id":"cli796r1a002qbyjxdqhx9fzg","_id":"cli796r1e0034byjx3iygfdis"},{"post_id":"cli796r1c002ybyjx259p8vxl","category_id":"cli796r1a002qbyjxdqhx9fzg","_id":"cli796r1e0037byjxcuhi76n1"},{"post_id":"cli796r150027byjxck4n8y08","category_id":"cli796r1d0030byjxdzos7zyi","_id":"cli796r1e0039byjxapvt1gjg"},{"post_id":"cli796r16002ebyjx27hp8h84","category_id":"cli796r1a002qbyjxdqhx9fzg","_id":"cli796r1f003cbyjxggdi4xdk"},{"post_id":"cli796r17002gbyjx995s7lph","category_id":"cli796r1d0030byjxdzos7zyi","_id":"cli796r1f003dbyjx1esw2wjx"},{"post_id":"cli796r18002kbyjx7ywncfo6","category_id":"cli796r1f003bbyjx9nzzad9x","_id":"cli796r1g003fbyjx2nyl4i1x"},{"post_id":"cli796r19002nbyjx2vqt5i1h","category_id":"cli796r1f003ebyjx6qxt5n6r","_id":"cli796r1g003hbyjxdo8yg3rj"},{"post_id":"cli796r1a002rbyjx184p0f41","category_id":"cli796r1f003ebyjx6qxt5n6r","_id":"cli796r1g003ibyjx81x6fp0b"},{"post_id":"cli796r1k003jbyjxfvkx5je7","category_id":"cli796r1a002qbyjxdqhx9fzg","_id":"cli796r1l003nbyjx56i44jo4"},{"post_id":"cli796r1l003kbyjxbhkr5en3","category_id":"cli796r1d0030byjxdzos7zyi","_id":"cli796r1m003obyjx7qu19oyk"}],"PostTag":[{"post_id":"cli796r050001byjx17g59n94","tag_id":"cli796r0c0005byjx3koz1riu","_id":"cli796r0h000ebyjxfjtdf32m"},{"post_id":"cli796r090003byjxfvbj3zy1","tag_id":"cli796r0g000dbyjx2ezheaif","_id":"cli796r0l000mbyjxbhvc2dl8"},{"post_id":"cli796r0d0007byjx72tcf7vi","tag_id":"cli796r0g000dbyjx2ezheaif","_id":"cli796r0o000sbyjx9q1b3rum"},{"post_id":"cli796r0f000bbyjxew5wgir7","tag_id":"cli796r0n000qbyjx1g70b1tb","_id":"cli796r0q000ybyjx3nco0rfk"},{"post_id":"cli796r0p000xbyjx1pjcfd6z","tag_id":"cli796r0p000wbyjxck90h8fj","_id":"cli796r0r0011byjxbdc365e5"},{"post_id":"cli796r0i000hbyjxb4fz1jy3","tag_id":"cli796r0p000wbyjxck90h8fj","_id":"cli796r0s0015byjxggf4af9k"},{"post_id":"cli796r0l000lbyjx63a81eoi","tag_id":"cli796r0r0013byjxfebq49vd","_id":"cli796r0u001bbyjx8iew356g"},{"post_id":"cli796r0n000rbyjx5iaaddjb","tag_id":"cli796r0u001abyjx21wjarv1","_id":"cli796r0w001ibyjxadg62ik1"},{"post_id":"cli796r0o000tbyjx1ef60th2","tag_id":"cli796r0r0013byjxfebq49vd","_id":"cli796r0y001nbyjx8q9kcjj0"},{"post_id":"cli796r10001sbyjxaa8r48r1","tag_id":"cli796r11001wbyjx40226gel","_id":"cli796r140023byjx0ruo9jgl"},{"post_id":"cli796r140026byjxae3qg31v","tag_id":"cli796r130022byjxggf614ai","_id":"cli796r150029byjx7kblhasx"},{"post_id":"cli796r11001xbyjx99e63h31","tag_id":"cli796r130022byjxggf614ai","_id":"cli796r16002dbyjx64j67dog"},{"post_id":"cli796r120020byjx50tqalwm","tag_id":"cli796r150028byjx1dyx6hyo","_id":"cli796r18002ibyjxbjj0fsgk"},{"post_id":"cli796r16002ebyjx27hp8h84","tag_id":"cli796r130022byjxggf614ai","_id":"cli796r19002lbyjxfn7t61dq"},{"post_id":"cli796r150027byjxck4n8y08","tag_id":"cli796r17002fbyjx31qj70av","_id":"cli796r1a002pbyjx01a94g9z"},{"post_id":"cli796r17002gbyjx995s7lph","tag_id":"cli796r19002mbyjxfu7be30u","_id":"cli796r1b002vbyjx5ftb3xsb"},{"post_id":"cli796r18002kbyjx7ywncfo6","tag_id":"cli796r1b002tbyjxgor94bng","_id":"cli796r1d0032byjxfz28gjbb"},{"post_id":"cli796r1b002sbyjxbjsa9kv7","tag_id":"cli796r1d002zbyjxgftwhh71","_id":"cli796r1e0036byjx83ggdnkd"},{"post_id":"cli796r1c002ybyjx259p8vxl","tag_id":"cli796r1e0033byjx6zna3xka","_id":"cli796r1f003abyjx3psv24i2"},{"post_id":"cli796r1k003jbyjxfvkx5je7","tag_id":"cli796r1e0033byjx6zna3xka","_id":"cli796r1l003lbyjx038whery"},{"post_id":"cli796r1l003kbyjxbhkr5en3","tag_id":"cli796r1l003mbyjx88b54tgg","_id":"cli796r1m003pbyjx42iz11zd"}],"Tag":[{"name":"working, acm","_id":"cli796r0c0005byjx3koz1riu"},{"name":"book","_id":"cli796r0g000dbyjx2ezheaif"},{"name":"Searching List， April","_id":"cli796r0n000qbyjx1g70b1tb"},{"name":"ospp, edgemesh","_id":"cli796r0p000wbyjxck90h8fj"},{"name":"ospp, CNI, Linux, Spec","_id":"cli796r0r0013byjxfebq49vd"},{"name":"ospp, Linux, Network","_id":"cli796r0u001abyjx21wjarv1"},{"name":"p2p,cpolar","_id":"cli796r11001wbyjx40226gel"},{"name":"working, 算法","_id":"cli796r130022byjxggf614ai"},{"name":"Golang","_id":"cli796r150028byjx1dyx6hyo"},{"name":"Dynamic Programming","_id":"cli796r17002fbyjx31qj70av"},{"name":"Working","_id":"cli796r19002mbyjxfu7be30u"},{"name":"算法， 南开大学，Golang, working","_id":"cli796r1b002tbyjxgor94bng"},{"name":"Golang, List","_id":"cli796r1d002zbyjxgftwhh71"},{"name":"双指针, 算法","_id":"cli796r1e0033byjx6zna3xka"},{"name":"链表, 算法, 数据结构","_id":"cli796r1l003mbyjx88b54tgg"}]}}