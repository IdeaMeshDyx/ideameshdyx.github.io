{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"themes/butterfly/source/css/index.styl","path":"css/index.styl","modified":1,"renderable":1},{"_id":"themes/butterfly/source/css/var.styl","path":"css/var.styl","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/404.jpg","path":"img/404.jpg","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/favicon.png","path":"img/favicon.png","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":1,"renderable":1},{"_id":"source/LICENSE","path":"LICENSE","modified":1,"renderable":0},{"_id":"source/img/avatar/2077_mobile.png","path":"img/avatar/2077_mobile.png","modified":1,"renderable":0},{"_id":"source/img/backgroud/moon.png","path":"img/backgroud/moon.png","modified":1,"renderable":0},{"_id":"source/img/backgroud/wallhaven-j3m8y5_1920x1080.png","path":"img/backgroud/wallhaven-j3m8y5_1920x1080.png","modified":1,"renderable":0},{"_id":"source/img/backgroud/worriar.png","path":"img/backgroud/worriar.png","modified":1,"renderable":0},{"_id":"source/img/cover/2077_city.png","path":"img/cover/2077_city.png","modified":1,"renderable":0},{"_id":"source/img/cover/elderring.png","path":"img/cover/elderring.png","modified":1,"renderable":0},{"_id":"source/img/logo/mesh.png","path":"img/logo/mesh.png","modified":1,"renderable":0},{"_id":"source/img/signature/signature-removebg.png","path":"img/signature/signature-removebg.png","modified":1,"renderable":0}],"Cache":[{"_id":"source/404.md","hash":"8fde9c71bb4fb2b5fdfce3973912c76127b7d337","modified":1682169841808},{"_id":"source/archives/index.md","hash":"d4b838f32fd09f696e8956017724c4bbc83aeb67","modified":1682169841868},{"_id":"source/about/index.md","hash":"4f97d7e47bebf04d8fdb81baeb5226f814f72512","modified":1682169841868},{"_id":"source/categories/index.md","hash":"47b49f2344165155757a914e0a0adce870b31c3d","modified":1682169841868},{"_id":"source/LICENSE","hash":"7df059597099bb7dcf25d2a9aedfaf4465f72d8d","modified":1682169841808},{"_id":"source/link/index.md","hash":"ee9380a6a315c42ac37ffba213fce9637329df79","modified":1682169841868},{"_id":"source/tags/index.md","hash":"ef8633bd29bfd6d9dcb07b108e5428496aa8d06a","modified":1682169841868},{"_id":"source/_posts/Markdown&Blog/Markdown-常用语法粘贴模板.md","hash":"d7193a606952e1b5e194af329242e183a5763fa9","modified":1682169842008},{"_id":"source/img/logo/mesh.png","hash":"f3f2952c8ce9746d53a5a6b8be035a5da68cf37c","modified":1682169841980},{"_id":"source/_posts/Algorithm/ACM-模式输入输出总结/ACM-模式输入输出总结.md","hash":"48695ebc120807e364701d1b4d1e01bba9b16f1c","modified":1682169842164},{"_id":"source/_posts/Algorithm/ [动态规划] 动态规划问题/ [动态规划] 动态规划问题.md","hash":"38eaec5adb44e08c3df979418a3dfa3c09f48d17","modified":1682169842164},{"_id":"source/_posts/Algorithm/Golang-数据结构/Golang-数据结构-链表.md","hash":"0d6230acff8ca6d37a644592827d01a3e2a023cd","modified":1682244769569},{"_id":"source/_posts/Algorithm/Golang-算法课程/Golang-算法课程--算法.md","hash":"467de38267443de615e6e190c9df68ee14664a1b","modified":1682169842176},{"_id":"source/_posts/Algorithm/Golang-非算法题目/Golang-非算法题目.md","hash":"c48ae5b4303cd21e9bc69902747e217adca80608","modified":1682169842176},{"_id":"source/_posts/Algorithm/[动态规划] 动态规划入门/[动态规划] 动态规划入门.md","hash":"7b34eeae7bb8703790a73f58ee224d6531643749","modified":1682169842176},{"_id":"source/_posts/Algorithm/Golang-数据结构/Golang-算法课程--数据结构.md","hash":"213cf294a51e8562cf1483408c3209712306c246","modified":1682169842164},{"_id":"source/_posts/Algorithm/算法代码通用模板思考/算法代码通用模板思考.md","hash":"d12b86c661711a0545157cacb18d1915223ad6ee","modified":1682169842176},{"_id":"source/_posts/Algorithm/算法课程-南开苏明老师/算法简要汇总.md","hash":"dd9997a679ba6bdbe402564c5e836625d62c0c14","modified":1682169842204},{"_id":"source/_posts/Common/zjx/test.md","hash":"4a5148526c12cf39c596771817fa4f8c206d16dd","modified":1682265925276},{"_id":"source/_posts/EdgeMesh/cilium与edgemesh性能测试/cilium与edgemesh性能测试.md","hash":"81fb8a64eeda33f8c01827cb8d0ab1a91ce5b179","modified":1682169842204},{"_id":"source/_posts/Book/读书笔记-深入理解Linux网络/读书笔记-深入理解Linux网络.md","hash":"e399a75a70e9f2633aec32b75acefe938292cdf3","modified":1682169842204},{"_id":"source/_posts/Go/Go-Pratical-knowledge/Go-Pratical-knowledge.md","hash":"9b61c9987ac8ceb06d6939b94c14807452482c6d","modified":1682169842216},{"_id":"source/_posts/Go/Go-enhanced-knowledge/Go-Goroutine.md","hash":"e20d1decf27cdc77c92c8a4fd3194413b67bc1ca","modified":1682169842216},{"_id":"source/_posts/Go/Go-enhanced-knowledge/Go-enhanced-knowledge.md","hash":"cfd7cbd30c51512e954b26fe14e70662c593d232","modified":1682169842204},{"_id":"source/_posts/Go/Golang-Common-Knowledege/Golang-Common-Knowledege.md","hash":"c02300d93b673798c579a709d1db31b3be9ee4e5","modified":1682169842216},{"_id":"source/_posts/Go/Golang-moudle/Golang-moudle.md","hash":"c68a175d9912fd71de4f60d5942ab80f4a8d9083","modified":1682169842216},{"_id":"source/_posts/Go/Go-basic-knowledge/Go-basic-knowledge.md","hash":"0518d3e8076a9f1e39e35b90c9d04304a0d6b0a4","modified":1682263225917},{"_id":"source/_posts/Go/Golang-moudle/strconv.md","hash":"644c301ecae6468c4d24bbfbff320478753b9a15","modified":1682169842216},{"_id":"source/_posts/Go/Golang-使用链表/Golang-使用链表.md","hash":"dd2b5b4275436b273e703c1cea60c4bcfec32cf9","modified":1682169842236},{"_id":"source/_posts/Go/Golang-协程底层原理解析/Golang-协程底层原理解析.md","hash":"1b6f22f7eb25f00de9de78bc4e8a0789d10649b2","modified":1682169842216},{"_id":"source/_posts/Kubernetes/Kubernetes-网络插件（CNI）性能测试/Kubernetes-网络插件（CNI）性能测试.md","hash":"448dd4023b523e436130a824cf2b658e56cbb6e1","modified":1682169842236},{"_id":"source/_posts/P2P/cpolar/cpolar 使用.md","hash":"89533ed4859ca5692e3604b7eda929a8c2aa654a","modified":1682259400107},{"_id":"source/_posts/RPC/【RPC】Golang-实现简单-RPC/【RPC】Golang-实现简单-RPC.md","hash":"d115a64a8d5b85d97d49a2901936d9e61f6140b8","modified":1682169842236},{"_id":"source/_posts/EdgeMesh/cilium与edgemesh性能测试/2023-ospp-fighting/2023-ospp-fighting.md","hash":"c0fbb4f639f9e6d823b84d1570b8216a07eb142e","modified":1682259407027},{"_id":"source/_posts/EdgeMesh/cilium与edgemesh性能测试/2023-ospp-fighting/Kubernetes 容器网络 CNI — CNI .md","hash":"5e4a54a99efb15a333c72f16f786b8b26bf165f0","modified":1682262713489},{"_id":"source/_posts/Algorithm/Golang-算法课程/Golang-双指针/Golang-双指针.md","hash":"f3877db90df2ac1d2e0ae252b221281d97ccc7eb","modified":1682169842288},{"_id":"source/_posts/Go/Go-面试问答回忆/Go 系统知识汇总.md","hash":"ca79470c1ca0906fa100a17620b636f0994d0e6e","modified":1682169842216},{"_id":"source/_posts/EdgeMesh/cilium与edgemesh性能测试/2023-ospp-fighting/Kubernetes 容器网络 CNI — Pod 容器网络.md","hash":"2d64ead540ce1a70a1c547addafe0b0bba81b50c","modified":1682175485391},{"_id":"source/_posts/EdgeMesh/cilium与edgemesh性能测试/2023-ospp-fighting/实现一个简单的 CNI.md","hash":"d56be022085492a6718a399a4b631ebdf6f799d2","modified":1682175485395},{"_id":"source/_posts/EdgeMesh/cilium与edgemesh性能测试/2023-ospp-fighting/Kubernetes 容器网络 CNI — 现有 CNI 方案的调研 .md","hash":"7b9998afc1a5ac196bf731ecb8d2d3a0e6b67641","modified":1682254625973},{"_id":"source/_posts/EdgeMesh/cilium与edgemesh性能测试/2023-ospp-fighting/Kubernetes 容器网络 CNI — Linux 网络虚拟化.md","hash":"b902b24ac36fa380bb3826aa1a590eec88b67b41","modified":1682244389042},{"_id":"themes/butterfly/LICENSE","hash":"1128f8f91104ba9ef98d37eea6523a888dcfa5de","modified":1682170033220},{"_id":"themes/butterfly/README.md","hash":"52967a864c244af4db8c63902586cb617ee5b8aa","modified":1682170033220},{"_id":"themes/butterfly/package.json","hash":"79b3dde82bc6d983dc383d2810e96fb697d4fba1","modified":1682170033220},{"_id":"themes/butterfly/README_CN.md","hash":"e19021371184361261ddef1d98eb308d78922714","modified":1682170033224},{"_id":"themes/butterfly/languages/default.yml","hash":"4025c0ba440eb24705dd0293ca9ca84efb3105cc","modified":1682170033336},{"_id":"themes/butterfly/languages/en.yml","hash":"4e9cdb7a3570929bcf082de7a4eac49140dddc73","modified":1682170033348},{"_id":"themes/butterfly/plugins.yml","hash":"c7a060713f72ec8b4a45244b3aa8d51d772f5ce8","modified":1682170033220},{"_id":"themes/butterfly/languages/zh-CN.yml","hash":"7dd849c3ba34986c57c764d9e36150b4bfffd2e9","modified":1682170033348},{"_id":"themes/butterfly/languages/zh-TW.yml","hash":"ee01e068f12dc33adfae5733824ea1255deb5ca6","modified":1682170033348},{"_id":"themes/butterfly/layout/category.pug","hash":"710708cfdb436bc875602abf096c919ccdf544db","modified":1682170033348},{"_id":"themes/butterfly/layout/archive.pug","hash":"a0c034c2d319320a54046805e80b58dc48b7e233","modified":1682170033348},{"_id":"themes/butterfly/layout/index.pug","hash":"e1c3146834c16e6077406180858add0a8183875a","modified":1682170033348},{"_id":"themes/butterfly/layout/page.pug","hash":"baf469784aef227e4cc840550888554588e87a13","modified":1682170033352},{"_id":"themes/butterfly/layout/post.pug","hash":"fc9f45252d78fcd15e4a82bfd144401cba5b169a","modified":1682170033352},{"_id":"themes/butterfly/layout/tag.pug","hash":"0440f42569df2676273c026a92384fa7729bc4e9","modified":1682170033352},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/config.yml","hash":"7dfe7189ffeaebb6db13842237f8e124649bea3d","modified":1682170033588},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/bug_report.yml","hash":"fc468a93a64c7a3e408fbac921c9f5a5a8f32027","modified":1682170033624},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/feature_request.yml","hash":"996640605ed1e8e35182f0fd9a60a88783b24b03","modified":1682170033588},{"_id":"themes/butterfly/.github/workflows/publish.yml","hash":"05857c2f265246d8de00e31037f2720709540c09","modified":1682170033624},{"_id":"themes/butterfly/.github/workflows/stale.yml","hash":"ac62b989b5550c756e1986fcc68f243170705383","modified":1682170033624},{"_id":"themes/butterfly/layout/includes/404.pug","hash":"cb49f737aca272ccfeb62880bd651eccee72a129","modified":1682170033624},{"_id":"themes/butterfly/_config.yml","hash":"79b66f0d703e362ce24b791055aaa9f0cd5cb44b","modified":1682170169564},{"_id":"themes/butterfly/layout/includes/additional-js.pug","hash":"aca0ec7ef69b21d1f242c62fed389468a0f0e1a2","modified":1682170033624},{"_id":"themes/butterfly/layout/includes/footer.pug","hash":"02390a5b6ae1f57497b22ba2e6be9f13cfb7acac","modified":1682170033624},{"_id":"themes/butterfly/layout/includes/head.pug","hash":"dd9fde431add984330e3178e06a8d74705e7340e","modified":1682170033624},{"_id":"themes/butterfly/layout/includes/layout.pug","hash":"7fa9ae4b70b87fc97e992dde5944681f92b59bea","modified":1682170033624},{"_id":"themes/butterfly/layout/includes/pagination.pug","hash":"4c85de4dea4dca4e5088097a79bd6d7009cbf8ef","modified":1682170033624},{"_id":"themes/butterfly/layout/includes/rightside.pug","hash":"83a1f2d31792206d432e8e2041e284d88327c02e","modified":1682170033624},{"_id":"themes/butterfly/layout/includes/sidebar.pug","hash":"8d39473ed112d113674a0f689f63fae06c72abd2","modified":1682170033652},{"_id":"themes/butterfly/scripts/events/404.js","hash":"83cd7f73225ccad123afbd526ce1834eb1eb6a6d","modified":1682170033652},{"_id":"themes/butterfly/scripts/events/comment.js","hash":"5351e0bc09e6b5b3f6d30f333a2520626a28ca3a","modified":1682170033652},{"_id":"themes/butterfly/scripts/events/cdn.js","hash":"21fb5aabe043486d095c4c8cce361ed85ba88a26","modified":1682170033652},{"_id":"themes/butterfly/scripts/events/init.js","hash":"3ace1139182d3d367149db138990891427f3356e","modified":1682170033652},{"_id":"themes/butterfly/scripts/events/stylus.js","hash":"9819f0996234fbd80d6c50a9e526c56ebf22588d","modified":1682170033652},{"_id":"themes/butterfly/scripts/events/welcome.js","hash":"8ad9911b755cba13dde2cc055c3f857a6b0dd20e","modified":1682170033652},{"_id":"themes/butterfly/scripts/filters/random_cover.js","hash":"8d25f47434deae870bbffd07efe528a40363ab4d","modified":1682170033652},{"_id":"themes/butterfly/scripts/filters/post_lazyload.js","hash":"932df912976261929f809b7dbd4eb473e7787345","modified":1682170033652},{"_id":"themes/butterfly/scripts/helpers/aside_archives.js","hash":"2ec66513d5322f185d2071acc052978ba9415a8e","modified":1682170033652},{"_id":"themes/butterfly/scripts/helpers/aside_categories.js","hash":"e00efdb5d02bc5c6eb4159e498af69fa61a7dbb9","modified":1682170033656},{"_id":"themes/butterfly/scripts/helpers/findArchiveLength.js","hash":"9ea86bd7a3c3fca3324f70b1cd4d9e42f9efb08d","modified":1682170033676},{"_id":"themes/butterfly/scripts/helpers/page.js","hash":"ce5d5a3d07b0d76ac5e96e5f9e5783f4b601b6be","modified":1682170033676},{"_id":"themes/butterfly/scripts/helpers/related_post.js","hash":"4677be4175da6800c0b3b8c1614e593f73df8831","modified":1682170033676},{"_id":"themes/butterfly/scripts/helpers/inject_head_js.js","hash":"4238e06ff448ff2ee717cd4c874f37f04d35da06","modified":1682170033676},{"_id":"themes/butterfly/scripts/tag/button.js","hash":"91d954f6e9fe6e571eb8ec9f8996294b2dc3688e","modified":1682170033676},{"_id":"themes/butterfly/scripts/tag/flink.js","hash":"ab62919fa567b95fbe14889517abda649991b1ee","modified":1682170033676},{"_id":"themes/butterfly/scripts/tag/gallery.js","hash":"950b3dbac0b21717458a8d1769cbfc454d0eff54","modified":1682170033676},{"_id":"themes/butterfly/scripts/tag/inlineImg.js","hash":"a43ee2c7871bdd93cb6beb804429e404570f7929","modified":1682170033676},{"_id":"themes/butterfly/scripts/tag/hide.js","hash":"396c3ab1bcf1c7693ad7e506eadd13016c6769b6","modified":1682170033676},{"_id":"themes/butterfly/scripts/tag/label.js","hash":"03b2afef41d02bd1045c89578a02402c28356006","modified":1682170033700},{"_id":"themes/butterfly/scripts/tag/mermaid.js","hash":"531808a290b8bdd66bac2faab211ada8e9646a37","modified":1682170033700},{"_id":"themes/butterfly/scripts/tag/note.js","hash":"d51812b43924f1bbf413c67499510dd125022005","modified":1682170033700},{"_id":"themes/butterfly/scripts/tag/score.js","hash":"ea679dfe12d0e2290113b4a9d00663ce7a5ee5ad","modified":1682170033700},{"_id":"themes/butterfly/scripts/tag/tabs.js","hash":"6c6e415623d0fd39da016d9e353bb4f5cca444f5","modified":1682170033700},{"_id":"themes/butterfly/scripts/tag/timeline.js","hash":"300eb779588bf35a1b687d9f829d866074b707e3","modified":1682170033700},{"_id":"themes/butterfly/source/css/index.styl","hash":"861998e4ac67a59529a8245a9130d68f826c9c12","modified":1682170033700},{"_id":"themes/butterfly/source/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1682170033700},{"_id":"themes/butterfly/source/css/var.styl","hash":"30abbb8eed880d51f61f336064d93abd709e0115","modified":1682170033700},{"_id":"themes/butterfly/source/js/utils.js","hash":"2e74fe8ae5ac20067668a18df5985459faf419f9","modified":1682170033708},{"_id":"themes/butterfly/source/js/main.js","hash":"05c825962e365af62096d3f1b4d7c9ee1b5fc2f5","modified":1682170033704},{"_id":"themes/butterfly/layout/includes/head/analytics.pug","hash":"67e1c3b48e4ca7ee0b2c76d3ca7476b9883cf105","modified":1682170033928},{"_id":"themes/butterfly/layout/includes/head/config.pug","hash":"021ccdca211cce0438a378ada37897a8ffcb9574","modified":1682170033928},{"_id":"themes/butterfly/layout/includes/head/Open_Graph.pug","hash":"8aa8d799aedbfd811195b84a451bc4b6e2647c12","modified":1682170033928},{"_id":"themes/butterfly/layout/includes/head/config_site.pug","hash":"7df90c8e432e33716517ab918b0a125bc284041b","modified":1682170033928},{"_id":"themes/butterfly/source/js/tw_cn.js","hash":"76d0c5c172cae44b34b0bd3125fd068b2c3cbd4a","modified":1682170033708},{"_id":"themes/butterfly/layout/includes/head/noscript.pug","hash":"d16ad2ee0ff5751fd7f8a5ce1b83935518674977","modified":1682170033928},{"_id":"themes/butterfly/layout/includes/head/google_adsense.pug","hash":"95a37e92b39c44bcbea4be7e29ddb3921c5b8220","modified":1682170033928},{"_id":"themes/butterfly/layout/includes/head/preconnect.pug","hash":"a03b3ddc06e7aa9fd07eea0d5f97c8d5addd2315","modified":1682170033928},{"_id":"themes/butterfly/layout/includes/head/pwa.pug","hash":"3d492cfe645d37c94d30512e0b230b0a09913148","modified":1682170033928},{"_id":"themes/butterfly/layout/includes/head/site_verification.pug","hash":"e2e8d681f183f00ce5ee239c42d2e36b3744daad","modified":1682170033968},{"_id":"themes/butterfly/layout/includes/header/index.pug","hash":"0c1551ef80bbece550fe520d91e21f083cbc14fe","modified":1682170033968},{"_id":"themes/butterfly/layout/includes/header/menu_item.pug","hash":"31346a210f4f9912c5b29f51d8f659913492f388","modified":1682170033968},{"_id":"themes/butterfly/layout/includes/header/nav.pug","hash":"f61659aa457d1a2d1baa3a13157996cfac4d6609","modified":1682170033968},{"_id":"themes/butterfly/layout/includes/header/social.pug","hash":"5de9a82032cdad1db3b868b797460921cd775fc2","modified":1682170033968},{"_id":"themes/butterfly/layout/includes/loading/fullpage-loading.pug","hash":"68cda524337dfe2e1467318a4a6c124b4c3845a7","modified":1682170033968},{"_id":"themes/butterfly/layout/includes/header/post-info.pug","hash":"9698f22751778dde063cbfbd01c59ca4462ccd85","modified":1682170033968},{"_id":"themes/butterfly/layout/includes/loading/index.pug","hash":"131f344d68b4c241d6e03849b243ee792fcd3cea","modified":1682170033968},{"_id":"themes/butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1682170033704},{"_id":"themes/butterfly/layout/includes/loading/pace.pug","hash":"6ab4e301c92586505d6cddce1b3ad23b7c79010d","modified":1682170033968},{"_id":"themes/butterfly/layout/includes/mixins/article-sort.pug","hash":"90554c2ca5ba946f4c02e1bc5fe2859cef1b1594","modified":1682170033988},{"_id":"themes/butterfly/layout/includes/page/categories.pug","hash":"5276a8d2835e05bd535fedc9f593a0ce8c3e8437","modified":1682170033968},{"_id":"themes/butterfly/layout/includes/page/default-page.pug","hash":"12c65c174d26a41821df9bad26cdf1087ec5b0ca","modified":1682170033968},{"_id":"themes/butterfly/layout/includes/page/tags.pug","hash":"9621991359e22b14049346f1cf87bdedc94edf5a","modified":1682170033988},{"_id":"themes/butterfly/layout/includes/page/flink.pug","hash":"a59bcfbb609a099c1bf5be40b7a94e7e2b06fc4a","modified":1682170033988},{"_id":"themes/butterfly/layout/includes/post/reward.pug","hash":"864869c43fe5b5bb6f4ac6b13dd4bfb16ea47550","modified":1682170033988},{"_id":"themes/butterfly/layout/includes/third-party/aplayer.pug","hash":"c7cfade2b160380432c47eef4cd62273b6508c58","modified":1682170033988},{"_id":"themes/butterfly/layout/includes/post/post-copyright.pug","hash":"ebecba46a5f4efe1c98a386df06c56e26fbd07b9","modified":1682170033988},{"_id":"themes/butterfly/layout/includes/third-party/pangu.pug","hash":"0f024e36b8116118233e10118714bde304e01e12","modified":1682170033988},{"_id":"themes/butterfly/layout/includes/third-party/effect.pug","hash":"6528e86656906117a1af6b90e0349c2c4651d5e1","modified":1682170033988},{"_id":"themes/butterfly/layout/includes/third-party/pjax.pug","hash":"fc0b09068009edd4026d90a669608cbe211aeecf","modified":1682170033992},{"_id":"themes/butterfly/layout/includes/mixins/post-ui.pug","hash":"294df7a74cf36af3a7030274d8b745979c1c8c70","modified":1682170033988},{"_id":"themes/butterfly/layout/includes/third-party/prismjs.pug","hash":"ffb9ea15a2b54423cd4cd441e2d061b8233e9b58","modified":1682170033992},{"_id":"themes/butterfly/layout/includes/third-party/subtitle.pug","hash":"35223531f8e086d57caec2d17d45ddbcb39deb74","modified":1682170034008},{"_id":"themes/butterfly/layout/includes/widget/card_ad.pug","hash":"60dc48a7b5d89c2a49123c3fc5893ab9c57dd225","modified":1682170033996},{"_id":"themes/butterfly/layout/includes/widget/card_announcement.pug","hash":"ae392459ad401a083ca51ee0b27526b3c1e1faed","modified":1682170034008},{"_id":"themes/butterfly/layout/includes/widget/card_archives.pug","hash":"86897010fe71503e239887fd8f6a4f5851737be9","modified":1682170034008},{"_id":"themes/butterfly/layout/includes/widget/card_bottom_self.pug","hash":"13dc8ce922e2e2332fe6ad5856ebb5dbf9ea4444","modified":1682170034008},{"_id":"themes/butterfly/layout/includes/widget/card_categories.pug","hash":"d1a416d0a8a7916d0b1a41d73adc66f8c811e493","modified":1682170034008},{"_id":"themes/butterfly/layout/includes/widget/card_author.pug","hash":"e37468e63db2a0ac09b65d21b7de3e62425bb455","modified":1682170034008},{"_id":"themes/butterfly/layout/includes/widget/card_newest_comment.pug","hash":"6d93564a8bd13cb9b52ee5e178db3bcbf18b1bc6","modified":1682170034008},{"_id":"themes/butterfly/layout/includes/widget/card_post_toc.pug","hash":"3057a2f6f051355e35d3b205121af8735100eacf","modified":1682170034008},{"_id":"themes/butterfly/layout/includes/widget/card_tags.pug","hash":"eceb4420a64c720f0d2741e89d6229bbb3d87353","modified":1682170034008},{"_id":"themes/butterfly/layout/includes/widget/card_recent_post.pug","hash":"e5aac7b28ed4123d75797263c64e74ac547945bc","modified":1682170034008},{"_id":"themes/butterfly/layout/includes/widget/index.pug","hash":"010e3d548ababca2280c4fc4168d9a4a1ee4f536","modified":1682170034012},{"_id":"themes/butterfly/layout/includes/widget/card_top_self.pug","hash":"ae67c6d4130a6c075058a9c1faea1648bcc6f83e","modified":1682170034008},{"_id":"themes/butterfly/source/css/_global/function.styl","hash":"7fdfbe8f97b41588bbd5c6f27e7e85a881b28954","modified":1682170034024},{"_id":"themes/butterfly/layout/includes/widget/card_webinfo.pug","hash":"35ce167c5a275211bfc1fa3d49adfde5b404d98f","modified":1682170034024},{"_id":"themes/butterfly/source/css/_highlight/theme.styl","hash":"bcd384c8b2aa0390c9eb69ac1abbfd1240ce1da4","modified":1682170034024},{"_id":"themes/butterfly/source/css/_highlight/highlight.styl","hash":"2f95e99b8351fbecd9037a1bbdc3fee9d6ea8a77","modified":1682170034024},{"_id":"themes/butterfly/source/css/_global/index.styl","hash":"4f5636c326f794417296bdb6bcfd6a8b207d69d8","modified":1682170034024},{"_id":"themes/butterfly/source/css/_layout/chat.styl","hash":"f9a5d3f1fc5ed0ed2ee4c1eaa58ed650d11ddebd","modified":1682170034024},{"_id":"themes/butterfly/source/css/_layout/comments.styl","hash":"c61dccca690d486c3d9c29cf028d87b777385141","modified":1682170034028},{"_id":"themes/butterfly/source/css/_layout/aside.styl","hash":"57adf29a3e36e4ea84384e36c034eb294dffb208","modified":1682170034024},{"_id":"themes/butterfly/source/css/_layout/footer.styl","hash":"83553445fbc92cad4ad220fbd87b4c3db958c32a","modified":1682170034028},{"_id":"themes/butterfly/source/css/_layout/pagination.styl","hash":"fb9f78bfbb79579f1d752cb73fb6d25c8418e0fd","modified":1682170034040},{"_id":"themes/butterfly/source/css/_layout/head.styl","hash":"45d71dbb2a61e30989851ba29bb8be7094574d14","modified":1682170034040},{"_id":"themes/butterfly/source/css/_layout/relatedposts.styl","hash":"d53de408cb27a2e704aba7f7402b7caebe0410d8","modified":1682170034040},{"_id":"themes/butterfly/source/css/_layout/loading.styl","hash":"ac2aeee9926f75b2a0098efe1c114126987430f2","modified":1682170034040},{"_id":"themes/butterfly/source/css/_layout/reward.styl","hash":"c5cfed620708807a48076b5ee59b0ba84e29aa80","modified":1682170034040},{"_id":"themes/butterfly/source/css/_layout/rightside.styl","hash":"bbc884d6b2158a833b77a1bbc07248e17874b22e","modified":1682170034040},{"_id":"themes/butterfly/source/css/_layout/sidebar.styl","hash":"631ca35a38bc4ac052e9caf47508ff1f99842fc7","modified":1682170034064},{"_id":"themes/butterfly/source/css/_layout/third-party.styl","hash":"ca39e634668ed4fbb43267ec4782c2b55c44e698","modified":1682170034064},{"_id":"themes/butterfly/source/css/_layout/post.styl","hash":"e24046fad288a13897195038cb7a63d1014cd7b8","modified":1682170034040},{"_id":"themes/butterfly/source/css/_mode/darkmode.styl","hash":"7ff0c456fae2717ddbbb9f8fae2734d449a5448b","modified":1682170034072},{"_id":"themes/butterfly/source/css/_page/404.styl","hash":"50dbb9e6d98c71ffe16741b8c1b0c1b9771efd2b","modified":1682170034072},{"_id":"themes/butterfly/source/css/_page/categories.styl","hash":"f01ee74948cedb44e53cd3bb1ef36b7d2778ede7","modified":1682170034072},{"_id":"themes/butterfly/source/css/_page/archives.styl","hash":"c9e98027f2dd730ce389c2047f62ebb748955fcf","modified":1682170034072},{"_id":"themes/butterfly/source/css/_page/common.styl","hash":"e4b9d6164e97b30c84e1218c7543c60f6b29edcc","modified":1682170034072},{"_id":"themes/butterfly/source/css/_page/flink.styl","hash":"98d755b686ee833e9da10afaa40c4ec2bd66c19a","modified":1682170034072},{"_id":"themes/butterfly/source/css/_page/homepage.styl","hash":"bb470da1d2ba292cae0a30a252f82f37c4130d2d","modified":1682170034088},{"_id":"themes/butterfly/source/css/_page/tags.styl","hash":"580feb7e8b0822a1be48ac380f8c5c53b1523321","modified":1682170034088},{"_id":"themes/butterfly/source/css/_mode/readmode.styl","hash":"ffea9e7c1543edcf080381e7b99828954c2f2cef","modified":1682170034072},{"_id":"themes/butterfly/source/css/_search/algolia.styl","hash":"649a054e73278b6724bd4dd9b94724791ec5c928","modified":1682170034088},{"_id":"themes/butterfly/source/css/_search/local-search.styl","hash":"a86e4e9198b225b4b73a7a45f04b86cbbed0d231","modified":1682170034088},{"_id":"themes/butterfly/source/css/_search/index.styl","hash":"678e56ad2e46b630364540fc6a881d6801192dcd","modified":1682170034088},{"_id":"themes/butterfly/source/css/_tags/hexo.styl","hash":"d76c38adf1d9c1279ef4241835667789f5b736e0","modified":1682170034088},{"_id":"themes/butterfly/source/css/_tags/button.styl","hash":"45f0c32bdea117540f6b14ebac6450d7142bd710","modified":1682170034088},{"_id":"themes/butterfly/source/css/_tags/inlineImg.styl","hash":"df9d405c33a9a68946b530410f64096bcb72560c","modified":1682170034088},{"_id":"themes/butterfly/source/css/_tags/hide.styl","hash":"ce489ca2e249e2a3cf71584e20d84bdb022e3475","modified":1682170034088},{"_id":"themes/butterfly/source/css/_tags/gallery.styl","hash":"81ad85acf0e0fe7f9ee23c16a700e7154574d5dd","modified":1682170034088},{"_id":"themes/butterfly/source/css/_tags/label.styl","hash":"66c59e193d794cdb02cca7bd1dc4aea5a19d7e84","modified":1682170034088},{"_id":"themes/butterfly/source/css/_tags/tabs.styl","hash":"bf9568444dd54e39dc59b461323dcd38942f27d9","modified":1682170034092},{"_id":"themes/butterfly/source/css/_tags/timeline.styl","hash":"f071156d439556e7463ed4bc61ceee87170d5d08","modified":1682170034092},{"_id":"themes/butterfly/source/css/_third-party/normalize.min.css","hash":"2c18a1c9604af475b4749def8f1959df88d8b276","modified":1682170034092},{"_id":"themes/butterfly/source/css/_tags/note.styl","hash":"85ae91c83691ea4511f4277da1194a185251cc78","modified":1682170034088},{"_id":"themes/butterfly/layout/includes/third-party/abcjs/abcjs.pug","hash":"ed6906b7c6aa7046bbad95dfdda9211997be7099","modified":1682170034216},{"_id":"themes/butterfly/source/js/search/algolia.js","hash":"fd86281d4f0f99ce173e49c1a0df3507fe268d37","modified":1682170034092},{"_id":"themes/butterfly/layout/includes/third-party/abcjs/index.pug","hash":"cabb3a06f8ef297a1ea3d91ced8abeaa0831aa14","modified":1682170034216},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/artalk.pug","hash":"99d9b17668260b242749c16851d9ec1024d31899","modified":1682170034216},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/disqus.pug","hash":"d85c3737b5c9548553a78b757a7698df126a52cf","modified":1682170034216},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/index.pug","hash":"b2d274db84ef22fbd6d5ea8f4404821898934209","modified":1682170034216},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/fb.pug","hash":"0344477a2cf38698318ead2681c63ac12f01586e","modified":1682170034240},{"_id":"themes/butterfly/source/js/search/local-search.js","hash":"8a0547ecb33ad2939450152adf54fca58e22a424","modified":1682170034092},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/remark42.pug","hash":"001e8be47854b891efe04013c240c38fed4185eb","modified":1682170034240},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/twikoo.pug","hash":"58406a7a3bf45815769f652bf3ef81e57dcd07eb","modified":1682170034240},{"_id":"themes/butterfly/layout/includes/third-party/chat/chatra.pug","hash":"481cd5053bafb1a19f623554a27d3aa077ea59c3","modified":1682170034240},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/waline.pug","hash":"55acc455ca8e13211e3906cf78e487cc92accee5","modified":1682170034240},{"_id":"themes/butterfly/layout/includes/third-party/chat/crisp.pug","hash":"76634112c64023177260d1317ae39cef2a68e35f","modified":1682170034240},{"_id":"themes/butterfly/layout/includes/third-party/chat/daovoice.pug","hash":"cfe63e7d26a6665df6aa32ca90868ad48e05ec04","modified":1682170034240},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/valine.pug","hash":"39427e107230a10790972349c9dd4c4f31d55eb7","modified":1682170034240},{"_id":"themes/butterfly/layout/includes/third-party/chat/index.pug","hash":"618e1b7f9204049b07beb9e1363c844a78a9ace3","modified":1682170034240},{"_id":"themes/butterfly/layout/includes/third-party/chat/messenger.pug","hash":"3ce0461534b786cb71d9141dff35fa5cb70e22b9","modified":1682170034240},{"_id":"themes/butterfly/layout/includes/third-party/comments/artalk.pug","hash":"95738f110598f999d627234e78ff9e9decac1b9b","modified":1682170034260},{"_id":"themes/butterfly/layout/includes/third-party/chat/tidio.pug","hash":"24a926756c2300b9c561aaab6bd3a71fdd16e16d","modified":1682170034240},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqus.pug","hash":"8ec24c1939895ac0db2b2e8700bc9307b4ceb53c","modified":1682170034260},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"3ba842bf4801b2f115c2cfe5657f35a732ce589f","modified":1682170034260},{"_id":"themes/butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"a833715eec2171ff05664d6d5752a57c954192ce","modified":1682170034260},{"_id":"themes/butterfly/layout/includes/third-party/comments/giscus.pug","hash":"9c16ff9cdc444ebf47eed33ea35b8366459a18f0","modified":1682170034260},{"_id":"themes/butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"1c3a87393cb49915940c2dd206356c2a16549767","modified":1682170034260},{"_id":"themes/butterfly/layout/includes/third-party/comments/index.pug","hash":"351fe25fbf02635b1f9e86e5e244c7d61f69baa7","modified":1682170034260},{"_id":"themes/butterfly/layout/includes/third-party/comments/js.pug","hash":"00ed91c52939b9675b316137f854d13684c895a6","modified":1682170034260},{"_id":"themes/butterfly/layout/includes/third-party/comments/remark42.pug","hash":"e9bdf80d6796afc04eb809dbbe780d97f22c7fcd","modified":1682170034260},{"_id":"themes/butterfly/layout/includes/third-party/comments/twikoo.pug","hash":"e18fbd88d8942e53e771f29b26209ab735c5c567","modified":1682170034264},{"_id":"themes/butterfly/layout/includes/third-party/comments/valine.pug","hash":"e55b9c0f8ced231f47eb88bd7f4ec99f29c5c29d","modified":1682170034264},{"_id":"themes/butterfly/layout/includes/third-party/comments/utterances.pug","hash":"a737046e730eb7264606ba0536218964044492f9","modified":1682170034264},{"_id":"themes/butterfly/layout/includes/third-party/comments/livere.pug","hash":"52ea8aa26b84d3ad38ae28cdf0f163e9ca8dced7","modified":1682170034260},{"_id":"themes/butterfly/layout/includes/third-party/math/index.pug","hash":"b8ae5fd7d74e1edcef21f5004fc96147e064d219","modified":1682170034264},{"_id":"themes/butterfly/layout/includes/third-party/comments/waline.pug","hash":"26ba1fc99117993087b1c6e02daa2626627d8eb1","modified":1682170034288},{"_id":"themes/butterfly/layout/includes/third-party/math/katex.pug","hash":"dfcbd9881be569ea420eff1a6b00e4f4dbe2138e","modified":1682170034264},{"_id":"themes/butterfly/layout/includes/third-party/math/mermaid.pug","hash":"8e33aca36a4d3ae9e041ba05ced8eff56ae38f77","modified":1682170034288},{"_id":"themes/butterfly/layout/includes/third-party/math/mathjax.pug","hash":"0ea633b11b357afa50c200290d19c32467d58a1d","modified":1682170034288},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/artalk.pug","hash":"e6ebbe137dd86b6d8750a6843e350fcd16030981","modified":1682170034288},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"04b2a5882e789a988e41d45abe606f0617b08e38","modified":1682170034288},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"e846ddfe4a63b15d1416f6055f5756af5e3da7c6","modified":1682170034288},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"4ec0642f2d5444acfab570a6f8c7868e7ff43fde","modified":1682170034308},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/valine.pug","hash":"d19e1c2c0a50f0e4547d71a17b9be88e8152f17c","modified":1682170034308},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"233907dd7f5b5f33412701d2ccffbc0bbae8707b","modified":1682170034288},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/waline.pug","hash":"441d87067d87d9996b53b25c05b8e620bd94b027","modified":1682170034308},{"_id":"themes/butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1682170033704},{"_id":"themes/butterfly/layout/includes/third-party/search/docsearch.pug","hash":"1c3e101445c5571ba998ce293d3984319df1b3b0","modified":1682170034308},{"_id":"themes/butterfly/layout/includes/third-party/search/algolia.pug","hash":"9c3c109a12d2b6916e8b4965cca12f521510ead9","modified":1682170034308},{"_id":"themes/butterfly/layout/includes/third-party/search/local-search.pug","hash":"5ebd5e8d39c9f77f5b2d983f6cd6802ccaf98746","modified":1682170034308},{"_id":"themes/butterfly/layout/includes/third-party/search/index.pug","hash":"a99a41334387ee9a46c6f8e8212331a29a10d159","modified":1682170034308},{"_id":"themes/butterfly/layout/includes/third-party/share/add-this.pug","hash":"2980f1889226ca981aa23b8eb1853fde26dcf89a","modified":1682170034308},{"_id":"themes/butterfly/layout/includes/third-party/share/addtoany.pug","hash":"85c92f8a7e44d7cd1c86f089a05be438535e5362","modified":1682170034308},{"_id":"themes/butterfly/layout/includes/third-party/share/index.pug","hash":"4c4a9c15215ae8ac5eadb0e086b278f76db9ee92","modified":1682170034308},{"_id":"themes/butterfly/layout/includes/third-party/share/share-js.pug","hash":"c7dd2b2ae9b23aa0a60fffd7df9e9f76ef52033e","modified":1682170034308},{"_id":"themes/butterfly/source/css/_highlight/highlight/diff.styl","hash":"cf1fae641c927621a4df1be5ca4a853b9b526e23","modified":1682170034308},{"_id":"themes/butterfly/source/css/_highlight/highlight/index.styl","hash":"18804c58239d95798fa86d0597f32d7f7dd30051","modified":1682170034312},{"_id":"themes/butterfly/source/css/_highlight/prismjs/diff.styl","hash":"5972c61f5125068cbe0af279a0c93a54847fdc3b","modified":1682170034312},{"_id":"themes/butterfly/source/css/_highlight/prismjs/index.styl","hash":"5dc2e0bcae9a54bfb9bdcc82d02ae5a3cf1ca97d","modified":1682170034312},{"_id":"themes/butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"8970cc1916c982b64a1478792b2822d1d31e276d","modified":1682170034312},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/remark42.pug","hash":"ab167c00da4506f591b96f0591bf5bd214a26d4b","modified":1682170034288},{"_id":"source/img/backgroud/worriar.png","hash":"b64eb20fbca3fd872e418fe8d99bb4231476ca43","modified":1682169841972},{"_id":"source/_posts/Algorithm/算法代码通用模板思考/tree_stack1.jpg","hash":"1a1eb04409eb03631a2f6acaefebdd6272ed937c","modified":1682169842180},{"_id":"source/_posts/Algorithm/算法代码通用模板思考/tree_stack2.jpg","hash":"f8207862e2abfdc69db0bbe1b2fda701f879e387","modified":1682169842204},{"_id":"source/img/backgroud/moon.png","hash":"aaa1e772e8c105173f3f3ef7bbe210ef402b363e","modified":1682169842248},{"_id":"source/img/signature/signature-removebg.png","hash":"ba5103eca83d60fd0682ad746442c48998b1c66f","modified":1682169842376},{"_id":"source/img/cover/elderring.png","hash":"64a2a218f16327a856375592a001d8ac3269d502","modified":1682169842356},{"_id":"source/img/avatar/2077_mobile.png","hash":"f5bba8aa0fd7a52106544451810c4da4a9c7b2c1","modified":1682169842308},{"_id":"source/img/backgroud/wallhaven-j3m8y5_1920x1080.png","hash":"f00c06b6d4b9249048ba275b082908bcd9afcbd7","modified":1682169842404},{"_id":"source/img/cover/2077_city.png","hash":"34b8054002690965e2cc7a7422491ca65cef023c","modified":1682169842412},{"_id":"public/atom.xml","hash":"70eb289e84e3d0ec639d85a3e775a12fbecc67bf","modified":1682266735473},{"_id":"public/sitemap.xml","hash":"14552c5b1e2f4d781b12a9b91d1554544ab961b1","modified":1682266735473},{"_id":"public/sitemap.txt","hash":"7a1daf5f0ca538e4cf0fb68aad7a00f3d71b5cdf","modified":1682266735473},{"_id":"public/404.html","hash":"23ebd4090627922aed7a33c2cc8b7e230ae0c0be","modified":1682266735473},{"_id":"public/about/index.html","hash":"d1531f48d6e247aa0ace0dcab9a5fa05b0a6370e","modified":1682266735473},{"_id":"public/archives/index.html","hash":"910d2241e7222cb3ce9b1cf033f255061ee0a4b5","modified":1682266735473},{"_id":"public/categories/index.html","hash":"a7889a30e7dbafe6a4dacc735e4b550d18084e0d","modified":1682266735473},{"_id":"public/link/index.html","hash":"0a636a0bc43c43f32995cfac2544e91e4d40c2be","modified":1682266735473},{"_id":"public/tags/index.html","hash":"d30b333badd73335da18d28c51256bc2c9a609b6","modified":1682266735473},{"_id":"public/2023/04/18/EdgeMesh/cilium与edgemesh性能测试/2023-ospp-fighting/2023-ospp-fighting/index.html","hash":"574a373c58cdc0ec33fd23ffc9fb361663f9cd8c","modified":1682266735473},{"_id":"public/2023/04/18/EdgeMesh/cilium与edgemesh性能测试/2023-ospp-fighting/Kubernetes 容器网络 CNI — CNI /index.html","hash":"7c123ce50b0ab02307d36882ac4e8ba7db168e1c","modified":1682266735473},{"_id":"public/2023/04/18/EdgeMesh/cilium与edgemesh性能测试/2023-ospp-fighting/Kubernetes 容器网络 CNI — Linux 网络虚拟化/index.html","hash":"95c613cf8c752a346c0db3c92b05869bf8f58d86","modified":1682266735473},{"_id":"public/2023/04/18/EdgeMesh/cilium与edgemesh性能测试/2023-ospp-fighting/Kubernetes 容器网络 CNI — 现有 CNI 方案的调研 /index.html","hash":"8fbb6aa7c9e012220eceb47ef2903daa93098dc2","modified":1682266735473},{"_id":"public/2023/04/09/Go/Go-basic-knowledge/Go-basic-knowledge/index.html","hash":"5fa31cf3746afba6e52ed705293e69b2d76e8a62","modified":1682266735473},{"_id":"public/2023/04/02/Book/读书笔记-深入理解Linux网络/读书笔记-深入理解Linux网络/index.html","hash":"4ceaef6e723eb6c2f9d0fead6aa5bc59d359ffbf","modified":1682266735473},{"_id":"public/2023/04/01/Algorithm/Golang-数据结构/Golang-数据结构-链表/index.html","hash":"8615343ca0efd04163a8cf7c728bd8553bd8cacd","modified":1682266735473},{"_id":"public/2023/04/01/Algorithm/Golang-数据结构/Golang-算法课程--数据结构/index.html","hash":"357b18b6b9eb78b0e68d9aff0a231d3aedbeb0ce","modified":1682266735473},{"_id":"public/2023/04/01/Algorithm/Golang-算法课程/Golang-双指针/Golang-双指针/index.html","hash":"5b98234e914760490208c83e72e5521a85a556df","modified":1682266735473},{"_id":"public/2023/04/01/Go/Go-面试问答回忆/Go 系统知识汇总/index.html","hash":"ae81e944aef2d1892c13eae84b27a04af2504190","modified":1682266735473},{"_id":"public/2023/03/27/Algorithm/算法课程-南开苏明老师/算法简要汇总/index.html","hash":"ba22c78787a232d30ed607cc834a5a0aa207fd88","modified":1682266735473},{"_id":"public/2023/03/25/Algorithm/ACM-模式输入输出总结/ACM-模式输入输出总结/index.html","hash":"2793583587d328983feae910e96e303f01e28f44","modified":1682266735473},{"_id":"public/archives/page/2/index.html","hash":"a4b4cc635957d932392f89389d698b26724b3ae2","modified":1682266735473},{"_id":"public/archives/2023/index.html","hash":"d2f301b0e2121a9d04cefd5dcb3b94c93c5241c0","modified":1682266735473},{"_id":"public/archives/2023/page/2/index.html","hash":"49dfb223b16adb0a4114c428082f464a33c35d4c","modified":1682266735473},{"_id":"public/archives/2023/03/index.html","hash":"a861d44822523c81916d27b0b0c4259de2378247","modified":1682266735473},{"_id":"public/archives/2023/04/index.html","hash":"8ea5ba2d24040490a5dc326229ecb25a7d0229e7","modified":1682266735473},{"_id":"public/categories/算法，Golang-链表/index.html","hash":"63bb3fb01c794a475b0c685f6e5b180bd8f8e856","modified":1682266735473},{"_id":"public/categories/算法，Golang/index.html","hash":"f0035c343fb19d37d374cdb9ecca287dfa792e7f","modified":1682266735473},{"_id":"public/categories/算法-Algrithm/index.html","hash":"8885e2d866bded202ea0efdf406eddaaa4646c99","modified":1682266735473},{"_id":"public/categories/Basic/index.html","hash":"8f3eeb950578b2f62919978df38c0d7153ab7b21","modified":1682266735473},{"_id":"public/categories/ospp/index.html","hash":"0f03a8a8029453560bd4c4bbfd64433296e8e5ac","modified":1682266735473},{"_id":"public/categories/CNI/index.html","hash":"6d4bdbe47d914e1c12aae437b88dd881ab61ca6b","modified":1682266735473},{"_id":"public/categories/Linux-Container/index.html","hash":"b64913b8bd56eba9a7ebe19fd8918a0e147f9e59","modified":1682266735473},{"_id":"public/categories/CNI-Plugins/index.html","hash":"45373ecf46c7f207fea2ab6e420fb632dbb09e82","modified":1682266735473},{"_id":"public/index.html","hash":"586f8484940c8078b92bc754adad11308c29053f","modified":1682266735473},{"_id":"public/page/2/index.html","hash":"889b47851da1693359f60a3b157a93c46b26ff84","modified":1682266735473},{"_id":"public/tags/Golang/index.html","hash":"0ae492f290ca50ddb55ee905b7cc6bab3df8271f","modified":1682266735473},{"_id":"public/tags/链表-算法/index.html","hash":"bf2420281efde11c46ff20103204984c1e851bb6","modified":1682266735473},{"_id":"public/tags/working-算法/index.html","hash":"94dc6fb1b58bbdd1b9353925cde158ae0d23556c","modified":1682266735473},{"_id":"public/tags/算法，-南开大学，Golang-working/index.html","hash":"412101923fd0606dd2b7a9a792a8ac9fdb019549","modified":1682266735473},{"_id":"public/tags/双指针-算法/index.html","hash":"6f03b00f14ad3aaf31236a98904fc523c1cc067a","modified":1682266735473},{"_id":"public/tags/ospp-edgemesh/index.html","hash":"c9c41135d8c18e5d4ba5995af7de4c06c8bb3e28","modified":1682266735473},{"_id":"public/tags/ospp-CNI-Linux-Spec/index.html","hash":"1c4f54ae22fc40e7f7729c83ae9749858c73376a","modified":1682266735473},{"_id":"public/tags/ospp-Linux-Network/index.html","hash":"0304d2b3a2c6d977c22beb61400e1268c4713a45","modified":1682266735473},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1682266735473},{"_id":"public/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1682266735473},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1682266735473},{"_id":"public/LICENSE","hash":"7df059597099bb7dcf25d2a9aedfaf4465f72d8d","modified":1682266735473},{"_id":"public/img/logo/mesh.png","hash":"f3f2952c8ce9746d53a5a6b8be035a5da68cf37c","modified":1682266735473},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1682266735473},{"_id":"public/js/utils.js","hash":"2e74fe8ae5ac20067668a18df5985459faf419f9","modified":1682266735473},{"_id":"public/js/search/algolia.js","hash":"fd86281d4f0f99ce173e49c1a0df3507fe268d37","modified":1682266735473},{"_id":"public/js/search/local-search.js","hash":"8a0547ecb33ad2939450152adf54fca58e22a424","modified":1682266735473},{"_id":"public/css/index.css","hash":"030f6a3e0090a50aae5eac103d7176eb811f6469","modified":1682266735473},{"_id":"public/js/main.js","hash":"05c825962e365af62096d3f1b4d7c9ee1b5fc2f5","modified":1682266735473},{"_id":"public/js/tw_cn.js","hash":"76d0c5c172cae44b34b0bd3125fd068b2c3cbd4a","modified":1682266735473},{"_id":"public/img/backgroud/worriar.png","hash":"b64eb20fbca3fd872e418fe8d99bb4231476ca43","modified":1682266735473},{"_id":"public/img/backgroud/moon.png","hash":"aaa1e772e8c105173f3f3ef7bbe210ef402b363e","modified":1682266735473},{"_id":"public/img/signature/signature-removebg.png","hash":"ba5103eca83d60fd0682ad746442c48998b1c66f","modified":1682266735473},{"_id":"public/img/cover/elderring.png","hash":"64a2a218f16327a856375592a001d8ac3269d502","modified":1682266735473},{"_id":"public/img/avatar/2077_mobile.png","hash":"f5bba8aa0fd7a52106544451810c4da4a9c7b2c1","modified":1682266735473},{"_id":"public/img/backgroud/wallhaven-j3m8y5_1920x1080.png","hash":"f00c06b6d4b9249048ba275b082908bcd9afcbd7","modified":1682266735473},{"_id":"public/img/cover/2077_city.png","hash":"34b8054002690965e2cc7a7422491ca65cef023c","modified":1682266735473}],"Category":[{"name":"算法，Golang, 链表","_id":"clgtm6jq7000blyjxdki832wu"},{"name":"算法，Golang","_id":"clgtm6jqb000ilyjx0eqs5db2"},{"name":"算法","_id":"clgtm6jqh000slyjx5nt64ove"},{"name":"算法[Algrithm]","_id":"clgtm6jqm0014lyjxa5c51rr5"},{"name":"测试","_id":"clgtm6jqn001blyjxedt9beza"},{"name":"Basic","_id":"clgtm6jqq001ilyjx7npw5u1k"},{"name":"Golang","_id":"clgtm6jqr001nlyjxan5cdbtk"},{"name":"index","_id":"clgtm6jqt001tlyjx2tivdak6"},{"name":"p2p","_id":"clgtm6jqx0024lyjxdwqk3a2h"},{"name":"ospp","_id":"clgtm6jr0002dlyjxf9pg9hh6"},{"name":"CNI","_id":"clgtm6jr1002hlyjx3npyh59g"},{"name":"Linux, Container","_id":"clgtm6jr1002mlyjx1onv3aha"},{"name":"Pod, Linux","_id":"clgtm6jr2002qlyjxdjc7hpkz"},{"name":"CNI Plugins","_id":"clgtm6jr2002tlyjxgg9h4s0a"}],"Data":[],"Page":[{"layout":"404","description":"I'm sorry there is nothing that you want , but you can enjoy the scenery here ...","header-img":"img/backgroud/worriar.png","_content":"","source":"404.md","raw":"---\nlayout: 404\ndescription: \"I'm sorry there is nothing that you want , but you can enjoy the scenery here ...\"\nheader-img: \"img/backgroud/worriar.png\"\n---\n","date":"2023-04-22T13:24:01.808Z","updated":"2023-04-22T13:24:01.808Z","path":"404.html","title":"","comments":1,"_id":"clgtm6jpt0000lyjx9rq7flzb","content":"","site":{"data":{}},"cover":"/img/cover/2077_city.png","cover_type":"img","excerpt":"","more":""},{"title":"about","header-img":"img/backgroud/wallhaven-j3m8y5_1920x1080.png","date":"2023-04-21T19:27:39.000Z","description":null,"_content":"","source":"about/index.md","raw":"---\ntitle: about\nheader-img: img/backgroud/wallhaven-j3m8y5_1920x1080.png\ndate: 2023-04-22 03:27:39\ndescription:\n---\n","updated":"2023-04-22T13:24:01.868Z","path":"about/index.html","comments":1,"layout":"page","_id":"clgtm6jq00002lyjxb6yk9yg2","content":"","site":{"data":{}},"cover":"/img/cover/elderring.png","cover_type":"img","excerpt":"","more":""},{"title":"archives","header-img":"img/backgroud/wallhaven-j3m8y5_1920x1080.png","date":"2023-04-21T19:27:26.000Z","description":null,"_content":"","source":"archives/index.md","raw":"---\ntitle: archives\nheader-img: img/backgroud/wallhaven-j3m8y5_1920x1080.png\ndate: 2023-04-22 03:27:26\ndescription:\n---\n","updated":"2023-04-22T13:24:01.868Z","path":"archives/index.html","comments":1,"layout":"page","_id":"clgtm6jq20004lyjx082k0wjb","content":"","site":{"data":{}},"cover":"/img/cover/elderring.png","cover_type":"img","excerpt":"","more":""},{"title":"categories","header-img":"img/backgroud/wallhaven-j3m8y5_1920x1080.png","date":"2023-04-21T19:28:17.000Z","description":null,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\nheader-img: img/backgroud/wallhaven-j3m8y5_1920x1080.png\ndate: 2023-04-22 03:28:17\ndescription:\n---\n","updated":"2023-04-22T13:24:01.868Z","path":"categories/index.html","comments":1,"layout":"page","_id":"clgtm6jq30006lyjxb44537fn","content":"","site":{"data":{}},"cover":"/img/cover/elderring.png","cover_type":"img","excerpt":"","more":""},{"title":"link","header-img":"img/backgroud/wallhaven-j3m8y5_1920x1080.png","date":"2023-04-21T19:27:02.000Z","description":null,"_content":"","source":"link/index.md","raw":"---\ntitle: link\nheader-img: img/backgroud/wallhaven-j3m8y5_1920x1080.png\ndate: 2023-04-22 03:27:02\ndescription:\n---\n","updated":"2023-04-22T13:24:01.868Z","path":"link/index.html","comments":1,"layout":"page","_id":"clgtm6jq60009lyjx81pq99i2","content":"","site":{"data":{}},"cover":"/img/cover/2077_city.png","cover_type":"img","excerpt":"","more":""},{"title":"tags","header-img":"img/backgroud/wallhaven-j3m8y5_1920x1080.png","date":"2023-04-21T19:29:17.000Z","description":null,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\nheader-img: img/backgroud/wallhaven-j3m8y5_1920x1080.png\ndate: 2023-04-22 03:29:17\ndescription:\n---\n","updated":"2023-04-22T13:24:01.868Z","path":"tags/index.html","comments":1,"layout":"page","_id":"clgtm6jq8000clyjxagsz976e","content":"","site":{"data":{}},"cover":"/img/cover/elderring.png","cover_type":"img","excerpt":"","more":""}],"Post":[{"title":"Markdown 常用语法粘贴模板","catalog":true,"date":"2023-04-04T17:17:26.000Z","subtitle":null,"header-img":null,"published":0,"_content":"","source":"_posts/Markdown&Blog/Markdown-常用语法粘贴模板.md","raw":"---\ntitle: Markdown 常用语法粘贴模板\ncatalog: true\ndate: 2023-04-05 01:17:26\nsubtitle:\nheader-img:\ntags:\ncategories:\npublished: false\n---\n","slug":"Markdown&Blog/Markdown-常用语法粘贴模板","updated":"2023-04-22T13:24:02.008Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgtm6jpw0001lyjx1kwe8chd","content":"","site":{"data":{}},"cover":"/img/cover/elderring.png","cover_type":"img","excerpt":"","more":""},{"title":"动态规划问题","catalog":true,"date":"2023-03-24T16:27:34.000Z","subtitle":null,"header-img":null,"published":0,"_content":"\n# [动态规划] 动态规划问题\n> 本文将过一遍所遇见的所有动态规划解决的问题并给出代码\n>\n\n## 斐波那契数\n> 力扣题目链接[https://leetcode.cn/problems/fibonacci-number/]\n>\n\n### 解题流程\n1. 问题分析\n   斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列。\n   \n   该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： F(0) = 0，F(1) = 1 F(n) = F(n - 1) + F(n - 2)，其中 n > 1 问题需求是给n ，请计算 F(n) 的值。\n\n   显然 i 的值包含整个定义域，求解的F(i) 也就是整个解集，需要遍历整个结果集来找对应 i 的解，可以使用 DP 来求解。\n   \n\n2. DP 解题流程\n   \n   * **确定dp数组以及下标的含义**\n  \n        dp[i]的定义为：第i个数的斐波那契数值是dp[i]\n\n   * **确定递推公式**\n\n        确定得到每一个dp[i]的公式，或者说遍历整个结果集合的方式\n    \n        在本题目当中，直接给出的是斐波那契数列\n   状态转移方程 dp[i] = dp[i - 1] + dp[i - 2];\n\n   * **dp数组如何初始化**\n  \n        > 本质上就是**寻找边界值，什么时候开始、什么时候结束**，在所有需要遍历的操作当中都需要考虑这个问题\n\n        一般的斐波那契数列已经给出初始边界值：\n        ```go\n        dp[0] := 0\n        dp[1] := 1\n        ```\n   \n   * **确定遍历顺序**\n\n        从递归公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，dp[i]是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序一定是从前到后遍历的\n\n   * **举例推导dp数组**\n\n        按照这个递推公式dp[i] = dp[i - 1] + dp[i - 2]，我们来推导一下，当N为10的时候，dp数组应该是如下的数列：\n   \n        0 1 1 2 3 5 8 13 21 34 55\n   \n        如果代码写出来，发现结果不对，就把dp数组打印出来看看和我们推导的数列是不是一致的。\n\n\n\n### 代码实现\n\n使用一个数组保存所有遍历的结果，通过索引i直接找到 f[i]对应的值：\n```golang\nfunc fib(n int) int {\n    var ans []int\n    ans = append(ans,0)\n    ans = append(ans,1)\n\n    for i := 2 ; i <= n ; i++ {\n        temp := ans[i-1] + ans[i-2]\n        ans = append(ans,temp)\n    }\n    return ans[n]\n}\n```\n* 时间复杂度：O(n)\n* 空间复杂度：O(n)\n\n但是可以观察到保留的 f 数组其实只用到了一个变量f[i], 并且最后需要的结果是一个固定值 n，也就是说结果是确定位置的，那么是可以只保留计算获得 f[n] 相关的值就可以：f[n-1] 和 f[n-2]，这样的保留过程对于其他的 i 值来说也完全一样，除了 n=0 和 n=1 两个时候的值，那么就需要单独对这两个值来做处理\n\n只保留的pre和now,也可以改成 tmp[i-1] 和 tmp[i-2]也就是改成一个长度为2的一维数组--滚动数组，该数组存储有效信息并跟随遍历的阶段移动\n\n```golang\nfunc fib(n int) int {\n    pre := 0\n    now := 1\n\n    for i:= 2 ; i <= n ; i++{\n        tmp := now\n        now = now + pre\n        pre = tmp\n    }\n    if n == 0 {\n        now = 0\n    }\n    return now\n}\n```\n\n---\n\n## 编辑距离\n> 力扣题目链接: (https://leetcode.cn/problems/edit-distance/)\n\n### 解题流程\n1. 问题分析\n   将word1变成word2，共有三类型的操作：增加、删除、替换；同时计算操作数最小的情况。\n\n   **是否使用动态规划**\n   一个最直白的想法就是我先把word1里面每一个字母都删除，进行len(word1)次操作；然后再加上word2里面的每一个字母，进行len(word2)次操作，当然这样的操作是次数最多的，是完全没有考虑到两个字符之间的关联性，当在字符串里面有相同的字母时候，就可以不操作跳过，再对后面的字符进行操作。\n\n   这样不断地替换中间的操作流程就是一个全遍历的过程，需要找寻几乎所有的排列组合且存在着 **最小值的优化目标 --> 适合动态规划**   \n\n\n   **为什么感觉问题解决会复杂？**\n\n   会发现增删都会改变字母的对应位置，而替换不改变位置，一些不同位置的字母可以通过增删变成对应相同位置的字母，也就是说三个操作之间相互关联。\n\n   同样的问题思考时候，word1变成word2其实也等价于word2变成word1,解题的流程是完全对称的。\n\n   结合以上因素，可以说一个dp状态就有了三种类型的迁移计算，那么我们需要设置一个dp[][][]的三维数组来分别表示三类状态迁移嘛？并不需要，因为替换可以等效为先减少一个字母，然后再增加一个字母只是代价增加为1而不是2，所以可以使用一个二维数组来表示：也就是dp[i][j]；其中i方向可以表示为减少word1 字母的操作，j方向标识增加word2字母的操作，i和j 同时增长表示替换操作：即先减少word1字母，然后增加word2字母。\n\n   还可以看到的是，依据上面的思考流程，i/j应当是和word1/2当中的单词位置相关联的；而麻烦的地方就集中在这个地方的理解上 <font color='red'>dp[i][j] 表示的是将word1前i-1个字符变成word2前j-1个字符最少的操作数</font>，dp[i][j]并不代表一个字符串或者说一个字符串形式，但是到dp[i][j]的路径可以唯一对应一个字符串\n\n   同时当我们使用上述的二位矩阵来计算时会发现，实质上我们也计算了将 word2 变成 word1的最小操作数\n\n\n\n2. DP 解题流程\n   * **确定dp数组以及下标的含义**\n   dp[i][j] 表示的是将word1前i-1个字符变成word2前j-1个字符最少的操作数\n\n   这里有两个需要强调的点：\n   * dp[i] 对应的字母是 word[i-1], 而 dp[0] 对应的是空字符\n   这样来规定矩阵的计算形式更有利于计算\n   * 矩阵中元素对应着操作数，到达操作数的路径对应字符串\n\n   * **确定递推公式**\n   > 也就是确认矩阵元素的迁移计算方向并计算操作数\n\n   如果word1[i - 1] == word2[j - 1]，也就意味着对应位置的字母是相同的，那么增删或者删增同一个字母是没有必要，在矩阵元素迁移中，表示向右下移动一格遍历一个字母，但是不用操作两字符串，dp[i][j]操作数不用增加。\n\n   如果word1[i - 1] != word2[j - 1]，那么接下来在矩阵当中移动，在i方向就意味着对word1[i-1]字母进行减操作，在j方向就意味着对word2[j-1]字母进行加操作\n\n   ```\n    if (word1[i - 1] == word2[j - 1])\n        不操作\n    if (word1[i - 1] != word2[j - 1])\n        dp[i][j] = min (增,删,换)\n   ```\n\n   * **dp数组如何初始化**\n   考虑到空字符串的计算，也就是说对另一方不做操作的情况：\n    * d[i][0] 表示只减少word1的字母\n    * d[0][j] 表示只增加word2的字母\n    * d[0][0] 表示空字母\n\n\n   * **确定遍历顺序**\n   将word1变成word2，也就是意味着需要遍历每一个word1字母和每一个word2字母\n   ```\n    dp[i][j] = dp[i - 1][j - 1]  // i-1,j-1位置两个字符串的字母相同，不用操作，所以在状态迁移时候不用增加dp操作数\n\n    //i-1,j-1位置两个字符串的字母不相同，需要对i-1，j-1位置上的字母做操作\n    dp[i][j] = dp[i - 1][j - 1] + 1 //替换\n    dp[i][j] = dp[i][j - 1] + 1 // 增加\n    dp[i][j] = dp[i - 1][j] + 1 // 减少\n   ```\n\n\n   * **举例推导dp数组**\n\n\n\n### 代码实现\n\n---\n## 两个字符串的删除操作\n> 题目链接：(https://leetcode.cn/problems/delete-operation-for-two-strings/)\n### 解题流程\n1. 问题分析\n   \n2. DP 解题流程\n   * **确定dp数组以及下标的含义**\n   * **确定递推公式**\n   * **dp数组如何初始化**\n   * **确定遍历顺序**\n   * **举例推导dp数组**\n### 代码实现\n\n\n---\n## 最长公共子序列\n> 题目链接：(https://leetcode.cn/problems/longest-common-subsequence/)\n### 解题流程\n1. 问题分析\n   \n2. DP 解题流程\n   * **确定dp数组以及下标的含义**\n   * **确定递推公式**\n   * **dp数组如何初始化**\n   * **确定遍历顺序**\n   * **举例推导dp数组**\n### 代码实现\n\n---\n## 打家劫舍\n### 解题流程\n1. 问题分析\n2. DP 解题流程\n   * **确定dp数组以及下标的含义**\n   * **确定递推公式**\n   * **dp数组如何初始化**\n   * **确定遍历顺序**\n   * **举例推导dp数组**\n### 代码实现\n\n---\n## 斐波那契数\n### 解题流程\n1. 问题分析\n2. DP 解题流程\n   * **确定dp数组以及下标的含义**\n   * **确定递推公式**\n   * **dp数组如何初始化**\n   * **确定遍历顺序**\n   * **举例推导dp数组**\n### 代码实现","source":"_posts/Algorithm/ [动态规划] 动态规划问题/ [动态规划] 动态规划问题.md","raw":"---\ntitle: 动态规划问题\ncatalog: true\ndate: 2023-03-25 00:27:34\nsubtitle:\nheader-img:\ntags:\ncategories:\npublished: false\n---\n\n# [动态规划] 动态规划问题\n> 本文将过一遍所遇见的所有动态规划解决的问题并给出代码\n>\n\n## 斐波那契数\n> 力扣题目链接[https://leetcode.cn/problems/fibonacci-number/]\n>\n\n### 解题流程\n1. 问题分析\n   斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列。\n   \n   该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： F(0) = 0，F(1) = 1 F(n) = F(n - 1) + F(n - 2)，其中 n > 1 问题需求是给n ，请计算 F(n) 的值。\n\n   显然 i 的值包含整个定义域，求解的F(i) 也就是整个解集，需要遍历整个结果集来找对应 i 的解，可以使用 DP 来求解。\n   \n\n2. DP 解题流程\n   \n   * **确定dp数组以及下标的含义**\n  \n        dp[i]的定义为：第i个数的斐波那契数值是dp[i]\n\n   * **确定递推公式**\n\n        确定得到每一个dp[i]的公式，或者说遍历整个结果集合的方式\n    \n        在本题目当中，直接给出的是斐波那契数列\n   状态转移方程 dp[i] = dp[i - 1] + dp[i - 2];\n\n   * **dp数组如何初始化**\n  \n        > 本质上就是**寻找边界值，什么时候开始、什么时候结束**，在所有需要遍历的操作当中都需要考虑这个问题\n\n        一般的斐波那契数列已经给出初始边界值：\n        ```go\n        dp[0] := 0\n        dp[1] := 1\n        ```\n   \n   * **确定遍历顺序**\n\n        从递归公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，dp[i]是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序一定是从前到后遍历的\n\n   * **举例推导dp数组**\n\n        按照这个递推公式dp[i] = dp[i - 1] + dp[i - 2]，我们来推导一下，当N为10的时候，dp数组应该是如下的数列：\n   \n        0 1 1 2 3 5 8 13 21 34 55\n   \n        如果代码写出来，发现结果不对，就把dp数组打印出来看看和我们推导的数列是不是一致的。\n\n\n\n### 代码实现\n\n使用一个数组保存所有遍历的结果，通过索引i直接找到 f[i]对应的值：\n```golang\nfunc fib(n int) int {\n    var ans []int\n    ans = append(ans,0)\n    ans = append(ans,1)\n\n    for i := 2 ; i <= n ; i++ {\n        temp := ans[i-1] + ans[i-2]\n        ans = append(ans,temp)\n    }\n    return ans[n]\n}\n```\n* 时间复杂度：O(n)\n* 空间复杂度：O(n)\n\n但是可以观察到保留的 f 数组其实只用到了一个变量f[i], 并且最后需要的结果是一个固定值 n，也就是说结果是确定位置的，那么是可以只保留计算获得 f[n] 相关的值就可以：f[n-1] 和 f[n-2]，这样的保留过程对于其他的 i 值来说也完全一样，除了 n=0 和 n=1 两个时候的值，那么就需要单独对这两个值来做处理\n\n只保留的pre和now,也可以改成 tmp[i-1] 和 tmp[i-2]也就是改成一个长度为2的一维数组--滚动数组，该数组存储有效信息并跟随遍历的阶段移动\n\n```golang\nfunc fib(n int) int {\n    pre := 0\n    now := 1\n\n    for i:= 2 ; i <= n ; i++{\n        tmp := now\n        now = now + pre\n        pre = tmp\n    }\n    if n == 0 {\n        now = 0\n    }\n    return now\n}\n```\n\n---\n\n## 编辑距离\n> 力扣题目链接: (https://leetcode.cn/problems/edit-distance/)\n\n### 解题流程\n1. 问题分析\n   将word1变成word2，共有三类型的操作：增加、删除、替换；同时计算操作数最小的情况。\n\n   **是否使用动态规划**\n   一个最直白的想法就是我先把word1里面每一个字母都删除，进行len(word1)次操作；然后再加上word2里面的每一个字母，进行len(word2)次操作，当然这样的操作是次数最多的，是完全没有考虑到两个字符之间的关联性，当在字符串里面有相同的字母时候，就可以不操作跳过，再对后面的字符进行操作。\n\n   这样不断地替换中间的操作流程就是一个全遍历的过程，需要找寻几乎所有的排列组合且存在着 **最小值的优化目标 --> 适合动态规划**   \n\n\n   **为什么感觉问题解决会复杂？**\n\n   会发现增删都会改变字母的对应位置，而替换不改变位置，一些不同位置的字母可以通过增删变成对应相同位置的字母，也就是说三个操作之间相互关联。\n\n   同样的问题思考时候，word1变成word2其实也等价于word2变成word1,解题的流程是完全对称的。\n\n   结合以上因素，可以说一个dp状态就有了三种类型的迁移计算，那么我们需要设置一个dp[][][]的三维数组来分别表示三类状态迁移嘛？并不需要，因为替换可以等效为先减少一个字母，然后再增加一个字母只是代价增加为1而不是2，所以可以使用一个二维数组来表示：也就是dp[i][j]；其中i方向可以表示为减少word1 字母的操作，j方向标识增加word2字母的操作，i和j 同时增长表示替换操作：即先减少word1字母，然后增加word2字母。\n\n   还可以看到的是，依据上面的思考流程，i/j应当是和word1/2当中的单词位置相关联的；而麻烦的地方就集中在这个地方的理解上 <font color='red'>dp[i][j] 表示的是将word1前i-1个字符变成word2前j-1个字符最少的操作数</font>，dp[i][j]并不代表一个字符串或者说一个字符串形式，但是到dp[i][j]的路径可以唯一对应一个字符串\n\n   同时当我们使用上述的二位矩阵来计算时会发现，实质上我们也计算了将 word2 变成 word1的最小操作数\n\n\n\n2. DP 解题流程\n   * **确定dp数组以及下标的含义**\n   dp[i][j] 表示的是将word1前i-1个字符变成word2前j-1个字符最少的操作数\n\n   这里有两个需要强调的点：\n   * dp[i] 对应的字母是 word[i-1], 而 dp[0] 对应的是空字符\n   这样来规定矩阵的计算形式更有利于计算\n   * 矩阵中元素对应着操作数，到达操作数的路径对应字符串\n\n   * **确定递推公式**\n   > 也就是确认矩阵元素的迁移计算方向并计算操作数\n\n   如果word1[i - 1] == word2[j - 1]，也就意味着对应位置的字母是相同的，那么增删或者删增同一个字母是没有必要，在矩阵元素迁移中，表示向右下移动一格遍历一个字母，但是不用操作两字符串，dp[i][j]操作数不用增加。\n\n   如果word1[i - 1] != word2[j - 1]，那么接下来在矩阵当中移动，在i方向就意味着对word1[i-1]字母进行减操作，在j方向就意味着对word2[j-1]字母进行加操作\n\n   ```\n    if (word1[i - 1] == word2[j - 1])\n        不操作\n    if (word1[i - 1] != word2[j - 1])\n        dp[i][j] = min (增,删,换)\n   ```\n\n   * **dp数组如何初始化**\n   考虑到空字符串的计算，也就是说对另一方不做操作的情况：\n    * d[i][0] 表示只减少word1的字母\n    * d[0][j] 表示只增加word2的字母\n    * d[0][0] 表示空字母\n\n\n   * **确定遍历顺序**\n   将word1变成word2，也就是意味着需要遍历每一个word1字母和每一个word2字母\n   ```\n    dp[i][j] = dp[i - 1][j - 1]  // i-1,j-1位置两个字符串的字母相同，不用操作，所以在状态迁移时候不用增加dp操作数\n\n    //i-1,j-1位置两个字符串的字母不相同，需要对i-1，j-1位置上的字母做操作\n    dp[i][j] = dp[i - 1][j - 1] + 1 //替换\n    dp[i][j] = dp[i][j - 1] + 1 // 增加\n    dp[i][j] = dp[i - 1][j] + 1 // 减少\n   ```\n\n\n   * **举例推导dp数组**\n\n\n\n### 代码实现\n\n---\n## 两个字符串的删除操作\n> 题目链接：(https://leetcode.cn/problems/delete-operation-for-two-strings/)\n### 解题流程\n1. 问题分析\n   \n2. DP 解题流程\n   * **确定dp数组以及下标的含义**\n   * **确定递推公式**\n   * **dp数组如何初始化**\n   * **确定遍历顺序**\n   * **举例推导dp数组**\n### 代码实现\n\n\n---\n## 最长公共子序列\n> 题目链接：(https://leetcode.cn/problems/longest-common-subsequence/)\n### 解题流程\n1. 问题分析\n   \n2. DP 解题流程\n   * **确定dp数组以及下标的含义**\n   * **确定递推公式**\n   * **dp数组如何初始化**\n   * **确定遍历顺序**\n   * **举例推导dp数组**\n### 代码实现\n\n---\n## 打家劫舍\n### 解题流程\n1. 问题分析\n2. DP 解题流程\n   * **确定dp数组以及下标的含义**\n   * **确定递推公式**\n   * **dp数组如何初始化**\n   * **确定遍历顺序**\n   * **举例推导dp数组**\n### 代码实现\n\n---\n## 斐波那契数\n### 解题流程\n1. 问题分析\n2. DP 解题流程\n   * **确定dp数组以及下标的含义**\n   * **确定递推公式**\n   * **dp数组如何初始化**\n   * **确定遍历顺序**\n   * **举例推导dp数组**\n### 代码实现","slug":"Algorithm/ [动态规划] 动态规划问题/ [动态规划] 动态规划问题","updated":"2023-04-22T13:24:02.164Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgtm6jq00003lyjxdbte595s","content":"<h1 id=\"动态规划-动态规划问题\"><a href=\"#动态规划-动态规划问题\" class=\"headerlink\" title=\"[动态规划] 动态规划问题\"></a>[动态规划] 动态规划问题</h1><blockquote>\n<p>本文将过一遍所遇见的所有动态规划解决的问题并给出代码</p>\n</blockquote>\n<h2 id=\"斐波那契数\"><a href=\"#斐波那契数\" class=\"headerlink\" title=\"斐波那契数\"></a>斐波那契数</h2><blockquote>\n<p>力扣题目链接[<a href=\"https://leetcode.cn/problems/fibonacci-number/]\">https://leetcode.cn/problems/fibonacci-number/]</a></p>\n</blockquote>\n<h3 id=\"解题流程\"><a href=\"#解题流程\" class=\"headerlink\" title=\"解题流程\"></a>解题流程</h3><ol>\n<li><p>问题分析<br>斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列。</p>\n<p>该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： F(0) = 0，F(1) = 1 F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1 问题需求是给n ，请计算 F(n) 的值。</p>\n<p>显然 i 的值包含整个定义域，求解的F(i) 也就是整个解集，需要遍历整个结果集来找对应 i 的解，可以使用 DP 来求解。</p>\n</li>\n<li><p>DP 解题流程</p>\n<ul>\n<li><p><strong>确定dp数组以及下标的含义</strong></p>\n<p>   dp[i]的定义为：第i个数的斐波那契数值是dp[i]</p>\n</li>\n<li><p><strong>确定递推公式</strong></p>\n<p>   确定得到每一个dp[i]的公式，或者说遍历整个结果集合的方式</p>\n<p>   在本题目当中，直接给出的是斐波那契数列<br>状态转移方程 dp[i] = dp[i - 1] + dp[i - 2];</p>\n</li>\n<li><p><strong>dp数组如何初始化</strong></p>\n<blockquote>\n<p>本质上就是<strong>寻找边界值，什么时候开始、什么时候结束</strong>，在所有需要遍历的操作当中都需要考虑这个问题</p>\n</blockquote>\n<p>   一般的斐波那契数列已经给出初始边界值：</p>\n   <figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dp[<span class=\"number\">0</span>] := <span class=\"number\">0</span></span><br><span class=\"line\">dp[<span class=\"number\">1</span>] := <span class=\"number\">1</span></span><br></pre></td></tr></table></figure></li>\n<li><p><strong>确定遍历顺序</strong></p>\n<p>   从递归公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，dp[i]是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序一定是从前到后遍历的</p>\n</li>\n<li><p><strong>举例推导dp数组</strong></p>\n<p>   按照这个递推公式dp[i] = dp[i - 1] + dp[i - 2]，我们来推导一下，当N为10的时候，dp数组应该是如下的数列：</p>\n<p>   0 1 1 2 3 5 8 13 21 34 55</p>\n<p>   如果代码写出来，发现结果不对，就把dp数组打印出来看看和我们推导的数列是不是一致的。</p>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><p>使用一个数组保存所有遍历的结果，通过索引i直接找到 f[i]对应的值：</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">fib</span><span class=\"params\">(n <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> ans []<span class=\"type\">int</span></span><br><span class=\"line\">    ans = <span class=\"built_in\">append</span>(ans,<span class=\"number\">0</span>)</span><br><span class=\"line\">    ans = <span class=\"built_in\">append</span>(ans,<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">2</span> ; i &lt;= n ; i++ &#123;</span><br><span class=\"line\">        temp := ans[i<span class=\"number\">-1</span>] + ans[i<span class=\"number\">-2</span>]</span><br><span class=\"line\">        ans = <span class=\"built_in\">append</span>(ans,temp)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans[n]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>时间复杂度：O(n)</li>\n<li>空间复杂度：O(n)</li>\n</ul>\n<p>但是可以观察到保留的 f 数组其实只用到了一个变量f[i], 并且最后需要的结果是一个固定值 n，也就是说结果是确定位置的，那么是可以只保留计算获得 f[n] 相关的值就可以：f[n-1] 和 f[n-2]，这样的保留过程对于其他的 i 值来说也完全一样，除了 n=0 和 n=1 两个时候的值，那么就需要单独对这两个值来做处理</p>\n<p>只保留的pre和now,也可以改成 tmp[i-1] 和 tmp[i-2]也就是改成一个长度为2的一维数组–滚动数组，该数组存储有效信息并跟随遍历的阶段移动</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">fib</span><span class=\"params\">(n <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    pre := <span class=\"number\">0</span></span><br><span class=\"line\">    now := <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i:= <span class=\"number\">2</span> ; i &lt;= n ; i++&#123;</span><br><span class=\"line\">        tmp := now</span><br><span class=\"line\">        now = now + pre</span><br><span class=\"line\">        pre = tmp</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> n == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        now = <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> now</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"编辑距离\"><a href=\"#编辑距离\" class=\"headerlink\" title=\"编辑距离\"></a>编辑距离</h2><blockquote>\n<p>力扣题目链接: (<a href=\"https://leetcode.cn/problems/edit-distance/\">https://leetcode.cn/problems/edit-distance/</a>)</p>\n</blockquote>\n<h3 id=\"解题流程-1\"><a href=\"#解题流程-1\" class=\"headerlink\" title=\"解题流程\"></a>解题流程</h3><ol>\n<li><p>问题分析<br>将word1变成word2，共有三类型的操作：增加、删除、替换；同时计算操作数最小的情况。</p>\n<p><strong>是否使用动态规划</strong><br>一个最直白的想法就是我先把word1里面每一个字母都删除，进行len(word1)次操作；然后再加上word2里面的每一个字母，进行len(word2)次操作，当然这样的操作是次数最多的，是完全没有考虑到两个字符之间的关联性，当在字符串里面有相同的字母时候，就可以不操作跳过，再对后面的字符进行操作。</p>\n<p>这样不断地替换中间的操作流程就是一个全遍历的过程，需要找寻几乎所有的排列组合且存在着 <strong>最小值的优化目标 –&gt; 适合动态规划</strong>   </p>\n</li>\n</ol>\n<p>   <strong>为什么感觉问题解决会复杂？</strong></p>\n<p>   会发现增删都会改变字母的对应位置，而替换不改变位置，一些不同位置的字母可以通过增删变成对应相同位置的字母，也就是说三个操作之间相互关联。</p>\n<p>   同样的问题思考时候，word1变成word2其实也等价于word2变成word1,解题的流程是完全对称的。</p>\n<p>   结合以上因素，可以说一个dp状态就有了三种类型的迁移计算，那么我们需要设置一个dp[][][]的三维数组来分别表示三类状态迁移嘛？并不需要，因为替换可以等效为先减少一个字母，然后再增加一个字母只是代价增加为1而不是2，所以可以使用一个二维数组来表示：也就是dp[i][j]；其中i方向可以表示为减少word1 字母的操作，j方向标识增加word2字母的操作，i和j 同时增长表示替换操作：即先减少word1字母，然后增加word2字母。</p>\n<p>   还可以看到的是，依据上面的思考流程，i/j应当是和word1/2当中的单词位置相关联的；而麻烦的地方就集中在这个地方的理解上 <font color='red'>dp[i][j] 表示的是将word1前i-1个字符变成word2前j-1个字符最少的操作数</font>，dp[i][j]并不代表一个字符串或者说一个字符串形式，但是到dp[i][j]的路径可以唯一对应一个字符串</p>\n<p>   同时当我们使用上述的二位矩阵来计算时会发现，实质上我们也计算了将 word2 变成 word1的最小操作数</p>\n<ol start=\"2\">\n<li><p>DP 解题流程</p>\n<ul>\n<li><strong>确定dp数组以及下标的含义</strong><br>dp[i][j] 表示的是将word1前i-1个字符变成word2前j-1个字符最少的操作数</li>\n</ul>\n<p>这里有两个需要强调的点：</p>\n<ul>\n<li><p>dp[i] 对应的字母是 word[i-1], 而 dp[0] 对应的是空字符<br>这样来规定矩阵的计算形式更有利于计算</p>\n</li>\n<li><p>矩阵中元素对应着操作数，到达操作数的路径对应字符串</p>\n</li>\n<li><p><strong>确定递推公式</strong></p>\n<blockquote>\n<p>也就是确认矩阵元素的迁移计算方向并计算操作数</p>\n</blockquote>\n</li>\n</ul>\n<p>如果word1[i - 1] == word2[j - 1]，也就意味着对应位置的字母是相同的，那么增删或者删增同一个字母是没有必要，在矩阵元素迁移中，表示向右下移动一格遍历一个字母，但是不用操作两字符串，dp[i][j]操作数不用增加。</p>\n<p>如果word1[i - 1] != word2[j - 1]，那么接下来在矩阵当中移动，在i方向就意味着对word1[i-1]字母进行减操作，在j方向就意味着对word2[j-1]字母进行加操作</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (word1[i - 1] == word2[j - 1])</span><br><span class=\"line\">    不操作</span><br><span class=\"line\">if (word1[i - 1] != word2[j - 1])</span><br><span class=\"line\">    dp[i][j] = min (增,删,换)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>dp数组如何初始化</strong><br>考虑到空字符串的计算，也就是说对另一方不做操作的情况：</li>\n<li>d[i][0] 表示只减少word1的字母</li>\n<li>d[0][j] 表示只增加word2的字母</li>\n<li>d[0][0] 表示空字母</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li><strong>确定遍历顺序</strong><br>将word1变成word2，也就是意味着需要遍历每一个word1字母和每一个word2字母<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dp[i][j] = dp[i - 1][j - 1]  // i-1,j-1位置两个字符串的字母相同，不用操作，所以在状态迁移时候不用增加dp操作数</span><br><span class=\"line\"></span><br><span class=\"line\">//i-1,j-1位置两个字符串的字母不相同，需要对i-1，j-1位置上的字母做操作</span><br><span class=\"line\">dp[i][j] = dp[i - 1][j - 1] + 1 //替换</span><br><span class=\"line\">dp[i][j] = dp[i][j - 1] + 1 // 增加</span><br><span class=\"line\">dp[i][j] = dp[i - 1][j] + 1 // 减少</span><br></pre></td></tr></table></figure></li>\n</ul>\n<ul>\n<li><strong>举例推导dp数组</strong></li>\n</ul>\n<h3 id=\"代码实现-1\"><a href=\"#代码实现-1\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><hr>\n<h2 id=\"两个字符串的删除操作\"><a href=\"#两个字符串的删除操作\" class=\"headerlink\" title=\"两个字符串的删除操作\"></a>两个字符串的删除操作</h2><blockquote>\n<p>题目链接：(<a href=\"https://leetcode.cn/problems/delete-operation-for-two-strings/\">https://leetcode.cn/problems/delete-operation-for-two-strings/</a>)</p>\n</blockquote>\n<h3 id=\"解题流程-2\"><a href=\"#解题流程-2\" class=\"headerlink\" title=\"解题流程\"></a>解题流程</h3><ol>\n<li>问题分析</li>\n<li>DP 解题流程<ul>\n<li><strong>确定dp数组以及下标的含义</strong></li>\n<li><strong>确定递推公式</strong></li>\n<li><strong>dp数组如何初始化</strong></li>\n<li><strong>确定遍历顺序</strong></li>\n<li><strong>举例推导dp数组</strong><h3 id=\"代码实现-2\"><a href=\"#代码实现-2\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3></li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2 id=\"最长公共子序列\"><a href=\"#最长公共子序列\" class=\"headerlink\" title=\"最长公共子序列\"></a>最长公共子序列</h2><blockquote>\n<p>题目链接：(<a href=\"https://leetcode.cn/problems/longest-common-subsequence/\">https://leetcode.cn/problems/longest-common-subsequence/</a>)</p>\n</blockquote>\n<h3 id=\"解题流程-3\"><a href=\"#解题流程-3\" class=\"headerlink\" title=\"解题流程\"></a>解题流程</h3><ol>\n<li>问题分析</li>\n<li>DP 解题流程<ul>\n<li><strong>确定dp数组以及下标的含义</strong></li>\n<li><strong>确定递推公式</strong></li>\n<li><strong>dp数组如何初始化</strong></li>\n<li><strong>确定遍历顺序</strong></li>\n<li><strong>举例推导dp数组</strong><h3 id=\"代码实现-3\"><a href=\"#代码实现-3\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3></li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2 id=\"打家劫舍\"><a href=\"#打家劫舍\" class=\"headerlink\" title=\"打家劫舍\"></a>打家劫舍</h2><h3 id=\"解题流程-4\"><a href=\"#解题流程-4\" class=\"headerlink\" title=\"解题流程\"></a>解题流程</h3><ol>\n<li>问题分析</li>\n<li>DP 解题流程<ul>\n<li><strong>确定dp数组以及下标的含义</strong></li>\n<li><strong>确定递推公式</strong></li>\n<li><strong>dp数组如何初始化</strong></li>\n<li><strong>确定遍历顺序</strong></li>\n<li><strong>举例推导dp数组</strong><h3 id=\"代码实现-4\"><a href=\"#代码实现-4\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3></li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2 id=\"斐波那契数-1\"><a href=\"#斐波那契数-1\" class=\"headerlink\" title=\"斐波那契数\"></a>斐波那契数</h2><h3 id=\"解题流程-5\"><a href=\"#解题流程-5\" class=\"headerlink\" title=\"解题流程\"></a>解题流程</h3><ol>\n<li>问题分析</li>\n<li>DP 解题流程<ul>\n<li><strong>确定dp数组以及下标的含义</strong></li>\n<li><strong>确定递推公式</strong></li>\n<li><strong>dp数组如何初始化</strong></li>\n<li><strong>确定遍历顺序</strong></li>\n<li><strong>举例推导dp数组</strong><h3 id=\"代码实现-5\"><a href=\"#代码实现-5\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3></li>\n</ul>\n</li>\n</ol>\n","site":{"data":{}},"cover":"/img/cover/elderring.png","cover_type":"img","excerpt":"","more":"<h1 id=\"动态规划-动态规划问题\"><a href=\"#动态规划-动态规划问题\" class=\"headerlink\" title=\"[动态规划] 动态规划问题\"></a>[动态规划] 动态规划问题</h1><blockquote>\n<p>本文将过一遍所遇见的所有动态规划解决的问题并给出代码</p>\n</blockquote>\n<h2 id=\"斐波那契数\"><a href=\"#斐波那契数\" class=\"headerlink\" title=\"斐波那契数\"></a>斐波那契数</h2><blockquote>\n<p>力扣题目链接[<a href=\"https://leetcode.cn/problems/fibonacci-number/]\">https://leetcode.cn/problems/fibonacci-number/]</a></p>\n</blockquote>\n<h3 id=\"解题流程\"><a href=\"#解题流程\" class=\"headerlink\" title=\"解题流程\"></a>解题流程</h3><ol>\n<li><p>问题分析<br>斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列。</p>\n<p>该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： F(0) = 0，F(1) = 1 F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1 问题需求是给n ，请计算 F(n) 的值。</p>\n<p>显然 i 的值包含整个定义域，求解的F(i) 也就是整个解集，需要遍历整个结果集来找对应 i 的解，可以使用 DP 来求解。</p>\n</li>\n<li><p>DP 解题流程</p>\n<ul>\n<li><p><strong>确定dp数组以及下标的含义</strong></p>\n<p>   dp[i]的定义为：第i个数的斐波那契数值是dp[i]</p>\n</li>\n<li><p><strong>确定递推公式</strong></p>\n<p>   确定得到每一个dp[i]的公式，或者说遍历整个结果集合的方式</p>\n<p>   在本题目当中，直接给出的是斐波那契数列<br>状态转移方程 dp[i] = dp[i - 1] + dp[i - 2];</p>\n</li>\n<li><p><strong>dp数组如何初始化</strong></p>\n<blockquote>\n<p>本质上就是<strong>寻找边界值，什么时候开始、什么时候结束</strong>，在所有需要遍历的操作当中都需要考虑这个问题</p>\n</blockquote>\n<p>   一般的斐波那契数列已经给出初始边界值：</p>\n   <figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dp[<span class=\"number\">0</span>] := <span class=\"number\">0</span></span><br><span class=\"line\">dp[<span class=\"number\">1</span>] := <span class=\"number\">1</span></span><br></pre></td></tr></table></figure></li>\n<li><p><strong>确定遍历顺序</strong></p>\n<p>   从递归公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，dp[i]是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序一定是从前到后遍历的</p>\n</li>\n<li><p><strong>举例推导dp数组</strong></p>\n<p>   按照这个递推公式dp[i] = dp[i - 1] + dp[i - 2]，我们来推导一下，当N为10的时候，dp数组应该是如下的数列：</p>\n<p>   0 1 1 2 3 5 8 13 21 34 55</p>\n<p>   如果代码写出来，发现结果不对，就把dp数组打印出来看看和我们推导的数列是不是一致的。</p>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><p>使用一个数组保存所有遍历的结果，通过索引i直接找到 f[i]对应的值：</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">fib</span><span class=\"params\">(n <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> ans []<span class=\"type\">int</span></span><br><span class=\"line\">    ans = <span class=\"built_in\">append</span>(ans,<span class=\"number\">0</span>)</span><br><span class=\"line\">    ans = <span class=\"built_in\">append</span>(ans,<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">2</span> ; i &lt;= n ; i++ &#123;</span><br><span class=\"line\">        temp := ans[i<span class=\"number\">-1</span>] + ans[i<span class=\"number\">-2</span>]</span><br><span class=\"line\">        ans = <span class=\"built_in\">append</span>(ans,temp)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans[n]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>时间复杂度：O(n)</li>\n<li>空间复杂度：O(n)</li>\n</ul>\n<p>但是可以观察到保留的 f 数组其实只用到了一个变量f[i], 并且最后需要的结果是一个固定值 n，也就是说结果是确定位置的，那么是可以只保留计算获得 f[n] 相关的值就可以：f[n-1] 和 f[n-2]，这样的保留过程对于其他的 i 值来说也完全一样，除了 n=0 和 n=1 两个时候的值，那么就需要单独对这两个值来做处理</p>\n<p>只保留的pre和now,也可以改成 tmp[i-1] 和 tmp[i-2]也就是改成一个长度为2的一维数组–滚动数组，该数组存储有效信息并跟随遍历的阶段移动</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">fib</span><span class=\"params\">(n <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    pre := <span class=\"number\">0</span></span><br><span class=\"line\">    now := <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i:= <span class=\"number\">2</span> ; i &lt;= n ; i++&#123;</span><br><span class=\"line\">        tmp := now</span><br><span class=\"line\">        now = now + pre</span><br><span class=\"line\">        pre = tmp</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> n == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        now = <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> now</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"编辑距离\"><a href=\"#编辑距离\" class=\"headerlink\" title=\"编辑距离\"></a>编辑距离</h2><blockquote>\n<p>力扣题目链接: (<a href=\"https://leetcode.cn/problems/edit-distance/\">https://leetcode.cn/problems/edit-distance/</a>)</p>\n</blockquote>\n<h3 id=\"解题流程-1\"><a href=\"#解题流程-1\" class=\"headerlink\" title=\"解题流程\"></a>解题流程</h3><ol>\n<li><p>问题分析<br>将word1变成word2，共有三类型的操作：增加、删除、替换；同时计算操作数最小的情况。</p>\n<p><strong>是否使用动态规划</strong><br>一个最直白的想法就是我先把word1里面每一个字母都删除，进行len(word1)次操作；然后再加上word2里面的每一个字母，进行len(word2)次操作，当然这样的操作是次数最多的，是完全没有考虑到两个字符之间的关联性，当在字符串里面有相同的字母时候，就可以不操作跳过，再对后面的字符进行操作。</p>\n<p>这样不断地替换中间的操作流程就是一个全遍历的过程，需要找寻几乎所有的排列组合且存在着 <strong>最小值的优化目标 –&gt; 适合动态规划</strong>   </p>\n</li>\n</ol>\n<p>   <strong>为什么感觉问题解决会复杂？</strong></p>\n<p>   会发现增删都会改变字母的对应位置，而替换不改变位置，一些不同位置的字母可以通过增删变成对应相同位置的字母，也就是说三个操作之间相互关联。</p>\n<p>   同样的问题思考时候，word1变成word2其实也等价于word2变成word1,解题的流程是完全对称的。</p>\n<p>   结合以上因素，可以说一个dp状态就有了三种类型的迁移计算，那么我们需要设置一个dp[][][]的三维数组来分别表示三类状态迁移嘛？并不需要，因为替换可以等效为先减少一个字母，然后再增加一个字母只是代价增加为1而不是2，所以可以使用一个二维数组来表示：也就是dp[i][j]；其中i方向可以表示为减少word1 字母的操作，j方向标识增加word2字母的操作，i和j 同时增长表示替换操作：即先减少word1字母，然后增加word2字母。</p>\n<p>   还可以看到的是，依据上面的思考流程，i/j应当是和word1/2当中的单词位置相关联的；而麻烦的地方就集中在这个地方的理解上 <font color='red'>dp[i][j] 表示的是将word1前i-1个字符变成word2前j-1个字符最少的操作数</font>，dp[i][j]并不代表一个字符串或者说一个字符串形式，但是到dp[i][j]的路径可以唯一对应一个字符串</p>\n<p>   同时当我们使用上述的二位矩阵来计算时会发现，实质上我们也计算了将 word2 变成 word1的最小操作数</p>\n<ol start=\"2\">\n<li><p>DP 解题流程</p>\n<ul>\n<li><strong>确定dp数组以及下标的含义</strong><br>dp[i][j] 表示的是将word1前i-1个字符变成word2前j-1个字符最少的操作数</li>\n</ul>\n<p>这里有两个需要强调的点：</p>\n<ul>\n<li><p>dp[i] 对应的字母是 word[i-1], 而 dp[0] 对应的是空字符<br>这样来规定矩阵的计算形式更有利于计算</p>\n</li>\n<li><p>矩阵中元素对应着操作数，到达操作数的路径对应字符串</p>\n</li>\n<li><p><strong>确定递推公式</strong></p>\n<blockquote>\n<p>也就是确认矩阵元素的迁移计算方向并计算操作数</p>\n</blockquote>\n</li>\n</ul>\n<p>如果word1[i - 1] == word2[j - 1]，也就意味着对应位置的字母是相同的，那么增删或者删增同一个字母是没有必要，在矩阵元素迁移中，表示向右下移动一格遍历一个字母，但是不用操作两字符串，dp[i][j]操作数不用增加。</p>\n<p>如果word1[i - 1] != word2[j - 1]，那么接下来在矩阵当中移动，在i方向就意味着对word1[i-1]字母进行减操作，在j方向就意味着对word2[j-1]字母进行加操作</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (word1[i - 1] == word2[j - 1])</span><br><span class=\"line\">    不操作</span><br><span class=\"line\">if (word1[i - 1] != word2[j - 1])</span><br><span class=\"line\">    dp[i][j] = min (增,删,换)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>dp数组如何初始化</strong><br>考虑到空字符串的计算，也就是说对另一方不做操作的情况：</li>\n<li>d[i][0] 表示只减少word1的字母</li>\n<li>d[0][j] 表示只增加word2的字母</li>\n<li>d[0][0] 表示空字母</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li><strong>确定遍历顺序</strong><br>将word1变成word2，也就是意味着需要遍历每一个word1字母和每一个word2字母<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dp[i][j] = dp[i - 1][j - 1]  // i-1,j-1位置两个字符串的字母相同，不用操作，所以在状态迁移时候不用增加dp操作数</span><br><span class=\"line\"></span><br><span class=\"line\">//i-1,j-1位置两个字符串的字母不相同，需要对i-1，j-1位置上的字母做操作</span><br><span class=\"line\">dp[i][j] = dp[i - 1][j - 1] + 1 //替换</span><br><span class=\"line\">dp[i][j] = dp[i][j - 1] + 1 // 增加</span><br><span class=\"line\">dp[i][j] = dp[i - 1][j] + 1 // 减少</span><br></pre></td></tr></table></figure></li>\n</ul>\n<ul>\n<li><strong>举例推导dp数组</strong></li>\n</ul>\n<h3 id=\"代码实现-1\"><a href=\"#代码实现-1\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><hr>\n<h2 id=\"两个字符串的删除操作\"><a href=\"#两个字符串的删除操作\" class=\"headerlink\" title=\"两个字符串的删除操作\"></a>两个字符串的删除操作</h2><blockquote>\n<p>题目链接：(<a href=\"https://leetcode.cn/problems/delete-operation-for-two-strings/\">https://leetcode.cn/problems/delete-operation-for-two-strings/</a>)</p>\n</blockquote>\n<h3 id=\"解题流程-2\"><a href=\"#解题流程-2\" class=\"headerlink\" title=\"解题流程\"></a>解题流程</h3><ol>\n<li>问题分析</li>\n<li>DP 解题流程<ul>\n<li><strong>确定dp数组以及下标的含义</strong></li>\n<li><strong>确定递推公式</strong></li>\n<li><strong>dp数组如何初始化</strong></li>\n<li><strong>确定遍历顺序</strong></li>\n<li><strong>举例推导dp数组</strong><h3 id=\"代码实现-2\"><a href=\"#代码实现-2\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3></li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2 id=\"最长公共子序列\"><a href=\"#最长公共子序列\" class=\"headerlink\" title=\"最长公共子序列\"></a>最长公共子序列</h2><blockquote>\n<p>题目链接：(<a href=\"https://leetcode.cn/problems/longest-common-subsequence/\">https://leetcode.cn/problems/longest-common-subsequence/</a>)</p>\n</blockquote>\n<h3 id=\"解题流程-3\"><a href=\"#解题流程-3\" class=\"headerlink\" title=\"解题流程\"></a>解题流程</h3><ol>\n<li>问题分析</li>\n<li>DP 解题流程<ul>\n<li><strong>确定dp数组以及下标的含义</strong></li>\n<li><strong>确定递推公式</strong></li>\n<li><strong>dp数组如何初始化</strong></li>\n<li><strong>确定遍历顺序</strong></li>\n<li><strong>举例推导dp数组</strong><h3 id=\"代码实现-3\"><a href=\"#代码实现-3\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3></li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2 id=\"打家劫舍\"><a href=\"#打家劫舍\" class=\"headerlink\" title=\"打家劫舍\"></a>打家劫舍</h2><h3 id=\"解题流程-4\"><a href=\"#解题流程-4\" class=\"headerlink\" title=\"解题流程\"></a>解题流程</h3><ol>\n<li>问题分析</li>\n<li>DP 解题流程<ul>\n<li><strong>确定dp数组以及下标的含义</strong></li>\n<li><strong>确定递推公式</strong></li>\n<li><strong>dp数组如何初始化</strong></li>\n<li><strong>确定遍历顺序</strong></li>\n<li><strong>举例推导dp数组</strong><h3 id=\"代码实现-4\"><a href=\"#代码实现-4\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3></li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2 id=\"斐波那契数-1\"><a href=\"#斐波那契数-1\" class=\"headerlink\" title=\"斐波那契数\"></a>斐波那契数</h2><h3 id=\"解题流程-5\"><a href=\"#解题流程-5\" class=\"headerlink\" title=\"解题流程\"></a>解题流程</h3><ol>\n<li>问题分析</li>\n<li>DP 解题流程<ul>\n<li><strong>确定dp数组以及下标的含义</strong></li>\n<li><strong>确定递推公式</strong></li>\n<li><strong>dp数组如何初始化</strong></li>\n<li><strong>确定遍历顺序</strong></li>\n<li><strong>举例推导dp数组</strong><h3 id=\"代码实现-5\"><a href=\"#代码实现-5\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3></li>\n</ul>\n</li>\n</ol>\n"},{"title":"ACM 模式输入输出总结","catalog":true,"date":"2023-03-25T19:38:52.000Z","subtitle":"解决牛客网输入输出问题","header-img":null,"_content":"\n# 输入格式归纳记录\n\n由于牛客网采用的是 acm 形式编写代码，所以需要在做题时候需要自行处理输入输出的数据格式，以 Golang 作为主要例子归纳如下：\n\n\n## 读取多行数据，每一行数据是多个空格隔开的元素\n``` golang\npackage main\nimport(\n    \"bufio\"\n    \"fmt\"\n    \"strings\"\n    \"strconv\"\n    \"os\"\n)\n\nfunc main(){\n    scanner := bufio.NewScanner(os.Stdin)\n    scanner.Split(bufio.ScanLines)\n    var sum int\n    for scanner.Scan(){\n        line := scanner.Text()\n        fields := strings.Fields(line)\n        for _, field := range fields{\n            num, err := strconv.Atoi(field)\n            if err == nil{\n                sum += num\n            }\n        }\n        fmt.Println(sum)\n        sum = 0\n    }\n}\n```\n\n\n\n# 输入数值的进制转换\n\n## 十进制数字转换为其他进制数字\n\n```golang\n    i := 255\n    // 将int类型的i转化为二进制字符串并输出\n    s := strconv.FormatInt(int64(i), 2)\n    fmt.Println(s) // \"11111111\"\n    // 将int类型的i转化为八进制字符串并输出\n    s = strconv.FormatInt(int64(i), 8)\n    fmt.Println(s) // \"377\"\n    // 将int类型的i转化为十六进制字符串并输出\n    s = strconv.FormatInt(int64(i), 16)\n    fmt.Println(s) // \"ff\"\n```\n\n## 其他进制转换为10进制\n\n```golang\n    s := \"377\"\n    i, err := strconv.ParseInt(s, 8, 0)\n    if err != nil {\n        fmt.Println(err)\n    } else {\n        fmt.Println(i) // 255\n    }\n```\n","source":"_posts/Algorithm/ACM-模式输入输出总结/ACM-模式输入输出总结.md","raw":"---\ntitle: ACM 模式输入输出总结\ncatalog: true\ndate: 2023-03-26 03:38:52\nsubtitle: 解决牛客网输入输出问题\nheader-img:\ntags: Golang\ncategories:\n---\n\n# 输入格式归纳记录\n\n由于牛客网采用的是 acm 形式编写代码，所以需要在做题时候需要自行处理输入输出的数据格式，以 Golang 作为主要例子归纳如下：\n\n\n## 读取多行数据，每一行数据是多个空格隔开的元素\n``` golang\npackage main\nimport(\n    \"bufio\"\n    \"fmt\"\n    \"strings\"\n    \"strconv\"\n    \"os\"\n)\n\nfunc main(){\n    scanner := bufio.NewScanner(os.Stdin)\n    scanner.Split(bufio.ScanLines)\n    var sum int\n    for scanner.Scan(){\n        line := scanner.Text()\n        fields := strings.Fields(line)\n        for _, field := range fields{\n            num, err := strconv.Atoi(field)\n            if err == nil{\n                sum += num\n            }\n        }\n        fmt.Println(sum)\n        sum = 0\n    }\n}\n```\n\n\n\n# 输入数值的进制转换\n\n## 十进制数字转换为其他进制数字\n\n```golang\n    i := 255\n    // 将int类型的i转化为二进制字符串并输出\n    s := strconv.FormatInt(int64(i), 2)\n    fmt.Println(s) // \"11111111\"\n    // 将int类型的i转化为八进制字符串并输出\n    s = strconv.FormatInt(int64(i), 8)\n    fmt.Println(s) // \"377\"\n    // 将int类型的i转化为十六进制字符串并输出\n    s = strconv.FormatInt(int64(i), 16)\n    fmt.Println(s) // \"ff\"\n```\n\n## 其他进制转换为10进制\n\n```golang\n    s := \"377\"\n    i, err := strconv.ParseInt(s, 8, 0)\n    if err != nil {\n        fmt.Println(err)\n    } else {\n        fmt.Println(i) // 255\n    }\n```\n","slug":"Algorithm/ACM-模式输入输出总结/ACM-模式输入输出总结","published":1,"updated":"2023-04-22T13:24:02.164Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgtm6jq30005lyjxe1mb1y4o","content":"<h1 id=\"输入格式归纳记录\"><a href=\"#输入格式归纳记录\" class=\"headerlink\" title=\"输入格式归纳记录\"></a>输入格式归纳记录</h1><p>由于牛客网采用的是 acm 形式编写代码，所以需要在做题时候需要自行处理输入输出的数据格式，以 Golang 作为主要例子归纳如下：</p>\n<h2 id=\"读取多行数据，每一行数据是多个空格隔开的元素\"><a href=\"#读取多行数据，每一行数据是多个空格隔开的元素\" class=\"headerlink\" title=\"读取多行数据，每一行数据是多个空格隔开的元素\"></a>读取多行数据，每一行数据是多个空格隔开的元素</h2><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"><span class=\"keyword\">import</span>(</span><br><span class=\"line\">    <span class=\"string\">&quot;bufio&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;strings&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;strconv&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;os&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    scanner := bufio.NewScanner(os.Stdin)</span><br><span class=\"line\">    scanner.Split(bufio.ScanLines)</span><br><span class=\"line\">    <span class=\"keyword\">var</span> sum <span class=\"type\">int</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> scanner.Scan()&#123;</span><br><span class=\"line\">        line := scanner.Text()</span><br><span class=\"line\">        fields := strings.Fields(line)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> _, field := <span class=\"keyword\">range</span> fields&#123;</span><br><span class=\"line\">            num, err := strconv.Atoi(field)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> err == <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">                sum += num</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        fmt.Println(sum)</span><br><span class=\"line\">        sum = <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"输入数值的进制转换\"><a href=\"#输入数值的进制转换\" class=\"headerlink\" title=\"输入数值的进制转换\"></a>输入数值的进制转换</h1><h2 id=\"十进制数字转换为其他进制数字\"><a href=\"#十进制数字转换为其他进制数字\" class=\"headerlink\" title=\"十进制数字转换为其他进制数字\"></a>十进制数字转换为其他进制数字</h2><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i := <span class=\"number\">255</span></span><br><span class=\"line\"><span class=\"comment\">// 将int类型的i转化为二进制字符串并输出</span></span><br><span class=\"line\">s := strconv.FormatInt(<span class=\"type\">int64</span>(i), <span class=\"number\">2</span>)</span><br><span class=\"line\">fmt.Println(s) <span class=\"comment\">// &quot;11111111&quot;</span></span><br><span class=\"line\"><span class=\"comment\">// 将int类型的i转化为八进制字符串并输出</span></span><br><span class=\"line\">s = strconv.FormatInt(<span class=\"type\">int64</span>(i), <span class=\"number\">8</span>)</span><br><span class=\"line\">fmt.Println(s) <span class=\"comment\">// &quot;377&quot;</span></span><br><span class=\"line\"><span class=\"comment\">// 将int类型的i转化为十六进制字符串并输出</span></span><br><span class=\"line\">s = strconv.FormatInt(<span class=\"type\">int64</span>(i), <span class=\"number\">16</span>)</span><br><span class=\"line\">fmt.Println(s) <span class=\"comment\">// &quot;ff&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"其他进制转换为10进制\"><a href=\"#其他进制转换为10进制\" class=\"headerlink\" title=\"其他进制转换为10进制\"></a>其他进制转换为10进制</h2><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s := <span class=\"string\">&quot;377&quot;</span></span><br><span class=\"line\">i, err := strconv.ParseInt(s, <span class=\"number\">8</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    fmt.Println(err)</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    fmt.Println(i) <span class=\"comment\">// 255</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":"/img/cover/2077_city.png","cover_type":"img","excerpt":"","more":"<h1 id=\"输入格式归纳记录\"><a href=\"#输入格式归纳记录\" class=\"headerlink\" title=\"输入格式归纳记录\"></a>输入格式归纳记录</h1><p>由于牛客网采用的是 acm 形式编写代码，所以需要在做题时候需要自行处理输入输出的数据格式，以 Golang 作为主要例子归纳如下：</p>\n<h2 id=\"读取多行数据，每一行数据是多个空格隔开的元素\"><a href=\"#读取多行数据，每一行数据是多个空格隔开的元素\" class=\"headerlink\" title=\"读取多行数据，每一行数据是多个空格隔开的元素\"></a>读取多行数据，每一行数据是多个空格隔开的元素</h2><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"><span class=\"keyword\">import</span>(</span><br><span class=\"line\">    <span class=\"string\">&quot;bufio&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;strings&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;strconv&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;os&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    scanner := bufio.NewScanner(os.Stdin)</span><br><span class=\"line\">    scanner.Split(bufio.ScanLines)</span><br><span class=\"line\">    <span class=\"keyword\">var</span> sum <span class=\"type\">int</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> scanner.Scan()&#123;</span><br><span class=\"line\">        line := scanner.Text()</span><br><span class=\"line\">        fields := strings.Fields(line)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> _, field := <span class=\"keyword\">range</span> fields&#123;</span><br><span class=\"line\">            num, err := strconv.Atoi(field)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> err == <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">                sum += num</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        fmt.Println(sum)</span><br><span class=\"line\">        sum = <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"输入数值的进制转换\"><a href=\"#输入数值的进制转换\" class=\"headerlink\" title=\"输入数值的进制转换\"></a>输入数值的进制转换</h1><h2 id=\"十进制数字转换为其他进制数字\"><a href=\"#十进制数字转换为其他进制数字\" class=\"headerlink\" title=\"十进制数字转换为其他进制数字\"></a>十进制数字转换为其他进制数字</h2><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i := <span class=\"number\">255</span></span><br><span class=\"line\"><span class=\"comment\">// 将int类型的i转化为二进制字符串并输出</span></span><br><span class=\"line\">s := strconv.FormatInt(<span class=\"type\">int64</span>(i), <span class=\"number\">2</span>)</span><br><span class=\"line\">fmt.Println(s) <span class=\"comment\">// &quot;11111111&quot;</span></span><br><span class=\"line\"><span class=\"comment\">// 将int类型的i转化为八进制字符串并输出</span></span><br><span class=\"line\">s = strconv.FormatInt(<span class=\"type\">int64</span>(i), <span class=\"number\">8</span>)</span><br><span class=\"line\">fmt.Println(s) <span class=\"comment\">// &quot;377&quot;</span></span><br><span class=\"line\"><span class=\"comment\">// 将int类型的i转化为十六进制字符串并输出</span></span><br><span class=\"line\">s = strconv.FormatInt(<span class=\"type\">int64</span>(i), <span class=\"number\">16</span>)</span><br><span class=\"line\">fmt.Println(s) <span class=\"comment\">// &quot;ff&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"其他进制转换为10进制\"><a href=\"#其他进制转换为10进制\" class=\"headerlink\" title=\"其他进制转换为10进制\"></a>其他进制转换为10进制</h2><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s := <span class=\"string\">&quot;377&quot;</span></span><br><span class=\"line\">i, err := strconv.ParseInt(s, <span class=\"number\">8</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    fmt.Println(err)</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    fmt.Println(i) <span class=\"comment\">// 255</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Golang-数据结构-链表","catalog":true,"date":"2023-04-01T16:46:21.000Z","subtitle":null,"header-img":null,"_content":"\n\n\n","source":"_posts/Algorithm/Golang-数据结构/Golang-数据结构-链表.md","raw":"---\ntitle: Golang-数据结构-链表\ncatalog: true\ndate: 2023-04-02 00:46:21\nsubtitle:\nheader-img:\ntags: 链表, 算法\ncategories: 算法，Golang, 链表\n---\n\n\n\n","slug":"Algorithm/Golang-数据结构/Golang-数据结构-链表","published":1,"updated":"2023-04-23T10:12:49.569Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgtm6jq40007lyjxeb2t6kdw","content":"","site":{"data":{}},"cover":"/img/cover/2077_city.png","cover_type":"img","excerpt":"","more":""},{"title":"Golang 算法课程--算法","catalog":true,"date":"2023-04-01T16:46:21.000Z","subtitle":null,"header-img":null,"published":0,"_content":"\n# 算法思想篇\n> 个人学习算法经验：\n> 1. 深入了解和使用一门语言 ---> Golang\n> 2. 深入理解基础的数据结构和算法基础 ---> 数学理论\n> 3. 知识需要依据模块和分区来做体系的整理和学习 \n\n# **1** &ensp; 二分搜索： 为什么说有序皆可用二分\n> 本章节的学习目标：\n> * 二分搜索的两个标准模板\n> * 二分搜索的提问破解法\n> * 二分搜索的切分法\n\n## **1.1** &ensp; 二分搜索的关键考点\n\n1. 开闭原则\n   一定要注意，在写二分搜索时候，每一个区间的表示都是严格按照开闭原则进行的\n   开闭原则 --> 左闭右开 --> 左边指针指向起点，右边指针指向尾部元素的后面一个空位 \n\n2. 区间的变化计算\n\n3. 代码的流畅度\n   * ==是否深度理解了二分搜索的原则在该题目当中的体现== --> <font color='red'> 所有算法题目的代码流畅度检验思考一</font>\n   * ==是否真的记住了代码的模板== --> <font color='red'> 所有算法题目的代码流畅度检验思考二</font>\n   * ==所有代码编写流畅度问题的根源都是在于不熟练--> 用的不多 --> 不会转化为已知的问题 --> 是否理解了运用的原理== --> <font color='red'> 代码熟练度尤其关注 </font>\n\n``` mermaid\ngraph TD\nA[联系] --> B(开闭原则)\nB --> D[二分搜索]\nB --> E[快速排序-三路切分]\nB --> F[归并排序-切分为两个区间]\nA --> C(扔掉一半)\nC --> G[二叉搜索树]\nG --> H[查找]\nG --> I[删除]\nG --> N[插入]\nC --> J(三路切分)\nJ --> K[第k小的数]\nJ --> L[唯一出现的数]   \n```\n<br />\n\n\n## **1.2** &ensp; 提问破解法解决二分问题\n\n### 要什么，什么就是x \n\n1. 将目标元素设置为 x --> 去除掉题目当中所给的最小最长最大最短等限制条件，得到一个点描述\n2. 得到目标 x 的区间范围: --> 决定左开右闭的规则\n   \n### 满足约束条件的f(x)=0\n\n### 不满足约束条件的f(x)设置为-1或者是1\n\n构造出一个单调变化的 f(x)，以上两步的关键在于确定（构造）f(x)是否有序，需要观察数组元素和题目要求的内容变化\n\n### 使用lowbound 还是 upbound\n最优解 0 在 f(x)=0 结果区间的最左边还是最右边，决定使用lowbound 还是 upbound \n\n### 有序数组中最左边的元素\n> 模板题目\n\n### 给定有序数组和target ，返回起始和终止位置\n> 模板题目\n\n\n### 寻找山峰\n\n\n\n### 最小长度的连续子数组\n求取的中间数组[-1,-1,0,0,1,1] 中元素代表的是子数组的长度，-1表示小于target,0 表示等于target\n<!-- // 209. 长度最小的子数组\n\n// 给定一个含有 n 个正整数的数组和一个正整数 target 。\n\n// 找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。\n\n//  \n\n// 示例 1：\n\n// 输入：target = 7, nums = [2,3,1,2,4,3]\n// 输出：2\n// 解释：子数组 [4,3] 是该条件下的长度最小的子数组。\n// 示例 2：\n\n// 输入：target = 4, nums = [1,4,4]\n// 输出：1\n// 示例 3：\n\n// 输入：target = 11, nums = [1,1,1,1,1,1,1,1]\n// 输出：0\n//  \n\n// 提示：\n\n// 1 <= target <= 109\n// 1 <= nums.length <= 105\n// 1 <= nums[i] <= 105\n\n// 求和数组 -->\n``` golang\nfunc isTarget(nums []int,l int,target int)int{\n    sum := 0\n    for i := 0 ; i < len(nums) ; i++ {\n        sum += nums[i]\n        if i < l-1 {\n            continue\n        }\n        if sum >= target{\n            return 0\n        } \n        sum = sum - nums[i-(l-1)]\n    } \n    return -1\n}\n\n\nfunc minSubArrayLen(target int, nums []int) int {\n    left, right := 1,len(nums)+1\n\n    for left < right{\n        m := left + (right-left)/2\n        now := isTarget(nums,m,target)\n        if now < 0 {\n            left = m + 1\n        }else{\n            right = m\n        }\n    }\n    if left > len(nums){\n        return 0\n    }\n    return left\n}\n```\n\n### 最大平均值\n但限制了数组长度为k的时候，可以直接使用滑动窗口来解决这个问题\n``` golang \n/**\n * @param nums: an array\n * @param k: an integer\n * @return: the maximum average value\n */\nfunc FindMaxAverage(nums []int, k int) float64 {\n\t// Write your code here\n\tmax := -10001\n\tsum := 0\n\tfor i := 0; i < len(nums); i++ {\n\t\tsum = sum + nums[i]\n\t\tif i < k-1 {\n\t\t\tcontinue\n\t\t}\n\t\tif sum > max {\n\t\t\tmax = sum\n\t\t}\n\t\tif i >= k-1 {\n\t\t\tsum = sum - nums[i-(k-1)]\n\t\t}\n\t}\n\treturn float64(max) / float64(k)\n}\n```\n### 连续子数组的最大和问题\n在上述两个问题的基础之上，衍生出来同类型的问题：\n1. 如果子数组的长度无限制： 采用落差发或者是双指针，DP来解决这个问题\n2. 子数组长度等于K 时候采用滑动窗口\n3. 长度>=K,采用滑动窗口和落差法来解决\n4. 如果限制长度必须要<=k的连续子数组最大和，可以分别求1-k的最大值，然后再选一个最大值\n\n\n## **3**三步切分法\n\n1. 找出一个分界元素\n2. 将有序的搜索空间分为两半（复杂度为O（1））\n   扔掉不需要的那一半\n3. 在剩下的空间中递归使用切分法\n\n切分法不需要有序性，但是二分搜索必须要求有序性\n### 求旋转数组当中的某个元素\n以下是未重复的题目：\n```\n33. 搜索旋转排序数组\n整数数组 nums 按升序排列，数组中的值 互不相同 。\n\n在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。\n\n给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。\n\n你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。\n\n示例 1：\n\n输入：nums = [4,5,6,7,0,1,2], target = 0\n输出：4\n示例 2：\n\n输入：nums = [4,5,6,7,0,1,2], target = 3\n输出：-1\n示例 3：\n\n输入：nums = [1], target = 0\n输出：-1\n \n\n提示：\n\n1 <= nums.length <= 5000\n-104 <= nums[i] <= 104\nnums 中的每个值都 独一无二\n题目数据保证 nums 在预先未知的某个下标上进行了旋转\n-104 <= target <= 104\n```\n\n如果增加一个重复的元素，题目变成：\n```\n81. 搜索旋转排序数组 II\n已知存在一个按非降序排列的整数数组 nums ，数组中的值不必互不相同。\n\n在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转 ，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,4,4,5,6,6,7] 在下标 5 处经旋转后可能变为 [4,5,6,6,7,0,1,2,4,4] 。\n\n给你 旋转后 的数组 nums 和一个整数 target ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 nums 中存在这个目标值 target ，则返回 true ，否则返回 false 。\n\n你必须尽可能减少整个操作步骤。\n```\n增加了重复的元素，那么只需要判断重复的元素是否是目标元素，如果不是那么就直接删除重复的元素，使得问题便会原本不重复元素的形式\n\n```golang\nfunc search(nums []int, target int)bool {\n    n := len(nums)\n    left,right := 0 , n\n\n    for left < right {\n        m := left + (right-left)/2\n\n        if nums[left] == target || nums[m] == target || nums[right-1] == target{\n            return true\n        }\n        if nums[m] > nums[left] {\n            if target > nums[left] && target < nums[m]{\n                right = m\n            }else{\n                left = m + 1\n            }\n        }else if nums[m] < nums[left]{\n            if target > nums[m] && target < nums[right-1]{\n                left = m + 1\n            }else{\n                right = m\n            }\n        }else{\n            for left < right && nums[m] == nums[left]{\n                left++\n            }\n        }\n    }\n    return false\n}\n```\n\n","source":"_posts/Algorithm/Golang-算法课程/Golang-算法课程--算法.md","raw":"---\ntitle: Golang 算法课程--算法\ncatalog: true\ndate: 2023-04-02 00:46:21\nsubtitle:\nheader-img:\ntags: working, 算法\ncategories: 算法，Golang\npublished: false\n---\n\n# 算法思想篇\n> 个人学习算法经验：\n> 1. 深入了解和使用一门语言 ---> Golang\n> 2. 深入理解基础的数据结构和算法基础 ---> 数学理论\n> 3. 知识需要依据模块和分区来做体系的整理和学习 \n\n# **1** &ensp; 二分搜索： 为什么说有序皆可用二分\n> 本章节的学习目标：\n> * 二分搜索的两个标准模板\n> * 二分搜索的提问破解法\n> * 二分搜索的切分法\n\n## **1.1** &ensp; 二分搜索的关键考点\n\n1. 开闭原则\n   一定要注意，在写二分搜索时候，每一个区间的表示都是严格按照开闭原则进行的\n   开闭原则 --> 左闭右开 --> 左边指针指向起点，右边指针指向尾部元素的后面一个空位 \n\n2. 区间的变化计算\n\n3. 代码的流畅度\n   * ==是否深度理解了二分搜索的原则在该题目当中的体现== --> <font color='red'> 所有算法题目的代码流畅度检验思考一</font>\n   * ==是否真的记住了代码的模板== --> <font color='red'> 所有算法题目的代码流畅度检验思考二</font>\n   * ==所有代码编写流畅度问题的根源都是在于不熟练--> 用的不多 --> 不会转化为已知的问题 --> 是否理解了运用的原理== --> <font color='red'> 代码熟练度尤其关注 </font>\n\n``` mermaid\ngraph TD\nA[联系] --> B(开闭原则)\nB --> D[二分搜索]\nB --> E[快速排序-三路切分]\nB --> F[归并排序-切分为两个区间]\nA --> C(扔掉一半)\nC --> G[二叉搜索树]\nG --> H[查找]\nG --> I[删除]\nG --> N[插入]\nC --> J(三路切分)\nJ --> K[第k小的数]\nJ --> L[唯一出现的数]   \n```\n<br />\n\n\n## **1.2** &ensp; 提问破解法解决二分问题\n\n### 要什么，什么就是x \n\n1. 将目标元素设置为 x --> 去除掉题目当中所给的最小最长最大最短等限制条件，得到一个点描述\n2. 得到目标 x 的区间范围: --> 决定左开右闭的规则\n   \n### 满足约束条件的f(x)=0\n\n### 不满足约束条件的f(x)设置为-1或者是1\n\n构造出一个单调变化的 f(x)，以上两步的关键在于确定（构造）f(x)是否有序，需要观察数组元素和题目要求的内容变化\n\n### 使用lowbound 还是 upbound\n最优解 0 在 f(x)=0 结果区间的最左边还是最右边，决定使用lowbound 还是 upbound \n\n### 有序数组中最左边的元素\n> 模板题目\n\n### 给定有序数组和target ，返回起始和终止位置\n> 模板题目\n\n\n### 寻找山峰\n\n\n\n### 最小长度的连续子数组\n求取的中间数组[-1,-1,0,0,1,1] 中元素代表的是子数组的长度，-1表示小于target,0 表示等于target\n<!-- // 209. 长度最小的子数组\n\n// 给定一个含有 n 个正整数的数组和一个正整数 target 。\n\n// 找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。\n\n//  \n\n// 示例 1：\n\n// 输入：target = 7, nums = [2,3,1,2,4,3]\n// 输出：2\n// 解释：子数组 [4,3] 是该条件下的长度最小的子数组。\n// 示例 2：\n\n// 输入：target = 4, nums = [1,4,4]\n// 输出：1\n// 示例 3：\n\n// 输入：target = 11, nums = [1,1,1,1,1,1,1,1]\n// 输出：0\n//  \n\n// 提示：\n\n// 1 <= target <= 109\n// 1 <= nums.length <= 105\n// 1 <= nums[i] <= 105\n\n// 求和数组 -->\n``` golang\nfunc isTarget(nums []int,l int,target int)int{\n    sum := 0\n    for i := 0 ; i < len(nums) ; i++ {\n        sum += nums[i]\n        if i < l-1 {\n            continue\n        }\n        if sum >= target{\n            return 0\n        } \n        sum = sum - nums[i-(l-1)]\n    } \n    return -1\n}\n\n\nfunc minSubArrayLen(target int, nums []int) int {\n    left, right := 1,len(nums)+1\n\n    for left < right{\n        m := left + (right-left)/2\n        now := isTarget(nums,m,target)\n        if now < 0 {\n            left = m + 1\n        }else{\n            right = m\n        }\n    }\n    if left > len(nums){\n        return 0\n    }\n    return left\n}\n```\n\n### 最大平均值\n但限制了数组长度为k的时候，可以直接使用滑动窗口来解决这个问题\n``` golang \n/**\n * @param nums: an array\n * @param k: an integer\n * @return: the maximum average value\n */\nfunc FindMaxAverage(nums []int, k int) float64 {\n\t// Write your code here\n\tmax := -10001\n\tsum := 0\n\tfor i := 0; i < len(nums); i++ {\n\t\tsum = sum + nums[i]\n\t\tif i < k-1 {\n\t\t\tcontinue\n\t\t}\n\t\tif sum > max {\n\t\t\tmax = sum\n\t\t}\n\t\tif i >= k-1 {\n\t\t\tsum = sum - nums[i-(k-1)]\n\t\t}\n\t}\n\treturn float64(max) / float64(k)\n}\n```\n### 连续子数组的最大和问题\n在上述两个问题的基础之上，衍生出来同类型的问题：\n1. 如果子数组的长度无限制： 采用落差发或者是双指针，DP来解决这个问题\n2. 子数组长度等于K 时候采用滑动窗口\n3. 长度>=K,采用滑动窗口和落差法来解决\n4. 如果限制长度必须要<=k的连续子数组最大和，可以分别求1-k的最大值，然后再选一个最大值\n\n\n## **3**三步切分法\n\n1. 找出一个分界元素\n2. 将有序的搜索空间分为两半（复杂度为O（1））\n   扔掉不需要的那一半\n3. 在剩下的空间中递归使用切分法\n\n切分法不需要有序性，但是二分搜索必须要求有序性\n### 求旋转数组当中的某个元素\n以下是未重复的题目：\n```\n33. 搜索旋转排序数组\n整数数组 nums 按升序排列，数组中的值 互不相同 。\n\n在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。\n\n给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。\n\n你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。\n\n示例 1：\n\n输入：nums = [4,5,6,7,0,1,2], target = 0\n输出：4\n示例 2：\n\n输入：nums = [4,5,6,7,0,1,2], target = 3\n输出：-1\n示例 3：\n\n输入：nums = [1], target = 0\n输出：-1\n \n\n提示：\n\n1 <= nums.length <= 5000\n-104 <= nums[i] <= 104\nnums 中的每个值都 独一无二\n题目数据保证 nums 在预先未知的某个下标上进行了旋转\n-104 <= target <= 104\n```\n\n如果增加一个重复的元素，题目变成：\n```\n81. 搜索旋转排序数组 II\n已知存在一个按非降序排列的整数数组 nums ，数组中的值不必互不相同。\n\n在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转 ，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,4,4,5,6,6,7] 在下标 5 处经旋转后可能变为 [4,5,6,6,7,0,1,2,4,4] 。\n\n给你 旋转后 的数组 nums 和一个整数 target ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 nums 中存在这个目标值 target ，则返回 true ，否则返回 false 。\n\n你必须尽可能减少整个操作步骤。\n```\n增加了重复的元素，那么只需要判断重复的元素是否是目标元素，如果不是那么就直接删除重复的元素，使得问题便会原本不重复元素的形式\n\n```golang\nfunc search(nums []int, target int)bool {\n    n := len(nums)\n    left,right := 0 , n\n\n    for left < right {\n        m := left + (right-left)/2\n\n        if nums[left] == target || nums[m] == target || nums[right-1] == target{\n            return true\n        }\n        if nums[m] > nums[left] {\n            if target > nums[left] && target < nums[m]{\n                right = m\n            }else{\n                left = m + 1\n            }\n        }else if nums[m] < nums[left]{\n            if target > nums[m] && target < nums[right-1]{\n                left = m + 1\n            }else{\n                right = m\n            }\n        }else{\n            for left < right && nums[m] == nums[left]{\n                left++\n            }\n        }\n    }\n    return false\n}\n```\n\n","slug":"Algorithm/Golang-算法课程/Golang-算法课程--算法","updated":"2023-04-22T13:24:02.176Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgtm6jq6000alyjx4nccd2gv","content":"<h1 id=\"算法思想篇\"><a href=\"#算法思想篇\" class=\"headerlink\" title=\"算法思想篇\"></a>算法思想篇</h1><blockquote>\n<p>个人学习算法经验：</p>\n<ol>\n<li>深入了解和使用一门语言 —&gt; Golang</li>\n<li>深入理解基础的数据结构和算法基础 —&gt; 数学理论</li>\n<li>知识需要依据模块和分区来做体系的整理和学习 </li>\n</ol>\n</blockquote>\n<h1 id=\"1-ensp-二分搜索：-为什么说有序皆可用二分\"><a href=\"#1-ensp-二分搜索：-为什么说有序皆可用二分\" class=\"headerlink\" title=\"1 &ensp; 二分搜索： 为什么说有序皆可用二分\"></a><strong>1</strong> &ensp; 二分搜索： 为什么说有序皆可用二分</h1><blockquote>\n<p>本章节的学习目标：</p>\n<ul>\n<li>二分搜索的两个标准模板</li>\n<li>二分搜索的提问破解法</li>\n<li>二分搜索的切分法</li>\n</ul>\n</blockquote>\n<h2 id=\"1-1-ensp-二分搜索的关键考点\"><a href=\"#1-1-ensp-二分搜索的关键考点\" class=\"headerlink\" title=\"1.1 &ensp; 二分搜索的关键考点\"></a><strong>1.1</strong> &ensp; 二分搜索的关键考点</h2><ol>\n<li><p>开闭原则<br>一定要注意，在写二分搜索时候，每一个区间的表示都是严格按照开闭原则进行的<br>开闭原则 –&gt; 左闭右开 –&gt; 左边指针指向起点，右边指针指向尾部元素的后面一个空位 </p>\n</li>\n<li><p>区间的变化计算</p>\n</li>\n<li><p>代码的流畅度</p>\n<ul>\n<li>==是否深度理解了二分搜索的原则在该题目当中的体现== –&gt; <font color='red'> 所有算法题目的代码流畅度检验思考一</font></li>\n<li>==是否真的记住了代码的模板== –&gt; <font color='red'> 所有算法题目的代码流畅度检验思考二</font></li>\n<li>==所有代码编写流畅度问题的根源都是在于不熟练–&gt; 用的不多 –&gt; 不会转化为已知的问题 –&gt; 是否理解了运用的原理== –&gt; <font color='red'> 代码熟练度尤其关注 </font></li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph TD</span><br><span class=\"line\">A[联系] --&gt; B(开闭原则)</span><br><span class=\"line\">B --&gt; D[二分搜索]</span><br><span class=\"line\">B --&gt; E[快速排序-三路切分]</span><br><span class=\"line\">B --&gt; F[归并排序-切分为两个区间]</span><br><span class=\"line\">A --&gt; C(扔掉一半)</span><br><span class=\"line\">C --&gt; G[二叉搜索树]</span><br><span class=\"line\">G --&gt; H[查找]</span><br><span class=\"line\">G --&gt; I[删除]</span><br><span class=\"line\">G --&gt; N[插入]</span><br><span class=\"line\">C --&gt; J(三路切分)</span><br><span class=\"line\">J --&gt; K[第k小的数]</span><br><span class=\"line\">J --&gt; L[唯一出现的数]   </span><br></pre></td></tr></table></figure>\n<br />\n\n\n<h2 id=\"1-2-ensp-提问破解法解决二分问题\"><a href=\"#1-2-ensp-提问破解法解决二分问题\" class=\"headerlink\" title=\"1.2 &ensp; 提问破解法解决二分问题\"></a><strong>1.2</strong> &ensp; 提问破解法解决二分问题</h2><h3 id=\"要什么，什么就是x\"><a href=\"#要什么，什么就是x\" class=\"headerlink\" title=\"要什么，什么就是x\"></a>要什么，什么就是x</h3><ol>\n<li>将目标元素设置为 x –&gt; 去除掉题目当中所给的最小最长最大最短等限制条件，得到一个点描述</li>\n<li>得到目标 x 的区间范围: –&gt; 决定左开右闭的规则</li>\n</ol>\n<h3 id=\"满足约束条件的f-x-0\"><a href=\"#满足约束条件的f-x-0\" class=\"headerlink\" title=\"满足约束条件的f(x)=0\"></a>满足约束条件的f(x)=0</h3><h3 id=\"不满足约束条件的f-x-设置为-1或者是1\"><a href=\"#不满足约束条件的f-x-设置为-1或者是1\" class=\"headerlink\" title=\"不满足约束条件的f(x)设置为-1或者是1\"></a>不满足约束条件的f(x)设置为-1或者是1</h3><p>构造出一个单调变化的 f(x)，以上两步的关键在于确定（构造）f(x)是否有序，需要观察数组元素和题目要求的内容变化</p>\n<h3 id=\"使用lowbound-还是-upbound\"><a href=\"#使用lowbound-还是-upbound\" class=\"headerlink\" title=\"使用lowbound 还是 upbound\"></a>使用lowbound 还是 upbound</h3><p>最优解 0 在 f(x)=0 结果区间的最左边还是最右边，决定使用lowbound 还是 upbound </p>\n<h3 id=\"有序数组中最左边的元素\"><a href=\"#有序数组中最左边的元素\" class=\"headerlink\" title=\"有序数组中最左边的元素\"></a>有序数组中最左边的元素</h3><blockquote>\n<p>模板题目</p>\n</blockquote>\n<h3 id=\"给定有序数组和target-，返回起始和终止位置\"><a href=\"#给定有序数组和target-，返回起始和终止位置\" class=\"headerlink\" title=\"给定有序数组和target ，返回起始和终止位置\"></a>给定有序数组和target ，返回起始和终止位置</h3><blockquote>\n<p>模板题目</p>\n</blockquote>\n<h3 id=\"寻找山峰\"><a href=\"#寻找山峰\" class=\"headerlink\" title=\"寻找山峰\"></a>寻找山峰</h3><h3 id=\"最小长度的连续子数组\"><a href=\"#最小长度的连续子数组\" class=\"headerlink\" title=\"最小长度的连续子数组\"></a>最小长度的连续子数组</h3><p>求取的中间数组[-1,-1,0,0,1,1] 中元素代表的是子数组的长度，-1表示小于target,0 表示等于target</p>\n<!-- // 209. 长度最小的子数组\n\n// 给定一个含有 n 个正整数的数组和一个正整数 target 。\n\n// 找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。\n\n//  \n\n// 示例 1：\n\n// 输入：target = 7, nums = [2,3,1,2,4,3]\n// 输出：2\n// 解释：子数组 [4,3] 是该条件下的长度最小的子数组。\n// 示例 2：\n\n// 输入：target = 4, nums = [1,4,4]\n// 输出：1\n// 示例 3：\n\n// 输入：target = 11, nums = [1,1,1,1,1,1,1,1]\n// 输出：0\n//  \n\n// 提示：\n\n// 1 <= target <= 109\n// 1 <= nums.length <= 105\n// 1 <= nums[i] <= 105\n\n// 求和数组 -->\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">isTarget</span><span class=\"params\">(nums []<span class=\"type\">int</span>,l <span class=\"type\">int</span>,target <span class=\"type\">int</span>)</span></span><span class=\"type\">int</span>&#123;</span><br><span class=\"line\">    sum := <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span> ; i &lt; <span class=\"built_in\">len</span>(nums) ; i++ &#123;</span><br><span class=\"line\">        sum += nums[i]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i &lt; l<span class=\"number\">-1</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> sum &gt;= target&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        sum = sum - nums[i-(l<span class=\"number\">-1</span>)]</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">minSubArrayLen</span><span class=\"params\">(target <span class=\"type\">int</span>, nums []<span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    left, right := <span class=\"number\">1</span>,<span class=\"built_in\">len</span>(nums)+<span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> left &lt; right&#123;</span><br><span class=\"line\">        m := left + (right-left)/<span class=\"number\">2</span></span><br><span class=\"line\">        now := isTarget(nums,m,target)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> now &lt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">            left = m + <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            right = m</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> left &gt; <span class=\"built_in\">len</span>(nums)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> left</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"最大平均值\"><a href=\"#最大平均值\" class=\"headerlink\" title=\"最大平均值\"></a>最大平均值</h3><p>但限制了数组长度为k的时候，可以直接使用滑动窗口来解决这个问题</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @param nums: an array</span></span><br><span class=\"line\"><span class=\"comment\"> * @param k: an integer</span></span><br><span class=\"line\"><span class=\"comment\"> * @return: the maximum average value</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">FindMaxAverage</span><span class=\"params\">(nums []<span class=\"type\">int</span>, k <span class=\"type\">int</span>)</span></span> <span class=\"type\">float64</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// Write your code here</span></span><br><span class=\"line\">\tmax := <span class=\"number\">-10001</span></span><br><span class=\"line\">\tsum := <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(nums); i++ &#123;</span><br><span class=\"line\">\t\tsum = sum + nums[i]</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> i &lt; k<span class=\"number\">-1</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> sum &gt; max &#123;</span><br><span class=\"line\">\t\t\tmax = sum</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> i &gt;= k<span class=\"number\">-1</span> &#123;</span><br><span class=\"line\">\t\t\tsum = sum - nums[i-(k<span class=\"number\">-1</span>)]</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"type\">float64</span>(max) / <span class=\"type\">float64</span>(k)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"连续子数组的最大和问题\"><a href=\"#连续子数组的最大和问题\" class=\"headerlink\" title=\"连续子数组的最大和问题\"></a>连续子数组的最大和问题</h3><p>在上述两个问题的基础之上，衍生出来同类型的问题：</p>\n<ol>\n<li>如果子数组的长度无限制： 采用落差发或者是双指针，DP来解决这个问题</li>\n<li>子数组长度等于K 时候采用滑动窗口</li>\n<li>长度&gt;=K,采用滑动窗口和落差法来解决</li>\n<li>如果限制长度必须要&lt;=k的连续子数组最大和，可以分别求1-k的最大值，然后再选一个最大值</li>\n</ol>\n<h2 id=\"3三步切分法\"><a href=\"#3三步切分法\" class=\"headerlink\" title=\"3三步切分法\"></a><strong>3</strong>三步切分法</h2><ol>\n<li>找出一个分界元素</li>\n<li>将有序的搜索空间分为两半（复杂度为O（1））<br>扔掉不需要的那一半</li>\n<li>在剩下的空间中递归使用切分法</li>\n</ol>\n<p>切分法不需要有序性，但是二分搜索必须要求有序性</p>\n<h3 id=\"求旋转数组当中的某个元素\"><a href=\"#求旋转数组当中的某个元素\" class=\"headerlink\" title=\"求旋转数组当中的某个元素\"></a>求旋转数组当中的某个元素</h3><p>以下是未重复的题目：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">33. 搜索旋转排序数组</span><br><span class=\"line\">整数数组 nums 按升序排列，数组中的值 互不相同 。</span><br><span class=\"line\"></span><br><span class=\"line\">在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。</span><br><span class=\"line\"></span><br><span class=\"line\">给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。</span><br><span class=\"line\"></span><br><span class=\"line\">你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。</span><br><span class=\"line\"></span><br><span class=\"line\">示例 1：</span><br><span class=\"line\"></span><br><span class=\"line\">输入：nums = [4,5,6,7,0,1,2], target = 0</span><br><span class=\"line\">输出：4</span><br><span class=\"line\">示例 2：</span><br><span class=\"line\"></span><br><span class=\"line\">输入：nums = [4,5,6,7,0,1,2], target = 3</span><br><span class=\"line\">输出：-1</span><br><span class=\"line\">示例 3：</span><br><span class=\"line\"></span><br><span class=\"line\">输入：nums = [1], target = 0</span><br><span class=\"line\">输出：-1</span><br><span class=\"line\"> </span><br><span class=\"line\"></span><br><span class=\"line\">提示：</span><br><span class=\"line\"></span><br><span class=\"line\">1 &lt;= nums.length &lt;= 5000</span><br><span class=\"line\">-104 &lt;= nums[i] &lt;= 104</span><br><span class=\"line\">nums 中的每个值都 独一无二</span><br><span class=\"line\">题目数据保证 nums 在预先未知的某个下标上进行了旋转</span><br><span class=\"line\">-104 &lt;= target &lt;= 104</span><br></pre></td></tr></table></figure>\n\n<p>如果增加一个重复的元素，题目变成：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">81. 搜索旋转排序数组 II</span><br><span class=\"line\">已知存在一个按非降序排列的整数数组 nums ，数组中的值不必互不相同。</span><br><span class=\"line\"></span><br><span class=\"line\">在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转 ，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,4,4,5,6,6,7] 在下标 5 处经旋转后可能变为 [4,5,6,6,7,0,1,2,4,4] 。</span><br><span class=\"line\"></span><br><span class=\"line\">给你 旋转后 的数组 nums 和一个整数 target ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 nums 中存在这个目标值 target ，则返回 true ，否则返回 false 。</span><br><span class=\"line\"></span><br><span class=\"line\">你必须尽可能减少整个操作步骤。</span><br></pre></td></tr></table></figure>\n<p>增加了重复的元素，那么只需要判断重复的元素是否是目标元素，如果不是那么就直接删除重复的元素，使得问题便会原本不重复元素的形式</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">search</span><span class=\"params\">(nums []<span class=\"type\">int</span>, target <span class=\"type\">int</span>)</span></span><span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    n := <span class=\"built_in\">len</span>(nums)</span><br><span class=\"line\">    left,right := <span class=\"number\">0</span> , n</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> left &lt; right &#123;</span><br><span class=\"line\">        m := left + (right-left)/<span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> nums[left] == target || nums[m] == target || nums[right<span class=\"number\">-1</span>] == target&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> nums[m] &gt; nums[left] &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> target &gt; nums[left] &amp;&amp; target &lt; nums[m]&#123;</span><br><span class=\"line\">                right = m</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                left = m + <span class=\"number\">1</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> nums[m] &lt; nums[left]&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> target &gt; nums[m] &amp;&amp; target &lt; nums[right<span class=\"number\">-1</span>]&#123;</span><br><span class=\"line\">                left = m + <span class=\"number\">1</span></span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                right = m</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> left &lt; right &amp;&amp; nums[m] == nums[left]&#123;</span><br><span class=\"line\">                left++</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"cover":"/img/cover/elderring.png","cover_type":"img","excerpt":"","more":"<h1 id=\"算法思想篇\"><a href=\"#算法思想篇\" class=\"headerlink\" title=\"算法思想篇\"></a>算法思想篇</h1><blockquote>\n<p>个人学习算法经验：</p>\n<ol>\n<li>深入了解和使用一门语言 —&gt; Golang</li>\n<li>深入理解基础的数据结构和算法基础 —&gt; 数学理论</li>\n<li>知识需要依据模块和分区来做体系的整理和学习 </li>\n</ol>\n</blockquote>\n<h1 id=\"1-ensp-二分搜索：-为什么说有序皆可用二分\"><a href=\"#1-ensp-二分搜索：-为什么说有序皆可用二分\" class=\"headerlink\" title=\"1 &ensp; 二分搜索： 为什么说有序皆可用二分\"></a><strong>1</strong> &ensp; 二分搜索： 为什么说有序皆可用二分</h1><blockquote>\n<p>本章节的学习目标：</p>\n<ul>\n<li>二分搜索的两个标准模板</li>\n<li>二分搜索的提问破解法</li>\n<li>二分搜索的切分法</li>\n</ul>\n</blockquote>\n<h2 id=\"1-1-ensp-二分搜索的关键考点\"><a href=\"#1-1-ensp-二分搜索的关键考点\" class=\"headerlink\" title=\"1.1 &ensp; 二分搜索的关键考点\"></a><strong>1.1</strong> &ensp; 二分搜索的关键考点</h2><ol>\n<li><p>开闭原则<br>一定要注意，在写二分搜索时候，每一个区间的表示都是严格按照开闭原则进行的<br>开闭原则 –&gt; 左闭右开 –&gt; 左边指针指向起点，右边指针指向尾部元素的后面一个空位 </p>\n</li>\n<li><p>区间的变化计算</p>\n</li>\n<li><p>代码的流畅度</p>\n<ul>\n<li>==是否深度理解了二分搜索的原则在该题目当中的体现== –&gt; <font color='red'> 所有算法题目的代码流畅度检验思考一</font></li>\n<li>==是否真的记住了代码的模板== –&gt; <font color='red'> 所有算法题目的代码流畅度检验思考二</font></li>\n<li>==所有代码编写流畅度问题的根源都是在于不熟练–&gt; 用的不多 –&gt; 不会转化为已知的问题 –&gt; 是否理解了运用的原理== –&gt; <font color='red'> 代码熟练度尤其关注 </font></li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph TD</span><br><span class=\"line\">A[联系] --&gt; B(开闭原则)</span><br><span class=\"line\">B --&gt; D[二分搜索]</span><br><span class=\"line\">B --&gt; E[快速排序-三路切分]</span><br><span class=\"line\">B --&gt; F[归并排序-切分为两个区间]</span><br><span class=\"line\">A --&gt; C(扔掉一半)</span><br><span class=\"line\">C --&gt; G[二叉搜索树]</span><br><span class=\"line\">G --&gt; H[查找]</span><br><span class=\"line\">G --&gt; I[删除]</span><br><span class=\"line\">G --&gt; N[插入]</span><br><span class=\"line\">C --&gt; J(三路切分)</span><br><span class=\"line\">J --&gt; K[第k小的数]</span><br><span class=\"line\">J --&gt; L[唯一出现的数]   </span><br></pre></td></tr></table></figure>\n<br />\n\n\n<h2 id=\"1-2-ensp-提问破解法解决二分问题\"><a href=\"#1-2-ensp-提问破解法解决二分问题\" class=\"headerlink\" title=\"1.2 &ensp; 提问破解法解决二分问题\"></a><strong>1.2</strong> &ensp; 提问破解法解决二分问题</h2><h3 id=\"要什么，什么就是x\"><a href=\"#要什么，什么就是x\" class=\"headerlink\" title=\"要什么，什么就是x\"></a>要什么，什么就是x</h3><ol>\n<li>将目标元素设置为 x –&gt; 去除掉题目当中所给的最小最长最大最短等限制条件，得到一个点描述</li>\n<li>得到目标 x 的区间范围: –&gt; 决定左开右闭的规则</li>\n</ol>\n<h3 id=\"满足约束条件的f-x-0\"><a href=\"#满足约束条件的f-x-0\" class=\"headerlink\" title=\"满足约束条件的f(x)=0\"></a>满足约束条件的f(x)=0</h3><h3 id=\"不满足约束条件的f-x-设置为-1或者是1\"><a href=\"#不满足约束条件的f-x-设置为-1或者是1\" class=\"headerlink\" title=\"不满足约束条件的f(x)设置为-1或者是1\"></a>不满足约束条件的f(x)设置为-1或者是1</h3><p>构造出一个单调变化的 f(x)，以上两步的关键在于确定（构造）f(x)是否有序，需要观察数组元素和题目要求的内容变化</p>\n<h3 id=\"使用lowbound-还是-upbound\"><a href=\"#使用lowbound-还是-upbound\" class=\"headerlink\" title=\"使用lowbound 还是 upbound\"></a>使用lowbound 还是 upbound</h3><p>最优解 0 在 f(x)=0 结果区间的最左边还是最右边，决定使用lowbound 还是 upbound </p>\n<h3 id=\"有序数组中最左边的元素\"><a href=\"#有序数组中最左边的元素\" class=\"headerlink\" title=\"有序数组中最左边的元素\"></a>有序数组中最左边的元素</h3><blockquote>\n<p>模板题目</p>\n</blockquote>\n<h3 id=\"给定有序数组和target-，返回起始和终止位置\"><a href=\"#给定有序数组和target-，返回起始和终止位置\" class=\"headerlink\" title=\"给定有序数组和target ，返回起始和终止位置\"></a>给定有序数组和target ，返回起始和终止位置</h3><blockquote>\n<p>模板题目</p>\n</blockquote>\n<h3 id=\"寻找山峰\"><a href=\"#寻找山峰\" class=\"headerlink\" title=\"寻找山峰\"></a>寻找山峰</h3><h3 id=\"最小长度的连续子数组\"><a href=\"#最小长度的连续子数组\" class=\"headerlink\" title=\"最小长度的连续子数组\"></a>最小长度的连续子数组</h3><p>求取的中间数组[-1,-1,0,0,1,1] 中元素代表的是子数组的长度，-1表示小于target,0 表示等于target</p>\n<!-- // 209. 长度最小的子数组\n\n// 给定一个含有 n 个正整数的数组和一个正整数 target 。\n\n// 找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。\n\n//  \n\n// 示例 1：\n\n// 输入：target = 7, nums = [2,3,1,2,4,3]\n// 输出：2\n// 解释：子数组 [4,3] 是该条件下的长度最小的子数组。\n// 示例 2：\n\n// 输入：target = 4, nums = [1,4,4]\n// 输出：1\n// 示例 3：\n\n// 输入：target = 11, nums = [1,1,1,1,1,1,1,1]\n// 输出：0\n//  \n\n// 提示：\n\n// 1 <= target <= 109\n// 1 <= nums.length <= 105\n// 1 <= nums[i] <= 105\n\n// 求和数组 -->\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">isTarget</span><span class=\"params\">(nums []<span class=\"type\">int</span>,l <span class=\"type\">int</span>,target <span class=\"type\">int</span>)</span></span><span class=\"type\">int</span>&#123;</span><br><span class=\"line\">    sum := <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span> ; i &lt; <span class=\"built_in\">len</span>(nums) ; i++ &#123;</span><br><span class=\"line\">        sum += nums[i]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i &lt; l<span class=\"number\">-1</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> sum &gt;= target&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        sum = sum - nums[i-(l<span class=\"number\">-1</span>)]</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">minSubArrayLen</span><span class=\"params\">(target <span class=\"type\">int</span>, nums []<span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    left, right := <span class=\"number\">1</span>,<span class=\"built_in\">len</span>(nums)+<span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> left &lt; right&#123;</span><br><span class=\"line\">        m := left + (right-left)/<span class=\"number\">2</span></span><br><span class=\"line\">        now := isTarget(nums,m,target)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> now &lt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">            left = m + <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            right = m</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> left &gt; <span class=\"built_in\">len</span>(nums)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> left</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"最大平均值\"><a href=\"#最大平均值\" class=\"headerlink\" title=\"最大平均值\"></a>最大平均值</h3><p>但限制了数组长度为k的时候，可以直接使用滑动窗口来解决这个问题</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @param nums: an array</span></span><br><span class=\"line\"><span class=\"comment\"> * @param k: an integer</span></span><br><span class=\"line\"><span class=\"comment\"> * @return: the maximum average value</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">FindMaxAverage</span><span class=\"params\">(nums []<span class=\"type\">int</span>, k <span class=\"type\">int</span>)</span></span> <span class=\"type\">float64</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// Write your code here</span></span><br><span class=\"line\">\tmax := <span class=\"number\">-10001</span></span><br><span class=\"line\">\tsum := <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(nums); i++ &#123;</span><br><span class=\"line\">\t\tsum = sum + nums[i]</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> i &lt; k<span class=\"number\">-1</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> sum &gt; max &#123;</span><br><span class=\"line\">\t\t\tmax = sum</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> i &gt;= k<span class=\"number\">-1</span> &#123;</span><br><span class=\"line\">\t\t\tsum = sum - nums[i-(k<span class=\"number\">-1</span>)]</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"type\">float64</span>(max) / <span class=\"type\">float64</span>(k)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"连续子数组的最大和问题\"><a href=\"#连续子数组的最大和问题\" class=\"headerlink\" title=\"连续子数组的最大和问题\"></a>连续子数组的最大和问题</h3><p>在上述两个问题的基础之上，衍生出来同类型的问题：</p>\n<ol>\n<li>如果子数组的长度无限制： 采用落差发或者是双指针，DP来解决这个问题</li>\n<li>子数组长度等于K 时候采用滑动窗口</li>\n<li>长度&gt;=K,采用滑动窗口和落差法来解决</li>\n<li>如果限制长度必须要&lt;=k的连续子数组最大和，可以分别求1-k的最大值，然后再选一个最大值</li>\n</ol>\n<h2 id=\"3三步切分法\"><a href=\"#3三步切分法\" class=\"headerlink\" title=\"3三步切分法\"></a><strong>3</strong>三步切分法</h2><ol>\n<li>找出一个分界元素</li>\n<li>将有序的搜索空间分为两半（复杂度为O（1））<br>扔掉不需要的那一半</li>\n<li>在剩下的空间中递归使用切分法</li>\n</ol>\n<p>切分法不需要有序性，但是二分搜索必须要求有序性</p>\n<h3 id=\"求旋转数组当中的某个元素\"><a href=\"#求旋转数组当中的某个元素\" class=\"headerlink\" title=\"求旋转数组当中的某个元素\"></a>求旋转数组当中的某个元素</h3><p>以下是未重复的题目：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">33. 搜索旋转排序数组</span><br><span class=\"line\">整数数组 nums 按升序排列，数组中的值 互不相同 。</span><br><span class=\"line\"></span><br><span class=\"line\">在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。</span><br><span class=\"line\"></span><br><span class=\"line\">给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。</span><br><span class=\"line\"></span><br><span class=\"line\">你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。</span><br><span class=\"line\"></span><br><span class=\"line\">示例 1：</span><br><span class=\"line\"></span><br><span class=\"line\">输入：nums = [4,5,6,7,0,1,2], target = 0</span><br><span class=\"line\">输出：4</span><br><span class=\"line\">示例 2：</span><br><span class=\"line\"></span><br><span class=\"line\">输入：nums = [4,5,6,7,0,1,2], target = 3</span><br><span class=\"line\">输出：-1</span><br><span class=\"line\">示例 3：</span><br><span class=\"line\"></span><br><span class=\"line\">输入：nums = [1], target = 0</span><br><span class=\"line\">输出：-1</span><br><span class=\"line\"> </span><br><span class=\"line\"></span><br><span class=\"line\">提示：</span><br><span class=\"line\"></span><br><span class=\"line\">1 &lt;= nums.length &lt;= 5000</span><br><span class=\"line\">-104 &lt;= nums[i] &lt;= 104</span><br><span class=\"line\">nums 中的每个值都 独一无二</span><br><span class=\"line\">题目数据保证 nums 在预先未知的某个下标上进行了旋转</span><br><span class=\"line\">-104 &lt;= target &lt;= 104</span><br></pre></td></tr></table></figure>\n\n<p>如果增加一个重复的元素，题目变成：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">81. 搜索旋转排序数组 II</span><br><span class=\"line\">已知存在一个按非降序排列的整数数组 nums ，数组中的值不必互不相同。</span><br><span class=\"line\"></span><br><span class=\"line\">在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转 ，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,4,4,5,6,6,7] 在下标 5 处经旋转后可能变为 [4,5,6,6,7,0,1,2,4,4] 。</span><br><span class=\"line\"></span><br><span class=\"line\">给你 旋转后 的数组 nums 和一个整数 target ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 nums 中存在这个目标值 target ，则返回 true ，否则返回 false 。</span><br><span class=\"line\"></span><br><span class=\"line\">你必须尽可能减少整个操作步骤。</span><br></pre></td></tr></table></figure>\n<p>增加了重复的元素，那么只需要判断重复的元素是否是目标元素，如果不是那么就直接删除重复的元素，使得问题便会原本不重复元素的形式</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">search</span><span class=\"params\">(nums []<span class=\"type\">int</span>, target <span class=\"type\">int</span>)</span></span><span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    n := <span class=\"built_in\">len</span>(nums)</span><br><span class=\"line\">    left,right := <span class=\"number\">0</span> , n</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> left &lt; right &#123;</span><br><span class=\"line\">        m := left + (right-left)/<span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> nums[left] == target || nums[m] == target || nums[right<span class=\"number\">-1</span>] == target&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> nums[m] &gt; nums[left] &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> target &gt; nums[left] &amp;&amp; target &lt; nums[m]&#123;</span><br><span class=\"line\">                right = m</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                left = m + <span class=\"number\">1</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> nums[m] &lt; nums[left]&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> target &gt; nums[m] &amp;&amp; target &lt; nums[right<span class=\"number\">-1</span>]&#123;</span><br><span class=\"line\">                left = m + <span class=\"number\">1</span></span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                right = m</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> left &lt; right &amp;&amp; nums[m] == nums[left]&#123;</span><br><span class=\"line\">                left++</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"Golang 算法课程--数据结构","catalog":true,"date":"2023-04-01T16:46:21.000Z","subtitle":null,"header-img":null,"_content":"\n# 告别盲目刷题，击破算法面试\n> 学习拉钩教育算法课程记录加个人感悟记录\n> 如果有版权问题，请联系 2374087322@qq.com 删除课程部分的内容\n> \n> 算法能力的高度，决定了个人能够解决的实战问题复杂度的上限\n>\n> 数学基础决定了算法能力的高低\n\n## ==解题流程==：\n\n### ==四部分析法==\n\n* **==模拟==** ： 模拟题目的运行\n  使用简单且有一定量的小例子，将自己当作计算机来执行这个流程\n  *一般使用题目给的较长的那个例子就可以*\n\\\n  这部分也是读题和理解输入输出内容的部分，理解题意的部分\n\\\n  这个时候一定不能够着急，不要害怕或者是觉得麻烦，一定要耐下性子，把简单的一个逻辑过程给跑清楚，理解这段程序或者是业务需要咱们处理什么样的问题。\n\\\n  跑的过程，不要完全先入为主，应当以题目的要求来推进演示。\n\\\n  不要想着在这一步就把所有的问题都给解决，一步步推进就可以. \n<br />\n\n* **==规律==** ： 尝试总结出题目的一般规律和特点\n  \n  数学规律和特性一般来说很难直接从零归纳出来，但我们可以依赖所学习的高数、线性代数、离散数学、测度论等高等数学理论当中所见到的数学计算模型来匹配，这也是这部分最重要的基础\n\n  先总结一些考题可能会用到的观察特点：\n  * 形式相关：比如 括号匹配、从1加到100，\n  * 数量变化：数量变化与取模相关，数量变化呈现递推公式\n  * \n\n\n* **==匹配==** ： 找到符合这些特点的数据结构和算法\n  * 关注数据的输入类型：对输入数据进行分类，哪一些数据进行怎样的操作\n\n  * **==怎样匹配呢？==**：\n    * 题目模拟的时候（这部分一般使用栈、队列、二叉树）来理解题目要求的数字变化\n    * 观察结果集合，或者是原本中间的变化集合，当期符合某种数据结构的变化特征的时候，就可以选用这个数据结构\n\n\n* **==考虑边界条件==**： 考虑特殊情况\n  特殊情况：\n  * 字符串为空，字符串只有一个，两个、\n  * 数组为空，数字为0或者是其他不符合规律的特殊情况\n\n\n* **==深度思考==** ： 平时练习当中的流程，用于提高算法模型的积累\n  * 深度： 这种解法还可以怎么优化\n  * 广度： 这种解法的具有普适性吗？可以推广吗？问题的限定条件变多的话，这个模型是否还可以适合。\n  * 数学模式扩散： 这样特点的问题是否有对应的数学模型或者是理论描述过\n\n\n\n# 栈： 从简单栈到单调栈，让栈问题不再困难\n\n## 结构特征\n\n先进后出\n\n对栈的操作：\n* **==pop==** 弹出栈顶元素，一般来说栈中可操作的元素就是栈顶元素，其他元素也都是先pop出其上面的元素，变成栈顶元素之后再进行操作。\n*  **==peek==** 获取栈顶元素，只是读取操作，但并没有弹出栈顶元素\n*  **==push==** 将元素压入栈中\n  \n### Golang 栈的使用\n\n在 Go 中并没有直接提供Stack的方法结构，但可以使用切片非常简单地表示和使用栈、队列结构。\n \n 先进后出的数据结构，使用**==切片==**表示，压入栈的操作就是往切片中添加元素，弹出栈的操作就是输出末尾元素，并将切片缩小为：`[:len(stack)-1]`\n\n以下为栈的代码模板实现：\n```golang\ntype Stack struct{\n    Stack []interface{}\n}\n\nfunc (s *Stack)push(x interface{}){\n    s = append(s,x)\n}\n\nfunc (s *Stack)pop(){\n    s = s[:len(s)-1]\n}\n\nfunc (s *Stack)peek()(x interface{}){\n    return s[len(s)-1]\n}\n```\n\n关键在于记住：\n* 栈顶元素 ---> 切片末尾元素\n* 切片是左闭右开，所以pop操作是 s = s[:len(s)-1], 但如果是队列pop出第一个元素就需要往后再移动一位 s = s[1:] 而不是 s = s[0:]\n\n## 典型题目\n\n### 判断字符串是否合法\n题目：https://leetcode.cn/problems/valid-parentheses/\n\n#### 正确解法和流程\nhttps://leetcode.cn/link/?target=https://www.bilibili.com/video/BV1AF411w78g\n```golang\nfunc isValid(s string) bool {\n    n := len(s)\n    if n % 2 == 1 {\n        return false\n    }\n    pairs := map[byte]byte{\n        ')': '(',\n        ']': '[',\n        '}': '{',\n    }\n    stack := []byte{}\n    for i := 0; i < n; i++ {\n        if pairs[s[i]] > 0 {\n            if len(stack) == 0 || stack[len(stack)-1] != pairs[s[i]] {\n                return false\n            }\n            stack = stack[:len(stack)-1]\n        } else {\n            stack = append(stack, s[i])\n        }\n    }\n    return len(stack) == 0\n}\n```\n\n#### 个人解法和流程\n\n> 问题集中体现在数据特性处理判断太过分散，属实是缝缝补补有一年\n> 对输入数据进行分类，哪一些数据进行怎样的操作\n> * 输入的是左括号应该入栈\n> * 输入的是右括号应该做判断\n<br />\n\n我的代码是：\n```golang\n    func isValid(s string) bool {\n    \n    l := len(s)\n    if l%2 != 0{\n        return false\n    }\n    stack := make([]rune, 0)\n\n    m := map[rune]rune{\n        ']':'[',\n        ')':'(',\n        '}':'{',\n    }\n    for _,v := range s{\n        if v == '[' ||v == '{' ||v == '('{\n            stack = append(stack,v)\n            continue\n        }\n        if len(stack) == 0{\n            return false\n        }\n        if stack[len(stack)-1] == m[v]{\n            stack = stack[:len(stack)-1]\n            continue\n        }\n\n        if m[v] != 0 {return false}\n    }\n\n    if len(stack) == 0{return true}\n\n    return false\n}\n```\n上述在判断栈顶元素的时候逻辑不够清晰，所以加了很多的if来补足条件，我们看例子当中所给的逻辑顺序：\n```golang\n        pairs := map[byte]byte{\n        ')': '(',\n        ']': '[',\n        '}': '{',\n    }\n    stack := []byte{}\n    for i := 0; i < n; i++ {\n        if pairs[s[i]] > 0 {\n            if len(stack) == 0 || stack[len(stack)-1] != pairs[s[i]] {\n                return false\n            }\n            stack = stack[:len(stack)-1]\n        } else {\n            stack = append(stack, s[i])\n        }\n    }\n    return len(stack) == 0\n```\n\n关键差距就在于这一句话：`pairs[s[i]] > 0 `, 这个判断对输入的数据做了一次分类，依据上面的map结构可知，这句话 < 0 时候标识map当中没有存储对应的对象，而map中存储的是所有的左括号，所以这个判断的作用是**当输入是右括号的时候进入函数**，然后逻辑体依据输入是右括号判断，如果当前栈里面没有元素或者是栈顶元素与右括号不匹配那么就返回false\n\\\n实际上我写的函数最后夜市做了类似的判断，但显然没有考虑数据分类的情况。\n\n\n### 判断大鱼吃小鱼最后留下的鱼\n题目：\n\n近似题目：https://www.nowcoder.com/questionTerminal/3fdfc63015df42c6a78fdae46709fa69?f=discussion\n\n<br />\n\n#### 正确解法和流程\n``` c++\nclass Solution {\npublic:\n    /**\n     * \n     * @param N int整型 N条鱼\n     * @param A int整型vector 每条鱼的体积为Ai\n     * @return int整型\n     */\n    struct P{\n        int x, t;\n    };\n    int solve(int N, vector<int>& A) {\n        stack<P> S;\n        int cnt = 0;\n        for(int i=N-1;i>=0;i--){\n            int t = 0;\n            while(!S.empty() && A[i]>S.top().x){\n                t = max(S.top().t, t+1);\n                S.pop();\n            }\n            S.push({A[i], t});\n            cnt = max(cnt, t);\n        }\n        return cnt;\n    }\n};\n```\n\n\n#### 个人解法和流程\n由于找不到相同的题目，就找了类似的题目，但是解题的思路不太一样\n图片上的大鱼吃小鱼，只需要每次比较栈顶元素和新进来的元素大小即可，当大于的时候，就不做操作，当栈顶元素小于输入元素的时候，pop出栈顶元素并push进入这个最大值，最后栈中元素就是结果。这个过程当中几处需要重视的地方是：\n* 当鱼的方向一致时候，大鱼并不会把同方向的小鱼给吃了【可能不论大小鱼的速度相同（bushi）】，而如果小鱼在左，大鱼在右，方向不同，则也不会吃\n\n\n牛客网的题目则加了非常多的条件和限制，是对栈问题的一个较大的变化\n\n> 对比上述两个题目可以观察到：\n> <font color ='blue'> 1. 消除的行为不同</font>\n>   括号匹配中，消除行为是配对的两者都会消除，也就是栈顶元素和输入元素一起被消除\n>   大鱼吃小鱼中，消除行为是配对的两者中会有一个被消除\n> --> 是否入栈和出栈的判断\n> <font color ='blue'> 2. 栈中的内容不同</font>\n>   括号匹配当中，栈中存放的就是内容本身\n>   大鱼吃小鱼当中，栈里存放的是内容的索引，可以通过索引找到内容\n> <font color ='blue'> 3. 弹栈的方式也不相同</font>\n>   括号匹配只需要每次弹出一个元素就可以\n>   大鱼则需要用while语句一直弹出到满足某个条件才停止\n\n\n## 栈问题的特征和解决流程\n\n### pop 行为不同\npop【弹栈的操作不一样】\n常见的就是每次循环都判断栈顶元素的特点而pop或者push或者不操作，但这样必须得是连续性的元素才有这样的特征\n\n**==在弹栈的时候，是否一定要满足某个条件才停止弹栈==**\n也就是说当输入元素之后需要将其和站内其他的元素进行比较，在使用的时候尤其要注意迭代过程\n\n### 栈中存储内容不相同\n是否栈中存储数据、还是存储索引、还是存储一个自建的新的结构\n\n### 栈顶元素的含义不相同\n\n\n## 单调栈\n\n单调栈是指栈中元素必须按照升序排列的栈或者是降序排列的栈\n\n单调栈分为：\n* 递增栈：\n    栈中元素从左到右遵守从小到大的顺序\n    入栈时候，当**入栈元素小于栈顶元素**就会pop出栈顶元素，直到入栈元素大于栈顶元素\n    特点是：\n    入栈小数会消除栈内大数\n\n* 递减栈\n    栈中元素从左到右遵守从大到小的顺序\n    入栈时候，当**入栈元素大于栈顶元素**就会pop出栈顶元素，直到入栈元素小于栈顶元素\n    特点是：\n    入栈大数会消除栈内小数\n\n\n### 典型代码：\n```golang\nstack := make([]int,0)\n/**递增栈的入栈\n* 用for 循环出栈，直到栈顶元素满足递增栈的要求\n*/\nfor len(stack)> 0 && A[i] > stack[len(stack)-1]{\n    // pop出栈内比 A[i]小但却在前面的元素\n    stack = stack[:len(stack)-1]\n}\nstack = append(stack,A[i])\n\n```\n### 找到当前数字右边最小的对应数字\n### 取k个字符，求字典序最小的组合\n> 字典序：\n> * 对单个元素按照ascii 表中大小顺序排列\n> * 多个元素时，按照从左到右顺序，先从高位字典排序，然后在相同高位中按照地位再字典排序\n### 给定一个数组，数组中元素代表模板的高度，请你求出相邻木板能剪出的最大矩形面积\n> 和求最大容积是一个题目\n\n<br />\n\n## leetcode 题目汇总\n\n> 以leetcode 题目为例子\n\n相关栈的题目汇总：\n[1][https://leetcode.cn/problem-list/xb9nqhhg/?topicSlugs=stack&page=1]\n[2][https://leetcode.cn/problem-list/e8X3pBZi/?page=1&topicSlugs=heap-priority-queue]\n[3][https://leetcode.cn/problem-list/2cktkvj/?page=1&topicSlugs=stack]\n\n\n# 队列：FIFO 队列与单调队列的深挖与扩展\n\n先进先出，是共同特征\n\n类别上可以分出：\n* FIFO队列\n* 单调队列\n\n## FIFO队列\n\n**==Push 元素时候， 总是将放在元素放在队列尾部，也就是操作 fifo[len(fifo)-1]==**\n**==Pop 元素时候，总是将队列首部的元素扔掉 ，也就是操作 fifo = fifo[1:]==**\n\n###  二叉树的层次遍历（两种方法）\n\n* 规律： \n广度遍历（层次遍历）：由于二叉树的特点，当拿到第N层的结点A之后，可以通过 A 的left，right指针拿到下一层的节点\n**但是与A在同一层的节点还有其他吗，这个时候就需要按层来存储节点，不能直接使用递归**\n\n    <br />\n    顺序输出：每层输出时，排在左边的节点，它的子节点同样排在下一层的最左边\n\n--> **==题目具备广度遍历（分层遍历）的特点 和 顺序输出的特点 ，应该想到应用FIFO队列==**\n\n* 边界\n  特殊判断： 如果发现是一棵空二叉树，就直接返回空结果\n  ==制定一个规则==： 不要让空指针进入到FIFO队列（一些编程的亮点）\n\n<font color = 'red'> 非常重要的概念： QSize 表示当前层数 </font>\n\n#### 层次遍历二叉树\n题目链接：https://leetcode.cn/problems/binary-tree-level-order-traversal/submissions/\n\n##### 解题思路1\n关键思路在于将每一层的节点都存在FIFO队列里面，在每次遍历的时候从左到右pop出该层的节点，同时在队尾加入他的左右孩子\n\n队首pop出当层节点，队尾append下一层的孩子节点\nQSize 记录当层的节点数量\n\n时间复杂度是O(n), 空间复杂度由QSize决定O(K),K表示QSize最大，也就是存储的一层节点数量最多的时候\n\n##### 代码\n```golang\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc levelOrder(root *TreeNode) [][]int {\n    // 创建FIFO 队列来存储遍历的过程\n    fifo := make([]*TreeNode,0)\n    // QSize 表示当前遍历的层\n    QSize := 1\n    // 初始化最终结果\n    result := make([][]int,0)\n    if root == nil{\n        return result\n    }\n    //将根节点入栈\n    fifo = append(fifo,root)\n    // 开始层序遍历，只要当前队列不为空\n    for len(fifo) > 0 {\n        // 创建结果数组用于存储当层pop出的元素值\n        tmp := make([]int, 0)\n        // 当层元素QSize全部遍历以此，这里不能用len(fifo)，因为fifo的长度是在变化的\n        for i := QSize;i > 0;i--{\n            // 拿出队列头元素\n            node := fifo[0]\n            // 判断他的左孩子是否为空\n            if node.Left!= nil{\n                fifo = append(fifo,node.Left)\n            }\n            // 判断他的右孩子是否为空\n            if node.Right != nil{\n                fifo = append(fifo,node.Right)\n            }\n            // 将该节点的值存入结果\n            tmp = append(tmp,node.Val)\n            // 推出队首元素\n            fifo = fifo[1:]\n        }\n        // 将结果 tmp 存入到结果数组当中\n        result = append(result,tmp)\n        // 重新计算当前层的节点数量\n        QSize = len(fifo)\n    }\n    return result\n}\n```\n##### 官方题解\n```golang\nfunc levelOrder(root *TreeNode) [][]int {\n    ret := [][]int{}\n    if root == nil {\n        return ret\n    }\n    q := []*TreeNode{root}\n    for i := 0; len(q) > 0; i++ {\n        ret = append(ret, []int{})\n        p := []*TreeNode{}\n        for j := 0; j < len(q); j++ {\n            node := q[j]\n            ret[i] = append(ret[i], node.Val)\n            if node.Left != nil {\n                p = append(p, node.Left)\n            }\n            if node.Right != nil {\n                p = append(p, node.Right)\n            }\n        }\n        q = p\n    }\n    return ret\n}\n\n```\n\n##### 解题思路2\n\n使用链表来解决问题\n\n#### 锯齿状层次遍历\n题目链接：https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/\n\n##### 解题思路\n层次遍历的基础上加一个qs，表示当前层是从左到右还是从右到左\n\n**==本题当中所犯的错误：==**：\n* 每一轮都需要重新计算qsize,一定不要忘了这一点\n* tmp 接收的时候还是按照栈的pop逻辑，所以顺序上还需要再反一次\n* 题目样例当中root是按照从左到右遍历过一次来计算的\n\n##### 代码\n\n```golang\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc zigzagLevelOrder(root *TreeNode) [][]int {\n    //结果数组\n    result := make([][]int,0)\n    //全局的fifo队列\n    fifo := make([]*TreeNode,0)\n    // Qsize 表示当前层的节点数，qs 表示该层的遍历顺序，0表示从左到右，1表示从右到左\n    Qsize ,qs := 1 , 1\n    // 如果树中没有节点则直接返回\n    if root == nil{\n        return result\n    }\n    // 将 root 放入队列\n    fifo = append(fifo,root)\n    //遍历整棵树\n    for len(fifo) > 0 {\n        tmp := make([]int,0)\n        for i:= 1; Qsize >= i && qs == 0 ;i++{\n            node := fifo[Qsize-i]\n            if node.Right != nil {\n                fifo = append(fifo,node.Right)\n            }\n            if node.Left != nil{\n                fifo = append(fifo,node.Left)\n            }\n            tmp = append(tmp,node.Val)                \n        }\n        for i:= 1; Qsize >= i && qs == 1 ;i++{\n            node := fifo[Qsize-i]\n            if node.Left != nil{\n                fifo = append(fifo,node.Left)\n            }\n            if node.Right != nil{\n                fifo = append(fifo,node.Right)\n            }\n            tmp = append(tmp,node.Val)                \n        }\n        fifo = fifo[Qsize:]\n        Qsize = len(fifo)\n        result = append(result,tmp)\n        if qs == 1{\n            qs = 0\n        }else{\n            qs = 1\n        }\n    }\n    return result\n}\n```\n\n\n\n#### 倒序层次遍历\n题目链接：https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/\n\n##### 解题思路\n从题目要求当中可以读出，是在之前的层序遍历基础上把结果倒过来输出，那么会比较自然想到可以在使用一个栈用来存储中间结果\n\n##### 代码\n\n```golang\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc levelOrderBottom(root *TreeNode) [][]int {\n    // 构造全局fifo队列\n    fifo := make([]*TreeNode,0)\n    // 构造结果栈\n    stack := make([][]int,0)\n    result := make([][]int,0)\n    //表示当前层的节点数量\n    Qsize := 1\n    fifo = append(fifo,root)\n    if root == nil{\n        return result\n    }\n    for len(fifo) > 0{\n        tmp := make([]int,0)\n        for Qsize > 0{\n            node:= fifo[0]\n            if node.Left != nil{\n                fifo =append(fifo,node.Left)\n            }\n            if node.Right != nil{\n                fifo = append(fifo,node.Right)\n            }\n            Qsize--\n            fifo = fifo[1:]\n            tmp = append(tmp,node.Val)\n        }\n        stack = append(stack,tmp)\n        Qsize = len(fifo)\n    }\n\n    // 将栈中元素pop 到结果当中\n    for len(stack) > 0{\n        result = append(result,stack[len(stack)-1])\n        stack = stack[:len(stack)-1]\n    }\n    return result\n}\n```\n\n## 循环队列\n\n设计一个可以容纳 k 个元素的循环队列，需要实现以下接口：\n\n```golang\ntype ringQueue interface{\n    //构造函数，参数k表示这个循环队列最多容纳k个元素\n    CircularQueue(int)\n    //将value放到队列中，成功返回true\n    EnQueue(int) bool\n    // 删除队首元素，成功返回true\n    DeQueue() bool\n    // 得到队首元素，如果队列为空，返回-1\n    Front() int\n    // 得到队尾元素，如果队列为空，返回-1\n    Rear() int\n    // 查看循环队列是否为空\n    isEmpty() bool\n    // 查看队列是否已经放满k个元素\n    isFull() bool\n}\n```\n\n* **==循环队列的重点在于==: <font color = 'red'>循环使用固定空间</font>**\n* **==难点在于==： <font color='red'>控制好 Front/Rear两个首位指示器</font>**\n\n### 表示方法1\n使用 `used`、`front`、`rear` 三个变量来控制，其中`used, front`都代表的是数组的下标\n\n注意以下几点：\n* index = i 的后一个是i+1，前一个是i+1\n* index = k-1 的后一个就是index=0\n* index = 0 的前一个是 index = k-1\n**==可以使用取模的方式统一处理==:**\n<font color='red'> index = i 的后一个元素下标是（i+1）% k</font>\n<font color='red'> index = i 的前一个元素下标是（i-1+k）% k</font>\n<font color='blue'>所有的循环数组下标的处理都需要按照这个取模的方式</font>\n\n参考的实例代码如下：\n```golang\ntype MyCircularQueue struct {\n    queue  []int\n    rear   int\n    front  int\n    used   int\n    length int\n}\n\nfunc CircularQueue(k int) ringQueue {\n    return &MyCircularQueue{\n        queue:  make([]int, k),\n        rear:   0,\n        front:  0,\n        used:   0,\n        length: k,\n    }\n}\n\nfunc (q *MyCircularQueue) EnQueue(value int) bool {\n    if q.isFull() {\n        return false \n    }\n    q.queue[q.rear] = value\n    q.rear = (q.rear + 1) % q.length\n    q.used++\n    return true\n}\n\nfunc (q *MyCircularQueue) DeQueue() bool {\n    if q.isEmpty() {\n        return false\n    }\n    q.front = (q.front + 1) % q.length\n    q.used--\n    return true\n}\n\nfunc (q *MyCircularQueue) Front() int {\n    if q.used == 0 {\n        return -1\n    }\n    return q.queue[q.front]\n}\n\nfunc (q *MyCircularQueue) Rear() int {\n    if q.used == 0 {\n        return -1\n    }\n    return q.queue[(q.rear-1+q.length)%q.length]\n}\n\nfunc (q *MyCircularQueue) isEmpty() bool {\n    return q.used == 0\n}\n\nfunc (q *MyCircularQueue) isFull() bool {\n    return q.used == q.length\n}\n```\n备注：\n在 `DeQueue()` 方法中，删除队首元素时并不会真的删除该元素，而是通过移动 `front` 指针来达到删除的效果。\n\n循环队列是一个环状的数据结构，可以想象成沿着环形路径移动指针。在实现循环队列时，每当删除队首元素时，我们需要将 `front` 指针向前移一位，指向队列中的下一个元素，这样队列中原来的第二个元素就成为了新的头部元素。这里使用 \"指向队列中的下一个元素\" 实际上是模运算的作用，如 `(i+1) % n` 将会得到指向 `i` 在循环数组中下一个元素的索引值。\n\n而在这个移动指针的过程中，由于队列的前面已经没有元素，所以我们不需要将队首元素真正地删除。相反，仅需要更新 `front` 指针，让它指向目前第一个元素，后面再添加新的元素，也会覆盖掉先前的元素，实现对队列的循环利用。\n\n### 表示方法2\n```golang\ntype MyCircularQueue struct {\n    // 使用 k + 1 ，也就是多余一个空格的循环队列来设计\n    queue []int\n    front int\n    rear int\n    capacity int\n}\n\n\nfunc Constructor(k int) MyCircularQueue {\n    return MyCircularQueue{\n        queue: make([]int,k+1),\n        front: 0,\n        rear: 0,\n        capacity: k+1,\n    }\n}\n\n\nfunc (this *MyCircularQueue) EnQueue(value int) bool {\n    if this.IsFull(){\n        return false\n    }\n    this.queue[this.rear] = value\n    this.rear = (this.rear + 1)%this.capacity\n    return true\n}\n\n\nfunc (this *MyCircularQueue) DeQueue() bool {\n    if this.IsEmpty(){\n        return false\n    }\n    this.front = (this.front+1)%this.capacity\n    return true\n}\n\n\nfunc (this *MyCircularQueue) Front() int {\n    if this.IsEmpty() {\n        return -1\n    }\n    return this.queue[this.front]\n}\n\n\nfunc (this *MyCircularQueue) Rear() int {\n    if this.IsEmpty(){\n        return -1\n    }\n    rearPosition := (this.rear-1+this.capacity)%this.capacity\n    return this.queue[rearPosition]\n}\n\n\nfunc (this *MyCircularQueue) IsEmpty() bool {\n    return this.rear ==this.front\n}\n\n\nfunc (this *MyCircularQueue) IsFull() bool {\n    return (this.rear+1)%this.capacity == this.front\n}\n\n/**\n * Your MyCircularQueue object will be instantiated and called as such:\n * obj := Constructor(k);\n * param_1 := obj.EnQueue(value);\n * param_2 := obj.DeQueue();\n * param_3 := obj.Front();\n * param_4 := obj.Rear();\n * param_5 := obj.IsEmpty();\n * param_6 := obj.IsFull();\n */\n```\n\n### 循环双向队列\n\n#### 解题思路\n\n\n**==犯错的地方：==**\n<font color='red'> InsertFront的时候，需要先移动front向前一位，然后再把值插进去</font>\n最开始想的，直接让front和rear都指向一个空白的空间，那么就需要在插入的时候先将front向前移动两位，但这样的话就会浪费一个数值的空间，因为多余一个位就完全可以满足要求\n\n使用k+1的情况，如果是在LRU缓存或者是Ringbuffer当中还需要考虑，将队尾[或者是队中]的元素插入到队首，也就是将最近使用的元素放到前面\n\n#### 代码\n\n```golang\ntype MyCircularDeque struct {\n    queue []int\n    front int\n    rear int \n    capacity int\n}\n\n\nfunc Constructor(k int) MyCircularDeque {\n    return MyCircularDeque{\n        queue: make([]int,k+1),\n        front: 0,\n        rear: 0,\n        capacity: k+1,\n    }\n}\n\n\nfunc (this *MyCircularDeque) InsertFront(value int) bool {\n    if this.IsFull(){\n        return false\n    }\n    this.front = (this.front-1 + this.capacity)%this.capacity\n    this.queue[this.front] = value\n    return true\n}\n\n\nfunc (this *MyCircularDeque) InsertLast(value int) bool {\n    if this.IsFull(){\n        return false\n    }\n    this.queue[this.rear] = value\n    this.rear = (this.rear+1)%this.capacity\n    return true\n}\n\n\nfunc (this *MyCircularDeque) DeleteFront() bool {\n    if this.IsEmpty(){\n        return false\n    }\n    this.front = (this.front+1)%this.capacity\n    return true\n}\n\n\nfunc (this *MyCircularDeque) DeleteLast() bool {\n    if this.IsEmpty(){\n        return false\n    }\n    this.rear = (this.rear-1+this.capacity)%this.capacity\n    return true\n}\n\n\nfunc (this *MyCircularDeque) GetFront() int {\n    if this.IsEmpty(){\n        return -1\n    }\n    return this.queue[this.front]\n}\n\n\nfunc (this *MyCircularDeque) GetRear() int {\n    if this.IsEmpty(){\n        return -1\n    }\n    return this.queue[(this.rear-1+this.capacity)%this.capacity]\n}\n\n\nfunc (this *MyCircularDeque) IsEmpty() bool {\n    return this.front == this.rear\n}\n\n\nfunc (this *MyCircularDeque) IsFull() bool {\n    return this.front == (this.rear+1)%this.capacity\n}\n\n\n/**\n * Your MyCircularDeque object will be instantiated and called as such:\n * obj := Constructor(k);\n * param_1 := obj.InsertFront(value);\n * param_2 := obj.InsertLast(value);\n * param_3 := obj.DeleteFront();\n * param_4 := obj.DeleteLast();\n * param_5 := obj.GetFront();\n * param_6 := obj.GetRear();\n * param_7 := obj.IsEmpty();\n * param_8 := obj.IsFull();\n */\n```\n\n相似点：\n* 都使用了取模的方式\n\n## 单调队列\n单调队列属于双端队列的一种\n\n要求队列中的元素必须满足单调性\n\n单调队列如对时候的要求：入队前后，单调性完整\n\n**==单调递减队列最重要的特性==:<font color='red'>入队和出队的组合，可以在O(1)时间得到某个区间上的最大值</font>**\n\n### 情况讨论\n> 需要回答的问题：\n> * 这个区间是什么\n> * 怎样定量地描述这个区间\n> * 与队列中的元素个数有什么关系\n可以分以下两种情况来讨论：\n1. 只有入队的情况\n   在没有出队的情况下，对原数组的比较范围就会逐步增加\n   队首元素表示是已比较范围内的最大值\n2. 出队和入队混合的情况\n   控制覆盖范围为 k --> 滑动窗口\n    * 入队： 扩展单调队列的覆盖范围\n    * 出队： 控制单调队列的覆盖范围\n    * 队首元素是覆盖范围的最大值\n    * 队列中的元素个数小于覆盖范围的元素个数\n\n### 核心代码\n```golang\n//入队的代码\nfunc (q *queue)push(val int){\n    // 入队时候，要剔除掉尾部的元素，知道尾部元素大于或者是等于入队元素\n    while(!q.isEmpty() && q.getLast()<val){\n        q.removeLast()\n    }\n    // 将元素入队\n    q.addLast(val)\n}\n\n// 出队的时候，需要给出一个value\nfunc(q *queue) pop(val int){\n    if(!q.isEmpty() && q.getFirst()==val){\n        q.removeFirst()\n    }\n}\n```\n这样的代码编写关键：\n* 队首元素q.getFirst() 所获取的值是队列中的最大值\n* 出队时\n  * 如果一个元素已经被其他元素剔除出去了，那么他就不会再入队\n  * 如果一个元素是当前队列的最大值，会再出队\n\n### 滑动窗口的最大值\n\n\n### 捡金币游戏\n\n> 考点:\n> * 找到get数组，并知道get数组是当前元素和滑动窗口中最大值的和计算而来\n> * 利用单调队列在get[]数组上操作，找到滑动窗口的最大值\n\n拓展： 是否存在不同的出队方式\n\n> 整理一下代码模板：\n> <font color = 'red'>分层遍历</font>\n> <font color = 'red'>循环队列</font>\n> <font color = 'red'>单调队列</font>\n\n一些有意思的题目：\n* 利用栈实现一个队列\n* 利用队列实现一个栈\n\n\n# 优先级队列：堆与优先级队列，筛选最优元素\n\n## 堆\n FIFO队列： 节点之间的优先级是由遍历时的顺序决定的\n 优先级队列： 节点之间按照大小进行排序后，再决定优先级，底层依赖的数据结构一般是堆\n\n#### 堆的分类\n\n1. 大根堆\n   节点的值比他的孩子节点都大\n\n2. 小根堆\n   节点的值要比他的孩子节点都小\n堆的特点--大堆的根是最大值，小堆的根是最小值\n\n\n#### 堆的实现\n> 以大堆为例子\n\n大多数时候都是使用数组来表示堆\n``` golang\ntype Heap struct {\n    data []int\n}\n\n// 创建新的大根堆\nfunc NewHeap() Heap {\n    return Heap{\n        data: make([]int, 0),\n    }\n}\n\n// 获取大根堆的长度\nfunc (h *Heap) Len() int {\n    return len(h.data)\n}\n\n// 获取指定位置元素的父节点位置\nfunc parent(i int) int {\n    return (i - 1) / 2\n}\n\n// 获取指定位置元素的左子节点位置\nfunc leftChild(i int) int {\n    return i*2 + 1\n}\n\n// 获取指定位置元素的右子节点位置\nfunc rightChild(i int) int {\n    return i*2 + 2\n}\n\n// 下沉操作，将指定位置的元素向下移动，直到它大于所有子节点为止\nfunc (h *Heap) sink(i int) {\n    for {\n        left, right := leftChild(i), rightChild(i)\n        maxPos := i\n        if left < h.Len() && h.data[left] > h.data[maxPos] {\n            maxPos = left\n        }\n        if right < h.Len() && h.data[right] > h.data[maxPos] {\n            maxPos = right\n        }\n        if maxPos == i {\n            break\n        }\n        h.data[i], h.data[maxPos] = h.data[maxPos], h.data[i]\n        i = maxPos\n    }\n}\n\n// 上浮操作，将指定位置的元素向上移动，直到它小于其父节点为止\nfunc (h *Heap) swim(i int) {\n    for i > 0 {\n        p := parent(i)\n        if h.data[p] >= h.data[i] {\n            break\n        }\n        h.data[p], h.data[i] = h.data[i], h.data[p]\n        i = p\n    }\n}\n\n// 出堆，弹出大根堆的堆顶元素，并重新调整堆结构\nfunc (h *Heap) pop() int {\n    res := h.data[0]\n    h.data[0] = h.data[len(h.data)-1]\n    h.data = h.data[:len(h.data)-1]\n    h.sink(0)\n    return res\n}\n\n// 入堆，将新元素插入到大根堆中，并重新调整堆结构\nfunc (h *Heap) push(val int) {\n    h.data = append(h.data, val)\n    h.swim(len(h.data) - 1)\n}\n\n```\n\n#### 最小的k个数\n> N 的数量级非常大，或者其希望能够获得一个较小的区间内的数字\n> 同时输出的操作是每时每刻的话，一直是用排序的代价就会很高\n在上述大根堆的基础上来完成的话，就是以下代码：\n\n```golang\nfunc getLeastNumbers(arr []int, k int) []int {\n    // 建立大根堆\n    minH := Heap{}\n    for i:=0; i < len(arr); i++{\n        minH.push(arr[i])\n        if len(minH.data) > k {\n            minH.pop()\n        }\n    }\n    return minH.data\n}\n```\n\n## 优先级队列               \n\n#### google 面试题目：有一台机器会每隔一秒输出一个信号，请在每次输出信号的时候输出所有信号的中间值，如果信号数量位偶数则返回中间两数的平均值\n题目连接：\n> leetcode 这道题目还能够用排序是因为算的是所有一共的，如果是实时输出就每次都需要排序，所以直接维护一个结构更适合\n\n\n# 链表： 如何利用\"假头，新链表，双指针\"解决链表类型题目\n> 解决链表问题的三板斧：\n> 假头\n> 新链表\n> 双指针\n> 链表尤其需要考虑各种边界条件、链表结构简单，但是查找交换反转非常容易出错\n>\n\n### 三板斧\n\n#### 假头\n在链表前面增加额外的节点--> 可以节省许多对于nil指针的操作，能够节省不少的精力\n\ndummy 指针初始化之后就不会再发生改变了\ntail  指针随着元素改变移动\n\n1. tail 插入节点\n2. 头部插入节点\n3. 查找结点（总是会查找目标节点的pre）\n4. 在指定位置插入节点--> getPre\n5. 删除节点\n```golang\ntype linkList interface{\n    initDummyList()\n    appendNode(*interface{})bool\n    getPre(int)*interface{}\n    findNode(int) *interface{}\n    insertNode(*interface{})bool\n    deletNode(int) bool\n}\n```\n\n\n# 树： 如何深度运用树的遍历\n> 大部分语言的map数据结构，基本上是基于树来实现的\nb+树，红黑树，二叉树等等，在leetcode和考题当中常见二叉树，同时对于其他的树结构，可以通过二叉树的遍历来扩展出对应的遍历方式。\n\n\n## **1** &ensp; 树节点的结构：\n\n```golang\ntype TreeNode struct{\n    val int\n    left *TreeNode\n    right *TreeNode\n}\n```\n## **2** &ensp; 前序遍历\n> <font color='red'>遍历根节点、左子树、右子树</font>\n\n### **2.1** &ensp; 使用递归完成前序遍历\n采用整体的思想：\n首先遍历根节点，然后遍历左子树的时候，就把左子树放到相应的位置，遍历右子树的时候，就把右子树放到相应的位置。\n然后展开左子树\n然后展开右子树\n\n> 时间复杂度：O(N)\n> 空间复杂度：O(K) K表示的树的高度\n<font color=CC6699>一定注意要问清楚:在访问每个节点的时候，是需要Print出来，还是放到一个链表/数组当中存储</font>\n\n``` Golang\n//使用递归方式\nfunc traverse(root *TreeNode){\n    if root == nil {\n        return \n    }\n    traverse(root.Left)\n    traverse(root.Right)\n}\n```\n\n### **2.2** &ensp; 使用栈完成前序遍历\n``` golang\npackage main\n\nimport \"fmt\"\n\ntype TreeNode struct {\n    Val   int\n    Left  *TreeNode\n    Right *TreeNode\n}\n\n// 前序遍历\nfunc preorderTraversal(root *TreeNode) []int {\n    if root == nil {\n        return []int{}\n    }\n\n    var res []int\n    var stack []*TreeNode\n    stack = append(stack, root)\n\n    for len(stack) > 0 {\n        node := stack[len(stack)-1]\n        stack = stack[:len(stack)-1]\n        res = append(res, node.Val)\n        if node.Right != nil {\n            stack = append(stack, node.Right)\n        }\n        if node.Left != nil {\n            stack = append(stack, node.Left)\n        }\n    }\n\n    return res\n}\n\n```\n\n### **2.2-1** &ensp; Morris 遍历: 只需要O(1)的空间\n\n\n### **2.3** &ensp; 题目\n下述为前序遍历常见题目\n\n#### **2.3.1** 验证二叉树\n验证一颗二叉树是否满足二叉搜索树的性质\n\n```golang\ntype basic struct{\n    node *TreeNode\n    leftboard int\n    rightboard int\n} \n\nfunc stackBst(root *TreeNode) bool{\n    // 构造边界影子树栈\n    stack := make([]basic,0)\n    left, right := math.MinInt64,math.MaxInt64\n    for root != nil || len(stack) > 0{\n        // 当还没有遍历完左子树\n        for root != nil{\n            // 判断不满足搜索树的节点要求\n            if root.Val <= left || root.Val >= right {\n                return false\n            }\n            // 满足范围要求，那就要往下继续找\n            // 先记录当前影子树的边界\n            stack = append(stack, basic{\n                node: root,\n                leftboard: left,\n                rightboard: right,\n            })\n            // 往下移动，同时缩小右边界\n            right = root.Val\n            root = root.Left\n        }\n        // 左子树遍历完了，找右子树\n        top := stack[len(stack)-1]\n        stack = stack[:len(stack)-1]\n\n        // 关键就是这里需要重新赋值比较的left和right\n        root = top.node\n        left,right = top.leftboard,top.rightboard\n        left = root.Val\n        root = root.Right       \n    }\n    return true\n}\n\nfunc isValidBST(root *TreeNode) bool {\n    return stackBst(root)\n}\n```\n或者是使用递归的方式\n```golang\nfunc isValidBST(root *TreeNode) bool {\n    ans := true\n    ans = preOderBST(root,math.MinInt64,math.MaxInt64)\n    return ans\n}\nfunc preOderBST(root *TreeNode, left int, right int)bool{\n\tif root == nil {\n\t\treturn true\n\t}\n\tif root.Val <= left || root.Val >= right {\n\t\treturn false\n\t}\n\treturn preOderBST(root.Left,left,root.Val) && preOderBST(root.Right,root.Val,right)\n}\n// // 特殊在于 golang 的特点： 传参如果要一直修改其中的值，就需要传入一个引用，或者是采用闭包的方式\n// func preOderBST(root *TreeNode, left int, right int, ans *bool){\n// \t// 递归是否达到条件，即到达叶节点，到达叶节点表示所有节点都满足情况，所以为true\n// \t// 第二个条件是 是否有判断出不满足的树，有的话ans就会变成false,直接返回\n// \tif root == nil || !(*ans) {\n// \t\treturn\n// \t}\n// \t// 判断条件就是 当前的值要小于right同时大于left才满足\n// \tif root.Val <= left || root.Val >= right {\n// \t\t*ans = false\n// \t\treturn\n// \t}\n// \t// 前序遍历\n// \tpreOderBST(root.Left, left, root.Val, ans)\n// \tpreOderBST(root.Right, root.Val, right, ans)\n// }\n```\n\n#### **2.3.2** 目标和的所有路径\nhttps://leetcode.cn/problems/path-sum/\n> 二叉树进行回溯的代码模板\n> * 遇到新的节点： 路径总是从尾部添加节点\n> * 遍历完节点，路径就把他从尾部扔掉\n```golang\n// func hasPathSum(root *TreeNode, targetSum int) bool {\n    \n//     var backTrace func(*TreeNode, int) bool\n//     backTrace = func(root *TreeNode, Sum int)bool{\n//         left , right := false,false \n\n//         if root == nil {\n//             return false\n//         }\n//         Sum += root.Val\n//         if root.Left == nil && root.Right == nil && Sum == targetSum {\n//             return true\n//         }\n//         if root.Left != nil{\n//             left = backTrace(root.Left,Sum)\n//         }\n//         if root.Right != nil{\n//             right = backTrace(root.Right,Sum)\n//         }\n//         return left || right\n//     }\n//     return backTrace(root,0)\n// }\n\n// // 使用广度优先的遍历--层序遍历--队列\n// func hasPathSum(root *TreeNode, targetSum int) bool {\n//     if root == nil{\n//         return false\n//     }\n//     fifo := make([]*TreeNode,0)\n//     Qsize := 1\n//     fifo = append(fifo,root)\n\n//     for len(fifo) > 0 {\n//         for Qsize > 0 {\n//             top := fifo[0]\n//             if top.Left == nil && top.Right == nil && top.Val == targetSum{\n//                 return true\n//             }\n//             if top.Left != nil{\n//                 top.Left.Val = top.Left.Val + top.Val\n//                 fifo = append(fifo,top.Left)\n//             }\n//             if top.Right != nil{\n//                 top.Right.Val = top.Right.Val + top.Val\n//                 fifo = append(fifo,top.Right)\n//             }\n//             fifo = fifo[1:]\n//             Qsize -= 1\n//         }\n//         Qsize = len(fifo)\n//     }\n//     return false\n// }\n\n// 使用栈来存储，栈中元素是当前树的路径\ntype path struct{\n    node *TreeNode\n    sum int\n}\n\nfunc hasPathSum(root *TreeNode, targetSum int) bool {\n    if root == nil {\n        return false\n    }\n    paths := make([]path,0)\n    paths = append(paths, path{\n        node: root,\n        sum: root.Val,\n    })\n    for len(paths) > 0 {\n        node := paths[len(paths)-1]\n        paths = paths[:len(paths)-1]\n        if node.node.Left == nil && node.node.Right == nil && node.sum == targetSum {\n            return true\n        }\n        if node.node.Right != nil {\n            right := node.node.Right\n            paths = append(paths,path{\n                node: right,\n                sum: right.Val + node.sum,\n            })\n        }\n        if node.node.Left != nil {\n            left := node.node.Left\n            paths = append(paths,path{\n                node: left,\n                sum: left.Val + node.sum,\n            })\n        }\n    } \n    return false\n}\n```\n\n#### **2.3.3** 得到路径和为指定数字的路径集合\nhttps://leetcode.cn/problems/path-sum-ii/solution/\n<font color='red'> 这道题目非常重要：有两大问题都在这个地方表现出来了</font>\n\n==Golang的特性：Defer函数的使用==\n这道题目在使用前序遍历的时候，由于在叶子节点以及从左子树转换为右子树的时候都需要将原本记录在path当中的路径节点删除pop出来，递归时候就需要考虑在什么时候执行出栈操作，没错即便是在递归当中也还是必须要考虑栈的操作，因为需要一个连续记录的路径信息\n\n关键在于pop的时机：pop的时机是：1. 本身是叶子节点，直接return 结束dfs，2. 左右的子树都被递归判断过的树中结点，也就是dfs(Left),dfs(Right)正常结束，刚好发现二者均都是在dfs执行完之后执行，而且覆盖了dfs执行完之后所有的情况\n同时 Golang 的 **Defer(){}** 会在函数执行完并在返回之前执行，完全满足这个场景的需求，所以可以在递归函数体当中使用defer来完成对应的操作\n\n==Golang的特性：切片索引==\n切片本身就是指针，且每次操作都会影响到底层数组\n如果不在递归函数体当中使用切片之前重新对切片进行赋值，那么，之后对于底层数组的操作也会反映到之前的切片上，产生的效果就是明明原本计算好了结果但最后得到的并不是正确答案，关键就在于==后面切片的操作修改了底层数组，导致原本切片对应的结果被修改了==\n\n```golang\nfunc pathSum(root *TreeNode, targetSum int) [][]int {\n    result := make([][]int,0)\n    path := make([]int,0)\n    if root == nil {\n        return result\n    }\n    var dfs func(*TreeNode,int)\n    dfs = func(root *TreeNode,left int){\n        if root == nil{\n            return \n        }\n        path = append(path,root.Val)\n        left = left - root.Val\n        defer func() { \n            path = path[:len(path)-1]\n        }()\n        if root.Left == nil && root.Right == nil && left == 0{\n            // new := make([]int,len(path))\n            // copy(new,path)\n            // result = append(result,new)\n            result = append(result,append([]int(nil),path...))\n            return \n        }\n        dfs(root.Left,left)\n        dfs(root.Right,left)\n    }\n    dfs(root,targetSum)\n    return result\n}\n```\n\n#### **2.3.3** \n> 等待回溯来看\n> https://leetcode.cn/problems/path-sum-iii/solution/437-lu-jing-zong-he-iii-dfshui-su-qian-zhui-he-yi-/\n\n\n## **3** 中序遍历\n<font color='red'>遍历左子树，然后是根节点，然后是右子树</font>\n\n### **3.1** &ensp; 使用递归完成中序遍历\n``` golang\n\n```\n\n### **3.2** &ensp; 使用栈完成中序遍历\n```golang\nfunc inorderTraversal(root *TreeNode) []int {\n    if root == nil {\n        return []int{}\n    }\n\n    var res []int\n    var stack []*TreeNode\n    var pathStack []string\n    node := root\n\n    for node != nil || len(stack) > 0 {\n        if node != nil {\n            stack = append(stack, node)\n            pathStack = append(pathStack, fmt.Sprintf(\"%d\", node.Val))\n            node = node.Left\n        } else {\n            node = stack[len(stack)-1]\n            stack = stack[:len(stack)-1]\n            path := pathStack[len(pathStack)-1]\n            pathStack = pathStack[:len(pathStack)-1]\n\n            if node.Left == nil && node.Right == nil {\n                res = append(res, node.Val)\n\n                // 输出到达叶子节点的路径\n                fmt.Println(path)\n            }\n\n            node = node.Right\n        }\n    }\n\n    return res\n}\n```\n\n### **3.3** 找出二叉搜索树里面出现次数最多的数\n找众数就需要遍历所有的节点，二叉搜索树中序遍历的结果会是一个递增的数组，其数据特性就在于使用中序遍历的时候，所有的元素都是连续的\n``` golang\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc findMode(root *TreeNode) []int {\n    // 结果数组\n    ans := make([]int,0)\n    base,count,maxnum := math.MinInt64,0,0\n\n    // 使用递归的方式\n    var dfs func(*TreeNode)\n    dfs = func(root *TreeNode){\n        if root == nil {\n            return \n        }\n        dfs(root.Left)\n        if root.Val == base {\n            count++\n        }else{\n            base = root.Val\n            count = 1\n        }\n        if count == maxnum {\n            ans = append(ans,base)\n        }\n        if count > maxnum {\n            ans = []int{}\n            maxnum = count\n            ans = append(ans,base)\n        }\n        dfs(root.Right)\n    }\n    dfs(root)\n    return ans\n}\n```\n\n### **3.4** 找出二叉搜索树里面任意两个节点之间绝对值得最小值\n\nhttps://leetcode.cn/problems/minimum-distance-between-bst-nodes/\n\n```golang\nfunc minDiffInBST(root *TreeNode) int {\n    // 使用栈来中序遍历，栈顶元素就是上一遍历的节点元素\n    stack := make([]*TreeNode,0)\n    res := make([]int,0)\n    for root != nil || len(stack) > 0{\n        for root != nil {\n            stack = append(stack,root)\n            root = root.Left\n        }\n\n        node := stack[len(stack)-1]\n        stack = stack[:len(stack)-1]\n        res = append(res,node.Val)\n\n        root = node\n        root = root.Right\n    }\n    m := math.MaxInt64\n    for i:= 0; i < len(res)-1; i++{\n        r := res[i+1]-res[i]\n        m = min(m,r) \n    } \n    return m\n}\n\nfunc min(args ...int)int{\n    min := args[0]\n    for _, val := range args{\n        if val < min {\n            min = val\n        }\n    }\n    return min\n}\n```\n\n### **3.5** 一棵二叉搜索树的两个节点被交换了，恢复这颗二叉搜索树\n\n```golang\nfunc recoverTree(root *TreeNode)  {\n    // 使用递归解决这个问题\n    problem := make([]*TreeNode,0)\n    var findP func(*TreeNode)\n    findP = func(root *TreeNode){\n        if root == nil{\n            return \n        }\n        findP(root.Left)\n        // if pre == math.MaxInt64{\n        //     pre = root.Val\n        //     return\n        // }\n        // if root.Val - pre < 0{\n        //     problem = append(problem,root)\n        // }\n        // pre = root.Val\n        problem = append(problem, root)\n        findP(root.Right)\n    }\n    findP(root)\n    pre,cur := -1,-1\n    for i := 0; i < len(problem)-1; i++{\n        if problem[i].Val > problem[i+1].Val {\n            cur = i + 1\n            if pre == -1 {\n                pre = i\n            }\n        }\n    }\n    problem[pre].Val,problem[cur].Val = problem[cur].Val,problem[pre].Val\n    return \n}\n```\n\n### 删除二叉搜索树的节点\n> 题目最重要的考点就是分类，讨论各种情况下的处理方式\n\n<font sizecolor ='red'>清晰地讲出每种情况的处理办法</font>\n<font sizecolor ='red'>清晰简介地实现代码</font>\n\n\n\n\n## 后序遍历\n\n### 使用栈完成后序遍历\n\n### 迭代写法的考点\n1. 是否有右子树\n2. pre指针是不是指向当前结点的右子树","source":"_posts/Algorithm/Golang-数据结构/Golang-算法课程--数据结构.md","raw":"---\ntitle: Golang 算法课程--数据结构\ncatalog: true\ndate: 2023-04-02 00:46:21\nsubtitle:\nheader-img:\ntags: working, 算法\ncategories: 算法，Golang\n---\n\n# 告别盲目刷题，击破算法面试\n> 学习拉钩教育算法课程记录加个人感悟记录\n> 如果有版权问题，请联系 2374087322@qq.com 删除课程部分的内容\n> \n> 算法能力的高度，决定了个人能够解决的实战问题复杂度的上限\n>\n> 数学基础决定了算法能力的高低\n\n## ==解题流程==：\n\n### ==四部分析法==\n\n* **==模拟==** ： 模拟题目的运行\n  使用简单且有一定量的小例子，将自己当作计算机来执行这个流程\n  *一般使用题目给的较长的那个例子就可以*\n\\\n  这部分也是读题和理解输入输出内容的部分，理解题意的部分\n\\\n  这个时候一定不能够着急，不要害怕或者是觉得麻烦，一定要耐下性子，把简单的一个逻辑过程给跑清楚，理解这段程序或者是业务需要咱们处理什么样的问题。\n\\\n  跑的过程，不要完全先入为主，应当以题目的要求来推进演示。\n\\\n  不要想着在这一步就把所有的问题都给解决，一步步推进就可以. \n<br />\n\n* **==规律==** ： 尝试总结出题目的一般规律和特点\n  \n  数学规律和特性一般来说很难直接从零归纳出来，但我们可以依赖所学习的高数、线性代数、离散数学、测度论等高等数学理论当中所见到的数学计算模型来匹配，这也是这部分最重要的基础\n\n  先总结一些考题可能会用到的观察特点：\n  * 形式相关：比如 括号匹配、从1加到100，\n  * 数量变化：数量变化与取模相关，数量变化呈现递推公式\n  * \n\n\n* **==匹配==** ： 找到符合这些特点的数据结构和算法\n  * 关注数据的输入类型：对输入数据进行分类，哪一些数据进行怎样的操作\n\n  * **==怎样匹配呢？==**：\n    * 题目模拟的时候（这部分一般使用栈、队列、二叉树）来理解题目要求的数字变化\n    * 观察结果集合，或者是原本中间的变化集合，当期符合某种数据结构的变化特征的时候，就可以选用这个数据结构\n\n\n* **==考虑边界条件==**： 考虑特殊情况\n  特殊情况：\n  * 字符串为空，字符串只有一个，两个、\n  * 数组为空，数字为0或者是其他不符合规律的特殊情况\n\n\n* **==深度思考==** ： 平时练习当中的流程，用于提高算法模型的积累\n  * 深度： 这种解法还可以怎么优化\n  * 广度： 这种解法的具有普适性吗？可以推广吗？问题的限定条件变多的话，这个模型是否还可以适合。\n  * 数学模式扩散： 这样特点的问题是否有对应的数学模型或者是理论描述过\n\n\n\n# 栈： 从简单栈到单调栈，让栈问题不再困难\n\n## 结构特征\n\n先进后出\n\n对栈的操作：\n* **==pop==** 弹出栈顶元素，一般来说栈中可操作的元素就是栈顶元素，其他元素也都是先pop出其上面的元素，变成栈顶元素之后再进行操作。\n*  **==peek==** 获取栈顶元素，只是读取操作，但并没有弹出栈顶元素\n*  **==push==** 将元素压入栈中\n  \n### Golang 栈的使用\n\n在 Go 中并没有直接提供Stack的方法结构，但可以使用切片非常简单地表示和使用栈、队列结构。\n \n 先进后出的数据结构，使用**==切片==**表示，压入栈的操作就是往切片中添加元素，弹出栈的操作就是输出末尾元素，并将切片缩小为：`[:len(stack)-1]`\n\n以下为栈的代码模板实现：\n```golang\ntype Stack struct{\n    Stack []interface{}\n}\n\nfunc (s *Stack)push(x interface{}){\n    s = append(s,x)\n}\n\nfunc (s *Stack)pop(){\n    s = s[:len(s)-1]\n}\n\nfunc (s *Stack)peek()(x interface{}){\n    return s[len(s)-1]\n}\n```\n\n关键在于记住：\n* 栈顶元素 ---> 切片末尾元素\n* 切片是左闭右开，所以pop操作是 s = s[:len(s)-1], 但如果是队列pop出第一个元素就需要往后再移动一位 s = s[1:] 而不是 s = s[0:]\n\n## 典型题目\n\n### 判断字符串是否合法\n题目：https://leetcode.cn/problems/valid-parentheses/\n\n#### 正确解法和流程\nhttps://leetcode.cn/link/?target=https://www.bilibili.com/video/BV1AF411w78g\n```golang\nfunc isValid(s string) bool {\n    n := len(s)\n    if n % 2 == 1 {\n        return false\n    }\n    pairs := map[byte]byte{\n        ')': '(',\n        ']': '[',\n        '}': '{',\n    }\n    stack := []byte{}\n    for i := 0; i < n; i++ {\n        if pairs[s[i]] > 0 {\n            if len(stack) == 0 || stack[len(stack)-1] != pairs[s[i]] {\n                return false\n            }\n            stack = stack[:len(stack)-1]\n        } else {\n            stack = append(stack, s[i])\n        }\n    }\n    return len(stack) == 0\n}\n```\n\n#### 个人解法和流程\n\n> 问题集中体现在数据特性处理判断太过分散，属实是缝缝补补有一年\n> 对输入数据进行分类，哪一些数据进行怎样的操作\n> * 输入的是左括号应该入栈\n> * 输入的是右括号应该做判断\n<br />\n\n我的代码是：\n```golang\n    func isValid(s string) bool {\n    \n    l := len(s)\n    if l%2 != 0{\n        return false\n    }\n    stack := make([]rune, 0)\n\n    m := map[rune]rune{\n        ']':'[',\n        ')':'(',\n        '}':'{',\n    }\n    for _,v := range s{\n        if v == '[' ||v == '{' ||v == '('{\n            stack = append(stack,v)\n            continue\n        }\n        if len(stack) == 0{\n            return false\n        }\n        if stack[len(stack)-1] == m[v]{\n            stack = stack[:len(stack)-1]\n            continue\n        }\n\n        if m[v] != 0 {return false}\n    }\n\n    if len(stack) == 0{return true}\n\n    return false\n}\n```\n上述在判断栈顶元素的时候逻辑不够清晰，所以加了很多的if来补足条件，我们看例子当中所给的逻辑顺序：\n```golang\n        pairs := map[byte]byte{\n        ')': '(',\n        ']': '[',\n        '}': '{',\n    }\n    stack := []byte{}\n    for i := 0; i < n; i++ {\n        if pairs[s[i]] > 0 {\n            if len(stack) == 0 || stack[len(stack)-1] != pairs[s[i]] {\n                return false\n            }\n            stack = stack[:len(stack)-1]\n        } else {\n            stack = append(stack, s[i])\n        }\n    }\n    return len(stack) == 0\n```\n\n关键差距就在于这一句话：`pairs[s[i]] > 0 `, 这个判断对输入的数据做了一次分类，依据上面的map结构可知，这句话 < 0 时候标识map当中没有存储对应的对象，而map中存储的是所有的左括号，所以这个判断的作用是**当输入是右括号的时候进入函数**，然后逻辑体依据输入是右括号判断，如果当前栈里面没有元素或者是栈顶元素与右括号不匹配那么就返回false\n\\\n实际上我写的函数最后夜市做了类似的判断，但显然没有考虑数据分类的情况。\n\n\n### 判断大鱼吃小鱼最后留下的鱼\n题目：\n\n近似题目：https://www.nowcoder.com/questionTerminal/3fdfc63015df42c6a78fdae46709fa69?f=discussion\n\n<br />\n\n#### 正确解法和流程\n``` c++\nclass Solution {\npublic:\n    /**\n     * \n     * @param N int整型 N条鱼\n     * @param A int整型vector 每条鱼的体积为Ai\n     * @return int整型\n     */\n    struct P{\n        int x, t;\n    };\n    int solve(int N, vector<int>& A) {\n        stack<P> S;\n        int cnt = 0;\n        for(int i=N-1;i>=0;i--){\n            int t = 0;\n            while(!S.empty() && A[i]>S.top().x){\n                t = max(S.top().t, t+1);\n                S.pop();\n            }\n            S.push({A[i], t});\n            cnt = max(cnt, t);\n        }\n        return cnt;\n    }\n};\n```\n\n\n#### 个人解法和流程\n由于找不到相同的题目，就找了类似的题目，但是解题的思路不太一样\n图片上的大鱼吃小鱼，只需要每次比较栈顶元素和新进来的元素大小即可，当大于的时候，就不做操作，当栈顶元素小于输入元素的时候，pop出栈顶元素并push进入这个最大值，最后栈中元素就是结果。这个过程当中几处需要重视的地方是：\n* 当鱼的方向一致时候，大鱼并不会把同方向的小鱼给吃了【可能不论大小鱼的速度相同（bushi）】，而如果小鱼在左，大鱼在右，方向不同，则也不会吃\n\n\n牛客网的题目则加了非常多的条件和限制，是对栈问题的一个较大的变化\n\n> 对比上述两个题目可以观察到：\n> <font color ='blue'> 1. 消除的行为不同</font>\n>   括号匹配中，消除行为是配对的两者都会消除，也就是栈顶元素和输入元素一起被消除\n>   大鱼吃小鱼中，消除行为是配对的两者中会有一个被消除\n> --> 是否入栈和出栈的判断\n> <font color ='blue'> 2. 栈中的内容不同</font>\n>   括号匹配当中，栈中存放的就是内容本身\n>   大鱼吃小鱼当中，栈里存放的是内容的索引，可以通过索引找到内容\n> <font color ='blue'> 3. 弹栈的方式也不相同</font>\n>   括号匹配只需要每次弹出一个元素就可以\n>   大鱼则需要用while语句一直弹出到满足某个条件才停止\n\n\n## 栈问题的特征和解决流程\n\n### pop 行为不同\npop【弹栈的操作不一样】\n常见的就是每次循环都判断栈顶元素的特点而pop或者push或者不操作，但这样必须得是连续性的元素才有这样的特征\n\n**==在弹栈的时候，是否一定要满足某个条件才停止弹栈==**\n也就是说当输入元素之后需要将其和站内其他的元素进行比较，在使用的时候尤其要注意迭代过程\n\n### 栈中存储内容不相同\n是否栈中存储数据、还是存储索引、还是存储一个自建的新的结构\n\n### 栈顶元素的含义不相同\n\n\n## 单调栈\n\n单调栈是指栈中元素必须按照升序排列的栈或者是降序排列的栈\n\n单调栈分为：\n* 递增栈：\n    栈中元素从左到右遵守从小到大的顺序\n    入栈时候，当**入栈元素小于栈顶元素**就会pop出栈顶元素，直到入栈元素大于栈顶元素\n    特点是：\n    入栈小数会消除栈内大数\n\n* 递减栈\n    栈中元素从左到右遵守从大到小的顺序\n    入栈时候，当**入栈元素大于栈顶元素**就会pop出栈顶元素，直到入栈元素小于栈顶元素\n    特点是：\n    入栈大数会消除栈内小数\n\n\n### 典型代码：\n```golang\nstack := make([]int,0)\n/**递增栈的入栈\n* 用for 循环出栈，直到栈顶元素满足递增栈的要求\n*/\nfor len(stack)> 0 && A[i] > stack[len(stack)-1]{\n    // pop出栈内比 A[i]小但却在前面的元素\n    stack = stack[:len(stack)-1]\n}\nstack = append(stack,A[i])\n\n```\n### 找到当前数字右边最小的对应数字\n### 取k个字符，求字典序最小的组合\n> 字典序：\n> * 对单个元素按照ascii 表中大小顺序排列\n> * 多个元素时，按照从左到右顺序，先从高位字典排序，然后在相同高位中按照地位再字典排序\n### 给定一个数组，数组中元素代表模板的高度，请你求出相邻木板能剪出的最大矩形面积\n> 和求最大容积是一个题目\n\n<br />\n\n## leetcode 题目汇总\n\n> 以leetcode 题目为例子\n\n相关栈的题目汇总：\n[1][https://leetcode.cn/problem-list/xb9nqhhg/?topicSlugs=stack&page=1]\n[2][https://leetcode.cn/problem-list/e8X3pBZi/?page=1&topicSlugs=heap-priority-queue]\n[3][https://leetcode.cn/problem-list/2cktkvj/?page=1&topicSlugs=stack]\n\n\n# 队列：FIFO 队列与单调队列的深挖与扩展\n\n先进先出，是共同特征\n\n类别上可以分出：\n* FIFO队列\n* 单调队列\n\n## FIFO队列\n\n**==Push 元素时候， 总是将放在元素放在队列尾部，也就是操作 fifo[len(fifo)-1]==**\n**==Pop 元素时候，总是将队列首部的元素扔掉 ，也就是操作 fifo = fifo[1:]==**\n\n###  二叉树的层次遍历（两种方法）\n\n* 规律： \n广度遍历（层次遍历）：由于二叉树的特点，当拿到第N层的结点A之后，可以通过 A 的left，right指针拿到下一层的节点\n**但是与A在同一层的节点还有其他吗，这个时候就需要按层来存储节点，不能直接使用递归**\n\n    <br />\n    顺序输出：每层输出时，排在左边的节点，它的子节点同样排在下一层的最左边\n\n--> **==题目具备广度遍历（分层遍历）的特点 和 顺序输出的特点 ，应该想到应用FIFO队列==**\n\n* 边界\n  特殊判断： 如果发现是一棵空二叉树，就直接返回空结果\n  ==制定一个规则==： 不要让空指针进入到FIFO队列（一些编程的亮点）\n\n<font color = 'red'> 非常重要的概念： QSize 表示当前层数 </font>\n\n#### 层次遍历二叉树\n题目链接：https://leetcode.cn/problems/binary-tree-level-order-traversal/submissions/\n\n##### 解题思路1\n关键思路在于将每一层的节点都存在FIFO队列里面，在每次遍历的时候从左到右pop出该层的节点，同时在队尾加入他的左右孩子\n\n队首pop出当层节点，队尾append下一层的孩子节点\nQSize 记录当层的节点数量\n\n时间复杂度是O(n), 空间复杂度由QSize决定O(K),K表示QSize最大，也就是存储的一层节点数量最多的时候\n\n##### 代码\n```golang\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc levelOrder(root *TreeNode) [][]int {\n    // 创建FIFO 队列来存储遍历的过程\n    fifo := make([]*TreeNode,0)\n    // QSize 表示当前遍历的层\n    QSize := 1\n    // 初始化最终结果\n    result := make([][]int,0)\n    if root == nil{\n        return result\n    }\n    //将根节点入栈\n    fifo = append(fifo,root)\n    // 开始层序遍历，只要当前队列不为空\n    for len(fifo) > 0 {\n        // 创建结果数组用于存储当层pop出的元素值\n        tmp := make([]int, 0)\n        // 当层元素QSize全部遍历以此，这里不能用len(fifo)，因为fifo的长度是在变化的\n        for i := QSize;i > 0;i--{\n            // 拿出队列头元素\n            node := fifo[0]\n            // 判断他的左孩子是否为空\n            if node.Left!= nil{\n                fifo = append(fifo,node.Left)\n            }\n            // 判断他的右孩子是否为空\n            if node.Right != nil{\n                fifo = append(fifo,node.Right)\n            }\n            // 将该节点的值存入结果\n            tmp = append(tmp,node.Val)\n            // 推出队首元素\n            fifo = fifo[1:]\n        }\n        // 将结果 tmp 存入到结果数组当中\n        result = append(result,tmp)\n        // 重新计算当前层的节点数量\n        QSize = len(fifo)\n    }\n    return result\n}\n```\n##### 官方题解\n```golang\nfunc levelOrder(root *TreeNode) [][]int {\n    ret := [][]int{}\n    if root == nil {\n        return ret\n    }\n    q := []*TreeNode{root}\n    for i := 0; len(q) > 0; i++ {\n        ret = append(ret, []int{})\n        p := []*TreeNode{}\n        for j := 0; j < len(q); j++ {\n            node := q[j]\n            ret[i] = append(ret[i], node.Val)\n            if node.Left != nil {\n                p = append(p, node.Left)\n            }\n            if node.Right != nil {\n                p = append(p, node.Right)\n            }\n        }\n        q = p\n    }\n    return ret\n}\n\n```\n\n##### 解题思路2\n\n使用链表来解决问题\n\n#### 锯齿状层次遍历\n题目链接：https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/\n\n##### 解题思路\n层次遍历的基础上加一个qs，表示当前层是从左到右还是从右到左\n\n**==本题当中所犯的错误：==**：\n* 每一轮都需要重新计算qsize,一定不要忘了这一点\n* tmp 接收的时候还是按照栈的pop逻辑，所以顺序上还需要再反一次\n* 题目样例当中root是按照从左到右遍历过一次来计算的\n\n##### 代码\n\n```golang\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc zigzagLevelOrder(root *TreeNode) [][]int {\n    //结果数组\n    result := make([][]int,0)\n    //全局的fifo队列\n    fifo := make([]*TreeNode,0)\n    // Qsize 表示当前层的节点数，qs 表示该层的遍历顺序，0表示从左到右，1表示从右到左\n    Qsize ,qs := 1 , 1\n    // 如果树中没有节点则直接返回\n    if root == nil{\n        return result\n    }\n    // 将 root 放入队列\n    fifo = append(fifo,root)\n    //遍历整棵树\n    for len(fifo) > 0 {\n        tmp := make([]int,0)\n        for i:= 1; Qsize >= i && qs == 0 ;i++{\n            node := fifo[Qsize-i]\n            if node.Right != nil {\n                fifo = append(fifo,node.Right)\n            }\n            if node.Left != nil{\n                fifo = append(fifo,node.Left)\n            }\n            tmp = append(tmp,node.Val)                \n        }\n        for i:= 1; Qsize >= i && qs == 1 ;i++{\n            node := fifo[Qsize-i]\n            if node.Left != nil{\n                fifo = append(fifo,node.Left)\n            }\n            if node.Right != nil{\n                fifo = append(fifo,node.Right)\n            }\n            tmp = append(tmp,node.Val)                \n        }\n        fifo = fifo[Qsize:]\n        Qsize = len(fifo)\n        result = append(result,tmp)\n        if qs == 1{\n            qs = 0\n        }else{\n            qs = 1\n        }\n    }\n    return result\n}\n```\n\n\n\n#### 倒序层次遍历\n题目链接：https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/\n\n##### 解题思路\n从题目要求当中可以读出，是在之前的层序遍历基础上把结果倒过来输出，那么会比较自然想到可以在使用一个栈用来存储中间结果\n\n##### 代码\n\n```golang\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc levelOrderBottom(root *TreeNode) [][]int {\n    // 构造全局fifo队列\n    fifo := make([]*TreeNode,0)\n    // 构造结果栈\n    stack := make([][]int,0)\n    result := make([][]int,0)\n    //表示当前层的节点数量\n    Qsize := 1\n    fifo = append(fifo,root)\n    if root == nil{\n        return result\n    }\n    for len(fifo) > 0{\n        tmp := make([]int,0)\n        for Qsize > 0{\n            node:= fifo[0]\n            if node.Left != nil{\n                fifo =append(fifo,node.Left)\n            }\n            if node.Right != nil{\n                fifo = append(fifo,node.Right)\n            }\n            Qsize--\n            fifo = fifo[1:]\n            tmp = append(tmp,node.Val)\n        }\n        stack = append(stack,tmp)\n        Qsize = len(fifo)\n    }\n\n    // 将栈中元素pop 到结果当中\n    for len(stack) > 0{\n        result = append(result,stack[len(stack)-1])\n        stack = stack[:len(stack)-1]\n    }\n    return result\n}\n```\n\n## 循环队列\n\n设计一个可以容纳 k 个元素的循环队列，需要实现以下接口：\n\n```golang\ntype ringQueue interface{\n    //构造函数，参数k表示这个循环队列最多容纳k个元素\n    CircularQueue(int)\n    //将value放到队列中，成功返回true\n    EnQueue(int) bool\n    // 删除队首元素，成功返回true\n    DeQueue() bool\n    // 得到队首元素，如果队列为空，返回-1\n    Front() int\n    // 得到队尾元素，如果队列为空，返回-1\n    Rear() int\n    // 查看循环队列是否为空\n    isEmpty() bool\n    // 查看队列是否已经放满k个元素\n    isFull() bool\n}\n```\n\n* **==循环队列的重点在于==: <font color = 'red'>循环使用固定空间</font>**\n* **==难点在于==： <font color='red'>控制好 Front/Rear两个首位指示器</font>**\n\n### 表示方法1\n使用 `used`、`front`、`rear` 三个变量来控制，其中`used, front`都代表的是数组的下标\n\n注意以下几点：\n* index = i 的后一个是i+1，前一个是i+1\n* index = k-1 的后一个就是index=0\n* index = 0 的前一个是 index = k-1\n**==可以使用取模的方式统一处理==:**\n<font color='red'> index = i 的后一个元素下标是（i+1）% k</font>\n<font color='red'> index = i 的前一个元素下标是（i-1+k）% k</font>\n<font color='blue'>所有的循环数组下标的处理都需要按照这个取模的方式</font>\n\n参考的实例代码如下：\n```golang\ntype MyCircularQueue struct {\n    queue  []int\n    rear   int\n    front  int\n    used   int\n    length int\n}\n\nfunc CircularQueue(k int) ringQueue {\n    return &MyCircularQueue{\n        queue:  make([]int, k),\n        rear:   0,\n        front:  0,\n        used:   0,\n        length: k,\n    }\n}\n\nfunc (q *MyCircularQueue) EnQueue(value int) bool {\n    if q.isFull() {\n        return false \n    }\n    q.queue[q.rear] = value\n    q.rear = (q.rear + 1) % q.length\n    q.used++\n    return true\n}\n\nfunc (q *MyCircularQueue) DeQueue() bool {\n    if q.isEmpty() {\n        return false\n    }\n    q.front = (q.front + 1) % q.length\n    q.used--\n    return true\n}\n\nfunc (q *MyCircularQueue) Front() int {\n    if q.used == 0 {\n        return -1\n    }\n    return q.queue[q.front]\n}\n\nfunc (q *MyCircularQueue) Rear() int {\n    if q.used == 0 {\n        return -1\n    }\n    return q.queue[(q.rear-1+q.length)%q.length]\n}\n\nfunc (q *MyCircularQueue) isEmpty() bool {\n    return q.used == 0\n}\n\nfunc (q *MyCircularQueue) isFull() bool {\n    return q.used == q.length\n}\n```\n备注：\n在 `DeQueue()` 方法中，删除队首元素时并不会真的删除该元素，而是通过移动 `front` 指针来达到删除的效果。\n\n循环队列是一个环状的数据结构，可以想象成沿着环形路径移动指针。在实现循环队列时，每当删除队首元素时，我们需要将 `front` 指针向前移一位，指向队列中的下一个元素，这样队列中原来的第二个元素就成为了新的头部元素。这里使用 \"指向队列中的下一个元素\" 实际上是模运算的作用，如 `(i+1) % n` 将会得到指向 `i` 在循环数组中下一个元素的索引值。\n\n而在这个移动指针的过程中，由于队列的前面已经没有元素，所以我们不需要将队首元素真正地删除。相反，仅需要更新 `front` 指针，让它指向目前第一个元素，后面再添加新的元素，也会覆盖掉先前的元素，实现对队列的循环利用。\n\n### 表示方法2\n```golang\ntype MyCircularQueue struct {\n    // 使用 k + 1 ，也就是多余一个空格的循环队列来设计\n    queue []int\n    front int\n    rear int\n    capacity int\n}\n\n\nfunc Constructor(k int) MyCircularQueue {\n    return MyCircularQueue{\n        queue: make([]int,k+1),\n        front: 0,\n        rear: 0,\n        capacity: k+1,\n    }\n}\n\n\nfunc (this *MyCircularQueue) EnQueue(value int) bool {\n    if this.IsFull(){\n        return false\n    }\n    this.queue[this.rear] = value\n    this.rear = (this.rear + 1)%this.capacity\n    return true\n}\n\n\nfunc (this *MyCircularQueue) DeQueue() bool {\n    if this.IsEmpty(){\n        return false\n    }\n    this.front = (this.front+1)%this.capacity\n    return true\n}\n\n\nfunc (this *MyCircularQueue) Front() int {\n    if this.IsEmpty() {\n        return -1\n    }\n    return this.queue[this.front]\n}\n\n\nfunc (this *MyCircularQueue) Rear() int {\n    if this.IsEmpty(){\n        return -1\n    }\n    rearPosition := (this.rear-1+this.capacity)%this.capacity\n    return this.queue[rearPosition]\n}\n\n\nfunc (this *MyCircularQueue) IsEmpty() bool {\n    return this.rear ==this.front\n}\n\n\nfunc (this *MyCircularQueue) IsFull() bool {\n    return (this.rear+1)%this.capacity == this.front\n}\n\n/**\n * Your MyCircularQueue object will be instantiated and called as such:\n * obj := Constructor(k);\n * param_1 := obj.EnQueue(value);\n * param_2 := obj.DeQueue();\n * param_3 := obj.Front();\n * param_4 := obj.Rear();\n * param_5 := obj.IsEmpty();\n * param_6 := obj.IsFull();\n */\n```\n\n### 循环双向队列\n\n#### 解题思路\n\n\n**==犯错的地方：==**\n<font color='red'> InsertFront的时候，需要先移动front向前一位，然后再把值插进去</font>\n最开始想的，直接让front和rear都指向一个空白的空间，那么就需要在插入的时候先将front向前移动两位，但这样的话就会浪费一个数值的空间，因为多余一个位就完全可以满足要求\n\n使用k+1的情况，如果是在LRU缓存或者是Ringbuffer当中还需要考虑，将队尾[或者是队中]的元素插入到队首，也就是将最近使用的元素放到前面\n\n#### 代码\n\n```golang\ntype MyCircularDeque struct {\n    queue []int\n    front int\n    rear int \n    capacity int\n}\n\n\nfunc Constructor(k int) MyCircularDeque {\n    return MyCircularDeque{\n        queue: make([]int,k+1),\n        front: 0,\n        rear: 0,\n        capacity: k+1,\n    }\n}\n\n\nfunc (this *MyCircularDeque) InsertFront(value int) bool {\n    if this.IsFull(){\n        return false\n    }\n    this.front = (this.front-1 + this.capacity)%this.capacity\n    this.queue[this.front] = value\n    return true\n}\n\n\nfunc (this *MyCircularDeque) InsertLast(value int) bool {\n    if this.IsFull(){\n        return false\n    }\n    this.queue[this.rear] = value\n    this.rear = (this.rear+1)%this.capacity\n    return true\n}\n\n\nfunc (this *MyCircularDeque) DeleteFront() bool {\n    if this.IsEmpty(){\n        return false\n    }\n    this.front = (this.front+1)%this.capacity\n    return true\n}\n\n\nfunc (this *MyCircularDeque) DeleteLast() bool {\n    if this.IsEmpty(){\n        return false\n    }\n    this.rear = (this.rear-1+this.capacity)%this.capacity\n    return true\n}\n\n\nfunc (this *MyCircularDeque) GetFront() int {\n    if this.IsEmpty(){\n        return -1\n    }\n    return this.queue[this.front]\n}\n\n\nfunc (this *MyCircularDeque) GetRear() int {\n    if this.IsEmpty(){\n        return -1\n    }\n    return this.queue[(this.rear-1+this.capacity)%this.capacity]\n}\n\n\nfunc (this *MyCircularDeque) IsEmpty() bool {\n    return this.front == this.rear\n}\n\n\nfunc (this *MyCircularDeque) IsFull() bool {\n    return this.front == (this.rear+1)%this.capacity\n}\n\n\n/**\n * Your MyCircularDeque object will be instantiated and called as such:\n * obj := Constructor(k);\n * param_1 := obj.InsertFront(value);\n * param_2 := obj.InsertLast(value);\n * param_3 := obj.DeleteFront();\n * param_4 := obj.DeleteLast();\n * param_5 := obj.GetFront();\n * param_6 := obj.GetRear();\n * param_7 := obj.IsEmpty();\n * param_8 := obj.IsFull();\n */\n```\n\n相似点：\n* 都使用了取模的方式\n\n## 单调队列\n单调队列属于双端队列的一种\n\n要求队列中的元素必须满足单调性\n\n单调队列如对时候的要求：入队前后，单调性完整\n\n**==单调递减队列最重要的特性==:<font color='red'>入队和出队的组合，可以在O(1)时间得到某个区间上的最大值</font>**\n\n### 情况讨论\n> 需要回答的问题：\n> * 这个区间是什么\n> * 怎样定量地描述这个区间\n> * 与队列中的元素个数有什么关系\n可以分以下两种情况来讨论：\n1. 只有入队的情况\n   在没有出队的情况下，对原数组的比较范围就会逐步增加\n   队首元素表示是已比较范围内的最大值\n2. 出队和入队混合的情况\n   控制覆盖范围为 k --> 滑动窗口\n    * 入队： 扩展单调队列的覆盖范围\n    * 出队： 控制单调队列的覆盖范围\n    * 队首元素是覆盖范围的最大值\n    * 队列中的元素个数小于覆盖范围的元素个数\n\n### 核心代码\n```golang\n//入队的代码\nfunc (q *queue)push(val int){\n    // 入队时候，要剔除掉尾部的元素，知道尾部元素大于或者是等于入队元素\n    while(!q.isEmpty() && q.getLast()<val){\n        q.removeLast()\n    }\n    // 将元素入队\n    q.addLast(val)\n}\n\n// 出队的时候，需要给出一个value\nfunc(q *queue) pop(val int){\n    if(!q.isEmpty() && q.getFirst()==val){\n        q.removeFirst()\n    }\n}\n```\n这样的代码编写关键：\n* 队首元素q.getFirst() 所获取的值是队列中的最大值\n* 出队时\n  * 如果一个元素已经被其他元素剔除出去了，那么他就不会再入队\n  * 如果一个元素是当前队列的最大值，会再出队\n\n### 滑动窗口的最大值\n\n\n### 捡金币游戏\n\n> 考点:\n> * 找到get数组，并知道get数组是当前元素和滑动窗口中最大值的和计算而来\n> * 利用单调队列在get[]数组上操作，找到滑动窗口的最大值\n\n拓展： 是否存在不同的出队方式\n\n> 整理一下代码模板：\n> <font color = 'red'>分层遍历</font>\n> <font color = 'red'>循环队列</font>\n> <font color = 'red'>单调队列</font>\n\n一些有意思的题目：\n* 利用栈实现一个队列\n* 利用队列实现一个栈\n\n\n# 优先级队列：堆与优先级队列，筛选最优元素\n\n## 堆\n FIFO队列： 节点之间的优先级是由遍历时的顺序决定的\n 优先级队列： 节点之间按照大小进行排序后，再决定优先级，底层依赖的数据结构一般是堆\n\n#### 堆的分类\n\n1. 大根堆\n   节点的值比他的孩子节点都大\n\n2. 小根堆\n   节点的值要比他的孩子节点都小\n堆的特点--大堆的根是最大值，小堆的根是最小值\n\n\n#### 堆的实现\n> 以大堆为例子\n\n大多数时候都是使用数组来表示堆\n``` golang\ntype Heap struct {\n    data []int\n}\n\n// 创建新的大根堆\nfunc NewHeap() Heap {\n    return Heap{\n        data: make([]int, 0),\n    }\n}\n\n// 获取大根堆的长度\nfunc (h *Heap) Len() int {\n    return len(h.data)\n}\n\n// 获取指定位置元素的父节点位置\nfunc parent(i int) int {\n    return (i - 1) / 2\n}\n\n// 获取指定位置元素的左子节点位置\nfunc leftChild(i int) int {\n    return i*2 + 1\n}\n\n// 获取指定位置元素的右子节点位置\nfunc rightChild(i int) int {\n    return i*2 + 2\n}\n\n// 下沉操作，将指定位置的元素向下移动，直到它大于所有子节点为止\nfunc (h *Heap) sink(i int) {\n    for {\n        left, right := leftChild(i), rightChild(i)\n        maxPos := i\n        if left < h.Len() && h.data[left] > h.data[maxPos] {\n            maxPos = left\n        }\n        if right < h.Len() && h.data[right] > h.data[maxPos] {\n            maxPos = right\n        }\n        if maxPos == i {\n            break\n        }\n        h.data[i], h.data[maxPos] = h.data[maxPos], h.data[i]\n        i = maxPos\n    }\n}\n\n// 上浮操作，将指定位置的元素向上移动，直到它小于其父节点为止\nfunc (h *Heap) swim(i int) {\n    for i > 0 {\n        p := parent(i)\n        if h.data[p] >= h.data[i] {\n            break\n        }\n        h.data[p], h.data[i] = h.data[i], h.data[p]\n        i = p\n    }\n}\n\n// 出堆，弹出大根堆的堆顶元素，并重新调整堆结构\nfunc (h *Heap) pop() int {\n    res := h.data[0]\n    h.data[0] = h.data[len(h.data)-1]\n    h.data = h.data[:len(h.data)-1]\n    h.sink(0)\n    return res\n}\n\n// 入堆，将新元素插入到大根堆中，并重新调整堆结构\nfunc (h *Heap) push(val int) {\n    h.data = append(h.data, val)\n    h.swim(len(h.data) - 1)\n}\n\n```\n\n#### 最小的k个数\n> N 的数量级非常大，或者其希望能够获得一个较小的区间内的数字\n> 同时输出的操作是每时每刻的话，一直是用排序的代价就会很高\n在上述大根堆的基础上来完成的话，就是以下代码：\n\n```golang\nfunc getLeastNumbers(arr []int, k int) []int {\n    // 建立大根堆\n    minH := Heap{}\n    for i:=0; i < len(arr); i++{\n        minH.push(arr[i])\n        if len(minH.data) > k {\n            minH.pop()\n        }\n    }\n    return minH.data\n}\n```\n\n## 优先级队列               \n\n#### google 面试题目：有一台机器会每隔一秒输出一个信号，请在每次输出信号的时候输出所有信号的中间值，如果信号数量位偶数则返回中间两数的平均值\n题目连接：\n> leetcode 这道题目还能够用排序是因为算的是所有一共的，如果是实时输出就每次都需要排序，所以直接维护一个结构更适合\n\n\n# 链表： 如何利用\"假头，新链表，双指针\"解决链表类型题目\n> 解决链表问题的三板斧：\n> 假头\n> 新链表\n> 双指针\n> 链表尤其需要考虑各种边界条件、链表结构简单，但是查找交换反转非常容易出错\n>\n\n### 三板斧\n\n#### 假头\n在链表前面增加额外的节点--> 可以节省许多对于nil指针的操作，能够节省不少的精力\n\ndummy 指针初始化之后就不会再发生改变了\ntail  指针随着元素改变移动\n\n1. tail 插入节点\n2. 头部插入节点\n3. 查找结点（总是会查找目标节点的pre）\n4. 在指定位置插入节点--> getPre\n5. 删除节点\n```golang\ntype linkList interface{\n    initDummyList()\n    appendNode(*interface{})bool\n    getPre(int)*interface{}\n    findNode(int) *interface{}\n    insertNode(*interface{})bool\n    deletNode(int) bool\n}\n```\n\n\n# 树： 如何深度运用树的遍历\n> 大部分语言的map数据结构，基本上是基于树来实现的\nb+树，红黑树，二叉树等等，在leetcode和考题当中常见二叉树，同时对于其他的树结构，可以通过二叉树的遍历来扩展出对应的遍历方式。\n\n\n## **1** &ensp; 树节点的结构：\n\n```golang\ntype TreeNode struct{\n    val int\n    left *TreeNode\n    right *TreeNode\n}\n```\n## **2** &ensp; 前序遍历\n> <font color='red'>遍历根节点、左子树、右子树</font>\n\n### **2.1** &ensp; 使用递归完成前序遍历\n采用整体的思想：\n首先遍历根节点，然后遍历左子树的时候，就把左子树放到相应的位置，遍历右子树的时候，就把右子树放到相应的位置。\n然后展开左子树\n然后展开右子树\n\n> 时间复杂度：O(N)\n> 空间复杂度：O(K) K表示的树的高度\n<font color=CC6699>一定注意要问清楚:在访问每个节点的时候，是需要Print出来，还是放到一个链表/数组当中存储</font>\n\n``` Golang\n//使用递归方式\nfunc traverse(root *TreeNode){\n    if root == nil {\n        return \n    }\n    traverse(root.Left)\n    traverse(root.Right)\n}\n```\n\n### **2.2** &ensp; 使用栈完成前序遍历\n``` golang\npackage main\n\nimport \"fmt\"\n\ntype TreeNode struct {\n    Val   int\n    Left  *TreeNode\n    Right *TreeNode\n}\n\n// 前序遍历\nfunc preorderTraversal(root *TreeNode) []int {\n    if root == nil {\n        return []int{}\n    }\n\n    var res []int\n    var stack []*TreeNode\n    stack = append(stack, root)\n\n    for len(stack) > 0 {\n        node := stack[len(stack)-1]\n        stack = stack[:len(stack)-1]\n        res = append(res, node.Val)\n        if node.Right != nil {\n            stack = append(stack, node.Right)\n        }\n        if node.Left != nil {\n            stack = append(stack, node.Left)\n        }\n    }\n\n    return res\n}\n\n```\n\n### **2.2-1** &ensp; Morris 遍历: 只需要O(1)的空间\n\n\n### **2.3** &ensp; 题目\n下述为前序遍历常见题目\n\n#### **2.3.1** 验证二叉树\n验证一颗二叉树是否满足二叉搜索树的性质\n\n```golang\ntype basic struct{\n    node *TreeNode\n    leftboard int\n    rightboard int\n} \n\nfunc stackBst(root *TreeNode) bool{\n    // 构造边界影子树栈\n    stack := make([]basic,0)\n    left, right := math.MinInt64,math.MaxInt64\n    for root != nil || len(stack) > 0{\n        // 当还没有遍历完左子树\n        for root != nil{\n            // 判断不满足搜索树的节点要求\n            if root.Val <= left || root.Val >= right {\n                return false\n            }\n            // 满足范围要求，那就要往下继续找\n            // 先记录当前影子树的边界\n            stack = append(stack, basic{\n                node: root,\n                leftboard: left,\n                rightboard: right,\n            })\n            // 往下移动，同时缩小右边界\n            right = root.Val\n            root = root.Left\n        }\n        // 左子树遍历完了，找右子树\n        top := stack[len(stack)-1]\n        stack = stack[:len(stack)-1]\n\n        // 关键就是这里需要重新赋值比较的left和right\n        root = top.node\n        left,right = top.leftboard,top.rightboard\n        left = root.Val\n        root = root.Right       \n    }\n    return true\n}\n\nfunc isValidBST(root *TreeNode) bool {\n    return stackBst(root)\n}\n```\n或者是使用递归的方式\n```golang\nfunc isValidBST(root *TreeNode) bool {\n    ans := true\n    ans = preOderBST(root,math.MinInt64,math.MaxInt64)\n    return ans\n}\nfunc preOderBST(root *TreeNode, left int, right int)bool{\n\tif root == nil {\n\t\treturn true\n\t}\n\tif root.Val <= left || root.Val >= right {\n\t\treturn false\n\t}\n\treturn preOderBST(root.Left,left,root.Val) && preOderBST(root.Right,root.Val,right)\n}\n// // 特殊在于 golang 的特点： 传参如果要一直修改其中的值，就需要传入一个引用，或者是采用闭包的方式\n// func preOderBST(root *TreeNode, left int, right int, ans *bool){\n// \t// 递归是否达到条件，即到达叶节点，到达叶节点表示所有节点都满足情况，所以为true\n// \t// 第二个条件是 是否有判断出不满足的树，有的话ans就会变成false,直接返回\n// \tif root == nil || !(*ans) {\n// \t\treturn\n// \t}\n// \t// 判断条件就是 当前的值要小于right同时大于left才满足\n// \tif root.Val <= left || root.Val >= right {\n// \t\t*ans = false\n// \t\treturn\n// \t}\n// \t// 前序遍历\n// \tpreOderBST(root.Left, left, root.Val, ans)\n// \tpreOderBST(root.Right, root.Val, right, ans)\n// }\n```\n\n#### **2.3.2** 目标和的所有路径\nhttps://leetcode.cn/problems/path-sum/\n> 二叉树进行回溯的代码模板\n> * 遇到新的节点： 路径总是从尾部添加节点\n> * 遍历完节点，路径就把他从尾部扔掉\n```golang\n// func hasPathSum(root *TreeNode, targetSum int) bool {\n    \n//     var backTrace func(*TreeNode, int) bool\n//     backTrace = func(root *TreeNode, Sum int)bool{\n//         left , right := false,false \n\n//         if root == nil {\n//             return false\n//         }\n//         Sum += root.Val\n//         if root.Left == nil && root.Right == nil && Sum == targetSum {\n//             return true\n//         }\n//         if root.Left != nil{\n//             left = backTrace(root.Left,Sum)\n//         }\n//         if root.Right != nil{\n//             right = backTrace(root.Right,Sum)\n//         }\n//         return left || right\n//     }\n//     return backTrace(root,0)\n// }\n\n// // 使用广度优先的遍历--层序遍历--队列\n// func hasPathSum(root *TreeNode, targetSum int) bool {\n//     if root == nil{\n//         return false\n//     }\n//     fifo := make([]*TreeNode,0)\n//     Qsize := 1\n//     fifo = append(fifo,root)\n\n//     for len(fifo) > 0 {\n//         for Qsize > 0 {\n//             top := fifo[0]\n//             if top.Left == nil && top.Right == nil && top.Val == targetSum{\n//                 return true\n//             }\n//             if top.Left != nil{\n//                 top.Left.Val = top.Left.Val + top.Val\n//                 fifo = append(fifo,top.Left)\n//             }\n//             if top.Right != nil{\n//                 top.Right.Val = top.Right.Val + top.Val\n//                 fifo = append(fifo,top.Right)\n//             }\n//             fifo = fifo[1:]\n//             Qsize -= 1\n//         }\n//         Qsize = len(fifo)\n//     }\n//     return false\n// }\n\n// 使用栈来存储，栈中元素是当前树的路径\ntype path struct{\n    node *TreeNode\n    sum int\n}\n\nfunc hasPathSum(root *TreeNode, targetSum int) bool {\n    if root == nil {\n        return false\n    }\n    paths := make([]path,0)\n    paths = append(paths, path{\n        node: root,\n        sum: root.Val,\n    })\n    for len(paths) > 0 {\n        node := paths[len(paths)-1]\n        paths = paths[:len(paths)-1]\n        if node.node.Left == nil && node.node.Right == nil && node.sum == targetSum {\n            return true\n        }\n        if node.node.Right != nil {\n            right := node.node.Right\n            paths = append(paths,path{\n                node: right,\n                sum: right.Val + node.sum,\n            })\n        }\n        if node.node.Left != nil {\n            left := node.node.Left\n            paths = append(paths,path{\n                node: left,\n                sum: left.Val + node.sum,\n            })\n        }\n    } \n    return false\n}\n```\n\n#### **2.3.3** 得到路径和为指定数字的路径集合\nhttps://leetcode.cn/problems/path-sum-ii/solution/\n<font color='red'> 这道题目非常重要：有两大问题都在这个地方表现出来了</font>\n\n==Golang的特性：Defer函数的使用==\n这道题目在使用前序遍历的时候，由于在叶子节点以及从左子树转换为右子树的时候都需要将原本记录在path当中的路径节点删除pop出来，递归时候就需要考虑在什么时候执行出栈操作，没错即便是在递归当中也还是必须要考虑栈的操作，因为需要一个连续记录的路径信息\n\n关键在于pop的时机：pop的时机是：1. 本身是叶子节点，直接return 结束dfs，2. 左右的子树都被递归判断过的树中结点，也就是dfs(Left),dfs(Right)正常结束，刚好发现二者均都是在dfs执行完之后执行，而且覆盖了dfs执行完之后所有的情况\n同时 Golang 的 **Defer(){}** 会在函数执行完并在返回之前执行，完全满足这个场景的需求，所以可以在递归函数体当中使用defer来完成对应的操作\n\n==Golang的特性：切片索引==\n切片本身就是指针，且每次操作都会影响到底层数组\n如果不在递归函数体当中使用切片之前重新对切片进行赋值，那么，之后对于底层数组的操作也会反映到之前的切片上，产生的效果就是明明原本计算好了结果但最后得到的并不是正确答案，关键就在于==后面切片的操作修改了底层数组，导致原本切片对应的结果被修改了==\n\n```golang\nfunc pathSum(root *TreeNode, targetSum int) [][]int {\n    result := make([][]int,0)\n    path := make([]int,0)\n    if root == nil {\n        return result\n    }\n    var dfs func(*TreeNode,int)\n    dfs = func(root *TreeNode,left int){\n        if root == nil{\n            return \n        }\n        path = append(path,root.Val)\n        left = left - root.Val\n        defer func() { \n            path = path[:len(path)-1]\n        }()\n        if root.Left == nil && root.Right == nil && left == 0{\n            // new := make([]int,len(path))\n            // copy(new,path)\n            // result = append(result,new)\n            result = append(result,append([]int(nil),path...))\n            return \n        }\n        dfs(root.Left,left)\n        dfs(root.Right,left)\n    }\n    dfs(root,targetSum)\n    return result\n}\n```\n\n#### **2.3.3** \n> 等待回溯来看\n> https://leetcode.cn/problems/path-sum-iii/solution/437-lu-jing-zong-he-iii-dfshui-su-qian-zhui-he-yi-/\n\n\n## **3** 中序遍历\n<font color='red'>遍历左子树，然后是根节点，然后是右子树</font>\n\n### **3.1** &ensp; 使用递归完成中序遍历\n``` golang\n\n```\n\n### **3.2** &ensp; 使用栈完成中序遍历\n```golang\nfunc inorderTraversal(root *TreeNode) []int {\n    if root == nil {\n        return []int{}\n    }\n\n    var res []int\n    var stack []*TreeNode\n    var pathStack []string\n    node := root\n\n    for node != nil || len(stack) > 0 {\n        if node != nil {\n            stack = append(stack, node)\n            pathStack = append(pathStack, fmt.Sprintf(\"%d\", node.Val))\n            node = node.Left\n        } else {\n            node = stack[len(stack)-1]\n            stack = stack[:len(stack)-1]\n            path := pathStack[len(pathStack)-1]\n            pathStack = pathStack[:len(pathStack)-1]\n\n            if node.Left == nil && node.Right == nil {\n                res = append(res, node.Val)\n\n                // 输出到达叶子节点的路径\n                fmt.Println(path)\n            }\n\n            node = node.Right\n        }\n    }\n\n    return res\n}\n```\n\n### **3.3** 找出二叉搜索树里面出现次数最多的数\n找众数就需要遍历所有的节点，二叉搜索树中序遍历的结果会是一个递增的数组，其数据特性就在于使用中序遍历的时候，所有的元素都是连续的\n``` golang\n/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc findMode(root *TreeNode) []int {\n    // 结果数组\n    ans := make([]int,0)\n    base,count,maxnum := math.MinInt64,0,0\n\n    // 使用递归的方式\n    var dfs func(*TreeNode)\n    dfs = func(root *TreeNode){\n        if root == nil {\n            return \n        }\n        dfs(root.Left)\n        if root.Val == base {\n            count++\n        }else{\n            base = root.Val\n            count = 1\n        }\n        if count == maxnum {\n            ans = append(ans,base)\n        }\n        if count > maxnum {\n            ans = []int{}\n            maxnum = count\n            ans = append(ans,base)\n        }\n        dfs(root.Right)\n    }\n    dfs(root)\n    return ans\n}\n```\n\n### **3.4** 找出二叉搜索树里面任意两个节点之间绝对值得最小值\n\nhttps://leetcode.cn/problems/minimum-distance-between-bst-nodes/\n\n```golang\nfunc minDiffInBST(root *TreeNode) int {\n    // 使用栈来中序遍历，栈顶元素就是上一遍历的节点元素\n    stack := make([]*TreeNode,0)\n    res := make([]int,0)\n    for root != nil || len(stack) > 0{\n        for root != nil {\n            stack = append(stack,root)\n            root = root.Left\n        }\n\n        node := stack[len(stack)-1]\n        stack = stack[:len(stack)-1]\n        res = append(res,node.Val)\n\n        root = node\n        root = root.Right\n    }\n    m := math.MaxInt64\n    for i:= 0; i < len(res)-1; i++{\n        r := res[i+1]-res[i]\n        m = min(m,r) \n    } \n    return m\n}\n\nfunc min(args ...int)int{\n    min := args[0]\n    for _, val := range args{\n        if val < min {\n            min = val\n        }\n    }\n    return min\n}\n```\n\n### **3.5** 一棵二叉搜索树的两个节点被交换了，恢复这颗二叉搜索树\n\n```golang\nfunc recoverTree(root *TreeNode)  {\n    // 使用递归解决这个问题\n    problem := make([]*TreeNode,0)\n    var findP func(*TreeNode)\n    findP = func(root *TreeNode){\n        if root == nil{\n            return \n        }\n        findP(root.Left)\n        // if pre == math.MaxInt64{\n        //     pre = root.Val\n        //     return\n        // }\n        // if root.Val - pre < 0{\n        //     problem = append(problem,root)\n        // }\n        // pre = root.Val\n        problem = append(problem, root)\n        findP(root.Right)\n    }\n    findP(root)\n    pre,cur := -1,-1\n    for i := 0; i < len(problem)-1; i++{\n        if problem[i].Val > problem[i+1].Val {\n            cur = i + 1\n            if pre == -1 {\n                pre = i\n            }\n        }\n    }\n    problem[pre].Val,problem[cur].Val = problem[cur].Val,problem[pre].Val\n    return \n}\n```\n\n### 删除二叉搜索树的节点\n> 题目最重要的考点就是分类，讨论各种情况下的处理方式\n\n<font sizecolor ='red'>清晰地讲出每种情况的处理办法</font>\n<font sizecolor ='red'>清晰简介地实现代码</font>\n\n\n\n\n## 后序遍历\n\n### 使用栈完成后序遍历\n\n### 迭代写法的考点\n1. 是否有右子树\n2. pre指针是不是指向当前结点的右子树","slug":"Algorithm/Golang-数据结构/Golang-算法课程--数据结构","published":1,"updated":"2023-04-22T13:24:02.164Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgtm6jq8000dlyjx30d637uz","content":"<h1 id=\"告别盲目刷题，击破算法面试\"><a href=\"#告别盲目刷题，击破算法面试\" class=\"headerlink\" title=\"告别盲目刷题，击破算法面试\"></a>告别盲目刷题，击破算法面试</h1><blockquote>\n<p>学习拉钩教育算法课程记录加个人感悟记录<br>如果有版权问题，请联系 <a href=\"mailto:&#x32;&#51;&#x37;&#x34;&#48;&#x38;&#55;&#51;&#x32;&#50;&#64;&#x71;&#113;&#46;&#x63;&#x6f;&#x6d;\">&#x32;&#51;&#x37;&#x34;&#48;&#x38;&#55;&#51;&#x32;&#50;&#64;&#x71;&#113;&#46;&#x63;&#x6f;&#x6d;</a> 删除课程部分的内容</p>\n<p>算法能力的高度，决定了个人能够解决的实战问题复杂度的上限</p>\n<p>数学基础决定了算法能力的高低</p>\n</blockquote>\n<h2 id=\"解题流程-：\"><a href=\"#解题流程-：\" class=\"headerlink\" title=\"==解题流程==：\"></a>==解题流程==：</h2><h3 id=\"四部分析法\"><a href=\"#四部分析法\" class=\"headerlink\" title=\"==四部分析法==\"></a>==四部分析法==</h3><ul>\n<li><p><strong>==模拟==</strong> ： 模拟题目的运行<br>使用简单且有一定量的小例子，将自己当作计算机来执行这个流程<br><em>一般使用题目给的较长的那个例子就可以</em><br><br>这部分也是读题和理解输入输出内容的部分，理解题意的部分<br><br>这个时候一定不能够着急，不要害怕或者是觉得麻烦，一定要耐下性子，把简单的一个逻辑过程给跑清楚，理解这段程序或者是业务需要咱们处理什么样的问题。<br><br>跑的过程，不要完全先入为主，应当以题目的要求来推进演示。<br><br>不要想着在这一步就把所有的问题都给解决，一步步推进就可以. </p>\n<br /></li>\n<li><p><strong>==规律==</strong> ： 尝试总结出题目的一般规律和特点</p>\n<p>数学规律和特性一般来说很难直接从零归纳出来，但我们可以依赖所学习的高数、线性代数、离散数学、测度论等高等数学理论当中所见到的数学计算模型来匹配，这也是这部分最重要的基础</p>\n<p>先总结一些考题可能会用到的观察特点：</p>\n<ul>\n<li>形式相关：比如 括号匹配、从1加到100，</li>\n<li>数量变化：数量变化与取模相关，数量变化呈现递推公式</li>\n<li></li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p><strong>==匹配==</strong> ： 找到符合这些特点的数据结构和算法</p>\n<ul>\n<li><p>关注数据的输入类型：对输入数据进行分类，哪一些数据进行怎样的操作</p>\n</li>\n<li><p>**==怎样匹配呢？==**：</p>\n<ul>\n<li>题目模拟的时候（这部分一般使用栈、队列、二叉树）来理解题目要求的数字变化</li>\n<li>观察结果集合，或者是原本中间的变化集合，当期符合某种数据结构的变化特征的时候，就可以选用这个数据结构</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>**==考虑边界条件==**： 考虑特殊情况<br>特殊情况：<ul>\n<li>字符串为空，字符串只有一个，两个、</li>\n<li>数组为空，数字为0或者是其他不符合规律的特殊情况</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><strong>==深度思考==</strong> ： 平时练习当中的流程，用于提高算法模型的积累<ul>\n<li>深度： 这种解法还可以怎么优化</li>\n<li>广度： 这种解法的具有普适性吗？可以推广吗？问题的限定条件变多的话，这个模型是否还可以适合。</li>\n<li>数学模式扩散： 这样特点的问题是否有对应的数学模型或者是理论描述过</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"栈：-从简单栈到单调栈，让栈问题不再困难\"><a href=\"#栈：-从简单栈到单调栈，让栈问题不再困难\" class=\"headerlink\" title=\"栈： 从简单栈到单调栈，让栈问题不再困难\"></a>栈： 从简单栈到单调栈，让栈问题不再困难</h1><h2 id=\"结构特征\"><a href=\"#结构特征\" class=\"headerlink\" title=\"结构特征\"></a>结构特征</h2><p>先进后出</p>\n<p>对栈的操作：</p>\n<ul>\n<li><strong>==pop==</strong> 弹出栈顶元素，一般来说栈中可操作的元素就是栈顶元素，其他元素也都是先pop出其上面的元素，变成栈顶元素之后再进行操作。</li>\n<li> <strong>==peek==</strong> 获取栈顶元素，只是读取操作，但并没有弹出栈顶元素</li>\n<li> <strong>==push==</strong> 将元素压入栈中</li>\n</ul>\n<h3 id=\"Golang-栈的使用\"><a href=\"#Golang-栈的使用\" class=\"headerlink\" title=\"Golang 栈的使用\"></a>Golang 栈的使用</h3><p>在 Go 中并没有直接提供Stack的方法结构，但可以使用切片非常简单地表示和使用栈、队列结构。</p>\n<p> 先进后出的数据结构，使用**==切片==**表示，压入栈的操作就是往切片中添加元素，弹出栈的操作就是输出末尾元素，并将切片缩小为：<code>[:len(stack)-1]</code></p>\n<p>以下为栈的代码模板实现：</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Stack <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">    Stack []<span class=\"keyword\">interface</span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *Stack)</span></span>push(x <span class=\"keyword\">interface</span>&#123;&#125;)&#123;</span><br><span class=\"line\">    s = <span class=\"built_in\">append</span>(s,x)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *Stack)</span></span>pop()&#123;</span><br><span class=\"line\">    s = s[:<span class=\"built_in\">len</span>(s)<span class=\"number\">-1</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *Stack)</span></span>peek()(x <span class=\"keyword\">interface</span>&#123;&#125;)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s[<span class=\"built_in\">len</span>(s)<span class=\"number\">-1</span>]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>关键在于记住：</p>\n<ul>\n<li>栈顶元素 —&gt; 切片末尾元素</li>\n<li>切片是左闭右开，所以pop操作是 s = s[:len(s)-1], 但如果是队列pop出第一个元素就需要往后再移动一位 s = s[1:] 而不是 s = s[0:]</li>\n</ul>\n<h2 id=\"典型题目\"><a href=\"#典型题目\" class=\"headerlink\" title=\"典型题目\"></a>典型题目</h2><h3 id=\"判断字符串是否合法\"><a href=\"#判断字符串是否合法\" class=\"headerlink\" title=\"判断字符串是否合法\"></a>判断字符串是否合法</h3><p>题目：<a href=\"https://leetcode.cn/problems/valid-parentheses/\">https://leetcode.cn/problems/valid-parentheses/</a></p>\n<h4 id=\"正确解法和流程\"><a href=\"#正确解法和流程\" class=\"headerlink\" title=\"正确解法和流程\"></a>正确解法和流程</h4><p><a href=\"https://leetcode.cn/link/?target=https://www.bilibili.com/video/BV1AF411w78g\">https://leetcode.cn/link/?target=https://www.bilibili.com/video/BV1AF411w78g</a></p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">isValid</span><span class=\"params\">(s <span class=\"type\">string</span>)</span></span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    n := <span class=\"built_in\">len</span>(s)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> n % <span class=\"number\">2</span> == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    pairs := <span class=\"keyword\">map</span>[<span class=\"type\">byte</span>]<span class=\"type\">byte</span>&#123;</span><br><span class=\"line\">        <span class=\"string\">&#x27;)&#x27;</span>: <span class=\"string\">&#x27;(&#x27;</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;]&#x27;</span>: <span class=\"string\">&#x27;[&#x27;</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;&#125;&#x27;</span>: <span class=\"string\">&#x27;&#123;&#x27;</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    stack := []<span class=\"type\">byte</span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; n; i++ &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> pairs[s[i]] &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(stack) == <span class=\"number\">0</span> || stack[<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>] != pairs[s[i]] &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            stack = stack[:<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>]</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            stack = <span class=\"built_in\">append</span>(stack, s[i])</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(stack) == <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"个人解法和流程\"><a href=\"#个人解法和流程\" class=\"headerlink\" title=\"个人解法和流程\"></a>个人解法和流程</h4><blockquote>\n<p>问题集中体现在数据特性处理判断太过分散，属实是缝缝补补有一年<br>对输入数据进行分类，哪一些数据进行怎样的操作</p>\n<ul>\n<li>输入的是左括号应该入栈</li>\n<li>输入的是右括号应该做判断<br /></li>\n</ul>\n</blockquote>\n<p>我的代码是：</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">isValid</span><span class=\"params\">(s <span class=\"type\">string</span>)</span></span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    l := <span class=\"built_in\">len</span>(s)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> l%<span class=\"number\">2</span> != <span class=\"number\">0</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    stack := <span class=\"built_in\">make</span>([]<span class=\"type\">rune</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    m := <span class=\"keyword\">map</span>[<span class=\"type\">rune</span>]<span class=\"type\">rune</span>&#123;</span><br><span class=\"line\">        <span class=\"string\">&#x27;]&#x27;</span>:<span class=\"string\">&#x27;[&#x27;</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;)&#x27;</span>:<span class=\"string\">&#x27;(&#x27;</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;&#125;&#x27;</span>:<span class=\"string\">&#x27;&#123;&#x27;</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _,v := <span class=\"keyword\">range</span> s&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> v == <span class=\"string\">&#x27;[&#x27;</span> ||v == <span class=\"string\">&#x27;&#123;&#x27;</span> ||v == <span class=\"string\">&#x27;(&#x27;</span>&#123;</span><br><span class=\"line\">            stack = <span class=\"built_in\">append</span>(stack,v)</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(stack) == <span class=\"number\">0</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> stack[<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>] == m[v]&#123;</span><br><span class=\"line\">            stack = stack[:<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>]</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> m[v] != <span class=\"number\">0</span> &#123;<span class=\"keyword\">return</span> <span class=\"literal\">false</span>&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(stack) == <span class=\"number\">0</span>&#123;<span class=\"keyword\">return</span> <span class=\"literal\">true</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述在判断栈顶元素的时候逻辑不够清晰，所以加了很多的if来补足条件，我们看例子当中所给的逻辑顺序：</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    pairs := <span class=\"keyword\">map</span>[<span class=\"type\">byte</span>]<span class=\"type\">byte</span>&#123;</span><br><span class=\"line\">    <span class=\"string\">&#x27;)&#x27;</span>: <span class=\"string\">&#x27;(&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;]&#x27;</span>: <span class=\"string\">&#x27;[&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;&#125;&#x27;</span>: <span class=\"string\">&#x27;&#123;&#x27;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">stack := []<span class=\"type\">byte</span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; n; i++ &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> pairs[s[i]] &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(stack) == <span class=\"number\">0</span> || stack[<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>] != pairs[s[i]] &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        stack = stack[:<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>]</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        stack = <span class=\"built_in\">append</span>(stack, s[i])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(stack) == <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n\n<p>关键差距就在于这一句话：<code>pairs[s[i]] &gt; 0 </code>, 这个判断对输入的数据做了一次分类，依据上面的map结构可知，这句话 &lt; 0 时候标识map当中没有存储对应的对象，而map中存储的是所有的左括号，所以这个判断的作用是<strong>当输入是右括号的时候进入函数</strong>，然后逻辑体依据输入是右括号判断，如果当前栈里面没有元素或者是栈顶元素与右括号不匹配那么就返回false<br><br>实际上我写的函数最后夜市做了类似的判断，但显然没有考虑数据分类的情况。</p>\n<h3 id=\"判断大鱼吃小鱼最后留下的鱼\"><a href=\"#判断大鱼吃小鱼最后留下的鱼\" class=\"headerlink\" title=\"判断大鱼吃小鱼最后留下的鱼\"></a>判断大鱼吃小鱼最后留下的鱼</h3><p>题目：</p>\n<p>近似题目：<a href=\"https://www.nowcoder.com/questionTerminal/3fdfc63015df42c6a78fdae46709fa69?f=discussion\">https://www.nowcoder.com/questionTerminal/3fdfc63015df42c6a78fdae46709fa69?f=discussion</a></p>\n<br />\n\n<h4 id=\"正确解法和流程-1\"><a href=\"#正确解法和流程-1\" class=\"headerlink\" title=\"正确解法和流程\"></a>正确解法和流程</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * </span></span><br><span class=\"line\"><span class=\"comment\">     * @param N int整型 N条鱼</span></span><br><span class=\"line\"><span class=\"comment\">     * @param A int整型vector 每条鱼的体积为Ai</span></span><br><span class=\"line\"><span class=\"comment\">     * @return int整型</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">P</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> x, t;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">solve</span><span class=\"params\">(<span class=\"type\">int</span> N, vector&lt;<span class=\"type\">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class=\"line\">        stack&lt;P&gt; S;</span><br><span class=\"line\">        <span class=\"type\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=N<span class=\"number\">-1</span>;i&gt;=<span class=\"number\">0</span>;i--)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> t = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(!S.<span class=\"built_in\">empty</span>() &amp;&amp; A[i]&gt;S.<span class=\"built_in\">top</span>().x)&#123;</span><br><span class=\"line\">                t = <span class=\"built_in\">max</span>(S.<span class=\"built_in\">top</span>().t, t+<span class=\"number\">1</span>);</span><br><span class=\"line\">                S.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            S.<span class=\"built_in\">push</span>(&#123;A[i], t&#125;);</span><br><span class=\"line\">            cnt = <span class=\"built_in\">max</span>(cnt, t);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cnt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"个人解法和流程-1\"><a href=\"#个人解法和流程-1\" class=\"headerlink\" title=\"个人解法和流程\"></a>个人解法和流程</h4><p>由于找不到相同的题目，就找了类似的题目，但是解题的思路不太一样<br>图片上的大鱼吃小鱼，只需要每次比较栈顶元素和新进来的元素大小即可，当大于的时候，就不做操作，当栈顶元素小于输入元素的时候，pop出栈顶元素并push进入这个最大值，最后栈中元素就是结果。这个过程当中几处需要重视的地方是：</p>\n<ul>\n<li>当鱼的方向一致时候，大鱼并不会把同方向的小鱼给吃了【可能不论大小鱼的速度相同（bushi）】，而如果小鱼在左，大鱼在右，方向不同，则也不会吃</li>\n</ul>\n<p>牛客网的题目则加了非常多的条件和限制，是对栈问题的一个较大的变化</p>\n<blockquote>\n<p>对比上述两个题目可以观察到：<br><font color ='blue'> 1. 消除的行为不同</font><br>  括号匹配中，消除行为是配对的两者都会消除，也就是栈顶元素和输入元素一起被消除<br>  大鱼吃小鱼中，消除行为是配对的两者中会有一个被消除<br>–&gt; 是否入栈和出栈的判断<br><font color ='blue'> 2. 栈中的内容不同</font><br>  括号匹配当中，栈中存放的就是内容本身<br>  大鱼吃小鱼当中，栈里存放的是内容的索引，可以通过索引找到内容<br><font color ='blue'> 3. 弹栈的方式也不相同</font><br>  括号匹配只需要每次弹出一个元素就可以<br>  大鱼则需要用while语句一直弹出到满足某个条件才停止</p>\n</blockquote>\n<h2 id=\"栈问题的特征和解决流程\"><a href=\"#栈问题的特征和解决流程\" class=\"headerlink\" title=\"栈问题的特征和解决流程\"></a>栈问题的特征和解决流程</h2><h3 id=\"pop-行为不同\"><a href=\"#pop-行为不同\" class=\"headerlink\" title=\"pop 行为不同\"></a>pop 行为不同</h3><p>pop【弹栈的操作不一样】<br>常见的就是每次循环都判断栈顶元素的特点而pop或者push或者不操作，但这样必须得是连续性的元素才有这样的特征</p>\n<p><strong>==在弹栈的时候，是否一定要满足某个条件才停止弹栈==</strong><br>也就是说当输入元素之后需要将其和站内其他的元素进行比较，在使用的时候尤其要注意迭代过程</p>\n<h3 id=\"栈中存储内容不相同\"><a href=\"#栈中存储内容不相同\" class=\"headerlink\" title=\"栈中存储内容不相同\"></a>栈中存储内容不相同</h3><p>是否栈中存储数据、还是存储索引、还是存储一个自建的新的结构</p>\n<h3 id=\"栈顶元素的含义不相同\"><a href=\"#栈顶元素的含义不相同\" class=\"headerlink\" title=\"栈顶元素的含义不相同\"></a>栈顶元素的含义不相同</h3><h2 id=\"单调栈\"><a href=\"#单调栈\" class=\"headerlink\" title=\"单调栈\"></a>单调栈</h2><p>单调栈是指栈中元素必须按照升序排列的栈或者是降序排列的栈</p>\n<p>单调栈分为：</p>\n<ul>\n<li><p>递增栈：<br>  栈中元素从左到右遵守从小到大的顺序<br>  入栈时候，当<strong>入栈元素小于栈顶元素</strong>就会pop出栈顶元素，直到入栈元素大于栈顶元素<br>  特点是：<br>  入栈小数会消除栈内大数</p>\n</li>\n<li><p>递减栈<br>  栈中元素从左到右遵守从大到小的顺序<br>  入栈时候，当<strong>入栈元素大于栈顶元素</strong>就会pop出栈顶元素，直到入栈元素小于栈顶元素<br>  特点是：<br>  入栈大数会消除栈内小数</p>\n</li>\n</ul>\n<h3 id=\"典型代码：\"><a href=\"#典型代码：\" class=\"headerlink\" title=\"典型代码：\"></a>典型代码：</h3><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stack := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"comment\">/**递增栈的入栈</span></span><br><span class=\"line\"><span class=\"comment\">* 用for 循环出栈，直到栈顶元素满足递增栈的要求</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> <span class=\"built_in\">len</span>(stack)&gt; <span class=\"number\">0</span> &amp;&amp; A[i] &gt; stack[<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>]&#123;</span><br><span class=\"line\">    <span class=\"comment\">// pop出栈内比 A[i]小但却在前面的元素</span></span><br><span class=\"line\">    stack = stack[:<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">stack = <span class=\"built_in\">append</span>(stack,A[i])</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"找到当前数字右边最小的对应数字\"><a href=\"#找到当前数字右边最小的对应数字\" class=\"headerlink\" title=\"找到当前数字右边最小的对应数字\"></a>找到当前数字右边最小的对应数字</h3><h3 id=\"取k个字符，求字典序最小的组合\"><a href=\"#取k个字符，求字典序最小的组合\" class=\"headerlink\" title=\"取k个字符，求字典序最小的组合\"></a>取k个字符，求字典序最小的组合</h3><blockquote>\n<p>字典序：</p>\n<ul>\n<li>对单个元素按照ascii 表中大小顺序排列</li>\n<li>多个元素时，按照从左到右顺序，先从高位字典排序，然后在相同高位中按照地位再字典排序</li>\n</ul>\n</blockquote>\n<h3 id=\"给定一个数组，数组中元素代表模板的高度，请你求出相邻木板能剪出的最大矩形面积\"><a href=\"#给定一个数组，数组中元素代表模板的高度，请你求出相邻木板能剪出的最大矩形面积\" class=\"headerlink\" title=\"给定一个数组，数组中元素代表模板的高度，请你求出相邻木板能剪出的最大矩形面积\"></a>给定一个数组，数组中元素代表模板的高度，请你求出相邻木板能剪出的最大矩形面积</h3><blockquote>\n<p>和求最大容积是一个题目</p>\n</blockquote>\n<br />\n\n<h2 id=\"leetcode-题目汇总\"><a href=\"#leetcode-题目汇总\" class=\"headerlink\" title=\"leetcode 题目汇总\"></a>leetcode 题目汇总</h2><blockquote>\n<p>以leetcode 题目为例子</p>\n</blockquote>\n<p>相关栈的题目汇总：<br>[1][<a href=\"https://leetcode.cn/problem-list/xb9nqhhg/?topicSlugs=stack&amp;page=1%5D\">https://leetcode.cn/problem-list/xb9nqhhg/?topicSlugs=stack&amp;page=1]</a><br>[2][<a href=\"https://leetcode.cn/problem-list/e8X3pBZi/?page=1&amp;topicSlugs=heap-priority-queue%5D\">https://leetcode.cn/problem-list/e8X3pBZi/?page=1&amp;topicSlugs=heap-priority-queue]</a><br>[3][<a href=\"https://leetcode.cn/problem-list/2cktkvj/?page=1&amp;topicSlugs=stack%5D\">https://leetcode.cn/problem-list/2cktkvj/?page=1&amp;topicSlugs=stack]</a></p>\n<h1 id=\"队列：FIFO-队列与单调队列的深挖与扩展\"><a href=\"#队列：FIFO-队列与单调队列的深挖与扩展\" class=\"headerlink\" title=\"队列：FIFO 队列与单调队列的深挖与扩展\"></a>队列：FIFO 队列与单调队列的深挖与扩展</h1><p>先进先出，是共同特征</p>\n<p>类别上可以分出：</p>\n<ul>\n<li>FIFO队列</li>\n<li>单调队列</li>\n</ul>\n<h2 id=\"FIFO队列\"><a href=\"#FIFO队列\" class=\"headerlink\" title=\"FIFO队列\"></a>FIFO队列</h2><p><strong>==Push 元素时候， 总是将放在元素放在队列尾部，也就是操作 fifo[len(fifo)-1]==</strong><br><strong>==Pop 元素时候，总是将队列首部的元素扔掉 ，也就是操作 fifo = fifo[1:]==</strong></p>\n<h3 id=\"二叉树的层次遍历（两种方法）\"><a href=\"#二叉树的层次遍历（两种方法）\" class=\"headerlink\" title=\"二叉树的层次遍历（两种方法）\"></a>二叉树的层次遍历（两种方法）</h3><ul>\n<li><p>规律：<br>广度遍历（层次遍历）：由于二叉树的特点，当拿到第N层的结点A之后，可以通过 A 的left，right指针拿到下一层的节点</p>\n</li>\n<li><p><em>但是与A在同一层的节点还有其他吗，这个时候就需要按层来存储节点，不能直接使用递归</em>*</p>\n   <br />\n   顺序输出：每层输出时，排在左边的节点，它的子节点同样排在下一层的最左边</li>\n</ul>\n<p>–&gt; <strong>==题目具备广度遍历（分层遍历）的特点 和 顺序输出的特点 ，应该想到应用FIFO队列==</strong></p>\n<ul>\n<li>边界<br>特殊判断： 如果发现是一棵空二叉树，就直接返回空结果<br>==制定一个规则==： 不要让空指针进入到FIFO队列（一些编程的亮点）</li>\n</ul>\n<p><font color = 'red'> 非常重要的概念： QSize 表示当前层数 </font></p>\n<h4 id=\"层次遍历二叉树\"><a href=\"#层次遍历二叉树\" class=\"headerlink\" title=\"层次遍历二叉树\"></a>层次遍历二叉树</h4><p>题目链接：<a href=\"https://leetcode.cn/problems/binary-tree-level-order-traversal/submissions/\">https://leetcode.cn/problems/binary-tree-level-order-traversal/submissions/</a></p>\n<h5 id=\"解题思路1\"><a href=\"#解题思路1\" class=\"headerlink\" title=\"解题思路1\"></a>解题思路1</h5><p>关键思路在于将每一层的节点都存在FIFO队列里面，在每次遍历的时候从左到右pop出该层的节点，同时在队尾加入他的左右孩子</p>\n<p>队首pop出当层节点，队尾append下一层的孩子节点<br>QSize 记录当层的节点数量</p>\n<p>时间复杂度是O(n), 空间复杂度由QSize决定O(K),K表示QSize最大，也就是存储的一层节点数量最多的时候</p>\n<h5 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h5><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * type TreeNode struct &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     Val int</span></span><br><span class=\"line\"><span class=\"comment\"> *     Left *TreeNode</span></span><br><span class=\"line\"><span class=\"comment\"> *     Right *TreeNode</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">levelOrder</span><span class=\"params\">(root *TreeNode)</span></span> [][]<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建FIFO 队列来存储遍历的过程</span></span><br><span class=\"line\">    fifo := <span class=\"built_in\">make</span>([]*TreeNode,<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"comment\">// QSize 表示当前遍历的层</span></span><br><span class=\"line\">    QSize := <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"comment\">// 初始化最终结果</span></span><br><span class=\"line\">    result := <span class=\"built_in\">make</span>([][]<span class=\"type\">int</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> root == <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//将根节点入栈</span></span><br><span class=\"line\">    fifo = <span class=\"built_in\">append</span>(fifo,root)</span><br><span class=\"line\">    <span class=\"comment\">// 开始层序遍历，只要当前队列不为空</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"built_in\">len</span>(fifo) &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建结果数组用于存储当层pop出的元素值</span></span><br><span class=\"line\">        tmp := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"comment\">// 当层元素QSize全部遍历以此，这里不能用len(fifo)，因为fifo的长度是在变化的</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i := QSize;i &gt; <span class=\"number\">0</span>;i--&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 拿出队列头元素</span></span><br><span class=\"line\">            node := fifo[<span class=\"number\">0</span>]</span><br><span class=\"line\">            <span class=\"comment\">// 判断他的左孩子是否为空</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> node.Left!= <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">                fifo = <span class=\"built_in\">append</span>(fifo,node.Left)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 判断他的右孩子是否为空</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> node.Right != <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">                fifo = <span class=\"built_in\">append</span>(fifo,node.Right)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 将该节点的值存入结果</span></span><br><span class=\"line\">            tmp = <span class=\"built_in\">append</span>(tmp,node.Val)</span><br><span class=\"line\">            <span class=\"comment\">// 推出队首元素</span></span><br><span class=\"line\">            fifo = fifo[<span class=\"number\">1</span>:]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 将结果 tmp 存入到结果数组当中</span></span><br><span class=\"line\">        result = <span class=\"built_in\">append</span>(result,tmp)</span><br><span class=\"line\">        <span class=\"comment\">// 重新计算当前层的节点数量</span></span><br><span class=\"line\">        QSize = <span class=\"built_in\">len</span>(fifo)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"官方题解\"><a href=\"#官方题解\" class=\"headerlink\" title=\"官方题解\"></a>官方题解</h5><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">levelOrder</span><span class=\"params\">(root *TreeNode)</span></span> [][]<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    ret := [][]<span class=\"type\">int</span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> root == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    q := []*TreeNode&#123;root&#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; <span class=\"built_in\">len</span>(q) &gt; <span class=\"number\">0</span>; i++ &#123;</span><br><span class=\"line\">        ret = <span class=\"built_in\">append</span>(ret, []<span class=\"type\">int</span>&#123;&#125;)</span><br><span class=\"line\">        p := []*TreeNode&#123;&#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j := <span class=\"number\">0</span>; j &lt; <span class=\"built_in\">len</span>(q); j++ &#123;</span><br><span class=\"line\">            node := q[j]</span><br><span class=\"line\">            ret[i] = <span class=\"built_in\">append</span>(ret[i], node.Val)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> node.Left != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">                p = <span class=\"built_in\">append</span>(p, node.Left)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> node.Right != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">                p = <span class=\"built_in\">append</span>(p, node.Right)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        q = p</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"解题思路2\"><a href=\"#解题思路2\" class=\"headerlink\" title=\"解题思路2\"></a>解题思路2</h5><p>使用链表来解决问题</p>\n<h4 id=\"锯齿状层次遍历\"><a href=\"#锯齿状层次遍历\" class=\"headerlink\" title=\"锯齿状层次遍历\"></a>锯齿状层次遍历</h4><p>题目链接：<a href=\"https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/\">https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/</a></p>\n<h5 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h5><p>层次遍历的基础上加一个qs，表示当前层是从左到右还是从右到左</p>\n<p>**==本题当中所犯的错误：==**：</p>\n<ul>\n<li>每一轮都需要重新计算qsize,一定不要忘了这一点</li>\n<li>tmp 接收的时候还是按照栈的pop逻辑，所以顺序上还需要再反一次</li>\n<li>题目样例当中root是按照从左到右遍历过一次来计算的</li>\n</ul>\n<h5 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h5><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * type TreeNode struct &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     Val int</span></span><br><span class=\"line\"><span class=\"comment\"> *     Left *TreeNode</span></span><br><span class=\"line\"><span class=\"comment\"> *     Right *TreeNode</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">zigzagLevelOrder</span><span class=\"params\">(root *TreeNode)</span></span> [][]<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//结果数组</span></span><br><span class=\"line\">    result := <span class=\"built_in\">make</span>([][]<span class=\"type\">int</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"comment\">//全局的fifo队列</span></span><br><span class=\"line\">    fifo := <span class=\"built_in\">make</span>([]*TreeNode,<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"comment\">// Qsize 表示当前层的节点数，qs 表示该层的遍历顺序，0表示从左到右，1表示从右到左</span></span><br><span class=\"line\">    Qsize ,qs := <span class=\"number\">1</span> , <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果树中没有节点则直接返回</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> root == <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 将 root 放入队列</span></span><br><span class=\"line\">    fifo = <span class=\"built_in\">append</span>(fifo,root)</span><br><span class=\"line\">    <span class=\"comment\">//遍历整棵树</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"built_in\">len</span>(fifo) &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        tmp := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i:= <span class=\"number\">1</span>; Qsize &gt;= i &amp;&amp; qs == <span class=\"number\">0</span> ;i++&#123;</span><br><span class=\"line\">            node := fifo[Qsize-i]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> node.Right != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">                fifo = <span class=\"built_in\">append</span>(fifo,node.Right)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> node.Left != <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">                fifo = <span class=\"built_in\">append</span>(fifo,node.Left)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            tmp = <span class=\"built_in\">append</span>(tmp,node.Val)                </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i:= <span class=\"number\">1</span>; Qsize &gt;= i &amp;&amp; qs == <span class=\"number\">1</span> ;i++&#123;</span><br><span class=\"line\">            node := fifo[Qsize-i]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> node.Left != <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">                fifo = <span class=\"built_in\">append</span>(fifo,node.Left)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> node.Right != <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">                fifo = <span class=\"built_in\">append</span>(fifo,node.Right)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            tmp = <span class=\"built_in\">append</span>(tmp,node.Val)                </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        fifo = fifo[Qsize:]</span><br><span class=\"line\">        Qsize = <span class=\"built_in\">len</span>(fifo)</span><br><span class=\"line\">        result = <span class=\"built_in\">append</span>(result,tmp)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> qs == <span class=\"number\">1</span>&#123;</span><br><span class=\"line\">            qs = <span class=\"number\">0</span></span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            qs = <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"倒序层次遍历\"><a href=\"#倒序层次遍历\" class=\"headerlink\" title=\"倒序层次遍历\"></a>倒序层次遍历</h4><p>题目链接：<a href=\"https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/\">https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/</a></p>\n<h5 id=\"解题思路-1\"><a href=\"#解题思路-1\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h5><p>从题目要求当中可以读出，是在之前的层序遍历基础上把结果倒过来输出，那么会比较自然想到可以在使用一个栈用来存储中间结果</p>\n<h5 id=\"代码-2\"><a href=\"#代码-2\" class=\"headerlink\" title=\"代码\"></a>代码</h5><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * type TreeNode struct &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     Val int</span></span><br><span class=\"line\"><span class=\"comment\"> *     Left *TreeNode</span></span><br><span class=\"line\"><span class=\"comment\"> *     Right *TreeNode</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">levelOrderBottom</span><span class=\"params\">(root *TreeNode)</span></span> [][]<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 构造全局fifo队列</span></span><br><span class=\"line\">    fifo := <span class=\"built_in\">make</span>([]*TreeNode,<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"comment\">// 构造结果栈</span></span><br><span class=\"line\">    stack := <span class=\"built_in\">make</span>([][]<span class=\"type\">int</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">    result := <span class=\"built_in\">make</span>([][]<span class=\"type\">int</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"comment\">//表示当前层的节点数量</span></span><br><span class=\"line\">    Qsize := <span class=\"number\">1</span></span><br><span class=\"line\">    fifo = <span class=\"built_in\">append</span>(fifo,root)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> root == <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"built_in\">len</span>(fifo) &gt; <span class=\"number\">0</span>&#123;</span><br><span class=\"line\">        tmp := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> Qsize &gt; <span class=\"number\">0</span>&#123;</span><br><span class=\"line\">            node:= fifo[<span class=\"number\">0</span>]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> node.Left != <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">                fifo =<span class=\"built_in\">append</span>(fifo,node.Left)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> node.Right != <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">                fifo = <span class=\"built_in\">append</span>(fifo,node.Right)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            Qsize--</span><br><span class=\"line\">            fifo = fifo[<span class=\"number\">1</span>:]</span><br><span class=\"line\">            tmp = <span class=\"built_in\">append</span>(tmp,node.Val)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        stack = <span class=\"built_in\">append</span>(stack,tmp)</span><br><span class=\"line\">        Qsize = <span class=\"built_in\">len</span>(fifo)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将栈中元素pop 到结果当中</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"built_in\">len</span>(stack) &gt; <span class=\"number\">0</span>&#123;</span><br><span class=\"line\">        result = <span class=\"built_in\">append</span>(result,stack[<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>])</span><br><span class=\"line\">        stack = stack[:<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"循环队列\"><a href=\"#循环队列\" class=\"headerlink\" title=\"循环队列\"></a>循环队列</h2><p>设计一个可以容纳 k 个元素的循环队列，需要实现以下接口：</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> ringQueue <span class=\"keyword\">interface</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//构造函数，参数k表示这个循环队列最多容纳k个元素</span></span><br><span class=\"line\">    CircularQueue(<span class=\"type\">int</span>)</span><br><span class=\"line\">    <span class=\"comment\">//将value放到队列中，成功返回true</span></span><br><span class=\"line\">    EnQueue(<span class=\"type\">int</span>) <span class=\"type\">bool</span></span><br><span class=\"line\">    <span class=\"comment\">// 删除队首元素，成功返回true</span></span><br><span class=\"line\">    DeQueue() <span class=\"type\">bool</span></span><br><span class=\"line\">    <span class=\"comment\">// 得到队首元素，如果队列为空，返回-1</span></span><br><span class=\"line\">    Front() <span class=\"type\">int</span></span><br><span class=\"line\">    <span class=\"comment\">// 得到队尾元素，如果队列为空，返回-1</span></span><br><span class=\"line\">    Rear() <span class=\"type\">int</span></span><br><span class=\"line\">    <span class=\"comment\">// 查看循环队列是否为空</span></span><br><span class=\"line\">    isEmpty() <span class=\"type\">bool</span></span><br><span class=\"line\">    <span class=\"comment\">// 查看队列是否已经放满k个元素</span></span><br><span class=\"line\">    isFull() <span class=\"type\">bool</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>==循环队列的重点在于==: <font color = 'red'>循环使用固定空间</font></strong></li>\n<li><strong>==难点在于==： <font color='red'>控制好 Front/Rear两个首位指示器</font></strong></li>\n</ul>\n<h3 id=\"表示方法1\"><a href=\"#表示方法1\" class=\"headerlink\" title=\"表示方法1\"></a>表示方法1</h3><p>使用 <code>used</code>、<code>front</code>、<code>rear</code> 三个变量来控制，其中<code>used, front</code>都代表的是数组的下标</p>\n<p>注意以下几点：</p>\n<ul>\n<li>index = i 的后一个是i+1，前一个是i+1</li>\n<li>index = k-1 的后一个就是index=0</li>\n<li>index = 0 的前一个是 index = k-1</li>\n<li><em>==可以使用取模的方式统一处理==:</em>*<br><font color='red'> index = i 的后一个元素下标是（i+1）% k</font><br><font color='red'> index = i 的前一个元素下标是（i-1+k）% k</font><br><font color='blue'>所有的循环数组下标的处理都需要按照这个取模的方式</font></li>\n</ul>\n<p>参考的实例代码如下：</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> MyCircularQueue <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    queue  []<span class=\"type\">int</span></span><br><span class=\"line\">    rear   <span class=\"type\">int</span></span><br><span class=\"line\">    front  <span class=\"type\">int</span></span><br><span class=\"line\">    used   <span class=\"type\">int</span></span><br><span class=\"line\">    length <span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">CircularQueue</span><span class=\"params\">(k <span class=\"type\">int</span>)</span></span> ringQueue &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;MyCircularQueue&#123;</span><br><span class=\"line\">        queue:  <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, k),</span><br><span class=\"line\">        rear:   <span class=\"number\">0</span>,</span><br><span class=\"line\">        front:  <span class=\"number\">0</span>,</span><br><span class=\"line\">        used:   <span class=\"number\">0</span>,</span><br><span class=\"line\">        length: k,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(q *MyCircularQueue)</span></span> EnQueue(value <span class=\"type\">int</span>) <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> q.isFull() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span> </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    q.queue[q.rear] = value</span><br><span class=\"line\">    q.rear = (q.rear + <span class=\"number\">1</span>) % q.length</span><br><span class=\"line\">    q.used++</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(q *MyCircularQueue)</span></span> DeQueue() <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> q.isEmpty() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    q.front = (q.front + <span class=\"number\">1</span>) % q.length</span><br><span class=\"line\">    q.used--</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(q *MyCircularQueue)</span></span> Front() <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> q.used == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> q.queue[q.front]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(q *MyCircularQueue)</span></span> Rear() <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> q.used == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> q.queue[(q.rear<span class=\"number\">-1</span>+q.length)%q.length]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(q *MyCircularQueue)</span></span> isEmpty() <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> q.used == <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(q *MyCircularQueue)</span></span> isFull() <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> q.used == q.length</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>备注：<br>在 <code>DeQueue()</code> 方法中，删除队首元素时并不会真的删除该元素，而是通过移动 <code>front</code> 指针来达到删除的效果。</p>\n<p>循环队列是一个环状的数据结构，可以想象成沿着环形路径移动指针。在实现循环队列时，每当删除队首元素时，我们需要将 <code>front</code> 指针向前移一位，指向队列中的下一个元素，这样队列中原来的第二个元素就成为了新的头部元素。这里使用 “指向队列中的下一个元素” 实际上是模运算的作用，如 <code>(i+1) % n</code> 将会得到指向 <code>i</code> 在循环数组中下一个元素的索引值。</p>\n<p>而在这个移动指针的过程中，由于队列的前面已经没有元素，所以我们不需要将队首元素真正地删除。相反，仅需要更新 <code>front</code> 指针，让它指向目前第一个元素，后面再添加新的元素，也会覆盖掉先前的元素，实现对队列的循环利用。</p>\n<h3 id=\"表示方法2\"><a href=\"#表示方法2\" class=\"headerlink\" title=\"表示方法2\"></a>表示方法2</h3><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> MyCircularQueue <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用 k + 1 ，也就是多余一个空格的循环队列来设计</span></span><br><span class=\"line\">    queue []<span class=\"type\">int</span></span><br><span class=\"line\">    front <span class=\"type\">int</span></span><br><span class=\"line\">    rear <span class=\"type\">int</span></span><br><span class=\"line\">    capacity <span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Constructor</span><span class=\"params\">(k <span class=\"type\">int</span>)</span></span> MyCircularQueue &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> MyCircularQueue&#123;</span><br><span class=\"line\">        queue: <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>,k+<span class=\"number\">1</span>),</span><br><span class=\"line\">        front: <span class=\"number\">0</span>,</span><br><span class=\"line\">        rear: <span class=\"number\">0</span>,</span><br><span class=\"line\">        capacity: k+<span class=\"number\">1</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyCircularQueue)</span></span> EnQueue(value <span class=\"type\">int</span>) <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> this.IsFull()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    this.queue[this.rear] = value</span><br><span class=\"line\">    this.rear = (this.rear + <span class=\"number\">1</span>)%this.capacity</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyCircularQueue)</span></span> DeQueue() <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> this.IsEmpty()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    this.front = (this.front+<span class=\"number\">1</span>)%this.capacity</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyCircularQueue)</span></span> Front() <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> this.IsEmpty() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> this.queue[this.front]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyCircularQueue)</span></span> Rear() <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> this.IsEmpty()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    rearPosition := (this.rear<span class=\"number\">-1</span>+this.capacity)%this.capacity</span><br><span class=\"line\">    <span class=\"keyword\">return</span> this.queue[rearPosition]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyCircularQueue)</span></span> IsEmpty() <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> this.rear ==this.front</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyCircularQueue)</span></span> IsFull() <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (this.rear+<span class=\"number\">1</span>)%this.capacity == this.front</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Your MyCircularQueue object will be instantiated and called as such:</span></span><br><span class=\"line\"><span class=\"comment\"> * obj := Constructor(k);</span></span><br><span class=\"line\"><span class=\"comment\"> * param_1 := obj.EnQueue(value);</span></span><br><span class=\"line\"><span class=\"comment\"> * param_2 := obj.DeQueue();</span></span><br><span class=\"line\"><span class=\"comment\"> * param_3 := obj.Front();</span></span><br><span class=\"line\"><span class=\"comment\"> * param_4 := obj.Rear();</span></span><br><span class=\"line\"><span class=\"comment\"> * param_5 := obj.IsEmpty();</span></span><br><span class=\"line\"><span class=\"comment\"> * param_6 := obj.IsFull();</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"循环双向队列\"><a href=\"#循环双向队列\" class=\"headerlink\" title=\"循环双向队列\"></a>循环双向队列</h3><h4 id=\"解题思路-2\"><a href=\"#解题思路-2\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h4><p><strong>==犯错的地方：==</strong><br><font color='red'> InsertFront的时候，需要先移动front向前一位，然后再把值插进去</font><br>最开始想的，直接让front和rear都指向一个空白的空间，那么就需要在插入的时候先将front向前移动两位，但这样的话就会浪费一个数值的空间，因为多余一个位就完全可以满足要求</p>\n<p>使用k+1的情况，如果是在LRU缓存或者是Ringbuffer当中还需要考虑，将队尾[或者是队中]的元素插入到队首，也就是将最近使用的元素放到前面</p>\n<h4 id=\"代码-3\"><a href=\"#代码-3\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> MyCircularDeque <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    queue []<span class=\"type\">int</span></span><br><span class=\"line\">    front <span class=\"type\">int</span></span><br><span class=\"line\">    rear <span class=\"type\">int</span> </span><br><span class=\"line\">    capacity <span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Constructor</span><span class=\"params\">(k <span class=\"type\">int</span>)</span></span> MyCircularDeque &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> MyCircularDeque&#123;</span><br><span class=\"line\">        queue: <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>,k+<span class=\"number\">1</span>),</span><br><span class=\"line\">        front: <span class=\"number\">0</span>,</span><br><span class=\"line\">        rear: <span class=\"number\">0</span>,</span><br><span class=\"line\">        capacity: k+<span class=\"number\">1</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyCircularDeque)</span></span> InsertFront(value <span class=\"type\">int</span>) <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> this.IsFull()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    this.front = (this.front<span class=\"number\">-1</span> + this.capacity)%this.capacity</span><br><span class=\"line\">    this.queue[this.front] = value</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyCircularDeque)</span></span> InsertLast(value <span class=\"type\">int</span>) <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> this.IsFull()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    this.queue[this.rear] = value</span><br><span class=\"line\">    this.rear = (this.rear+<span class=\"number\">1</span>)%this.capacity</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyCircularDeque)</span></span> DeleteFront() <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> this.IsEmpty()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    this.front = (this.front+<span class=\"number\">1</span>)%this.capacity</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyCircularDeque)</span></span> DeleteLast() <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> this.IsEmpty()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    this.rear = (this.rear<span class=\"number\">-1</span>+this.capacity)%this.capacity</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyCircularDeque)</span></span> GetFront() <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> this.IsEmpty()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> this.queue[this.front]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyCircularDeque)</span></span> GetRear() <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> this.IsEmpty()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> this.queue[(this.rear<span class=\"number\">-1</span>+this.capacity)%this.capacity]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyCircularDeque)</span></span> IsEmpty() <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> this.front == this.rear</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyCircularDeque)</span></span> IsFull() <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> this.front == (this.rear+<span class=\"number\">1</span>)%this.capacity</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Your MyCircularDeque object will be instantiated and called as such:</span></span><br><span class=\"line\"><span class=\"comment\"> * obj := Constructor(k);</span></span><br><span class=\"line\"><span class=\"comment\"> * param_1 := obj.InsertFront(value);</span></span><br><span class=\"line\"><span class=\"comment\"> * param_2 := obj.InsertLast(value);</span></span><br><span class=\"line\"><span class=\"comment\"> * param_3 := obj.DeleteFront();</span></span><br><span class=\"line\"><span class=\"comment\"> * param_4 := obj.DeleteLast();</span></span><br><span class=\"line\"><span class=\"comment\"> * param_5 := obj.GetFront();</span></span><br><span class=\"line\"><span class=\"comment\"> * param_6 := obj.GetRear();</span></span><br><span class=\"line\"><span class=\"comment\"> * param_7 := obj.IsEmpty();</span></span><br><span class=\"line\"><span class=\"comment\"> * param_8 := obj.IsFull();</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n\n<p>相似点：</p>\n<ul>\n<li>都使用了取模的方式</li>\n</ul>\n<h2 id=\"单调队列\"><a href=\"#单调队列\" class=\"headerlink\" title=\"单调队列\"></a>单调队列</h2><p>单调队列属于双端队列的一种</p>\n<p>要求队列中的元素必须满足单调性</p>\n<p>单调队列如对时候的要求：入队前后，单调性完整</p>\n<p><strong>==单调递减队列最重要的特性==:<font color='red'>入队和出队的组合，可以在O(1)时间得到某个区间上的最大值</font></strong></p>\n<h3 id=\"情况讨论\"><a href=\"#情况讨论\" class=\"headerlink\" title=\"情况讨论\"></a>情况讨论</h3><blockquote>\n<p>需要回答的问题：</p>\n<ul>\n<li>这个区间是什么</li>\n<li>怎样定量地描述这个区间</li>\n<li>与队列中的元素个数有什么关系<br>可以分以下两种情况来讨论：</li>\n</ul>\n</blockquote>\n<ol>\n<li>只有入队的情况<br>在没有出队的情况下，对原数组的比较范围就会逐步增加<br>队首元素表示是已比较范围内的最大值</li>\n<li>出队和入队混合的情况<br>控制覆盖范围为 k –&gt; 滑动窗口<ul>\n<li>入队： 扩展单调队列的覆盖范围</li>\n<li>出队： 控制单调队列的覆盖范围</li>\n<li>队首元素是覆盖范围的最大值</li>\n<li>队列中的元素个数小于覆盖范围的元素个数</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"核心代码\"><a href=\"#核心代码\" class=\"headerlink\" title=\"核心代码\"></a>核心代码</h3><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//入队的代码</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(q *queue)</span></span>push(val <span class=\"type\">int</span>)&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 入队时候，要剔除掉尾部的元素，知道尾部元素大于或者是等于入队元素</span></span><br><span class=\"line\">    while(!q.isEmpty() &amp;&amp; q.getLast()&lt;val)&#123;</span><br><span class=\"line\">        q.removeLast()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 将元素入队</span></span><br><span class=\"line\">    q.addLast(val)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 出队的时候，需要给出一个value</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(q *queue)</span></span> pop(val <span class=\"type\">int</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!q.isEmpty() &amp;&amp; q.getFirst()==val)&#123;</span><br><span class=\"line\">        q.removeFirst()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样的代码编写关键：</p>\n<ul>\n<li>队首元素q.getFirst() 所获取的值是队列中的最大值</li>\n<li>出队时<ul>\n<li>如果一个元素已经被其他元素剔除出去了，那么他就不会再入队</li>\n<li>如果一个元素是当前队列的最大值，会再出队</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"滑动窗口的最大值\"><a href=\"#滑动窗口的最大值\" class=\"headerlink\" title=\"滑动窗口的最大值\"></a>滑动窗口的最大值</h3><h3 id=\"捡金币游戏\"><a href=\"#捡金币游戏\" class=\"headerlink\" title=\"捡金币游戏\"></a>捡金币游戏</h3><blockquote>\n<p>考点:</p>\n<ul>\n<li>找到get数组，并知道get数组是当前元素和滑动窗口中最大值的和计算而来</li>\n<li>利用单调队列在get[]数组上操作，找到滑动窗口的最大值</li>\n</ul>\n</blockquote>\n<p>拓展： 是否存在不同的出队方式</p>\n<blockquote>\n<p>整理一下代码模板：<br><font color = 'red'>分层遍历</font><br><font color = 'red'>循环队列</font><br><font color = 'red'>单调队列</font></p>\n</blockquote>\n<p>一些有意思的题目：</p>\n<ul>\n<li>利用栈实现一个队列</li>\n<li>利用队列实现一个栈</li>\n</ul>\n<h1 id=\"优先级队列：堆与优先级队列，筛选最优元素\"><a href=\"#优先级队列：堆与优先级队列，筛选最优元素\" class=\"headerlink\" title=\"优先级队列：堆与优先级队列，筛选最优元素\"></a>优先级队列：堆与优先级队列，筛选最优元素</h1><h2 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h2><p> FIFO队列： 节点之间的优先级是由遍历时的顺序决定的<br> 优先级队列： 节点之间按照大小进行排序后，再决定优先级，底层依赖的数据结构一般是堆</p>\n<h4 id=\"堆的分类\"><a href=\"#堆的分类\" class=\"headerlink\" title=\"堆的分类\"></a>堆的分类</h4><ol>\n<li><p>大根堆<br>节点的值比他的孩子节点都大</p>\n</li>\n<li><p>小根堆<br>节点的值要比他的孩子节点都小<br>堆的特点–大堆的根是最大值，小堆的根是最小值</p>\n</li>\n</ol>\n<h4 id=\"堆的实现\"><a href=\"#堆的实现\" class=\"headerlink\" title=\"堆的实现\"></a>堆的实现</h4><blockquote>\n<p>以大堆为例子</p>\n</blockquote>\n<p>大多数时候都是使用数组来表示堆</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Heap <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    data []<span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建新的大根堆</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewHeap</span><span class=\"params\">()</span></span> Heap &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Heap&#123;</span><br><span class=\"line\">        data: <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, <span class=\"number\">0</span>),</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取大根堆的长度</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h *Heap)</span></span> Len() <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(h.data)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取指定位置元素的父节点位置</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">parent</span><span class=\"params\">(i <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (i - <span class=\"number\">1</span>) / <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取指定位置元素的左子节点位置</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">leftChild</span><span class=\"params\">(i <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> i*<span class=\"number\">2</span> + <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取指定位置元素的右子节点位置</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">rightChild</span><span class=\"params\">(i <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> i*<span class=\"number\">2</span> + <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 下沉操作，将指定位置的元素向下移动，直到它大于所有子节点为止</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h *Heap)</span></span> sink(i <span class=\"type\">int</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">        left, right := leftChild(i), rightChild(i)</span><br><span class=\"line\">        maxPos := i</span><br><span class=\"line\">        <span class=\"keyword\">if</span> left &lt; h.Len() &amp;&amp; h.data[left] &gt; h.data[maxPos] &#123;</span><br><span class=\"line\">            maxPos = left</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> right &lt; h.Len() &amp;&amp; h.data[right] &gt; h.data[maxPos] &#123;</span><br><span class=\"line\">            maxPos = right</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> maxPos == i &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        h.data[i], h.data[maxPos] = h.data[maxPos], h.data[i]</span><br><span class=\"line\">        i = maxPos</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 上浮操作，将指定位置的元素向上移动，直到它小于其父节点为止</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h *Heap)</span></span> swim(i <span class=\"type\">int</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        p := parent(i)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> h.data[p] &gt;= h.data[i] &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        h.data[p], h.data[i] = h.data[i], h.data[p]</span><br><span class=\"line\">        i = p</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 出堆，弹出大根堆的堆顶元素，并重新调整堆结构</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h *Heap)</span></span> pop() <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    res := h.data[<span class=\"number\">0</span>]</span><br><span class=\"line\">    h.data[<span class=\"number\">0</span>] = h.data[<span class=\"built_in\">len</span>(h.data)<span class=\"number\">-1</span>]</span><br><span class=\"line\">    h.data = h.data[:<span class=\"built_in\">len</span>(h.data)<span class=\"number\">-1</span>]</span><br><span class=\"line\">    h.sink(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 入堆，将新元素插入到大根堆中，并重新调整堆结构</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h *Heap)</span></span> push(val <span class=\"type\">int</span>) &#123;</span><br><span class=\"line\">    h.data = <span class=\"built_in\">append</span>(h.data, val)</span><br><span class=\"line\">    h.swim(<span class=\"built_in\">len</span>(h.data) - <span class=\"number\">1</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"最小的k个数\"><a href=\"#最小的k个数\" class=\"headerlink\" title=\"最小的k个数\"></a>最小的k个数</h4><blockquote>\n<p>N 的数量级非常大，或者其希望能够获得一个较小的区间内的数字<br>同时输出的操作是每时每刻的话，一直是用排序的代价就会很高<br>在上述大根堆的基础上来完成的话，就是以下代码：</p>\n</blockquote>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">getLeastNumbers</span><span class=\"params\">(arr []<span class=\"type\">int</span>, k <span class=\"type\">int</span>)</span></span> []<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 建立大根堆</span></span><br><span class=\"line\">    minH := Heap&#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i:=<span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(arr); i++&#123;</span><br><span class=\"line\">        minH.push(arr[i])</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(minH.data) &gt; k &#123;</span><br><span class=\"line\">            minH.pop()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> minH.data</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"优先级队列\"><a href=\"#优先级队列\" class=\"headerlink\" title=\"优先级队列\"></a>优先级队列</h2><h4 id=\"google-面试题目：有一台机器会每隔一秒输出一个信号，请在每次输出信号的时候输出所有信号的中间值，如果信号数量位偶数则返回中间两数的平均值\"><a href=\"#google-面试题目：有一台机器会每隔一秒输出一个信号，请在每次输出信号的时候输出所有信号的中间值，如果信号数量位偶数则返回中间两数的平均值\" class=\"headerlink\" title=\"google 面试题目：有一台机器会每隔一秒输出一个信号，请在每次输出信号的时候输出所有信号的中间值，如果信号数量位偶数则返回中间两数的平均值\"></a>google 面试题目：有一台机器会每隔一秒输出一个信号，请在每次输出信号的时候输出所有信号的中间值，如果信号数量位偶数则返回中间两数的平均值</h4><p>题目连接：</p>\n<blockquote>\n<p>leetcode 这道题目还能够用排序是因为算的是所有一共的，如果是实时输出就每次都需要排序，所以直接维护一个结构更适合</p>\n</blockquote>\n<h1 id=\"链表：-如何利用”假头，新链表，双指针”解决链表类型题目\"><a href=\"#链表：-如何利用”假头，新链表，双指针”解决链表类型题目\" class=\"headerlink\" title=\"链表： 如何利用”假头，新链表，双指针”解决链表类型题目\"></a>链表： 如何利用”假头，新链表，双指针”解决链表类型题目</h1><blockquote>\n<p>解决链表问题的三板斧：<br>假头<br>新链表<br>双指针<br>链表尤其需要考虑各种边界条件、链表结构简单，但是查找交换反转非常容易出错</p>\n</blockquote>\n<h3 id=\"三板斧\"><a href=\"#三板斧\" class=\"headerlink\" title=\"三板斧\"></a>三板斧</h3><h4 id=\"假头\"><a href=\"#假头\" class=\"headerlink\" title=\"假头\"></a>假头</h4><p>在链表前面增加额外的节点–&gt; 可以节省许多对于nil指针的操作，能够节省不少的精力</p>\n<p>dummy 指针初始化之后就不会再发生改变了<br>tail  指针随着元素改变移动</p>\n<ol>\n<li>tail 插入节点</li>\n<li>头部插入节点</li>\n<li>查找结点（总是会查找目标节点的pre）</li>\n<li>在指定位置插入节点–&gt; getPre</li>\n<li>删除节点<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> linkList <span class=\"keyword\">interface</span>&#123;</span><br><span class=\"line\">    initDummyList()</span><br><span class=\"line\">    appendNode(*<span class=\"keyword\">interface</span>&#123;&#125;)<span class=\"type\">bool</span></span><br><span class=\"line\">    getPre(<span class=\"type\">int</span>)*<span class=\"keyword\">interface</span>&#123;&#125;</span><br><span class=\"line\">    findNode(<span class=\"type\">int</span>) *<span class=\"keyword\">interface</span>&#123;&#125;</span><br><span class=\"line\">    insertNode(*<span class=\"keyword\">interface</span>&#123;&#125;)<span class=\"type\">bool</span></span><br><span class=\"line\">    deletNode(<span class=\"type\">int</span>) <span class=\"type\">bool</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h1 id=\"树：-如何深度运用树的遍历\"><a href=\"#树：-如何深度运用树的遍历\" class=\"headerlink\" title=\"树： 如何深度运用树的遍历\"></a>树： 如何深度运用树的遍历</h1><blockquote>\n<p>大部分语言的map数据结构，基本上是基于树来实现的<br>b+树，红黑树，二叉树等等，在leetcode和考题当中常见二叉树，同时对于其他的树结构，可以通过二叉树的遍历来扩展出对应的遍历方式。</p>\n</blockquote>\n<h2 id=\"1-ensp-树节点的结构：\"><a href=\"#1-ensp-树节点的结构：\" class=\"headerlink\" title=\"1 &ensp; 树节点的结构：\"></a><strong>1</strong> &ensp; 树节点的结构：</h2><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> TreeNode <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">    val <span class=\"type\">int</span></span><br><span class=\"line\">    left *TreeNode</span><br><span class=\"line\">    right *TreeNode</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-ensp-前序遍历\"><a href=\"#2-ensp-前序遍历\" class=\"headerlink\" title=\"2 &ensp; 前序遍历\"></a><strong>2</strong> &ensp; 前序遍历</h2><blockquote>\n<p><font color='red'>遍历根节点、左子树、右子树</font></p>\n</blockquote>\n<h3 id=\"2-1-ensp-使用递归完成前序遍历\"><a href=\"#2-1-ensp-使用递归完成前序遍历\" class=\"headerlink\" title=\"2.1 &ensp; 使用递归完成前序遍历\"></a><strong>2.1</strong> &ensp; 使用递归完成前序遍历</h3><p>采用整体的思想：<br>首先遍历根节点，然后遍历左子树的时候，就把左子树放到相应的位置，遍历右子树的时候，就把右子树放到相应的位置。<br>然后展开左子树<br>然后展开右子树</p>\n<blockquote>\n<p>时间复杂度：O(N)<br>空间复杂度：O(K) K表示的树的高度<br><font color=CC6699>一定注意要问清楚:在访问每个节点的时候，是需要Print出来，还是放到一个链表/数组当中存储</font></p>\n</blockquote>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//使用递归方式</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">traverse</span><span class=\"params\">(root *TreeNode)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> root == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    traverse(root.Left)</span><br><span class=\"line\">    traverse(root.Right)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-ensp-使用栈完成前序遍历\"><a href=\"#2-2-ensp-使用栈完成前序遍历\" class=\"headerlink\" title=\"2.2 &ensp; 使用栈完成前序遍历\"></a><strong>2.2</strong> &ensp; 使用栈完成前序遍历</h3><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> TreeNode <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Val   <span class=\"type\">int</span></span><br><span class=\"line\">    Left  *TreeNode</span><br><span class=\"line\">    Right *TreeNode</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 前序遍历</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">preorderTraversal</span><span class=\"params\">(root *TreeNode)</span></span> []<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> root == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> []<span class=\"type\">int</span>&#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> res []<span class=\"type\">int</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> stack []*TreeNode</span><br><span class=\"line\">    stack = <span class=\"built_in\">append</span>(stack, root)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"built_in\">len</span>(stack) &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        node := stack[<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>]</span><br><span class=\"line\">        stack = stack[:<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>]</span><br><span class=\"line\">        res = <span class=\"built_in\">append</span>(res, node.Val)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> node.Right != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            stack = <span class=\"built_in\">append</span>(stack, node.Right)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> node.Left != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            stack = <span class=\"built_in\">append</span>(stack, node.Left)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-1-ensp-Morris-遍历-只需要O-1-的空间\"><a href=\"#2-2-1-ensp-Morris-遍历-只需要O-1-的空间\" class=\"headerlink\" title=\"2.2-1 &ensp; Morris 遍历: 只需要O(1)的空间\"></a><strong>2.2-1</strong> &ensp; Morris 遍历: 只需要O(1)的空间</h3><h3 id=\"2-3-ensp-题目\"><a href=\"#2-3-ensp-题目\" class=\"headerlink\" title=\"2.3 &ensp; 题目\"></a><strong>2.3</strong> &ensp; 题目</h3><p>下述为前序遍历常见题目</p>\n<h4 id=\"2-3-1-验证二叉树\"><a href=\"#2-3-1-验证二叉树\" class=\"headerlink\" title=\"2.3.1 验证二叉树\"></a><strong>2.3.1</strong> 验证二叉树</h4><p>验证一颗二叉树是否满足二叉搜索树的性质</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> basic <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">    node *TreeNode</span><br><span class=\"line\">    leftboard <span class=\"type\">int</span></span><br><span class=\"line\">    rightboard <span class=\"type\">int</span></span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">stackBst</span><span class=\"params\">(root *TreeNode)</span></span> <span class=\"type\">bool</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 构造边界影子树栈</span></span><br><span class=\"line\">    stack := <span class=\"built_in\">make</span>([]basic,<span class=\"number\">0</span>)</span><br><span class=\"line\">    left, right := math.MinInt64,math.MaxInt64</span><br><span class=\"line\">    <span class=\"keyword\">for</span> root != <span class=\"literal\">nil</span> || <span class=\"built_in\">len</span>(stack) &gt; <span class=\"number\">0</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 当还没有遍历完左子树</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> root != <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 判断不满足搜索树的节点要求</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> root.Val &lt;= left || root.Val &gt;= right &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 满足范围要求，那就要往下继续找</span></span><br><span class=\"line\">            <span class=\"comment\">// 先记录当前影子树的边界</span></span><br><span class=\"line\">            stack = <span class=\"built_in\">append</span>(stack, basic&#123;</span><br><span class=\"line\">                node: root,</span><br><span class=\"line\">                leftboard: left,</span><br><span class=\"line\">                rightboard: right,</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">            <span class=\"comment\">// 往下移动，同时缩小右边界</span></span><br><span class=\"line\">            right = root.Val</span><br><span class=\"line\">            root = root.Left</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 左子树遍历完了，找右子树</span></span><br><span class=\"line\">        top := stack[<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>]</span><br><span class=\"line\">        stack = stack[:<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 关键就是这里需要重新赋值比较的left和right</span></span><br><span class=\"line\">        root = top.node</span><br><span class=\"line\">        left,right = top.leftboard,top.rightboard</span><br><span class=\"line\">        left = root.Val</span><br><span class=\"line\">        root = root.Right       </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">isValidBST</span><span class=\"params\">(root *TreeNode)</span></span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> stackBst(root)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>或者是使用递归的方式</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">isValidBST</span><span class=\"params\">(root *TreeNode)</span></span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    ans := <span class=\"literal\">true</span></span><br><span class=\"line\">    ans = preOderBST(root,math.MinInt64,math.MaxInt64)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">preOderBST</span><span class=\"params\">(root *TreeNode, left <span class=\"type\">int</span>, right <span class=\"type\">int</span>)</span></span><span class=\"type\">bool</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> root == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> root.Val &lt;= left || root.Val &gt;= right &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> preOderBST(root.Left,left,root.Val) &amp;&amp; preOderBST(root.Right,root.Val,right)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// // 特殊在于 golang 的特点： 传参如果要一直修改其中的值，就需要传入一个引用，或者是采用闭包的方式</span></span><br><span class=\"line\"><span class=\"comment\">// func preOderBST(root *TreeNode, left int, right int, ans *bool)&#123;</span></span><br><span class=\"line\"><span class=\"comment\">// \t// 递归是否达到条件，即到达叶节点，到达叶节点表示所有节点都满足情况，所以为true</span></span><br><span class=\"line\"><span class=\"comment\">// \t// 第二个条件是 是否有判断出不满足的树，有的话ans就会变成false,直接返回</span></span><br><span class=\"line\"><span class=\"comment\">// \tif root == nil || !(*ans) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">// \t\treturn</span></span><br><span class=\"line\"><span class=\"comment\">// \t&#125;</span></span><br><span class=\"line\"><span class=\"comment\">// \t// 判断条件就是 当前的值要小于right同时大于left才满足</span></span><br><span class=\"line\"><span class=\"comment\">// \tif root.Val &lt;= left || root.Val &gt;= right &#123;</span></span><br><span class=\"line\"><span class=\"comment\">// \t\t*ans = false</span></span><br><span class=\"line\"><span class=\"comment\">// \t\treturn</span></span><br><span class=\"line\"><span class=\"comment\">// \t&#125;</span></span><br><span class=\"line\"><span class=\"comment\">// \t// 前序遍历</span></span><br><span class=\"line\"><span class=\"comment\">// \tpreOderBST(root.Left, left, root.Val, ans)</span></span><br><span class=\"line\"><span class=\"comment\">// \tpreOderBST(root.Right, root.Val, right, ans)</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-3-2-目标和的所有路径\"><a href=\"#2-3-2-目标和的所有路径\" class=\"headerlink\" title=\"2.3.2 目标和的所有路径\"></a><strong>2.3.2</strong> 目标和的所有路径</h4><p><a href=\"https://leetcode.cn/problems/path-sum/\">https://leetcode.cn/problems/path-sum/</a></p>\n<blockquote>\n<p>二叉树进行回溯的代码模板</p>\n<ul>\n<li>遇到新的节点： 路径总是从尾部添加节点</li>\n<li>遍历完节点，路径就把他从尾部扔掉</li>\n</ul>\n</blockquote>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// func hasPathSum(root *TreeNode, targetSum int) bool &#123;</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">//     var backTrace func(*TreeNode, int) bool</span></span><br><span class=\"line\"><span class=\"comment\">//     backTrace = func(root *TreeNode, Sum int)bool&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//         left , right := false,false </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//         if root == nil &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//             return false</span></span><br><span class=\"line\"><span class=\"comment\">//         &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//         Sum += root.Val</span></span><br><span class=\"line\"><span class=\"comment\">//         if root.Left == nil &amp;&amp; root.Right == nil &amp;&amp; Sum == targetSum &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//             return true</span></span><br><span class=\"line\"><span class=\"comment\">//         &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//         if root.Left != nil&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//             left = backTrace(root.Left,Sum)</span></span><br><span class=\"line\"><span class=\"comment\">//         &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//         if root.Right != nil&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//             right = backTrace(root.Right,Sum)</span></span><br><span class=\"line\"><span class=\"comment\">//         &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//         return left || right</span></span><br><span class=\"line\"><span class=\"comment\">//     &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//     return backTrace(root,0)</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// // 使用广度优先的遍历--层序遍历--队列</span></span><br><span class=\"line\"><span class=\"comment\">// func hasPathSum(root *TreeNode, targetSum int) bool &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//     if root == nil&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//         return false</span></span><br><span class=\"line\"><span class=\"comment\">//     &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//     fifo := make([]*TreeNode,0)</span></span><br><span class=\"line\"><span class=\"comment\">//     Qsize := 1</span></span><br><span class=\"line\"><span class=\"comment\">//     fifo = append(fifo,root)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//     for len(fifo) &gt; 0 &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//         for Qsize &gt; 0 &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//             top := fifo[0]</span></span><br><span class=\"line\"><span class=\"comment\">//             if top.Left == nil &amp;&amp; top.Right == nil &amp;&amp; top.Val == targetSum&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//                 return true</span></span><br><span class=\"line\"><span class=\"comment\">//             &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//             if top.Left != nil&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//                 top.Left.Val = top.Left.Val + top.Val</span></span><br><span class=\"line\"><span class=\"comment\">//                 fifo = append(fifo,top.Left)</span></span><br><span class=\"line\"><span class=\"comment\">//             &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//             if top.Right != nil&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//                 top.Right.Val = top.Right.Val + top.Val</span></span><br><span class=\"line\"><span class=\"comment\">//                 fifo = append(fifo,top.Right)</span></span><br><span class=\"line\"><span class=\"comment\">//             &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//             fifo = fifo[1:]</span></span><br><span class=\"line\"><span class=\"comment\">//             Qsize -= 1</span></span><br><span class=\"line\"><span class=\"comment\">//         &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//         Qsize = len(fifo)</span></span><br><span class=\"line\"><span class=\"comment\">//     &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//     return false</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用栈来存储，栈中元素是当前树的路径</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> path <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">    node *TreeNode</span><br><span class=\"line\">    sum <span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">hasPathSum</span><span class=\"params\">(root *TreeNode, targetSum <span class=\"type\">int</span>)</span></span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> root == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    paths := <span class=\"built_in\">make</span>([]path,<span class=\"number\">0</span>)</span><br><span class=\"line\">    paths = <span class=\"built_in\">append</span>(paths, path&#123;</span><br><span class=\"line\">        node: root,</span><br><span class=\"line\">        sum: root.Val,</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"built_in\">len</span>(paths) &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        node := paths[<span class=\"built_in\">len</span>(paths)<span class=\"number\">-1</span>]</span><br><span class=\"line\">        paths = paths[:<span class=\"built_in\">len</span>(paths)<span class=\"number\">-1</span>]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> node.node.Left == <span class=\"literal\">nil</span> &amp;&amp; node.node.Right == <span class=\"literal\">nil</span> &amp;&amp; node.sum == targetSum &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> node.node.Right != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            right := node.node.Right</span><br><span class=\"line\">            paths = <span class=\"built_in\">append</span>(paths,path&#123;</span><br><span class=\"line\">                node: right,</span><br><span class=\"line\">                sum: right.Val + node.sum,</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> node.node.Left != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            left := node.node.Left</span><br><span class=\"line\">            paths = <span class=\"built_in\">append</span>(paths,path&#123;</span><br><span class=\"line\">                node: left,</span><br><span class=\"line\">                sum: left.Val + node.sum,</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-3-3-得到路径和为指定数字的路径集合\"><a href=\"#2-3-3-得到路径和为指定数字的路径集合\" class=\"headerlink\" title=\"2.3.3 得到路径和为指定数字的路径集合\"></a><strong>2.3.3</strong> 得到路径和为指定数字的路径集合</h4><p><a href=\"https://leetcode.cn/problems/path-sum-ii/solution/\">https://leetcode.cn/problems/path-sum-ii/solution/</a><br><font color='red'> 这道题目非常重要：有两大问题都在这个地方表现出来了</font></p>\n<p>==Golang的特性：Defer函数的使用==<br>这道题目在使用前序遍历的时候，由于在叶子节点以及从左子树转换为右子树的时候都需要将原本记录在path当中的路径节点删除pop出来，递归时候就需要考虑在什么时候执行出栈操作，没错即便是在递归当中也还是必须要考虑栈的操作，因为需要一个连续记录的路径信息</p>\n<p>关键在于pop的时机：pop的时机是：1. 本身是叶子节点，直接return 结束dfs，2. 左右的子树都被递归判断过的树中结点，也就是dfs(Left),dfs(Right)正常结束，刚好发现二者均都是在dfs执行完之后执行，而且覆盖了dfs执行完之后所有的情况<br>同时 Golang 的 <strong>Defer(){}</strong> 会在函数执行完并在返回之前执行，完全满足这个场景的需求，所以可以在递归函数体当中使用defer来完成对应的操作</p>\n<p>==Golang的特性：切片索引==<br>切片本身就是指针，且每次操作都会影响到底层数组<br>如果不在递归函数体当中使用切片之前重新对切片进行赋值，那么，之后对于底层数组的操作也会反映到之前的切片上，产生的效果就是明明原本计算好了结果但最后得到的并不是正确答案，关键就在于==后面切片的操作修改了底层数组，导致原本切片对应的结果被修改了==</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">pathSum</span><span class=\"params\">(root *TreeNode, targetSum <span class=\"type\">int</span>)</span></span> [][]<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    result := <span class=\"built_in\">make</span>([][]<span class=\"type\">int</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">    path := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> root == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> dfs <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(*TreeNode,<span class=\"type\">int</span>)</span></span></span><br><span class=\"line\">    dfs = <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(root *TreeNode,left <span class=\"type\">int</span>)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> root == <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        path = <span class=\"built_in\">append</span>(path,root.Val)</span><br><span class=\"line\">        left = left - root.Val</span><br><span class=\"line\">        <span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123; </span><br><span class=\"line\">            path = path[:<span class=\"built_in\">len</span>(path)<span class=\"number\">-1</span>]</span><br><span class=\"line\">        &#125;()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> root.Left == <span class=\"literal\">nil</span> &amp;&amp; root.Right == <span class=\"literal\">nil</span> &amp;&amp; left == <span class=\"number\">0</span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// new := make([]int,len(path))</span></span><br><span class=\"line\">            <span class=\"comment\">// copy(new,path)</span></span><br><span class=\"line\">            <span class=\"comment\">// result = append(result,new)</span></span><br><span class=\"line\">            result = <span class=\"built_in\">append</span>(result,<span class=\"built_in\">append</span>([]<span class=\"type\">int</span>(<span class=\"literal\">nil</span>),path...))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        dfs(root.Left,left)</span><br><span class=\"line\">        dfs(root.Right,left)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dfs(root,targetSum)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-3-3\"><a href=\"#2-3-3\" class=\"headerlink\" title=\"2.3.3\"></a><strong>2.3.3</strong></h4><blockquote>\n<p>等待回溯来看<br><a href=\"https://leetcode.cn/problems/path-sum-iii/solution/437-lu-jing-zong-he-iii-dfshui-su-qian-zhui-he-yi-/\">https://leetcode.cn/problems/path-sum-iii/solution/437-lu-jing-zong-he-iii-dfshui-su-qian-zhui-he-yi-/</a></p>\n</blockquote>\n<h2 id=\"3-中序遍历\"><a href=\"#3-中序遍历\" class=\"headerlink\" title=\"3 中序遍历\"></a><strong>3</strong> 中序遍历</h2><p><font color='red'>遍历左子树，然后是根节点，然后是右子树</font></p>\n<h3 id=\"3-1-ensp-使用递归完成中序遍历\"><a href=\"#3-1-ensp-使用递归完成中序遍历\" class=\"headerlink\" title=\"3.1 &ensp; 使用递归完成中序遍历\"></a><strong>3.1</strong> &ensp; 使用递归完成中序遍历</h3><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-ensp-使用栈完成中序遍历\"><a href=\"#3-2-ensp-使用栈完成中序遍历\" class=\"headerlink\" title=\"3.2 &ensp; 使用栈完成中序遍历\"></a><strong>3.2</strong> &ensp; 使用栈完成中序遍历</h3><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">inorderTraversal</span><span class=\"params\">(root *TreeNode)</span></span> []<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> root == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> []<span class=\"type\">int</span>&#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> res []<span class=\"type\">int</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> stack []*TreeNode</span><br><span class=\"line\">    <span class=\"keyword\">var</span> pathStack []<span class=\"type\">string</span></span><br><span class=\"line\">    node := root</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> node != <span class=\"literal\">nil</span> || <span class=\"built_in\">len</span>(stack) &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> node != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            stack = <span class=\"built_in\">append</span>(stack, node)</span><br><span class=\"line\">            pathStack = <span class=\"built_in\">append</span>(pathStack, fmt.Sprintf(<span class=\"string\">&quot;%d&quot;</span>, node.Val))</span><br><span class=\"line\">            node = node.Left</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            node = stack[<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>]</span><br><span class=\"line\">            stack = stack[:<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>]</span><br><span class=\"line\">            path := pathStack[<span class=\"built_in\">len</span>(pathStack)<span class=\"number\">-1</span>]</span><br><span class=\"line\">            pathStack = pathStack[:<span class=\"built_in\">len</span>(pathStack)<span class=\"number\">-1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> node.Left == <span class=\"literal\">nil</span> &amp;&amp; node.Right == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">                res = <span class=\"built_in\">append</span>(res, node.Val)</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 输出到达叶子节点的路径</span></span><br><span class=\"line\">                fmt.Println(path)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            node = node.Right</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-3-找出二叉搜索树里面出现次数最多的数\"><a href=\"#3-3-找出二叉搜索树里面出现次数最多的数\" class=\"headerlink\" title=\"3.3 找出二叉搜索树里面出现次数最多的数\"></a><strong>3.3</strong> 找出二叉搜索树里面出现次数最多的数</h3><p>找众数就需要遍历所有的节点，二叉搜索树中序遍历的结果会是一个递增的数组，其数据特性就在于使用中序遍历的时候，所有的元素都是连续的</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * type TreeNode struct &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     Val int</span></span><br><span class=\"line\"><span class=\"comment\"> *     Left *TreeNode</span></span><br><span class=\"line\"><span class=\"comment\"> *     Right *TreeNode</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">findMode</span><span class=\"params\">(root *TreeNode)</span></span> []<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 结果数组</span></span><br><span class=\"line\">    ans := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">    base,count,maxnum := math.MinInt64,<span class=\"number\">0</span>,<span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使用递归的方式</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> dfs <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(*TreeNode)</span></span></span><br><span class=\"line\">    dfs = <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(root *TreeNode)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> root == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        dfs(root.Left)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> root.Val == base &#123;</span><br><span class=\"line\">            count++</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            base = root.Val</span><br><span class=\"line\">            count = <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> count == maxnum &#123;</span><br><span class=\"line\">            ans = <span class=\"built_in\">append</span>(ans,base)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> count &gt; maxnum &#123;</span><br><span class=\"line\">            ans = []<span class=\"type\">int</span>&#123;&#125;</span><br><span class=\"line\">            maxnum = count</span><br><span class=\"line\">            ans = <span class=\"built_in\">append</span>(ans,base)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        dfs(root.Right)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dfs(root)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-4-找出二叉搜索树里面任意两个节点之间绝对值得最小值\"><a href=\"#3-4-找出二叉搜索树里面任意两个节点之间绝对值得最小值\" class=\"headerlink\" title=\"3.4 找出二叉搜索树里面任意两个节点之间绝对值得最小值\"></a><strong>3.4</strong> 找出二叉搜索树里面任意两个节点之间绝对值得最小值</h3><p><a href=\"https://leetcode.cn/problems/minimum-distance-between-bst-nodes/\">https://leetcode.cn/problems/minimum-distance-between-bst-nodes/</a></p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">minDiffInBST</span><span class=\"params\">(root *TreeNode)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用栈来中序遍历，栈顶元素就是上一遍历的节点元素</span></span><br><span class=\"line\">    stack := <span class=\"built_in\">make</span>([]*TreeNode,<span class=\"number\">0</span>)</span><br><span class=\"line\">    res := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> root != <span class=\"literal\">nil</span> || <span class=\"built_in\">len</span>(stack) &gt; <span class=\"number\">0</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> root != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            stack = <span class=\"built_in\">append</span>(stack,root)</span><br><span class=\"line\">            root = root.Left</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        node := stack[<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>]</span><br><span class=\"line\">        stack = stack[:<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>]</span><br><span class=\"line\">        res = <span class=\"built_in\">append</span>(res,node.Val)</span><br><span class=\"line\"></span><br><span class=\"line\">        root = node</span><br><span class=\"line\">        root = root.Right</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    m := math.MaxInt64</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i:= <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(res)<span class=\"number\">-1</span>; i++&#123;</span><br><span class=\"line\">        r := res[i+<span class=\"number\">1</span>]-res[i]</span><br><span class=\"line\">        m = min(m,r) </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> m</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">min</span><span class=\"params\">(args ...<span class=\"type\">int</span>)</span></span><span class=\"type\">int</span>&#123;</span><br><span class=\"line\">    min := args[<span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, val := <span class=\"keyword\">range</span> args&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> val &lt; min &#123;</span><br><span class=\"line\">            min = val</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> min</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-5-一棵二叉搜索树的两个节点被交换了，恢复这颗二叉搜索树\"><a href=\"#3-5-一棵二叉搜索树的两个节点被交换了，恢复这颗二叉搜索树\" class=\"headerlink\" title=\"3.5 一棵二叉搜索树的两个节点被交换了，恢复这颗二叉搜索树\"></a><strong>3.5</strong> 一棵二叉搜索树的两个节点被交换了，恢复这颗二叉搜索树</h3><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">recoverTree</span><span class=\"params\">(root *TreeNode)</span></span>  &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用递归解决这个问题</span></span><br><span class=\"line\">    problem := <span class=\"built_in\">make</span>([]*TreeNode,<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">var</span> findP <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(*TreeNode)</span></span></span><br><span class=\"line\">    findP = <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(root *TreeNode)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> root == <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        findP(root.Left)</span><br><span class=\"line\">        <span class=\"comment\">// if pre == math.MaxInt64&#123;</span></span><br><span class=\"line\">        <span class=\"comment\">//     pre = root.Val</span></span><br><span class=\"line\">        <span class=\"comment\">//     return</span></span><br><span class=\"line\">        <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">        <span class=\"comment\">// if root.Val - pre &lt; 0&#123;</span></span><br><span class=\"line\">        <span class=\"comment\">//     problem = append(problem,root)</span></span><br><span class=\"line\">        <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">        <span class=\"comment\">// pre = root.Val</span></span><br><span class=\"line\">        problem = <span class=\"built_in\">append</span>(problem, root)</span><br><span class=\"line\">        findP(root.Right)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    findP(root)</span><br><span class=\"line\">    pre,cur := <span class=\"number\">-1</span>,<span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(problem)<span class=\"number\">-1</span>; i++&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> problem[i].Val &gt; problem[i+<span class=\"number\">1</span>].Val &#123;</span><br><span class=\"line\">            cur = i + <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> pre == <span class=\"number\">-1</span> &#123;</span><br><span class=\"line\">                pre = i</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    problem[pre].Val,problem[cur].Val = problem[cur].Val,problem[pre].Val</span><br><span class=\"line\">    <span class=\"keyword\">return</span> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"删除二叉搜索树的节点\"><a href=\"#删除二叉搜索树的节点\" class=\"headerlink\" title=\"删除二叉搜索树的节点\"></a>删除二叉搜索树的节点</h3><blockquote>\n<p>题目最重要的考点就是分类，讨论各种情况下的处理方式</p>\n</blockquote>\n<p><font sizecolor ='red'>清晰地讲出每种情况的处理办法</font><br><font sizecolor ='red'>清晰简介地实现代码</font></p>\n<h2 id=\"后序遍历\"><a href=\"#后序遍历\" class=\"headerlink\" title=\"后序遍历\"></a>后序遍历</h2><h3 id=\"使用栈完成后序遍历\"><a href=\"#使用栈完成后序遍历\" class=\"headerlink\" title=\"使用栈完成后序遍历\"></a>使用栈完成后序遍历</h3><h3 id=\"迭代写法的考点\"><a href=\"#迭代写法的考点\" class=\"headerlink\" title=\"迭代写法的考点\"></a>迭代写法的考点</h3><ol>\n<li>是否有右子树</li>\n<li>pre指针是不是指向当前结点的右子树</li>\n</ol>\n","site":{"data":{}},"cover":"/img/cover/2077_city.png","cover_type":"img","excerpt":"","more":"<h1 id=\"告别盲目刷题，击破算法面试\"><a href=\"#告别盲目刷题，击破算法面试\" class=\"headerlink\" title=\"告别盲目刷题，击破算法面试\"></a>告别盲目刷题，击破算法面试</h1><blockquote>\n<p>学习拉钩教育算法课程记录加个人感悟记录<br>如果有版权问题，请联系 <a href=\"mailto:&#x32;&#51;&#x37;&#x34;&#48;&#x38;&#55;&#51;&#x32;&#50;&#64;&#x71;&#113;&#46;&#x63;&#x6f;&#x6d;\">&#x32;&#51;&#x37;&#x34;&#48;&#x38;&#55;&#51;&#x32;&#50;&#64;&#x71;&#113;&#46;&#x63;&#x6f;&#x6d;</a> 删除课程部分的内容</p>\n<p>算法能力的高度，决定了个人能够解决的实战问题复杂度的上限</p>\n<p>数学基础决定了算法能力的高低</p>\n</blockquote>\n<h2 id=\"解题流程-：\"><a href=\"#解题流程-：\" class=\"headerlink\" title=\"==解题流程==：\"></a>==解题流程==：</h2><h3 id=\"四部分析法\"><a href=\"#四部分析法\" class=\"headerlink\" title=\"==四部分析法==\"></a>==四部分析法==</h3><ul>\n<li><p><strong>==模拟==</strong> ： 模拟题目的运行<br>使用简单且有一定量的小例子，将自己当作计算机来执行这个流程<br><em>一般使用题目给的较长的那个例子就可以</em><br><br>这部分也是读题和理解输入输出内容的部分，理解题意的部分<br><br>这个时候一定不能够着急，不要害怕或者是觉得麻烦，一定要耐下性子，把简单的一个逻辑过程给跑清楚，理解这段程序或者是业务需要咱们处理什么样的问题。<br><br>跑的过程，不要完全先入为主，应当以题目的要求来推进演示。<br><br>不要想着在这一步就把所有的问题都给解决，一步步推进就可以. </p>\n<br /></li>\n<li><p><strong>==规律==</strong> ： 尝试总结出题目的一般规律和特点</p>\n<p>数学规律和特性一般来说很难直接从零归纳出来，但我们可以依赖所学习的高数、线性代数、离散数学、测度论等高等数学理论当中所见到的数学计算模型来匹配，这也是这部分最重要的基础</p>\n<p>先总结一些考题可能会用到的观察特点：</p>\n<ul>\n<li>形式相关：比如 括号匹配、从1加到100，</li>\n<li>数量变化：数量变化与取模相关，数量变化呈现递推公式</li>\n<li></li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p><strong>==匹配==</strong> ： 找到符合这些特点的数据结构和算法</p>\n<ul>\n<li><p>关注数据的输入类型：对输入数据进行分类，哪一些数据进行怎样的操作</p>\n</li>\n<li><p>**==怎样匹配呢？==**：</p>\n<ul>\n<li>题目模拟的时候（这部分一般使用栈、队列、二叉树）来理解题目要求的数字变化</li>\n<li>观察结果集合，或者是原本中间的变化集合，当期符合某种数据结构的变化特征的时候，就可以选用这个数据结构</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>**==考虑边界条件==**： 考虑特殊情况<br>特殊情况：<ul>\n<li>字符串为空，字符串只有一个，两个、</li>\n<li>数组为空，数字为0或者是其他不符合规律的特殊情况</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><strong>==深度思考==</strong> ： 平时练习当中的流程，用于提高算法模型的积累<ul>\n<li>深度： 这种解法还可以怎么优化</li>\n<li>广度： 这种解法的具有普适性吗？可以推广吗？问题的限定条件变多的话，这个模型是否还可以适合。</li>\n<li>数学模式扩散： 这样特点的问题是否有对应的数学模型或者是理论描述过</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"栈：-从简单栈到单调栈，让栈问题不再困难\"><a href=\"#栈：-从简单栈到单调栈，让栈问题不再困难\" class=\"headerlink\" title=\"栈： 从简单栈到单调栈，让栈问题不再困难\"></a>栈： 从简单栈到单调栈，让栈问题不再困难</h1><h2 id=\"结构特征\"><a href=\"#结构特征\" class=\"headerlink\" title=\"结构特征\"></a>结构特征</h2><p>先进后出</p>\n<p>对栈的操作：</p>\n<ul>\n<li><strong>==pop==</strong> 弹出栈顶元素，一般来说栈中可操作的元素就是栈顶元素，其他元素也都是先pop出其上面的元素，变成栈顶元素之后再进行操作。</li>\n<li> <strong>==peek==</strong> 获取栈顶元素，只是读取操作，但并没有弹出栈顶元素</li>\n<li> <strong>==push==</strong> 将元素压入栈中</li>\n</ul>\n<h3 id=\"Golang-栈的使用\"><a href=\"#Golang-栈的使用\" class=\"headerlink\" title=\"Golang 栈的使用\"></a>Golang 栈的使用</h3><p>在 Go 中并没有直接提供Stack的方法结构，但可以使用切片非常简单地表示和使用栈、队列结构。</p>\n<p> 先进后出的数据结构，使用**==切片==**表示，压入栈的操作就是往切片中添加元素，弹出栈的操作就是输出末尾元素，并将切片缩小为：<code>[:len(stack)-1]</code></p>\n<p>以下为栈的代码模板实现：</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Stack <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">    Stack []<span class=\"keyword\">interface</span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *Stack)</span></span>push(x <span class=\"keyword\">interface</span>&#123;&#125;)&#123;</span><br><span class=\"line\">    s = <span class=\"built_in\">append</span>(s,x)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *Stack)</span></span>pop()&#123;</span><br><span class=\"line\">    s = s[:<span class=\"built_in\">len</span>(s)<span class=\"number\">-1</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(s *Stack)</span></span>peek()(x <span class=\"keyword\">interface</span>&#123;&#125;)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s[<span class=\"built_in\">len</span>(s)<span class=\"number\">-1</span>]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>关键在于记住：</p>\n<ul>\n<li>栈顶元素 —&gt; 切片末尾元素</li>\n<li>切片是左闭右开，所以pop操作是 s = s[:len(s)-1], 但如果是队列pop出第一个元素就需要往后再移动一位 s = s[1:] 而不是 s = s[0:]</li>\n</ul>\n<h2 id=\"典型题目\"><a href=\"#典型题目\" class=\"headerlink\" title=\"典型题目\"></a>典型题目</h2><h3 id=\"判断字符串是否合法\"><a href=\"#判断字符串是否合法\" class=\"headerlink\" title=\"判断字符串是否合法\"></a>判断字符串是否合法</h3><p>题目：<a href=\"https://leetcode.cn/problems/valid-parentheses/\">https://leetcode.cn/problems/valid-parentheses/</a></p>\n<h4 id=\"正确解法和流程\"><a href=\"#正确解法和流程\" class=\"headerlink\" title=\"正确解法和流程\"></a>正确解法和流程</h4><p><a href=\"https://leetcode.cn/link/?target=https://www.bilibili.com/video/BV1AF411w78g\">https://leetcode.cn/link/?target=https://www.bilibili.com/video/BV1AF411w78g</a></p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">isValid</span><span class=\"params\">(s <span class=\"type\">string</span>)</span></span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    n := <span class=\"built_in\">len</span>(s)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> n % <span class=\"number\">2</span> == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    pairs := <span class=\"keyword\">map</span>[<span class=\"type\">byte</span>]<span class=\"type\">byte</span>&#123;</span><br><span class=\"line\">        <span class=\"string\">&#x27;)&#x27;</span>: <span class=\"string\">&#x27;(&#x27;</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;]&#x27;</span>: <span class=\"string\">&#x27;[&#x27;</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;&#125;&#x27;</span>: <span class=\"string\">&#x27;&#123;&#x27;</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    stack := []<span class=\"type\">byte</span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; n; i++ &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> pairs[s[i]] &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(stack) == <span class=\"number\">0</span> || stack[<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>] != pairs[s[i]] &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            stack = stack[:<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>]</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            stack = <span class=\"built_in\">append</span>(stack, s[i])</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(stack) == <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"个人解法和流程\"><a href=\"#个人解法和流程\" class=\"headerlink\" title=\"个人解法和流程\"></a>个人解法和流程</h4><blockquote>\n<p>问题集中体现在数据特性处理判断太过分散，属实是缝缝补补有一年<br>对输入数据进行分类，哪一些数据进行怎样的操作</p>\n<ul>\n<li>输入的是左括号应该入栈</li>\n<li>输入的是右括号应该做判断<br /></li>\n</ul>\n</blockquote>\n<p>我的代码是：</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">isValid</span><span class=\"params\">(s <span class=\"type\">string</span>)</span></span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    l := <span class=\"built_in\">len</span>(s)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> l%<span class=\"number\">2</span> != <span class=\"number\">0</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    stack := <span class=\"built_in\">make</span>([]<span class=\"type\">rune</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    m := <span class=\"keyword\">map</span>[<span class=\"type\">rune</span>]<span class=\"type\">rune</span>&#123;</span><br><span class=\"line\">        <span class=\"string\">&#x27;]&#x27;</span>:<span class=\"string\">&#x27;[&#x27;</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;)&#x27;</span>:<span class=\"string\">&#x27;(&#x27;</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;&#125;&#x27;</span>:<span class=\"string\">&#x27;&#123;&#x27;</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _,v := <span class=\"keyword\">range</span> s&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> v == <span class=\"string\">&#x27;[&#x27;</span> ||v == <span class=\"string\">&#x27;&#123;&#x27;</span> ||v == <span class=\"string\">&#x27;(&#x27;</span>&#123;</span><br><span class=\"line\">            stack = <span class=\"built_in\">append</span>(stack,v)</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(stack) == <span class=\"number\">0</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> stack[<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>] == m[v]&#123;</span><br><span class=\"line\">            stack = stack[:<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>]</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> m[v] != <span class=\"number\">0</span> &#123;<span class=\"keyword\">return</span> <span class=\"literal\">false</span>&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(stack) == <span class=\"number\">0</span>&#123;<span class=\"keyword\">return</span> <span class=\"literal\">true</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述在判断栈顶元素的时候逻辑不够清晰，所以加了很多的if来补足条件，我们看例子当中所给的逻辑顺序：</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    pairs := <span class=\"keyword\">map</span>[<span class=\"type\">byte</span>]<span class=\"type\">byte</span>&#123;</span><br><span class=\"line\">    <span class=\"string\">&#x27;)&#x27;</span>: <span class=\"string\">&#x27;(&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;]&#x27;</span>: <span class=\"string\">&#x27;[&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;&#125;&#x27;</span>: <span class=\"string\">&#x27;&#123;&#x27;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">stack := []<span class=\"type\">byte</span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; n; i++ &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> pairs[s[i]] &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(stack) == <span class=\"number\">0</span> || stack[<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>] != pairs[s[i]] &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        stack = stack[:<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>]</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        stack = <span class=\"built_in\">append</span>(stack, s[i])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(stack) == <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n\n<p>关键差距就在于这一句话：<code>pairs[s[i]] &gt; 0 </code>, 这个判断对输入的数据做了一次分类，依据上面的map结构可知，这句话 &lt; 0 时候标识map当中没有存储对应的对象，而map中存储的是所有的左括号，所以这个判断的作用是<strong>当输入是右括号的时候进入函数</strong>，然后逻辑体依据输入是右括号判断，如果当前栈里面没有元素或者是栈顶元素与右括号不匹配那么就返回false<br><br>实际上我写的函数最后夜市做了类似的判断，但显然没有考虑数据分类的情况。</p>\n<h3 id=\"判断大鱼吃小鱼最后留下的鱼\"><a href=\"#判断大鱼吃小鱼最后留下的鱼\" class=\"headerlink\" title=\"判断大鱼吃小鱼最后留下的鱼\"></a>判断大鱼吃小鱼最后留下的鱼</h3><p>题目：</p>\n<p>近似题目：<a href=\"https://www.nowcoder.com/questionTerminal/3fdfc63015df42c6a78fdae46709fa69?f=discussion\">https://www.nowcoder.com/questionTerminal/3fdfc63015df42c6a78fdae46709fa69?f=discussion</a></p>\n<br />\n\n<h4 id=\"正确解法和流程-1\"><a href=\"#正确解法和流程-1\" class=\"headerlink\" title=\"正确解法和流程\"></a>正确解法和流程</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * </span></span><br><span class=\"line\"><span class=\"comment\">     * @param N int整型 N条鱼</span></span><br><span class=\"line\"><span class=\"comment\">     * @param A int整型vector 每条鱼的体积为Ai</span></span><br><span class=\"line\"><span class=\"comment\">     * @return int整型</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">P</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> x, t;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">solve</span><span class=\"params\">(<span class=\"type\">int</span> N, vector&lt;<span class=\"type\">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class=\"line\">        stack&lt;P&gt; S;</span><br><span class=\"line\">        <span class=\"type\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=N<span class=\"number\">-1</span>;i&gt;=<span class=\"number\">0</span>;i--)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> t = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(!S.<span class=\"built_in\">empty</span>() &amp;&amp; A[i]&gt;S.<span class=\"built_in\">top</span>().x)&#123;</span><br><span class=\"line\">                t = <span class=\"built_in\">max</span>(S.<span class=\"built_in\">top</span>().t, t+<span class=\"number\">1</span>);</span><br><span class=\"line\">                S.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            S.<span class=\"built_in\">push</span>(&#123;A[i], t&#125;);</span><br><span class=\"line\">            cnt = <span class=\"built_in\">max</span>(cnt, t);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cnt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"个人解法和流程-1\"><a href=\"#个人解法和流程-1\" class=\"headerlink\" title=\"个人解法和流程\"></a>个人解法和流程</h4><p>由于找不到相同的题目，就找了类似的题目，但是解题的思路不太一样<br>图片上的大鱼吃小鱼，只需要每次比较栈顶元素和新进来的元素大小即可，当大于的时候，就不做操作，当栈顶元素小于输入元素的时候，pop出栈顶元素并push进入这个最大值，最后栈中元素就是结果。这个过程当中几处需要重视的地方是：</p>\n<ul>\n<li>当鱼的方向一致时候，大鱼并不会把同方向的小鱼给吃了【可能不论大小鱼的速度相同（bushi）】，而如果小鱼在左，大鱼在右，方向不同，则也不会吃</li>\n</ul>\n<p>牛客网的题目则加了非常多的条件和限制，是对栈问题的一个较大的变化</p>\n<blockquote>\n<p>对比上述两个题目可以观察到：<br><font color ='blue'> 1. 消除的行为不同</font><br>  括号匹配中，消除行为是配对的两者都会消除，也就是栈顶元素和输入元素一起被消除<br>  大鱼吃小鱼中，消除行为是配对的两者中会有一个被消除<br>–&gt; 是否入栈和出栈的判断<br><font color ='blue'> 2. 栈中的内容不同</font><br>  括号匹配当中，栈中存放的就是内容本身<br>  大鱼吃小鱼当中，栈里存放的是内容的索引，可以通过索引找到内容<br><font color ='blue'> 3. 弹栈的方式也不相同</font><br>  括号匹配只需要每次弹出一个元素就可以<br>  大鱼则需要用while语句一直弹出到满足某个条件才停止</p>\n</blockquote>\n<h2 id=\"栈问题的特征和解决流程\"><a href=\"#栈问题的特征和解决流程\" class=\"headerlink\" title=\"栈问题的特征和解决流程\"></a>栈问题的特征和解决流程</h2><h3 id=\"pop-行为不同\"><a href=\"#pop-行为不同\" class=\"headerlink\" title=\"pop 行为不同\"></a>pop 行为不同</h3><p>pop【弹栈的操作不一样】<br>常见的就是每次循环都判断栈顶元素的特点而pop或者push或者不操作，但这样必须得是连续性的元素才有这样的特征</p>\n<p><strong>==在弹栈的时候，是否一定要满足某个条件才停止弹栈==</strong><br>也就是说当输入元素之后需要将其和站内其他的元素进行比较，在使用的时候尤其要注意迭代过程</p>\n<h3 id=\"栈中存储内容不相同\"><a href=\"#栈中存储内容不相同\" class=\"headerlink\" title=\"栈中存储内容不相同\"></a>栈中存储内容不相同</h3><p>是否栈中存储数据、还是存储索引、还是存储一个自建的新的结构</p>\n<h3 id=\"栈顶元素的含义不相同\"><a href=\"#栈顶元素的含义不相同\" class=\"headerlink\" title=\"栈顶元素的含义不相同\"></a>栈顶元素的含义不相同</h3><h2 id=\"单调栈\"><a href=\"#单调栈\" class=\"headerlink\" title=\"单调栈\"></a>单调栈</h2><p>单调栈是指栈中元素必须按照升序排列的栈或者是降序排列的栈</p>\n<p>单调栈分为：</p>\n<ul>\n<li><p>递增栈：<br>  栈中元素从左到右遵守从小到大的顺序<br>  入栈时候，当<strong>入栈元素小于栈顶元素</strong>就会pop出栈顶元素，直到入栈元素大于栈顶元素<br>  特点是：<br>  入栈小数会消除栈内大数</p>\n</li>\n<li><p>递减栈<br>  栈中元素从左到右遵守从大到小的顺序<br>  入栈时候，当<strong>入栈元素大于栈顶元素</strong>就会pop出栈顶元素，直到入栈元素小于栈顶元素<br>  特点是：<br>  入栈大数会消除栈内小数</p>\n</li>\n</ul>\n<h3 id=\"典型代码：\"><a href=\"#典型代码：\" class=\"headerlink\" title=\"典型代码：\"></a>典型代码：</h3><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stack := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"comment\">/**递增栈的入栈</span></span><br><span class=\"line\"><span class=\"comment\">* 用for 循环出栈，直到栈顶元素满足递增栈的要求</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> <span class=\"built_in\">len</span>(stack)&gt; <span class=\"number\">0</span> &amp;&amp; A[i] &gt; stack[<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>]&#123;</span><br><span class=\"line\">    <span class=\"comment\">// pop出栈内比 A[i]小但却在前面的元素</span></span><br><span class=\"line\">    stack = stack[:<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">stack = <span class=\"built_in\">append</span>(stack,A[i])</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"找到当前数字右边最小的对应数字\"><a href=\"#找到当前数字右边最小的对应数字\" class=\"headerlink\" title=\"找到当前数字右边最小的对应数字\"></a>找到当前数字右边最小的对应数字</h3><h3 id=\"取k个字符，求字典序最小的组合\"><a href=\"#取k个字符，求字典序最小的组合\" class=\"headerlink\" title=\"取k个字符，求字典序最小的组合\"></a>取k个字符，求字典序最小的组合</h3><blockquote>\n<p>字典序：</p>\n<ul>\n<li>对单个元素按照ascii 表中大小顺序排列</li>\n<li>多个元素时，按照从左到右顺序，先从高位字典排序，然后在相同高位中按照地位再字典排序</li>\n</ul>\n</blockquote>\n<h3 id=\"给定一个数组，数组中元素代表模板的高度，请你求出相邻木板能剪出的最大矩形面积\"><a href=\"#给定一个数组，数组中元素代表模板的高度，请你求出相邻木板能剪出的最大矩形面积\" class=\"headerlink\" title=\"给定一个数组，数组中元素代表模板的高度，请你求出相邻木板能剪出的最大矩形面积\"></a>给定一个数组，数组中元素代表模板的高度，请你求出相邻木板能剪出的最大矩形面积</h3><blockquote>\n<p>和求最大容积是一个题目</p>\n</blockquote>\n<br />\n\n<h2 id=\"leetcode-题目汇总\"><a href=\"#leetcode-题目汇总\" class=\"headerlink\" title=\"leetcode 题目汇总\"></a>leetcode 题目汇总</h2><blockquote>\n<p>以leetcode 题目为例子</p>\n</blockquote>\n<p>相关栈的题目汇总：<br>[1][<a href=\"https://leetcode.cn/problem-list/xb9nqhhg/?topicSlugs=stack&amp;page=1%5D\">https://leetcode.cn/problem-list/xb9nqhhg/?topicSlugs=stack&amp;page=1]</a><br>[2][<a href=\"https://leetcode.cn/problem-list/e8X3pBZi/?page=1&amp;topicSlugs=heap-priority-queue%5D\">https://leetcode.cn/problem-list/e8X3pBZi/?page=1&amp;topicSlugs=heap-priority-queue]</a><br>[3][<a href=\"https://leetcode.cn/problem-list/2cktkvj/?page=1&amp;topicSlugs=stack%5D\">https://leetcode.cn/problem-list/2cktkvj/?page=1&amp;topicSlugs=stack]</a></p>\n<h1 id=\"队列：FIFO-队列与单调队列的深挖与扩展\"><a href=\"#队列：FIFO-队列与单调队列的深挖与扩展\" class=\"headerlink\" title=\"队列：FIFO 队列与单调队列的深挖与扩展\"></a>队列：FIFO 队列与单调队列的深挖与扩展</h1><p>先进先出，是共同特征</p>\n<p>类别上可以分出：</p>\n<ul>\n<li>FIFO队列</li>\n<li>单调队列</li>\n</ul>\n<h2 id=\"FIFO队列\"><a href=\"#FIFO队列\" class=\"headerlink\" title=\"FIFO队列\"></a>FIFO队列</h2><p><strong>==Push 元素时候， 总是将放在元素放在队列尾部，也就是操作 fifo[len(fifo)-1]==</strong><br><strong>==Pop 元素时候，总是将队列首部的元素扔掉 ，也就是操作 fifo = fifo[1:]==</strong></p>\n<h3 id=\"二叉树的层次遍历（两种方法）\"><a href=\"#二叉树的层次遍历（两种方法）\" class=\"headerlink\" title=\"二叉树的层次遍历（两种方法）\"></a>二叉树的层次遍历（两种方法）</h3><ul>\n<li><p>规律：<br>广度遍历（层次遍历）：由于二叉树的特点，当拿到第N层的结点A之后，可以通过 A 的left，right指针拿到下一层的节点</p>\n</li>\n<li><p><em>但是与A在同一层的节点还有其他吗，这个时候就需要按层来存储节点，不能直接使用递归</em>*</p>\n   <br />\n   顺序输出：每层输出时，排在左边的节点，它的子节点同样排在下一层的最左边</li>\n</ul>\n<p>–&gt; <strong>==题目具备广度遍历（分层遍历）的特点 和 顺序输出的特点 ，应该想到应用FIFO队列==</strong></p>\n<ul>\n<li>边界<br>特殊判断： 如果发现是一棵空二叉树，就直接返回空结果<br>==制定一个规则==： 不要让空指针进入到FIFO队列（一些编程的亮点）</li>\n</ul>\n<p><font color = 'red'> 非常重要的概念： QSize 表示当前层数 </font></p>\n<h4 id=\"层次遍历二叉树\"><a href=\"#层次遍历二叉树\" class=\"headerlink\" title=\"层次遍历二叉树\"></a>层次遍历二叉树</h4><p>题目链接：<a href=\"https://leetcode.cn/problems/binary-tree-level-order-traversal/submissions/\">https://leetcode.cn/problems/binary-tree-level-order-traversal/submissions/</a></p>\n<h5 id=\"解题思路1\"><a href=\"#解题思路1\" class=\"headerlink\" title=\"解题思路1\"></a>解题思路1</h5><p>关键思路在于将每一层的节点都存在FIFO队列里面，在每次遍历的时候从左到右pop出该层的节点，同时在队尾加入他的左右孩子</p>\n<p>队首pop出当层节点，队尾append下一层的孩子节点<br>QSize 记录当层的节点数量</p>\n<p>时间复杂度是O(n), 空间复杂度由QSize决定O(K),K表示QSize最大，也就是存储的一层节点数量最多的时候</p>\n<h5 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h5><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * type TreeNode struct &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     Val int</span></span><br><span class=\"line\"><span class=\"comment\"> *     Left *TreeNode</span></span><br><span class=\"line\"><span class=\"comment\"> *     Right *TreeNode</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">levelOrder</span><span class=\"params\">(root *TreeNode)</span></span> [][]<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建FIFO 队列来存储遍历的过程</span></span><br><span class=\"line\">    fifo := <span class=\"built_in\">make</span>([]*TreeNode,<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"comment\">// QSize 表示当前遍历的层</span></span><br><span class=\"line\">    QSize := <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"comment\">// 初始化最终结果</span></span><br><span class=\"line\">    result := <span class=\"built_in\">make</span>([][]<span class=\"type\">int</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> root == <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//将根节点入栈</span></span><br><span class=\"line\">    fifo = <span class=\"built_in\">append</span>(fifo,root)</span><br><span class=\"line\">    <span class=\"comment\">// 开始层序遍历，只要当前队列不为空</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"built_in\">len</span>(fifo) &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建结果数组用于存储当层pop出的元素值</span></span><br><span class=\"line\">        tmp := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"comment\">// 当层元素QSize全部遍历以此，这里不能用len(fifo)，因为fifo的长度是在变化的</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i := QSize;i &gt; <span class=\"number\">0</span>;i--&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 拿出队列头元素</span></span><br><span class=\"line\">            node := fifo[<span class=\"number\">0</span>]</span><br><span class=\"line\">            <span class=\"comment\">// 判断他的左孩子是否为空</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> node.Left!= <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">                fifo = <span class=\"built_in\">append</span>(fifo,node.Left)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 判断他的右孩子是否为空</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> node.Right != <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">                fifo = <span class=\"built_in\">append</span>(fifo,node.Right)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 将该节点的值存入结果</span></span><br><span class=\"line\">            tmp = <span class=\"built_in\">append</span>(tmp,node.Val)</span><br><span class=\"line\">            <span class=\"comment\">// 推出队首元素</span></span><br><span class=\"line\">            fifo = fifo[<span class=\"number\">1</span>:]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 将结果 tmp 存入到结果数组当中</span></span><br><span class=\"line\">        result = <span class=\"built_in\">append</span>(result,tmp)</span><br><span class=\"line\">        <span class=\"comment\">// 重新计算当前层的节点数量</span></span><br><span class=\"line\">        QSize = <span class=\"built_in\">len</span>(fifo)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"官方题解\"><a href=\"#官方题解\" class=\"headerlink\" title=\"官方题解\"></a>官方题解</h5><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">levelOrder</span><span class=\"params\">(root *TreeNode)</span></span> [][]<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    ret := [][]<span class=\"type\">int</span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> root == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    q := []*TreeNode&#123;root&#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; <span class=\"built_in\">len</span>(q) &gt; <span class=\"number\">0</span>; i++ &#123;</span><br><span class=\"line\">        ret = <span class=\"built_in\">append</span>(ret, []<span class=\"type\">int</span>&#123;&#125;)</span><br><span class=\"line\">        p := []*TreeNode&#123;&#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j := <span class=\"number\">0</span>; j &lt; <span class=\"built_in\">len</span>(q); j++ &#123;</span><br><span class=\"line\">            node := q[j]</span><br><span class=\"line\">            ret[i] = <span class=\"built_in\">append</span>(ret[i], node.Val)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> node.Left != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">                p = <span class=\"built_in\">append</span>(p, node.Left)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> node.Right != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">                p = <span class=\"built_in\">append</span>(p, node.Right)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        q = p</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"解题思路2\"><a href=\"#解题思路2\" class=\"headerlink\" title=\"解题思路2\"></a>解题思路2</h5><p>使用链表来解决问题</p>\n<h4 id=\"锯齿状层次遍历\"><a href=\"#锯齿状层次遍历\" class=\"headerlink\" title=\"锯齿状层次遍历\"></a>锯齿状层次遍历</h4><p>题目链接：<a href=\"https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/\">https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/</a></p>\n<h5 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h5><p>层次遍历的基础上加一个qs，表示当前层是从左到右还是从右到左</p>\n<p>**==本题当中所犯的错误：==**：</p>\n<ul>\n<li>每一轮都需要重新计算qsize,一定不要忘了这一点</li>\n<li>tmp 接收的时候还是按照栈的pop逻辑，所以顺序上还需要再反一次</li>\n<li>题目样例当中root是按照从左到右遍历过一次来计算的</li>\n</ul>\n<h5 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h5><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * type TreeNode struct &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     Val int</span></span><br><span class=\"line\"><span class=\"comment\"> *     Left *TreeNode</span></span><br><span class=\"line\"><span class=\"comment\"> *     Right *TreeNode</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">zigzagLevelOrder</span><span class=\"params\">(root *TreeNode)</span></span> [][]<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//结果数组</span></span><br><span class=\"line\">    result := <span class=\"built_in\">make</span>([][]<span class=\"type\">int</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"comment\">//全局的fifo队列</span></span><br><span class=\"line\">    fifo := <span class=\"built_in\">make</span>([]*TreeNode,<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"comment\">// Qsize 表示当前层的节点数，qs 表示该层的遍历顺序，0表示从左到右，1表示从右到左</span></span><br><span class=\"line\">    Qsize ,qs := <span class=\"number\">1</span> , <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果树中没有节点则直接返回</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> root == <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 将 root 放入队列</span></span><br><span class=\"line\">    fifo = <span class=\"built_in\">append</span>(fifo,root)</span><br><span class=\"line\">    <span class=\"comment\">//遍历整棵树</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"built_in\">len</span>(fifo) &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        tmp := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i:= <span class=\"number\">1</span>; Qsize &gt;= i &amp;&amp; qs == <span class=\"number\">0</span> ;i++&#123;</span><br><span class=\"line\">            node := fifo[Qsize-i]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> node.Right != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">                fifo = <span class=\"built_in\">append</span>(fifo,node.Right)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> node.Left != <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">                fifo = <span class=\"built_in\">append</span>(fifo,node.Left)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            tmp = <span class=\"built_in\">append</span>(tmp,node.Val)                </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i:= <span class=\"number\">1</span>; Qsize &gt;= i &amp;&amp; qs == <span class=\"number\">1</span> ;i++&#123;</span><br><span class=\"line\">            node := fifo[Qsize-i]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> node.Left != <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">                fifo = <span class=\"built_in\">append</span>(fifo,node.Left)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> node.Right != <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">                fifo = <span class=\"built_in\">append</span>(fifo,node.Right)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            tmp = <span class=\"built_in\">append</span>(tmp,node.Val)                </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        fifo = fifo[Qsize:]</span><br><span class=\"line\">        Qsize = <span class=\"built_in\">len</span>(fifo)</span><br><span class=\"line\">        result = <span class=\"built_in\">append</span>(result,tmp)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> qs == <span class=\"number\">1</span>&#123;</span><br><span class=\"line\">            qs = <span class=\"number\">0</span></span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            qs = <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"倒序层次遍历\"><a href=\"#倒序层次遍历\" class=\"headerlink\" title=\"倒序层次遍历\"></a>倒序层次遍历</h4><p>题目链接：<a href=\"https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/\">https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/</a></p>\n<h5 id=\"解题思路-1\"><a href=\"#解题思路-1\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h5><p>从题目要求当中可以读出，是在之前的层序遍历基础上把结果倒过来输出，那么会比较自然想到可以在使用一个栈用来存储中间结果</p>\n<h5 id=\"代码-2\"><a href=\"#代码-2\" class=\"headerlink\" title=\"代码\"></a>代码</h5><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * type TreeNode struct &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     Val int</span></span><br><span class=\"line\"><span class=\"comment\"> *     Left *TreeNode</span></span><br><span class=\"line\"><span class=\"comment\"> *     Right *TreeNode</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">levelOrderBottom</span><span class=\"params\">(root *TreeNode)</span></span> [][]<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 构造全局fifo队列</span></span><br><span class=\"line\">    fifo := <span class=\"built_in\">make</span>([]*TreeNode,<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"comment\">// 构造结果栈</span></span><br><span class=\"line\">    stack := <span class=\"built_in\">make</span>([][]<span class=\"type\">int</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">    result := <span class=\"built_in\">make</span>([][]<span class=\"type\">int</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"comment\">//表示当前层的节点数量</span></span><br><span class=\"line\">    Qsize := <span class=\"number\">1</span></span><br><span class=\"line\">    fifo = <span class=\"built_in\">append</span>(fifo,root)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> root == <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"built_in\">len</span>(fifo) &gt; <span class=\"number\">0</span>&#123;</span><br><span class=\"line\">        tmp := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> Qsize &gt; <span class=\"number\">0</span>&#123;</span><br><span class=\"line\">            node:= fifo[<span class=\"number\">0</span>]</span><br><span class=\"line\">            <span class=\"keyword\">if</span> node.Left != <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">                fifo =<span class=\"built_in\">append</span>(fifo,node.Left)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> node.Right != <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">                fifo = <span class=\"built_in\">append</span>(fifo,node.Right)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            Qsize--</span><br><span class=\"line\">            fifo = fifo[<span class=\"number\">1</span>:]</span><br><span class=\"line\">            tmp = <span class=\"built_in\">append</span>(tmp,node.Val)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        stack = <span class=\"built_in\">append</span>(stack,tmp)</span><br><span class=\"line\">        Qsize = <span class=\"built_in\">len</span>(fifo)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将栈中元素pop 到结果当中</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"built_in\">len</span>(stack) &gt; <span class=\"number\">0</span>&#123;</span><br><span class=\"line\">        result = <span class=\"built_in\">append</span>(result,stack[<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>])</span><br><span class=\"line\">        stack = stack[:<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"循环队列\"><a href=\"#循环队列\" class=\"headerlink\" title=\"循环队列\"></a>循环队列</h2><p>设计一个可以容纳 k 个元素的循环队列，需要实现以下接口：</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> ringQueue <span class=\"keyword\">interface</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//构造函数，参数k表示这个循环队列最多容纳k个元素</span></span><br><span class=\"line\">    CircularQueue(<span class=\"type\">int</span>)</span><br><span class=\"line\">    <span class=\"comment\">//将value放到队列中，成功返回true</span></span><br><span class=\"line\">    EnQueue(<span class=\"type\">int</span>) <span class=\"type\">bool</span></span><br><span class=\"line\">    <span class=\"comment\">// 删除队首元素，成功返回true</span></span><br><span class=\"line\">    DeQueue() <span class=\"type\">bool</span></span><br><span class=\"line\">    <span class=\"comment\">// 得到队首元素，如果队列为空，返回-1</span></span><br><span class=\"line\">    Front() <span class=\"type\">int</span></span><br><span class=\"line\">    <span class=\"comment\">// 得到队尾元素，如果队列为空，返回-1</span></span><br><span class=\"line\">    Rear() <span class=\"type\">int</span></span><br><span class=\"line\">    <span class=\"comment\">// 查看循环队列是否为空</span></span><br><span class=\"line\">    isEmpty() <span class=\"type\">bool</span></span><br><span class=\"line\">    <span class=\"comment\">// 查看队列是否已经放满k个元素</span></span><br><span class=\"line\">    isFull() <span class=\"type\">bool</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>==循环队列的重点在于==: <font color = 'red'>循环使用固定空间</font></strong></li>\n<li><strong>==难点在于==： <font color='red'>控制好 Front/Rear两个首位指示器</font></strong></li>\n</ul>\n<h3 id=\"表示方法1\"><a href=\"#表示方法1\" class=\"headerlink\" title=\"表示方法1\"></a>表示方法1</h3><p>使用 <code>used</code>、<code>front</code>、<code>rear</code> 三个变量来控制，其中<code>used, front</code>都代表的是数组的下标</p>\n<p>注意以下几点：</p>\n<ul>\n<li>index = i 的后一个是i+1，前一个是i+1</li>\n<li>index = k-1 的后一个就是index=0</li>\n<li>index = 0 的前一个是 index = k-1</li>\n<li><em>==可以使用取模的方式统一处理==:</em>*<br><font color='red'> index = i 的后一个元素下标是（i+1）% k</font><br><font color='red'> index = i 的前一个元素下标是（i-1+k）% k</font><br><font color='blue'>所有的循环数组下标的处理都需要按照这个取模的方式</font></li>\n</ul>\n<p>参考的实例代码如下：</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> MyCircularQueue <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    queue  []<span class=\"type\">int</span></span><br><span class=\"line\">    rear   <span class=\"type\">int</span></span><br><span class=\"line\">    front  <span class=\"type\">int</span></span><br><span class=\"line\">    used   <span class=\"type\">int</span></span><br><span class=\"line\">    length <span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">CircularQueue</span><span class=\"params\">(k <span class=\"type\">int</span>)</span></span> ringQueue &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;MyCircularQueue&#123;</span><br><span class=\"line\">        queue:  <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, k),</span><br><span class=\"line\">        rear:   <span class=\"number\">0</span>,</span><br><span class=\"line\">        front:  <span class=\"number\">0</span>,</span><br><span class=\"line\">        used:   <span class=\"number\">0</span>,</span><br><span class=\"line\">        length: k,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(q *MyCircularQueue)</span></span> EnQueue(value <span class=\"type\">int</span>) <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> q.isFull() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span> </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    q.queue[q.rear] = value</span><br><span class=\"line\">    q.rear = (q.rear + <span class=\"number\">1</span>) % q.length</span><br><span class=\"line\">    q.used++</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(q *MyCircularQueue)</span></span> DeQueue() <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> q.isEmpty() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    q.front = (q.front + <span class=\"number\">1</span>) % q.length</span><br><span class=\"line\">    q.used--</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(q *MyCircularQueue)</span></span> Front() <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> q.used == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> q.queue[q.front]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(q *MyCircularQueue)</span></span> Rear() <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> q.used == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> q.queue[(q.rear<span class=\"number\">-1</span>+q.length)%q.length]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(q *MyCircularQueue)</span></span> isEmpty() <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> q.used == <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(q *MyCircularQueue)</span></span> isFull() <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> q.used == q.length</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>备注：<br>在 <code>DeQueue()</code> 方法中，删除队首元素时并不会真的删除该元素，而是通过移动 <code>front</code> 指针来达到删除的效果。</p>\n<p>循环队列是一个环状的数据结构，可以想象成沿着环形路径移动指针。在实现循环队列时，每当删除队首元素时，我们需要将 <code>front</code> 指针向前移一位，指向队列中的下一个元素，这样队列中原来的第二个元素就成为了新的头部元素。这里使用 “指向队列中的下一个元素” 实际上是模运算的作用，如 <code>(i+1) % n</code> 将会得到指向 <code>i</code> 在循环数组中下一个元素的索引值。</p>\n<p>而在这个移动指针的过程中，由于队列的前面已经没有元素，所以我们不需要将队首元素真正地删除。相反，仅需要更新 <code>front</code> 指针，让它指向目前第一个元素，后面再添加新的元素，也会覆盖掉先前的元素，实现对队列的循环利用。</p>\n<h3 id=\"表示方法2\"><a href=\"#表示方法2\" class=\"headerlink\" title=\"表示方法2\"></a>表示方法2</h3><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> MyCircularQueue <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用 k + 1 ，也就是多余一个空格的循环队列来设计</span></span><br><span class=\"line\">    queue []<span class=\"type\">int</span></span><br><span class=\"line\">    front <span class=\"type\">int</span></span><br><span class=\"line\">    rear <span class=\"type\">int</span></span><br><span class=\"line\">    capacity <span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Constructor</span><span class=\"params\">(k <span class=\"type\">int</span>)</span></span> MyCircularQueue &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> MyCircularQueue&#123;</span><br><span class=\"line\">        queue: <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>,k+<span class=\"number\">1</span>),</span><br><span class=\"line\">        front: <span class=\"number\">0</span>,</span><br><span class=\"line\">        rear: <span class=\"number\">0</span>,</span><br><span class=\"line\">        capacity: k+<span class=\"number\">1</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyCircularQueue)</span></span> EnQueue(value <span class=\"type\">int</span>) <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> this.IsFull()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    this.queue[this.rear] = value</span><br><span class=\"line\">    this.rear = (this.rear + <span class=\"number\">1</span>)%this.capacity</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyCircularQueue)</span></span> DeQueue() <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> this.IsEmpty()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    this.front = (this.front+<span class=\"number\">1</span>)%this.capacity</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyCircularQueue)</span></span> Front() <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> this.IsEmpty() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> this.queue[this.front]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyCircularQueue)</span></span> Rear() <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> this.IsEmpty()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    rearPosition := (this.rear<span class=\"number\">-1</span>+this.capacity)%this.capacity</span><br><span class=\"line\">    <span class=\"keyword\">return</span> this.queue[rearPosition]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyCircularQueue)</span></span> IsEmpty() <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> this.rear ==this.front</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyCircularQueue)</span></span> IsFull() <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (this.rear+<span class=\"number\">1</span>)%this.capacity == this.front</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Your MyCircularQueue object will be instantiated and called as such:</span></span><br><span class=\"line\"><span class=\"comment\"> * obj := Constructor(k);</span></span><br><span class=\"line\"><span class=\"comment\"> * param_1 := obj.EnQueue(value);</span></span><br><span class=\"line\"><span class=\"comment\"> * param_2 := obj.DeQueue();</span></span><br><span class=\"line\"><span class=\"comment\"> * param_3 := obj.Front();</span></span><br><span class=\"line\"><span class=\"comment\"> * param_4 := obj.Rear();</span></span><br><span class=\"line\"><span class=\"comment\"> * param_5 := obj.IsEmpty();</span></span><br><span class=\"line\"><span class=\"comment\"> * param_6 := obj.IsFull();</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"循环双向队列\"><a href=\"#循环双向队列\" class=\"headerlink\" title=\"循环双向队列\"></a>循环双向队列</h3><h4 id=\"解题思路-2\"><a href=\"#解题思路-2\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h4><p><strong>==犯错的地方：==</strong><br><font color='red'> InsertFront的时候，需要先移动front向前一位，然后再把值插进去</font><br>最开始想的，直接让front和rear都指向一个空白的空间，那么就需要在插入的时候先将front向前移动两位，但这样的话就会浪费一个数值的空间，因为多余一个位就完全可以满足要求</p>\n<p>使用k+1的情况，如果是在LRU缓存或者是Ringbuffer当中还需要考虑，将队尾[或者是队中]的元素插入到队首，也就是将最近使用的元素放到前面</p>\n<h4 id=\"代码-3\"><a href=\"#代码-3\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> MyCircularDeque <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    queue []<span class=\"type\">int</span></span><br><span class=\"line\">    front <span class=\"type\">int</span></span><br><span class=\"line\">    rear <span class=\"type\">int</span> </span><br><span class=\"line\">    capacity <span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Constructor</span><span class=\"params\">(k <span class=\"type\">int</span>)</span></span> MyCircularDeque &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> MyCircularDeque&#123;</span><br><span class=\"line\">        queue: <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>,k+<span class=\"number\">1</span>),</span><br><span class=\"line\">        front: <span class=\"number\">0</span>,</span><br><span class=\"line\">        rear: <span class=\"number\">0</span>,</span><br><span class=\"line\">        capacity: k+<span class=\"number\">1</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyCircularDeque)</span></span> InsertFront(value <span class=\"type\">int</span>) <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> this.IsFull()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    this.front = (this.front<span class=\"number\">-1</span> + this.capacity)%this.capacity</span><br><span class=\"line\">    this.queue[this.front] = value</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyCircularDeque)</span></span> InsertLast(value <span class=\"type\">int</span>) <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> this.IsFull()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    this.queue[this.rear] = value</span><br><span class=\"line\">    this.rear = (this.rear+<span class=\"number\">1</span>)%this.capacity</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyCircularDeque)</span></span> DeleteFront() <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> this.IsEmpty()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    this.front = (this.front+<span class=\"number\">1</span>)%this.capacity</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyCircularDeque)</span></span> DeleteLast() <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> this.IsEmpty()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    this.rear = (this.rear<span class=\"number\">-1</span>+this.capacity)%this.capacity</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyCircularDeque)</span></span> GetFront() <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> this.IsEmpty()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> this.queue[this.front]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyCircularDeque)</span></span> GetRear() <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> this.IsEmpty()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> this.queue[(this.rear<span class=\"number\">-1</span>+this.capacity)%this.capacity]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyCircularDeque)</span></span> IsEmpty() <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> this.front == this.rear</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(this *MyCircularDeque)</span></span> IsFull() <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> this.front == (this.rear+<span class=\"number\">1</span>)%this.capacity</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Your MyCircularDeque object will be instantiated and called as such:</span></span><br><span class=\"line\"><span class=\"comment\"> * obj := Constructor(k);</span></span><br><span class=\"line\"><span class=\"comment\"> * param_1 := obj.InsertFront(value);</span></span><br><span class=\"line\"><span class=\"comment\"> * param_2 := obj.InsertLast(value);</span></span><br><span class=\"line\"><span class=\"comment\"> * param_3 := obj.DeleteFront();</span></span><br><span class=\"line\"><span class=\"comment\"> * param_4 := obj.DeleteLast();</span></span><br><span class=\"line\"><span class=\"comment\"> * param_5 := obj.GetFront();</span></span><br><span class=\"line\"><span class=\"comment\"> * param_6 := obj.GetRear();</span></span><br><span class=\"line\"><span class=\"comment\"> * param_7 := obj.IsEmpty();</span></span><br><span class=\"line\"><span class=\"comment\"> * param_8 := obj.IsFull();</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n\n<p>相似点：</p>\n<ul>\n<li>都使用了取模的方式</li>\n</ul>\n<h2 id=\"单调队列\"><a href=\"#单调队列\" class=\"headerlink\" title=\"单调队列\"></a>单调队列</h2><p>单调队列属于双端队列的一种</p>\n<p>要求队列中的元素必须满足单调性</p>\n<p>单调队列如对时候的要求：入队前后，单调性完整</p>\n<p><strong>==单调递减队列最重要的特性==:<font color='red'>入队和出队的组合，可以在O(1)时间得到某个区间上的最大值</font></strong></p>\n<h3 id=\"情况讨论\"><a href=\"#情况讨论\" class=\"headerlink\" title=\"情况讨论\"></a>情况讨论</h3><blockquote>\n<p>需要回答的问题：</p>\n<ul>\n<li>这个区间是什么</li>\n<li>怎样定量地描述这个区间</li>\n<li>与队列中的元素个数有什么关系<br>可以分以下两种情况来讨论：</li>\n</ul>\n</blockquote>\n<ol>\n<li>只有入队的情况<br>在没有出队的情况下，对原数组的比较范围就会逐步增加<br>队首元素表示是已比较范围内的最大值</li>\n<li>出队和入队混合的情况<br>控制覆盖范围为 k –&gt; 滑动窗口<ul>\n<li>入队： 扩展单调队列的覆盖范围</li>\n<li>出队： 控制单调队列的覆盖范围</li>\n<li>队首元素是覆盖范围的最大值</li>\n<li>队列中的元素个数小于覆盖范围的元素个数</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"核心代码\"><a href=\"#核心代码\" class=\"headerlink\" title=\"核心代码\"></a>核心代码</h3><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//入队的代码</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(q *queue)</span></span>push(val <span class=\"type\">int</span>)&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 入队时候，要剔除掉尾部的元素，知道尾部元素大于或者是等于入队元素</span></span><br><span class=\"line\">    while(!q.isEmpty() &amp;&amp; q.getLast()&lt;val)&#123;</span><br><span class=\"line\">        q.removeLast()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 将元素入队</span></span><br><span class=\"line\">    q.addLast(val)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 出队的时候，需要给出一个value</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(q *queue)</span></span> pop(val <span class=\"type\">int</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!q.isEmpty() &amp;&amp; q.getFirst()==val)&#123;</span><br><span class=\"line\">        q.removeFirst()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样的代码编写关键：</p>\n<ul>\n<li>队首元素q.getFirst() 所获取的值是队列中的最大值</li>\n<li>出队时<ul>\n<li>如果一个元素已经被其他元素剔除出去了，那么他就不会再入队</li>\n<li>如果一个元素是当前队列的最大值，会再出队</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"滑动窗口的最大值\"><a href=\"#滑动窗口的最大值\" class=\"headerlink\" title=\"滑动窗口的最大值\"></a>滑动窗口的最大值</h3><h3 id=\"捡金币游戏\"><a href=\"#捡金币游戏\" class=\"headerlink\" title=\"捡金币游戏\"></a>捡金币游戏</h3><blockquote>\n<p>考点:</p>\n<ul>\n<li>找到get数组，并知道get数组是当前元素和滑动窗口中最大值的和计算而来</li>\n<li>利用单调队列在get[]数组上操作，找到滑动窗口的最大值</li>\n</ul>\n</blockquote>\n<p>拓展： 是否存在不同的出队方式</p>\n<blockquote>\n<p>整理一下代码模板：<br><font color = 'red'>分层遍历</font><br><font color = 'red'>循环队列</font><br><font color = 'red'>单调队列</font></p>\n</blockquote>\n<p>一些有意思的题目：</p>\n<ul>\n<li>利用栈实现一个队列</li>\n<li>利用队列实现一个栈</li>\n</ul>\n<h1 id=\"优先级队列：堆与优先级队列，筛选最优元素\"><a href=\"#优先级队列：堆与优先级队列，筛选最优元素\" class=\"headerlink\" title=\"优先级队列：堆与优先级队列，筛选最优元素\"></a>优先级队列：堆与优先级队列，筛选最优元素</h1><h2 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h2><p> FIFO队列： 节点之间的优先级是由遍历时的顺序决定的<br> 优先级队列： 节点之间按照大小进行排序后，再决定优先级，底层依赖的数据结构一般是堆</p>\n<h4 id=\"堆的分类\"><a href=\"#堆的分类\" class=\"headerlink\" title=\"堆的分类\"></a>堆的分类</h4><ol>\n<li><p>大根堆<br>节点的值比他的孩子节点都大</p>\n</li>\n<li><p>小根堆<br>节点的值要比他的孩子节点都小<br>堆的特点–大堆的根是最大值，小堆的根是最小值</p>\n</li>\n</ol>\n<h4 id=\"堆的实现\"><a href=\"#堆的实现\" class=\"headerlink\" title=\"堆的实现\"></a>堆的实现</h4><blockquote>\n<p>以大堆为例子</p>\n</blockquote>\n<p>大多数时候都是使用数组来表示堆</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Heap <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    data []<span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建新的大根堆</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewHeap</span><span class=\"params\">()</span></span> Heap &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Heap&#123;</span><br><span class=\"line\">        data: <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, <span class=\"number\">0</span>),</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取大根堆的长度</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h *Heap)</span></span> Len() <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(h.data)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取指定位置元素的父节点位置</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">parent</span><span class=\"params\">(i <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (i - <span class=\"number\">1</span>) / <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取指定位置元素的左子节点位置</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">leftChild</span><span class=\"params\">(i <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> i*<span class=\"number\">2</span> + <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取指定位置元素的右子节点位置</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">rightChild</span><span class=\"params\">(i <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> i*<span class=\"number\">2</span> + <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 下沉操作，将指定位置的元素向下移动，直到它大于所有子节点为止</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h *Heap)</span></span> sink(i <span class=\"type\">int</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">        left, right := leftChild(i), rightChild(i)</span><br><span class=\"line\">        maxPos := i</span><br><span class=\"line\">        <span class=\"keyword\">if</span> left &lt; h.Len() &amp;&amp; h.data[left] &gt; h.data[maxPos] &#123;</span><br><span class=\"line\">            maxPos = left</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> right &lt; h.Len() &amp;&amp; h.data[right] &gt; h.data[maxPos] &#123;</span><br><span class=\"line\">            maxPos = right</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> maxPos == i &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        h.data[i], h.data[maxPos] = h.data[maxPos], h.data[i]</span><br><span class=\"line\">        i = maxPos</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 上浮操作，将指定位置的元素向上移动，直到它小于其父节点为止</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h *Heap)</span></span> swim(i <span class=\"type\">int</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        p := parent(i)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> h.data[p] &gt;= h.data[i] &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        h.data[p], h.data[i] = h.data[i], h.data[p]</span><br><span class=\"line\">        i = p</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 出堆，弹出大根堆的堆顶元素，并重新调整堆结构</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h *Heap)</span></span> pop() <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    res := h.data[<span class=\"number\">0</span>]</span><br><span class=\"line\">    h.data[<span class=\"number\">0</span>] = h.data[<span class=\"built_in\">len</span>(h.data)<span class=\"number\">-1</span>]</span><br><span class=\"line\">    h.data = h.data[:<span class=\"built_in\">len</span>(h.data)<span class=\"number\">-1</span>]</span><br><span class=\"line\">    h.sink(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 入堆，将新元素插入到大根堆中，并重新调整堆结构</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h *Heap)</span></span> push(val <span class=\"type\">int</span>) &#123;</span><br><span class=\"line\">    h.data = <span class=\"built_in\">append</span>(h.data, val)</span><br><span class=\"line\">    h.swim(<span class=\"built_in\">len</span>(h.data) - <span class=\"number\">1</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"最小的k个数\"><a href=\"#最小的k个数\" class=\"headerlink\" title=\"最小的k个数\"></a>最小的k个数</h4><blockquote>\n<p>N 的数量级非常大，或者其希望能够获得一个较小的区间内的数字<br>同时输出的操作是每时每刻的话，一直是用排序的代价就会很高<br>在上述大根堆的基础上来完成的话，就是以下代码：</p>\n</blockquote>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">getLeastNumbers</span><span class=\"params\">(arr []<span class=\"type\">int</span>, k <span class=\"type\">int</span>)</span></span> []<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 建立大根堆</span></span><br><span class=\"line\">    minH := Heap&#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i:=<span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(arr); i++&#123;</span><br><span class=\"line\">        minH.push(arr[i])</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(minH.data) &gt; k &#123;</span><br><span class=\"line\">            minH.pop()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> minH.data</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"优先级队列\"><a href=\"#优先级队列\" class=\"headerlink\" title=\"优先级队列\"></a>优先级队列</h2><h4 id=\"google-面试题目：有一台机器会每隔一秒输出一个信号，请在每次输出信号的时候输出所有信号的中间值，如果信号数量位偶数则返回中间两数的平均值\"><a href=\"#google-面试题目：有一台机器会每隔一秒输出一个信号，请在每次输出信号的时候输出所有信号的中间值，如果信号数量位偶数则返回中间两数的平均值\" class=\"headerlink\" title=\"google 面试题目：有一台机器会每隔一秒输出一个信号，请在每次输出信号的时候输出所有信号的中间值，如果信号数量位偶数则返回中间两数的平均值\"></a>google 面试题目：有一台机器会每隔一秒输出一个信号，请在每次输出信号的时候输出所有信号的中间值，如果信号数量位偶数则返回中间两数的平均值</h4><p>题目连接：</p>\n<blockquote>\n<p>leetcode 这道题目还能够用排序是因为算的是所有一共的，如果是实时输出就每次都需要排序，所以直接维护一个结构更适合</p>\n</blockquote>\n<h1 id=\"链表：-如何利用”假头，新链表，双指针”解决链表类型题目\"><a href=\"#链表：-如何利用”假头，新链表，双指针”解决链表类型题目\" class=\"headerlink\" title=\"链表： 如何利用”假头，新链表，双指针”解决链表类型题目\"></a>链表： 如何利用”假头，新链表，双指针”解决链表类型题目</h1><blockquote>\n<p>解决链表问题的三板斧：<br>假头<br>新链表<br>双指针<br>链表尤其需要考虑各种边界条件、链表结构简单，但是查找交换反转非常容易出错</p>\n</blockquote>\n<h3 id=\"三板斧\"><a href=\"#三板斧\" class=\"headerlink\" title=\"三板斧\"></a>三板斧</h3><h4 id=\"假头\"><a href=\"#假头\" class=\"headerlink\" title=\"假头\"></a>假头</h4><p>在链表前面增加额外的节点–&gt; 可以节省许多对于nil指针的操作，能够节省不少的精力</p>\n<p>dummy 指针初始化之后就不会再发生改变了<br>tail  指针随着元素改变移动</p>\n<ol>\n<li>tail 插入节点</li>\n<li>头部插入节点</li>\n<li>查找结点（总是会查找目标节点的pre）</li>\n<li>在指定位置插入节点–&gt; getPre</li>\n<li>删除节点<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> linkList <span class=\"keyword\">interface</span>&#123;</span><br><span class=\"line\">    initDummyList()</span><br><span class=\"line\">    appendNode(*<span class=\"keyword\">interface</span>&#123;&#125;)<span class=\"type\">bool</span></span><br><span class=\"line\">    getPre(<span class=\"type\">int</span>)*<span class=\"keyword\">interface</span>&#123;&#125;</span><br><span class=\"line\">    findNode(<span class=\"type\">int</span>) *<span class=\"keyword\">interface</span>&#123;&#125;</span><br><span class=\"line\">    insertNode(*<span class=\"keyword\">interface</span>&#123;&#125;)<span class=\"type\">bool</span></span><br><span class=\"line\">    deletNode(<span class=\"type\">int</span>) <span class=\"type\">bool</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h1 id=\"树：-如何深度运用树的遍历\"><a href=\"#树：-如何深度运用树的遍历\" class=\"headerlink\" title=\"树： 如何深度运用树的遍历\"></a>树： 如何深度运用树的遍历</h1><blockquote>\n<p>大部分语言的map数据结构，基本上是基于树来实现的<br>b+树，红黑树，二叉树等等，在leetcode和考题当中常见二叉树，同时对于其他的树结构，可以通过二叉树的遍历来扩展出对应的遍历方式。</p>\n</blockquote>\n<h2 id=\"1-ensp-树节点的结构：\"><a href=\"#1-ensp-树节点的结构：\" class=\"headerlink\" title=\"1 &ensp; 树节点的结构：\"></a><strong>1</strong> &ensp; 树节点的结构：</h2><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> TreeNode <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">    val <span class=\"type\">int</span></span><br><span class=\"line\">    left *TreeNode</span><br><span class=\"line\">    right *TreeNode</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-ensp-前序遍历\"><a href=\"#2-ensp-前序遍历\" class=\"headerlink\" title=\"2 &ensp; 前序遍历\"></a><strong>2</strong> &ensp; 前序遍历</h2><blockquote>\n<p><font color='red'>遍历根节点、左子树、右子树</font></p>\n</blockquote>\n<h3 id=\"2-1-ensp-使用递归完成前序遍历\"><a href=\"#2-1-ensp-使用递归完成前序遍历\" class=\"headerlink\" title=\"2.1 &ensp; 使用递归完成前序遍历\"></a><strong>2.1</strong> &ensp; 使用递归完成前序遍历</h3><p>采用整体的思想：<br>首先遍历根节点，然后遍历左子树的时候，就把左子树放到相应的位置，遍历右子树的时候，就把右子树放到相应的位置。<br>然后展开左子树<br>然后展开右子树</p>\n<blockquote>\n<p>时间复杂度：O(N)<br>空间复杂度：O(K) K表示的树的高度<br><font color=CC6699>一定注意要问清楚:在访问每个节点的时候，是需要Print出来，还是放到一个链表/数组当中存储</font></p>\n</blockquote>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//使用递归方式</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">traverse</span><span class=\"params\">(root *TreeNode)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> root == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    traverse(root.Left)</span><br><span class=\"line\">    traverse(root.Right)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-ensp-使用栈完成前序遍历\"><a href=\"#2-2-ensp-使用栈完成前序遍历\" class=\"headerlink\" title=\"2.2 &ensp; 使用栈完成前序遍历\"></a><strong>2.2</strong> &ensp; 使用栈完成前序遍历</h3><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> TreeNode <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Val   <span class=\"type\">int</span></span><br><span class=\"line\">    Left  *TreeNode</span><br><span class=\"line\">    Right *TreeNode</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 前序遍历</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">preorderTraversal</span><span class=\"params\">(root *TreeNode)</span></span> []<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> root == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> []<span class=\"type\">int</span>&#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> res []<span class=\"type\">int</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> stack []*TreeNode</span><br><span class=\"line\">    stack = <span class=\"built_in\">append</span>(stack, root)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"built_in\">len</span>(stack) &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        node := stack[<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>]</span><br><span class=\"line\">        stack = stack[:<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>]</span><br><span class=\"line\">        res = <span class=\"built_in\">append</span>(res, node.Val)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> node.Right != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            stack = <span class=\"built_in\">append</span>(stack, node.Right)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> node.Left != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            stack = <span class=\"built_in\">append</span>(stack, node.Left)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-1-ensp-Morris-遍历-只需要O-1-的空间\"><a href=\"#2-2-1-ensp-Morris-遍历-只需要O-1-的空间\" class=\"headerlink\" title=\"2.2-1 &ensp; Morris 遍历: 只需要O(1)的空间\"></a><strong>2.2-1</strong> &ensp; Morris 遍历: 只需要O(1)的空间</h3><h3 id=\"2-3-ensp-题目\"><a href=\"#2-3-ensp-题目\" class=\"headerlink\" title=\"2.3 &ensp; 题目\"></a><strong>2.3</strong> &ensp; 题目</h3><p>下述为前序遍历常见题目</p>\n<h4 id=\"2-3-1-验证二叉树\"><a href=\"#2-3-1-验证二叉树\" class=\"headerlink\" title=\"2.3.1 验证二叉树\"></a><strong>2.3.1</strong> 验证二叉树</h4><p>验证一颗二叉树是否满足二叉搜索树的性质</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> basic <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">    node *TreeNode</span><br><span class=\"line\">    leftboard <span class=\"type\">int</span></span><br><span class=\"line\">    rightboard <span class=\"type\">int</span></span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">stackBst</span><span class=\"params\">(root *TreeNode)</span></span> <span class=\"type\">bool</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 构造边界影子树栈</span></span><br><span class=\"line\">    stack := <span class=\"built_in\">make</span>([]basic,<span class=\"number\">0</span>)</span><br><span class=\"line\">    left, right := math.MinInt64,math.MaxInt64</span><br><span class=\"line\">    <span class=\"keyword\">for</span> root != <span class=\"literal\">nil</span> || <span class=\"built_in\">len</span>(stack) &gt; <span class=\"number\">0</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 当还没有遍历完左子树</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> root != <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 判断不满足搜索树的节点要求</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> root.Val &lt;= left || root.Val &gt;= right &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 满足范围要求，那就要往下继续找</span></span><br><span class=\"line\">            <span class=\"comment\">// 先记录当前影子树的边界</span></span><br><span class=\"line\">            stack = <span class=\"built_in\">append</span>(stack, basic&#123;</span><br><span class=\"line\">                node: root,</span><br><span class=\"line\">                leftboard: left,</span><br><span class=\"line\">                rightboard: right,</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">            <span class=\"comment\">// 往下移动，同时缩小右边界</span></span><br><span class=\"line\">            right = root.Val</span><br><span class=\"line\">            root = root.Left</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 左子树遍历完了，找右子树</span></span><br><span class=\"line\">        top := stack[<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>]</span><br><span class=\"line\">        stack = stack[:<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 关键就是这里需要重新赋值比较的left和right</span></span><br><span class=\"line\">        root = top.node</span><br><span class=\"line\">        left,right = top.leftboard,top.rightboard</span><br><span class=\"line\">        left = root.Val</span><br><span class=\"line\">        root = root.Right       </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">isValidBST</span><span class=\"params\">(root *TreeNode)</span></span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> stackBst(root)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>或者是使用递归的方式</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">isValidBST</span><span class=\"params\">(root *TreeNode)</span></span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    ans := <span class=\"literal\">true</span></span><br><span class=\"line\">    ans = preOderBST(root,math.MinInt64,math.MaxInt64)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">preOderBST</span><span class=\"params\">(root *TreeNode, left <span class=\"type\">int</span>, right <span class=\"type\">int</span>)</span></span><span class=\"type\">bool</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> root == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> root.Val &lt;= left || root.Val &gt;= right &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> preOderBST(root.Left,left,root.Val) &amp;&amp; preOderBST(root.Right,root.Val,right)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// // 特殊在于 golang 的特点： 传参如果要一直修改其中的值，就需要传入一个引用，或者是采用闭包的方式</span></span><br><span class=\"line\"><span class=\"comment\">// func preOderBST(root *TreeNode, left int, right int, ans *bool)&#123;</span></span><br><span class=\"line\"><span class=\"comment\">// \t// 递归是否达到条件，即到达叶节点，到达叶节点表示所有节点都满足情况，所以为true</span></span><br><span class=\"line\"><span class=\"comment\">// \t// 第二个条件是 是否有判断出不满足的树，有的话ans就会变成false,直接返回</span></span><br><span class=\"line\"><span class=\"comment\">// \tif root == nil || !(*ans) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">// \t\treturn</span></span><br><span class=\"line\"><span class=\"comment\">// \t&#125;</span></span><br><span class=\"line\"><span class=\"comment\">// \t// 判断条件就是 当前的值要小于right同时大于left才满足</span></span><br><span class=\"line\"><span class=\"comment\">// \tif root.Val &lt;= left || root.Val &gt;= right &#123;</span></span><br><span class=\"line\"><span class=\"comment\">// \t\t*ans = false</span></span><br><span class=\"line\"><span class=\"comment\">// \t\treturn</span></span><br><span class=\"line\"><span class=\"comment\">// \t&#125;</span></span><br><span class=\"line\"><span class=\"comment\">// \t// 前序遍历</span></span><br><span class=\"line\"><span class=\"comment\">// \tpreOderBST(root.Left, left, root.Val, ans)</span></span><br><span class=\"line\"><span class=\"comment\">// \tpreOderBST(root.Right, root.Val, right, ans)</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-3-2-目标和的所有路径\"><a href=\"#2-3-2-目标和的所有路径\" class=\"headerlink\" title=\"2.3.2 目标和的所有路径\"></a><strong>2.3.2</strong> 目标和的所有路径</h4><p><a href=\"https://leetcode.cn/problems/path-sum/\">https://leetcode.cn/problems/path-sum/</a></p>\n<blockquote>\n<p>二叉树进行回溯的代码模板</p>\n<ul>\n<li>遇到新的节点： 路径总是从尾部添加节点</li>\n<li>遍历完节点，路径就把他从尾部扔掉</li>\n</ul>\n</blockquote>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// func hasPathSum(root *TreeNode, targetSum int) bool &#123;</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">//     var backTrace func(*TreeNode, int) bool</span></span><br><span class=\"line\"><span class=\"comment\">//     backTrace = func(root *TreeNode, Sum int)bool&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//         left , right := false,false </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//         if root == nil &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//             return false</span></span><br><span class=\"line\"><span class=\"comment\">//         &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//         Sum += root.Val</span></span><br><span class=\"line\"><span class=\"comment\">//         if root.Left == nil &amp;&amp; root.Right == nil &amp;&amp; Sum == targetSum &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//             return true</span></span><br><span class=\"line\"><span class=\"comment\">//         &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//         if root.Left != nil&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//             left = backTrace(root.Left,Sum)</span></span><br><span class=\"line\"><span class=\"comment\">//         &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//         if root.Right != nil&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//             right = backTrace(root.Right,Sum)</span></span><br><span class=\"line\"><span class=\"comment\">//         &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//         return left || right</span></span><br><span class=\"line\"><span class=\"comment\">//     &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//     return backTrace(root,0)</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// // 使用广度优先的遍历--层序遍历--队列</span></span><br><span class=\"line\"><span class=\"comment\">// func hasPathSum(root *TreeNode, targetSum int) bool &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//     if root == nil&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//         return false</span></span><br><span class=\"line\"><span class=\"comment\">//     &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//     fifo := make([]*TreeNode,0)</span></span><br><span class=\"line\"><span class=\"comment\">//     Qsize := 1</span></span><br><span class=\"line\"><span class=\"comment\">//     fifo = append(fifo,root)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//     for len(fifo) &gt; 0 &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//         for Qsize &gt; 0 &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//             top := fifo[0]</span></span><br><span class=\"line\"><span class=\"comment\">//             if top.Left == nil &amp;&amp; top.Right == nil &amp;&amp; top.Val == targetSum&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//                 return true</span></span><br><span class=\"line\"><span class=\"comment\">//             &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//             if top.Left != nil&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//                 top.Left.Val = top.Left.Val + top.Val</span></span><br><span class=\"line\"><span class=\"comment\">//                 fifo = append(fifo,top.Left)</span></span><br><span class=\"line\"><span class=\"comment\">//             &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//             if top.Right != nil&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//                 top.Right.Val = top.Right.Val + top.Val</span></span><br><span class=\"line\"><span class=\"comment\">//                 fifo = append(fifo,top.Right)</span></span><br><span class=\"line\"><span class=\"comment\">//             &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//             fifo = fifo[1:]</span></span><br><span class=\"line\"><span class=\"comment\">//             Qsize -= 1</span></span><br><span class=\"line\"><span class=\"comment\">//         &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//         Qsize = len(fifo)</span></span><br><span class=\"line\"><span class=\"comment\">//     &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//     return false</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用栈来存储，栈中元素是当前树的路径</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> path <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">    node *TreeNode</span><br><span class=\"line\">    sum <span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">hasPathSum</span><span class=\"params\">(root *TreeNode, targetSum <span class=\"type\">int</span>)</span></span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> root == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    paths := <span class=\"built_in\">make</span>([]path,<span class=\"number\">0</span>)</span><br><span class=\"line\">    paths = <span class=\"built_in\">append</span>(paths, path&#123;</span><br><span class=\"line\">        node: root,</span><br><span class=\"line\">        sum: root.Val,</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"built_in\">len</span>(paths) &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        node := paths[<span class=\"built_in\">len</span>(paths)<span class=\"number\">-1</span>]</span><br><span class=\"line\">        paths = paths[:<span class=\"built_in\">len</span>(paths)<span class=\"number\">-1</span>]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> node.node.Left == <span class=\"literal\">nil</span> &amp;&amp; node.node.Right == <span class=\"literal\">nil</span> &amp;&amp; node.sum == targetSum &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> node.node.Right != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            right := node.node.Right</span><br><span class=\"line\">            paths = <span class=\"built_in\">append</span>(paths,path&#123;</span><br><span class=\"line\">                node: right,</span><br><span class=\"line\">                sum: right.Val + node.sum,</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> node.node.Left != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            left := node.node.Left</span><br><span class=\"line\">            paths = <span class=\"built_in\">append</span>(paths,path&#123;</span><br><span class=\"line\">                node: left,</span><br><span class=\"line\">                sum: left.Val + node.sum,</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-3-3-得到路径和为指定数字的路径集合\"><a href=\"#2-3-3-得到路径和为指定数字的路径集合\" class=\"headerlink\" title=\"2.3.3 得到路径和为指定数字的路径集合\"></a><strong>2.3.3</strong> 得到路径和为指定数字的路径集合</h4><p><a href=\"https://leetcode.cn/problems/path-sum-ii/solution/\">https://leetcode.cn/problems/path-sum-ii/solution/</a><br><font color='red'> 这道题目非常重要：有两大问题都在这个地方表现出来了</font></p>\n<p>==Golang的特性：Defer函数的使用==<br>这道题目在使用前序遍历的时候，由于在叶子节点以及从左子树转换为右子树的时候都需要将原本记录在path当中的路径节点删除pop出来，递归时候就需要考虑在什么时候执行出栈操作，没错即便是在递归当中也还是必须要考虑栈的操作，因为需要一个连续记录的路径信息</p>\n<p>关键在于pop的时机：pop的时机是：1. 本身是叶子节点，直接return 结束dfs，2. 左右的子树都被递归判断过的树中结点，也就是dfs(Left),dfs(Right)正常结束，刚好发现二者均都是在dfs执行完之后执行，而且覆盖了dfs执行完之后所有的情况<br>同时 Golang 的 <strong>Defer(){}</strong> 会在函数执行完并在返回之前执行，完全满足这个场景的需求，所以可以在递归函数体当中使用defer来完成对应的操作</p>\n<p>==Golang的特性：切片索引==<br>切片本身就是指针，且每次操作都会影响到底层数组<br>如果不在递归函数体当中使用切片之前重新对切片进行赋值，那么，之后对于底层数组的操作也会反映到之前的切片上，产生的效果就是明明原本计算好了结果但最后得到的并不是正确答案，关键就在于==后面切片的操作修改了底层数组，导致原本切片对应的结果被修改了==</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">pathSum</span><span class=\"params\">(root *TreeNode, targetSum <span class=\"type\">int</span>)</span></span> [][]<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    result := <span class=\"built_in\">make</span>([][]<span class=\"type\">int</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">    path := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> root == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> dfs <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(*TreeNode,<span class=\"type\">int</span>)</span></span></span><br><span class=\"line\">    dfs = <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(root *TreeNode,left <span class=\"type\">int</span>)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> root == <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        path = <span class=\"built_in\">append</span>(path,root.Val)</span><br><span class=\"line\">        left = left - root.Val</span><br><span class=\"line\">        <span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123; </span><br><span class=\"line\">            path = path[:<span class=\"built_in\">len</span>(path)<span class=\"number\">-1</span>]</span><br><span class=\"line\">        &#125;()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> root.Left == <span class=\"literal\">nil</span> &amp;&amp; root.Right == <span class=\"literal\">nil</span> &amp;&amp; left == <span class=\"number\">0</span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// new := make([]int,len(path))</span></span><br><span class=\"line\">            <span class=\"comment\">// copy(new,path)</span></span><br><span class=\"line\">            <span class=\"comment\">// result = append(result,new)</span></span><br><span class=\"line\">            result = <span class=\"built_in\">append</span>(result,<span class=\"built_in\">append</span>([]<span class=\"type\">int</span>(<span class=\"literal\">nil</span>),path...))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        dfs(root.Left,left)</span><br><span class=\"line\">        dfs(root.Right,left)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dfs(root,targetSum)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-3-3\"><a href=\"#2-3-3\" class=\"headerlink\" title=\"2.3.3\"></a><strong>2.3.3</strong></h4><blockquote>\n<p>等待回溯来看<br><a href=\"https://leetcode.cn/problems/path-sum-iii/solution/437-lu-jing-zong-he-iii-dfshui-su-qian-zhui-he-yi-/\">https://leetcode.cn/problems/path-sum-iii/solution/437-lu-jing-zong-he-iii-dfshui-su-qian-zhui-he-yi-/</a></p>\n</blockquote>\n<h2 id=\"3-中序遍历\"><a href=\"#3-中序遍历\" class=\"headerlink\" title=\"3 中序遍历\"></a><strong>3</strong> 中序遍历</h2><p><font color='red'>遍历左子树，然后是根节点，然后是右子树</font></p>\n<h3 id=\"3-1-ensp-使用递归完成中序遍历\"><a href=\"#3-1-ensp-使用递归完成中序遍历\" class=\"headerlink\" title=\"3.1 &ensp; 使用递归完成中序遍历\"></a><strong>3.1</strong> &ensp; 使用递归完成中序遍历</h3><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-ensp-使用栈完成中序遍历\"><a href=\"#3-2-ensp-使用栈完成中序遍历\" class=\"headerlink\" title=\"3.2 &ensp; 使用栈完成中序遍历\"></a><strong>3.2</strong> &ensp; 使用栈完成中序遍历</h3><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">inorderTraversal</span><span class=\"params\">(root *TreeNode)</span></span> []<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> root == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> []<span class=\"type\">int</span>&#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> res []<span class=\"type\">int</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> stack []*TreeNode</span><br><span class=\"line\">    <span class=\"keyword\">var</span> pathStack []<span class=\"type\">string</span></span><br><span class=\"line\">    node := root</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> node != <span class=\"literal\">nil</span> || <span class=\"built_in\">len</span>(stack) &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> node != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            stack = <span class=\"built_in\">append</span>(stack, node)</span><br><span class=\"line\">            pathStack = <span class=\"built_in\">append</span>(pathStack, fmt.Sprintf(<span class=\"string\">&quot;%d&quot;</span>, node.Val))</span><br><span class=\"line\">            node = node.Left</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            node = stack[<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>]</span><br><span class=\"line\">            stack = stack[:<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>]</span><br><span class=\"line\">            path := pathStack[<span class=\"built_in\">len</span>(pathStack)<span class=\"number\">-1</span>]</span><br><span class=\"line\">            pathStack = pathStack[:<span class=\"built_in\">len</span>(pathStack)<span class=\"number\">-1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> node.Left == <span class=\"literal\">nil</span> &amp;&amp; node.Right == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">                res = <span class=\"built_in\">append</span>(res, node.Val)</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 输出到达叶子节点的路径</span></span><br><span class=\"line\">                fmt.Println(path)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            node = node.Right</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-3-找出二叉搜索树里面出现次数最多的数\"><a href=\"#3-3-找出二叉搜索树里面出现次数最多的数\" class=\"headerlink\" title=\"3.3 找出二叉搜索树里面出现次数最多的数\"></a><strong>3.3</strong> 找出二叉搜索树里面出现次数最多的数</h3><p>找众数就需要遍历所有的节点，二叉搜索树中序遍历的结果会是一个递增的数组，其数据特性就在于使用中序遍历的时候，所有的元素都是连续的</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * type TreeNode struct &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     Val int</span></span><br><span class=\"line\"><span class=\"comment\"> *     Left *TreeNode</span></span><br><span class=\"line\"><span class=\"comment\"> *     Right *TreeNode</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">findMode</span><span class=\"params\">(root *TreeNode)</span></span> []<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 结果数组</span></span><br><span class=\"line\">    ans := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">    base,count,maxnum := math.MinInt64,<span class=\"number\">0</span>,<span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使用递归的方式</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> dfs <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(*TreeNode)</span></span></span><br><span class=\"line\">    dfs = <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(root *TreeNode)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> root == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        dfs(root.Left)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> root.Val == base &#123;</span><br><span class=\"line\">            count++</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            base = root.Val</span><br><span class=\"line\">            count = <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> count == maxnum &#123;</span><br><span class=\"line\">            ans = <span class=\"built_in\">append</span>(ans,base)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> count &gt; maxnum &#123;</span><br><span class=\"line\">            ans = []<span class=\"type\">int</span>&#123;&#125;</span><br><span class=\"line\">            maxnum = count</span><br><span class=\"line\">            ans = <span class=\"built_in\">append</span>(ans,base)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        dfs(root.Right)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dfs(root)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-4-找出二叉搜索树里面任意两个节点之间绝对值得最小值\"><a href=\"#3-4-找出二叉搜索树里面任意两个节点之间绝对值得最小值\" class=\"headerlink\" title=\"3.4 找出二叉搜索树里面任意两个节点之间绝对值得最小值\"></a><strong>3.4</strong> 找出二叉搜索树里面任意两个节点之间绝对值得最小值</h3><p><a href=\"https://leetcode.cn/problems/minimum-distance-between-bst-nodes/\">https://leetcode.cn/problems/minimum-distance-between-bst-nodes/</a></p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">minDiffInBST</span><span class=\"params\">(root *TreeNode)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用栈来中序遍历，栈顶元素就是上一遍历的节点元素</span></span><br><span class=\"line\">    stack := <span class=\"built_in\">make</span>([]*TreeNode,<span class=\"number\">0</span>)</span><br><span class=\"line\">    res := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> root != <span class=\"literal\">nil</span> || <span class=\"built_in\">len</span>(stack) &gt; <span class=\"number\">0</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> root != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            stack = <span class=\"built_in\">append</span>(stack,root)</span><br><span class=\"line\">            root = root.Left</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        node := stack[<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>]</span><br><span class=\"line\">        stack = stack[:<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>]</span><br><span class=\"line\">        res = <span class=\"built_in\">append</span>(res,node.Val)</span><br><span class=\"line\"></span><br><span class=\"line\">        root = node</span><br><span class=\"line\">        root = root.Right</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    m := math.MaxInt64</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i:= <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(res)<span class=\"number\">-1</span>; i++&#123;</span><br><span class=\"line\">        r := res[i+<span class=\"number\">1</span>]-res[i]</span><br><span class=\"line\">        m = min(m,r) </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> m</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">min</span><span class=\"params\">(args ...<span class=\"type\">int</span>)</span></span><span class=\"type\">int</span>&#123;</span><br><span class=\"line\">    min := args[<span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, val := <span class=\"keyword\">range</span> args&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> val &lt; min &#123;</span><br><span class=\"line\">            min = val</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> min</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-5-一棵二叉搜索树的两个节点被交换了，恢复这颗二叉搜索树\"><a href=\"#3-5-一棵二叉搜索树的两个节点被交换了，恢复这颗二叉搜索树\" class=\"headerlink\" title=\"3.5 一棵二叉搜索树的两个节点被交换了，恢复这颗二叉搜索树\"></a><strong>3.5</strong> 一棵二叉搜索树的两个节点被交换了，恢复这颗二叉搜索树</h3><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">recoverTree</span><span class=\"params\">(root *TreeNode)</span></span>  &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用递归解决这个问题</span></span><br><span class=\"line\">    problem := <span class=\"built_in\">make</span>([]*TreeNode,<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">var</span> findP <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(*TreeNode)</span></span></span><br><span class=\"line\">    findP = <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(root *TreeNode)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> root == <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        findP(root.Left)</span><br><span class=\"line\">        <span class=\"comment\">// if pre == math.MaxInt64&#123;</span></span><br><span class=\"line\">        <span class=\"comment\">//     pre = root.Val</span></span><br><span class=\"line\">        <span class=\"comment\">//     return</span></span><br><span class=\"line\">        <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">        <span class=\"comment\">// if root.Val - pre &lt; 0&#123;</span></span><br><span class=\"line\">        <span class=\"comment\">//     problem = append(problem,root)</span></span><br><span class=\"line\">        <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">        <span class=\"comment\">// pre = root.Val</span></span><br><span class=\"line\">        problem = <span class=\"built_in\">append</span>(problem, root)</span><br><span class=\"line\">        findP(root.Right)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    findP(root)</span><br><span class=\"line\">    pre,cur := <span class=\"number\">-1</span>,<span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(problem)<span class=\"number\">-1</span>; i++&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> problem[i].Val &gt; problem[i+<span class=\"number\">1</span>].Val &#123;</span><br><span class=\"line\">            cur = i + <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> pre == <span class=\"number\">-1</span> &#123;</span><br><span class=\"line\">                pre = i</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    problem[pre].Val,problem[cur].Val = problem[cur].Val,problem[pre].Val</span><br><span class=\"line\">    <span class=\"keyword\">return</span> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"删除二叉搜索树的节点\"><a href=\"#删除二叉搜索树的节点\" class=\"headerlink\" title=\"删除二叉搜索树的节点\"></a>删除二叉搜索树的节点</h3><blockquote>\n<p>题目最重要的考点就是分类，讨论各种情况下的处理方式</p>\n</blockquote>\n<p><font sizecolor ='red'>清晰地讲出每种情况的处理办法</font><br><font sizecolor ='red'>清晰简介地实现代码</font></p>\n<h2 id=\"后序遍历\"><a href=\"#后序遍历\" class=\"headerlink\" title=\"后序遍历\"></a>后序遍历</h2><h3 id=\"使用栈完成后序遍历\"><a href=\"#使用栈完成后序遍历\" class=\"headerlink\" title=\"使用栈完成后序遍历\"></a>使用栈完成后序遍历</h3><h3 id=\"迭代写法的考点\"><a href=\"#迭代写法的考点\" class=\"headerlink\" title=\"迭代写法的考点\"></a>迭代写法的考点</h3><ol>\n<li>是否有右子树</li>\n<li>pre指针是不是指向当前结点的右子树</li>\n</ol>\n"},{"title":"Golang-非算法题目","catalog":true,"date":"2023-04-03T11:45:36.000Z","subtitle":null,"header-img":null,"published":0,"_content":"","source":"_posts/Algorithm/Golang-非算法题目/Golang-非算法题目.md","raw":"---\ntitle: Golang-非算法题目\ncatalog: true\ndate: 2023-04-03 19:45:36\nsubtitle:\nheader-img:\ntags:\ncategories:\npublished: false\n---\n","slug":"Algorithm/Golang-非算法题目/Golang-非算法题目","updated":"2023-04-22T13:24:02.176Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgtm6jq9000elyjx1uxr195c","content":"","site":{"data":{}},"cover":"/img/cover/elderring.png","cover_type":"img","excerpt":"","more":""},{"title":"动态规划入门","catalog":true,"date":"2023-03-23T18:20:14.000Z","subtitle":null,"header-img":null,"published":0,"_content":"\n# [动态规划] 动态规划入门\n\n> 核心特征： 动态规划中，每一个状态是有上一个状态推导出来的\n\n## 什么是动态规划\n> 对于一个问题，如何才能够识别出他是一个需要用动态规划解决的问题\n\n问题本质上不能够被划归为 DP(Dynamic Problem) 问题，因为 DP 是解决方法的特征并不是问题的特征。\n\n那么目标就变成哪一些问题可以使用 DP 来解决呢？\n\n首先是明确 DP 方法的特点： DP 本质上是**暴力解法，列举计算所有的可能，但通过 “memoized approach”(缓存思想)去消除了重复性的工作**。比如在斐波那契数列当中，当需要计算 f[i]的数值时候，完全可以从f[1],f[0] 重新开始计算，但当我们将f[i]和f[i-1]的计算式子排在一起的时候，就会发现二者从f[0]到f[i-2]的计算流程是完全一样的，也就是说f[i] 的结果可以从f[i-1]的结果上获取；那么从这个例子来看，我们可以将 DP 的方法流程理解为：\n* 求解问题需要列举/计算所有可能的解[问题的解包含在全集当中]\n* 计算每一种可能的流程和方法是完全一致的，且相互关联，一部分的结果可以帮助计算其它部分的结果\n\n\n结合上述的 DP 方法特点分析，依照笔者刷题看论文的经验来说，当一个问题是优化性质的问题，需要求解“最短/最长、最小化/最大化、最少/最多、最少/最大、最大/最小”的目标，而求解这个目标需要遍历几乎所有可能的排列组合，这类型的题目如果没有微积分、取模或者是其他更加直接的计算方式，那么简化的暴力破解方法-- DP 可能就是一个比较好的选择。\n这类型问题的表述可以是：“找到编辑操作的最小数量”，“找到最长的公共子序列”，\n\n\n## 动态规划与递归\n> 核心不同点就是：动态规划自下而上，递归自上而下\n\n动态规划和递归相同的特征在于：解决问题时候复用了计算的公式和流程，也就是说获得每一个阶段结果的计算流程(公式)是相同的，所以可以用同一段函数代码来表示\n\n不相同的地方在于：递归是从 f[i] 开始，不断回退调用之前的计算流程；而动态规划是从 f[0] 开始，不断累积存储中间的结果，直到遍历找到 f[i]\n\n## 使用动态规划的方法\n\n参考已有文章所给出的方法，结合个人的分析，给出以下解题流程：\n\n### 分析问题的解题流程，是否存在上述所说优化特征以及遍历形式，确定是否使用 DP 解题\n   \n\n### 使用 DP 解题\n\n1. 确定dp数组（dp table）以及下标的含义\n   **什么是DP数组呢？**\n   dp[i] 代表的是 i 位置的结果值(就是遍历到 i 值应该得出的结果值)\n   > dp 当然也不一定就是一维数组, 可以是dp[i][j], 得看 DP 遍历时候每一层循环分别的计算公式和意义是什么\n\n\n\n2. 确定递推公式\n3. dp数组如何初始化\n4. 确定遍历顺序\n5. 举例推导dp数组\n\n\n# 参考文献\n[1] 代码随想录: [https://programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E8%A7%A3%E9%A2%98%E6%AD%A5%E9%AA%A4]\n\n[2] Quora: [https://www.quora.com/How-do-I-recognize-a-problem-as-a-dynamic-programming-problem]\n\n[3] StackFlow: \n* [https://stackoverflow.com/questions/6164629/what-is-the-difference-between-bottom-up-and-top-down]\n* [https://stackoverflow.blog/2022/01/31/the-complete-beginners-guide-to-dynamic-programming/]\n* [https://softwareengineering.stackexchange.com/questions/219802/how-do-you-identify-a-problem-as-being-suitable-for-dynamic-programming]\n* [https://stackoverflow.com/questions/6184869/what-is-the-difference-between-memoization-and-dynamic-programming]\n\n[4] SpiceWorks: [https://www.spiceworks.com/tech/devops/articles/what-is-dynamic-programming/]\n\n[5] WAYNE W BISHOP：\n* [https://www.waynewbishop.com/dynamic-programming-problems]\n* [https://www.waynewbishop.com/computer-science-interview-questions]\n\n[6] Blog:\n* [https://people.computing.clemson.edu/~bcdean/dp_practice/]\n\n[7] Not used But may useful in the future:\n* [https://learntocodewith.me/posts/dynamic-programming/]\n* [https://medium.com/@adam.dejans/using-dynamic-programming-for-problem-solving-b54be2e47747]","source":"_posts/Algorithm/[动态规划] 动态规划入门/[动态规划] 动态规划入门.md","raw":"---\ntitle: 动态规划入门\ncatalog: true\ndate: 2023-03-24 02:20:14\nsubtitle: \nheader-img:\ntags: Dynamic Programming\ncategories: 算法\npublished: false\n---\n\n# [动态规划] 动态规划入门\n\n> 核心特征： 动态规划中，每一个状态是有上一个状态推导出来的\n\n## 什么是动态规划\n> 对于一个问题，如何才能够识别出他是一个需要用动态规划解决的问题\n\n问题本质上不能够被划归为 DP(Dynamic Problem) 问题，因为 DP 是解决方法的特征并不是问题的特征。\n\n那么目标就变成哪一些问题可以使用 DP 来解决呢？\n\n首先是明确 DP 方法的特点： DP 本质上是**暴力解法，列举计算所有的可能，但通过 “memoized approach”(缓存思想)去消除了重复性的工作**。比如在斐波那契数列当中，当需要计算 f[i]的数值时候，完全可以从f[1],f[0] 重新开始计算，但当我们将f[i]和f[i-1]的计算式子排在一起的时候，就会发现二者从f[0]到f[i-2]的计算流程是完全一样的，也就是说f[i] 的结果可以从f[i-1]的结果上获取；那么从这个例子来看，我们可以将 DP 的方法流程理解为：\n* 求解问题需要列举/计算所有可能的解[问题的解包含在全集当中]\n* 计算每一种可能的流程和方法是完全一致的，且相互关联，一部分的结果可以帮助计算其它部分的结果\n\n\n结合上述的 DP 方法特点分析，依照笔者刷题看论文的经验来说，当一个问题是优化性质的问题，需要求解“最短/最长、最小化/最大化、最少/最多、最少/最大、最大/最小”的目标，而求解这个目标需要遍历几乎所有可能的排列组合，这类型的题目如果没有微积分、取模或者是其他更加直接的计算方式，那么简化的暴力破解方法-- DP 可能就是一个比较好的选择。\n这类型问题的表述可以是：“找到编辑操作的最小数量”，“找到最长的公共子序列”，\n\n\n## 动态规划与递归\n> 核心不同点就是：动态规划自下而上，递归自上而下\n\n动态规划和递归相同的特征在于：解决问题时候复用了计算的公式和流程，也就是说获得每一个阶段结果的计算流程(公式)是相同的，所以可以用同一段函数代码来表示\n\n不相同的地方在于：递归是从 f[i] 开始，不断回退调用之前的计算流程；而动态规划是从 f[0] 开始，不断累积存储中间的结果，直到遍历找到 f[i]\n\n## 使用动态规划的方法\n\n参考已有文章所给出的方法，结合个人的分析，给出以下解题流程：\n\n### 分析问题的解题流程，是否存在上述所说优化特征以及遍历形式，确定是否使用 DP 解题\n   \n\n### 使用 DP 解题\n\n1. 确定dp数组（dp table）以及下标的含义\n   **什么是DP数组呢？**\n   dp[i] 代表的是 i 位置的结果值(就是遍历到 i 值应该得出的结果值)\n   > dp 当然也不一定就是一维数组, 可以是dp[i][j], 得看 DP 遍历时候每一层循环分别的计算公式和意义是什么\n\n\n\n2. 确定递推公式\n3. dp数组如何初始化\n4. 确定遍历顺序\n5. 举例推导dp数组\n\n\n# 参考文献\n[1] 代码随想录: [https://programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E8%A7%A3%E9%A2%98%E6%AD%A5%E9%AA%A4]\n\n[2] Quora: [https://www.quora.com/How-do-I-recognize-a-problem-as-a-dynamic-programming-problem]\n\n[3] StackFlow: \n* [https://stackoverflow.com/questions/6164629/what-is-the-difference-between-bottom-up-and-top-down]\n* [https://stackoverflow.blog/2022/01/31/the-complete-beginners-guide-to-dynamic-programming/]\n* [https://softwareengineering.stackexchange.com/questions/219802/how-do-you-identify-a-problem-as-being-suitable-for-dynamic-programming]\n* [https://stackoverflow.com/questions/6184869/what-is-the-difference-between-memoization-and-dynamic-programming]\n\n[4] SpiceWorks: [https://www.spiceworks.com/tech/devops/articles/what-is-dynamic-programming/]\n\n[5] WAYNE W BISHOP：\n* [https://www.waynewbishop.com/dynamic-programming-problems]\n* [https://www.waynewbishop.com/computer-science-interview-questions]\n\n[6] Blog:\n* [https://people.computing.clemson.edu/~bcdean/dp_practice/]\n\n[7] Not used But may useful in the future:\n* [https://learntocodewith.me/posts/dynamic-programming/]\n* [https://medium.com/@adam.dejans/using-dynamic-programming-for-problem-solving-b54be2e47747]","slug":"Algorithm/[动态规划] 动态规划入门/[动态规划] 动态规划入门","updated":"2023-04-22T13:24:02.176Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgtm6jqb000hlyjxeojzhsj5","content":"<h1 id=\"动态规划-动态规划入门\"><a href=\"#动态规划-动态规划入门\" class=\"headerlink\" title=\"[动态规划] 动态规划入门\"></a>[动态规划] 动态规划入门</h1><blockquote>\n<p>核心特征： 动态规划中，每一个状态是有上一个状态推导出来的</p>\n</blockquote>\n<h2 id=\"什么是动态规划\"><a href=\"#什么是动态规划\" class=\"headerlink\" title=\"什么是动态规划\"></a>什么是动态规划</h2><blockquote>\n<p>对于一个问题，如何才能够识别出他是一个需要用动态规划解决的问题</p>\n</blockquote>\n<p>问题本质上不能够被划归为 DP(Dynamic Problem) 问题，因为 DP 是解决方法的特征并不是问题的特征。</p>\n<p>那么目标就变成哪一些问题可以使用 DP 来解决呢？</p>\n<p>首先是明确 DP 方法的特点： DP 本质上是<strong>暴力解法，列举计算所有的可能，但通过 “memoized approach”(缓存思想)去消除了重复性的工作</strong>。比如在斐波那契数列当中，当需要计算 f[i]的数值时候，完全可以从f[1],f[0] 重新开始计算，但当我们将f[i]和f[i-1]的计算式子排在一起的时候，就会发现二者从f[0]到f[i-2]的计算流程是完全一样的，也就是说f[i] 的结果可以从f[i-1]的结果上获取；那么从这个例子来看，我们可以将 DP 的方法流程理解为：</p>\n<ul>\n<li>求解问题需要列举/计算所有可能的解[问题的解包含在全集当中]</li>\n<li>计算每一种可能的流程和方法是完全一致的，且相互关联，一部分的结果可以帮助计算其它部分的结果</li>\n</ul>\n<p>结合上述的 DP 方法特点分析，依照笔者刷题看论文的经验来说，当一个问题是优化性质的问题，需要求解“最短/最长、最小化/最大化、最少/最多、最少/最大、最大/最小”的目标，而求解这个目标需要遍历几乎所有可能的排列组合，这类型的题目如果没有微积分、取模或者是其他更加直接的计算方式，那么简化的暴力破解方法– DP 可能就是一个比较好的选择。<br>这类型问题的表述可以是：“找到编辑操作的最小数量”，“找到最长的公共子序列”，</p>\n<h2 id=\"动态规划与递归\"><a href=\"#动态规划与递归\" class=\"headerlink\" title=\"动态规划与递归\"></a>动态规划与递归</h2><blockquote>\n<p>核心不同点就是：动态规划自下而上，递归自上而下</p>\n</blockquote>\n<p>动态规划和递归相同的特征在于：解决问题时候复用了计算的公式和流程，也就是说获得每一个阶段结果的计算流程(公式)是相同的，所以可以用同一段函数代码来表示</p>\n<p>不相同的地方在于：递归是从 f[i] 开始，不断回退调用之前的计算流程；而动态规划是从 f[0] 开始，不断累积存储中间的结果，直到遍历找到 f[i]</p>\n<h2 id=\"使用动态规划的方法\"><a href=\"#使用动态规划的方法\" class=\"headerlink\" title=\"使用动态规划的方法\"></a>使用动态规划的方法</h2><p>参考已有文章所给出的方法，结合个人的分析，给出以下解题流程：</p>\n<h3 id=\"分析问题的解题流程，是否存在上述所说优化特征以及遍历形式，确定是否使用-DP-解题\"><a href=\"#分析问题的解题流程，是否存在上述所说优化特征以及遍历形式，确定是否使用-DP-解题\" class=\"headerlink\" title=\"分析问题的解题流程，是否存在上述所说优化特征以及遍历形式，确定是否使用 DP 解题\"></a>分析问题的解题流程，是否存在上述所说优化特征以及遍历形式，确定是否使用 DP 解题</h3><h3 id=\"使用-DP-解题\"><a href=\"#使用-DP-解题\" class=\"headerlink\" title=\"使用 DP 解题\"></a>使用 DP 解题</h3><ol>\n<li>确定dp数组（dp table）以及下标的含义<br><strong>什么是DP数组呢？</strong><br>dp[i] 代表的是 i 位置的结果值(就是遍历到 i 值应该得出的结果值)<blockquote>\n<p>dp 当然也不一定就是一维数组, 可以是dp[i][j], 得看 DP 遍历时候每一层循环分别的计算公式和意义是什么</p>\n</blockquote>\n</li>\n</ol>\n<ol start=\"2\">\n<li>确定递推公式</li>\n<li>dp数组如何初始化</li>\n<li>确定遍历顺序</li>\n<li>举例推导dp数组</li>\n</ol>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><p>[1] 代码随想录: [<a href=\"https://programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E8%A7%A3%E9%A2%98%E6%AD%A5%E9%AA%A4]\">https://programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E8%A7%A3%E9%A2%98%E6%AD%A5%E9%AA%A4]</a></p>\n<p>[2] Quora: [<a href=\"https://www.quora.com/How-do-I-recognize-a-problem-as-a-dynamic-programming-problem]\">https://www.quora.com/How-do-I-recognize-a-problem-as-a-dynamic-programming-problem]</a></p>\n<p>[3] StackFlow: </p>\n<ul>\n<li>[<a href=\"https://stackoverflow.com/questions/6164629/what-is-the-difference-between-bottom-up-and-top-down]\">https://stackoverflow.com/questions/6164629/what-is-the-difference-between-bottom-up-and-top-down]</a></li>\n<li>[<a href=\"https://stackoverflow.blog/2022/01/31/the-complete-beginners-guide-to-dynamic-programming/]\">https://stackoverflow.blog/2022/01/31/the-complete-beginners-guide-to-dynamic-programming/]</a></li>\n<li>[<a href=\"https://softwareengineering.stackexchange.com/questions/219802/how-do-you-identify-a-problem-as-being-suitable-for-dynamic-programming]\">https://softwareengineering.stackexchange.com/questions/219802/how-do-you-identify-a-problem-as-being-suitable-for-dynamic-programming]</a></li>\n<li>[<a href=\"https://stackoverflow.com/questions/6184869/what-is-the-difference-between-memoization-and-dynamic-programming]\">https://stackoverflow.com/questions/6184869/what-is-the-difference-between-memoization-and-dynamic-programming]</a></li>\n</ul>\n<p>[4] SpiceWorks: [<a href=\"https://www.spiceworks.com/tech/devops/articles/what-is-dynamic-programming/]\">https://www.spiceworks.com/tech/devops/articles/what-is-dynamic-programming/]</a></p>\n<p>[5] WAYNE W BISHOP：</p>\n<ul>\n<li>[<a href=\"https://www.waynewbishop.com/dynamic-programming-problems]\">https://www.waynewbishop.com/dynamic-programming-problems]</a></li>\n<li>[<a href=\"https://www.waynewbishop.com/computer-science-interview-questions]\">https://www.waynewbishop.com/computer-science-interview-questions]</a></li>\n</ul>\n<p>[6] Blog:</p>\n<ul>\n<li>[<a href=\"https://people.computing.clemson.edu/~bcdean/dp_practice/]\">https://people.computing.clemson.edu/~bcdean/dp_practice/]</a></li>\n</ul>\n<p>[7] Not used But may useful in the future:</p>\n<ul>\n<li>[<a href=\"https://learntocodewith.me/posts/dynamic-programming/]\">https://learntocodewith.me/posts/dynamic-programming/]</a></li>\n<li>[<a href=\"https://medium.com/@adam.dejans/using-dynamic-programming-for-problem-solving-b54be2e47747]\">https://medium.com/@adam.dejans/using-dynamic-programming-for-problem-solving-b54be2e47747]</a></li>\n</ul>\n","site":{"data":{}},"cover":"/img/cover/elderring.png","cover_type":"img","excerpt":"","more":"<h1 id=\"动态规划-动态规划入门\"><a href=\"#动态规划-动态规划入门\" class=\"headerlink\" title=\"[动态规划] 动态规划入门\"></a>[动态规划] 动态规划入门</h1><blockquote>\n<p>核心特征： 动态规划中，每一个状态是有上一个状态推导出来的</p>\n</blockquote>\n<h2 id=\"什么是动态规划\"><a href=\"#什么是动态规划\" class=\"headerlink\" title=\"什么是动态规划\"></a>什么是动态规划</h2><blockquote>\n<p>对于一个问题，如何才能够识别出他是一个需要用动态规划解决的问题</p>\n</blockquote>\n<p>问题本质上不能够被划归为 DP(Dynamic Problem) 问题，因为 DP 是解决方法的特征并不是问题的特征。</p>\n<p>那么目标就变成哪一些问题可以使用 DP 来解决呢？</p>\n<p>首先是明确 DP 方法的特点： DP 本质上是<strong>暴力解法，列举计算所有的可能，但通过 “memoized approach”(缓存思想)去消除了重复性的工作</strong>。比如在斐波那契数列当中，当需要计算 f[i]的数值时候，完全可以从f[1],f[0] 重新开始计算，但当我们将f[i]和f[i-1]的计算式子排在一起的时候，就会发现二者从f[0]到f[i-2]的计算流程是完全一样的，也就是说f[i] 的结果可以从f[i-1]的结果上获取；那么从这个例子来看，我们可以将 DP 的方法流程理解为：</p>\n<ul>\n<li>求解问题需要列举/计算所有可能的解[问题的解包含在全集当中]</li>\n<li>计算每一种可能的流程和方法是完全一致的，且相互关联，一部分的结果可以帮助计算其它部分的结果</li>\n</ul>\n<p>结合上述的 DP 方法特点分析，依照笔者刷题看论文的经验来说，当一个问题是优化性质的问题，需要求解“最短/最长、最小化/最大化、最少/最多、最少/最大、最大/最小”的目标，而求解这个目标需要遍历几乎所有可能的排列组合，这类型的题目如果没有微积分、取模或者是其他更加直接的计算方式，那么简化的暴力破解方法– DP 可能就是一个比较好的选择。<br>这类型问题的表述可以是：“找到编辑操作的最小数量”，“找到最长的公共子序列”，</p>\n<h2 id=\"动态规划与递归\"><a href=\"#动态规划与递归\" class=\"headerlink\" title=\"动态规划与递归\"></a>动态规划与递归</h2><blockquote>\n<p>核心不同点就是：动态规划自下而上，递归自上而下</p>\n</blockquote>\n<p>动态规划和递归相同的特征在于：解决问题时候复用了计算的公式和流程，也就是说获得每一个阶段结果的计算流程(公式)是相同的，所以可以用同一段函数代码来表示</p>\n<p>不相同的地方在于：递归是从 f[i] 开始，不断回退调用之前的计算流程；而动态规划是从 f[0] 开始，不断累积存储中间的结果，直到遍历找到 f[i]</p>\n<h2 id=\"使用动态规划的方法\"><a href=\"#使用动态规划的方法\" class=\"headerlink\" title=\"使用动态规划的方法\"></a>使用动态规划的方法</h2><p>参考已有文章所给出的方法，结合个人的分析，给出以下解题流程：</p>\n<h3 id=\"分析问题的解题流程，是否存在上述所说优化特征以及遍历形式，确定是否使用-DP-解题\"><a href=\"#分析问题的解题流程，是否存在上述所说优化特征以及遍历形式，确定是否使用-DP-解题\" class=\"headerlink\" title=\"分析问题的解题流程，是否存在上述所说优化特征以及遍历形式，确定是否使用 DP 解题\"></a>分析问题的解题流程，是否存在上述所说优化特征以及遍历形式，确定是否使用 DP 解题</h3><h3 id=\"使用-DP-解题\"><a href=\"#使用-DP-解题\" class=\"headerlink\" title=\"使用 DP 解题\"></a>使用 DP 解题</h3><ol>\n<li>确定dp数组（dp table）以及下标的含义<br><strong>什么是DP数组呢？</strong><br>dp[i] 代表的是 i 位置的结果值(就是遍历到 i 值应该得出的结果值)<blockquote>\n<p>dp 当然也不一定就是一维数组, 可以是dp[i][j], 得看 DP 遍历时候每一层循环分别的计算公式和意义是什么</p>\n</blockquote>\n</li>\n</ol>\n<ol start=\"2\">\n<li>确定递推公式</li>\n<li>dp数组如何初始化</li>\n<li>确定遍历顺序</li>\n<li>举例推导dp数组</li>\n</ol>\n<h1 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h1><p>[1] 代码随想录: [<a href=\"https://programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E8%A7%A3%E9%A2%98%E6%AD%A5%E9%AA%A4]\">https://programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E8%A7%A3%E9%A2%98%E6%AD%A5%E9%AA%A4]</a></p>\n<p>[2] Quora: [<a href=\"https://www.quora.com/How-do-I-recognize-a-problem-as-a-dynamic-programming-problem]\">https://www.quora.com/How-do-I-recognize-a-problem-as-a-dynamic-programming-problem]</a></p>\n<p>[3] StackFlow: </p>\n<ul>\n<li>[<a href=\"https://stackoverflow.com/questions/6164629/what-is-the-difference-between-bottom-up-and-top-down]\">https://stackoverflow.com/questions/6164629/what-is-the-difference-between-bottom-up-and-top-down]</a></li>\n<li>[<a href=\"https://stackoverflow.blog/2022/01/31/the-complete-beginners-guide-to-dynamic-programming/]\">https://stackoverflow.blog/2022/01/31/the-complete-beginners-guide-to-dynamic-programming/]</a></li>\n<li>[<a href=\"https://softwareengineering.stackexchange.com/questions/219802/how-do-you-identify-a-problem-as-being-suitable-for-dynamic-programming]\">https://softwareengineering.stackexchange.com/questions/219802/how-do-you-identify-a-problem-as-being-suitable-for-dynamic-programming]</a></li>\n<li>[<a href=\"https://stackoverflow.com/questions/6184869/what-is-the-difference-between-memoization-and-dynamic-programming]\">https://stackoverflow.com/questions/6184869/what-is-the-difference-between-memoization-and-dynamic-programming]</a></li>\n</ul>\n<p>[4] SpiceWorks: [<a href=\"https://www.spiceworks.com/tech/devops/articles/what-is-dynamic-programming/]\">https://www.spiceworks.com/tech/devops/articles/what-is-dynamic-programming/]</a></p>\n<p>[5] WAYNE W BISHOP：</p>\n<ul>\n<li>[<a href=\"https://www.waynewbishop.com/dynamic-programming-problems]\">https://www.waynewbishop.com/dynamic-programming-problems]</a></li>\n<li>[<a href=\"https://www.waynewbishop.com/computer-science-interview-questions]\">https://www.waynewbishop.com/computer-science-interview-questions]</a></li>\n</ul>\n<p>[6] Blog:</p>\n<ul>\n<li>[<a href=\"https://people.computing.clemson.edu/~bcdean/dp_practice/]\">https://people.computing.clemson.edu/~bcdean/dp_practice/]</a></li>\n</ul>\n<p>[7] Not used But may useful in the future:</p>\n<ul>\n<li>[<a href=\"https://learntocodewith.me/posts/dynamic-programming/]\">https://learntocodewith.me/posts/dynamic-programming/]</a></li>\n<li>[<a href=\"https://medium.com/@adam.dejans/using-dynamic-programming-for-problem-solving-b54be2e47747]\">https://medium.com/@adam.dejans/using-dynamic-programming-for-problem-solving-b54be2e47747]</a></li>\n</ul>\n"},{"title":"算法代码通用模板思考","catalog":true,"date":"2023-03-29T17:25:25.000Z","subtitle":null,"header-img":null,"published":0,"_content":"\n# 文档前言\n\n当我完成了许多的算法题目以及其扩展题目之后，总是在那几天对于解决这类性特征的问题有着较多的见解，而且发现同类型特征的问题往往有着相似的解法，尤其是在我回顾一些问题却发现他们异常陌生的时候，我察觉到自己不能通过简单的肌肉记忆来提高解决问题的能力，重复和已经解决思考的部分应当有浓缩和归类的操作\n\n本文档的主要内容将主要包含两个部分：\n* 基础简单算法的模式化归纳：忽略代码实现的细节和边界条件，将算法当中最主要的公式和代码片段摘出\n* 特征问题的通解归纳，将具有特征特点的问题归纳出一个通用的范式\n\n# 二叉树\n\n## 二叉树的遍历\n在树的**深度优先**遍历算法当中（包括前序、中序、后序），常常使用的是递归的方式，也就是：\n\n* <font color ='red'>前序遍历：中、左、右 </font>\n* <font color ='red'>中序遍历：左、中、右 </font>\n* <font color ='red'>后序遍历：左、右、中 </font>\n\n\n### 颜色标记法\n\n受到(henry)[https://leetcode.cn/problems/binary-tree-inorder-traversal/solution/yan-se-biao-ji-fa-yi-chong-tong-yong-qie-jian-ming/] 解题方法的启发\n\n将树的遍历问题放到栈的逻辑下面，其实有几点问题：\n* 入栈的元素只有两种： 指向节点的指针和空指针，类似于：`[1,null,2,null,3,null,4,null,5,null,6]`\n* 出栈的时候操作的必定是一个有指向地址的指针，那么出栈操作代表些什么\n* 怎样才能够区别出左子树和右子树呢？\n\n栈是先进后出的数据结构，与递归和函数调用类似，越是靠近栈底的元素他在树的结构上就越高。而栈的这个特性保证了树的结构，也就是说左/右子树必定是在右/左子树之前弹出，换句话说除了当前遍历的节点node，他的左右在遍历过程其实中代表的是一棵树，继续向栈里推入元素就是在不断地展开他的树节点，而这样的顺序必定是被中间的Node所标志的，如图中所示\n\n\n<div style=\"display:flex;flex-direction:row;\"r>\n    <img src='./tree_stack1.jpg' width=\"400\" height=\"200\" style=\"margin-right:10px;\"/>\n    <img src='./tree_stack2.jpg' width=\"400\" height=\"200\" style=\"margin-left:10px;\"/>\n</div>\n\n\\\n回到上述三个问题来理解就会容易一些\n1. 因为栈存储的是树，而不是节点，所以一些叶节点没有左右子树，这部分依旧还是会以逻辑形式入栈 \n2. 出栈入栈是对应的，所以理解上也应该要对应起来说，第一次入栈只要该节点不是root，那么他必定是以某个节点的左右节点身份入栈的，此时的入栈操作标识的是当前节点为root 的子树，所以第一次出栈是用来将其从树的身份转化为节点，通过将其标记为 1 [有颜色，标志为确实为一个节点]，然后再入栈表示为遍历，当把整棵树放入栈中后，出栈操作则对应节点，此时栈中所有标记为1的部分就是实际遍历的节点，而且按照入栈的顺序表示出中、后、前序.\n那么按照这样的思路，我们来编写一下对二叉树的中序遍历：\n\n``` golang \ntype TreeNode struct{\n    Right *TreeNode\n    Left  *TreeNode\n    Val  int\n}\n\n//\nfunc traversal(root *TreeNode) []interface{}{\n    // 颜色点，用于标记出入栈\n    type node struct{\n        Color int\n        Node *TreeNode\n    }\n\n    stack := make([]*node,0)\n    stack = append(stack,node{0，root})\n\n    // 需要的结果函数\n    //result := make([]interface,0)\n    res := make([]int,0)\n\n    for len(stack) > 0{\n        // 每次都取出栈顶元素进行判定\n        n := stack[len(stack)-1]\n        stack = stack[:len(stack)-1]\n\n        if n.Node == nil {\n            continue\n        }\n\n        if n.Color == 0{\n            stack = append(stack,node{0,n.Node.Right})\n            stack = append(stack,node{1,n.Node})\n            stack = append(stack,node{0,n.Node.Left})\n        }else{\n            res = append(res, n.Node.Val)\n        }\n    }\n    return res\n}\n\n```\n\n在这段代码当中，由于标记方式的存在和入栈方式是两次入栈，所以几乎可以是模板样式来解决问题，而且好记忆\n\n在代码当中可以修改的地方只有两处：\n``` golang\n    if n.Color == 0{\n        【第一处】\n        可以修改为不同的深度遍历顺序\n        【前序遍历】：\n        ···\n            stack = append(stack,node{0,n.Node.Right})\n            stack = append(stack,node{0,n.Node.Left}) \n            stack = append(stack,node{1,n.Node})   \n        ···\n        【中序遍历】\n        ···\n            stack = append(stack,node{0,n.Node.Right})\n            stack = append(stack,node{1,n.Node})  \n            stack = append(stack,node{0,n.Node.Left}) \n        ···\n        【后序遍历】\n        ···\n            stack = append(stack,node{1,n.Node})  \n            stack = append(stack,node{0,n.Node.Right})\n            stack = append(stack,node{0,n.Node.Left}) \n        ···\n    }else{\n        【第二处】\n        添加对当前node值的修改函数\n    }\n```\n\n### 递归方法\n\n使用递归最关键还是两条：\n* 递归结束的条件\n* 递归函数的结构\n\n普通的前序遍历数组的代码：\n```golang\n\n\n```\n\n# 常见运算标识\n\n## 最大最小值\n\n以下这两个都是可以接受多个变量参数的求最大最小值\n``` golang\n    func max(args ...int)int{\n        m := args[0]\n        for _,val := range args{\n            if val > m{\n                m = val\n            }\n        }\n        return m\n    }\n\n    func min(args ...int)int{\n        m := args[0]\n        for _,val := range args{\n            if val < m{\n                m = val\n            }\n        }\n        return m\n    }\n```\n\n## 异或，同或\n```golang\nfunc xor(a, b bool) bool {\n    return (a || b) && !(a && b)\n}\n```\n```golang\nfunc xnor(a, b bool) bool {\n    return (a && b) || (!a && !b)\n}\n```\n\n\n## 位运算\n\n### 两数相加\n```golang\nfunc getSum(a int, b int) int {\n    // 异或+与运算:时间复杂度O(logSum) | 空间复杂度O(1)\n    a, b = a ^ b, (a & b) << 1\n    for b != 0 {\n        a, b = a ^ b, (a & b) << 1\n    }\n    return a\n}\n```\n\n### 两数相除\n```golang\nfunc divide(dividend int, divisor int) int {\n    if dividend==0 {return 0}\n    if dividend==math.MinInt32 && divisor==-1 {return math.MaxInt32}\n\n    diffSign:=false\n    if (dividend<0)!=(divisor<0) {\n        diffSign=true\n    }\n\n    i,j,sum := 0,0,0\n    for {\n        tmp:=0\n        if diffSign {\n            tmp=sum-divisor<<j\n        }else{\n            tmp=sum+divisor<<j\n        }\n        if (dividend>0 && tmp>dividend) || (dividend<0 && tmp<dividend) {\n            if j==0 {break}\n            j-- //步长减半\n            continue\n        }\n        sum=tmp\n        i+=1<<j\n        j++ //步长加倍\n    }\n\n    if diffSign {\n        return -i\n    }\n    return i\n}\n```\n\n\n\n## 二维矩阵转置\n``` golang\nfunc transposeMatrix(matrix [][]int) [][]int {\n    // 获取矩阵的行数和列数\n    rows, cols := len(matrix), len(matrix[0])\n    // 定义一个新的二维数组，用于存储转置后的矩阵\n    transposed := make([][]int, cols)\n    for i := range transposed {\n        transposed[i] = make([]int, rows)\n    }\n    // 遍历原矩阵，将其每个元素放置在转置矩阵中的相应位置\n    for i := 0; i < rows; i++ {\n        for j := 0; j < cols; j++ {\n            transposed[j][i] = matrix[i][j]\n        }\n    }\n    return transposed\n}\n```","source":"_posts/Algorithm/算法代码通用模板思考/算法代码通用模板思考.md","raw":"---\ntitle: 算法代码通用模板思考\ncatalog: true\ndate: 2023-03-30 01:25:25\nsubtitle:\nheader-img:\ntags: Working\ncategories: 算法 \npublished: false\n---\n\n# 文档前言\n\n当我完成了许多的算法题目以及其扩展题目之后，总是在那几天对于解决这类性特征的问题有着较多的见解，而且发现同类型特征的问题往往有着相似的解法，尤其是在我回顾一些问题却发现他们异常陌生的时候，我察觉到自己不能通过简单的肌肉记忆来提高解决问题的能力，重复和已经解决思考的部分应当有浓缩和归类的操作\n\n本文档的主要内容将主要包含两个部分：\n* 基础简单算法的模式化归纳：忽略代码实现的细节和边界条件，将算法当中最主要的公式和代码片段摘出\n* 特征问题的通解归纳，将具有特征特点的问题归纳出一个通用的范式\n\n# 二叉树\n\n## 二叉树的遍历\n在树的**深度优先**遍历算法当中（包括前序、中序、后序），常常使用的是递归的方式，也就是：\n\n* <font color ='red'>前序遍历：中、左、右 </font>\n* <font color ='red'>中序遍历：左、中、右 </font>\n* <font color ='red'>后序遍历：左、右、中 </font>\n\n\n### 颜色标记法\n\n受到(henry)[https://leetcode.cn/problems/binary-tree-inorder-traversal/solution/yan-se-biao-ji-fa-yi-chong-tong-yong-qie-jian-ming/] 解题方法的启发\n\n将树的遍历问题放到栈的逻辑下面，其实有几点问题：\n* 入栈的元素只有两种： 指向节点的指针和空指针，类似于：`[1,null,2,null,3,null,4,null,5,null,6]`\n* 出栈的时候操作的必定是一个有指向地址的指针，那么出栈操作代表些什么\n* 怎样才能够区别出左子树和右子树呢？\n\n栈是先进后出的数据结构，与递归和函数调用类似，越是靠近栈底的元素他在树的结构上就越高。而栈的这个特性保证了树的结构，也就是说左/右子树必定是在右/左子树之前弹出，换句话说除了当前遍历的节点node，他的左右在遍历过程其实中代表的是一棵树，继续向栈里推入元素就是在不断地展开他的树节点，而这样的顺序必定是被中间的Node所标志的，如图中所示\n\n\n<div style=\"display:flex;flex-direction:row;\"r>\n    <img src='./tree_stack1.jpg' width=\"400\" height=\"200\" style=\"margin-right:10px;\"/>\n    <img src='./tree_stack2.jpg' width=\"400\" height=\"200\" style=\"margin-left:10px;\"/>\n</div>\n\n\\\n回到上述三个问题来理解就会容易一些\n1. 因为栈存储的是树，而不是节点，所以一些叶节点没有左右子树，这部分依旧还是会以逻辑形式入栈 \n2. 出栈入栈是对应的，所以理解上也应该要对应起来说，第一次入栈只要该节点不是root，那么他必定是以某个节点的左右节点身份入栈的，此时的入栈操作标识的是当前节点为root 的子树，所以第一次出栈是用来将其从树的身份转化为节点，通过将其标记为 1 [有颜色，标志为确实为一个节点]，然后再入栈表示为遍历，当把整棵树放入栈中后，出栈操作则对应节点，此时栈中所有标记为1的部分就是实际遍历的节点，而且按照入栈的顺序表示出中、后、前序.\n那么按照这样的思路，我们来编写一下对二叉树的中序遍历：\n\n``` golang \ntype TreeNode struct{\n    Right *TreeNode\n    Left  *TreeNode\n    Val  int\n}\n\n//\nfunc traversal(root *TreeNode) []interface{}{\n    // 颜色点，用于标记出入栈\n    type node struct{\n        Color int\n        Node *TreeNode\n    }\n\n    stack := make([]*node,0)\n    stack = append(stack,node{0，root})\n\n    // 需要的结果函数\n    //result := make([]interface,0)\n    res := make([]int,0)\n\n    for len(stack) > 0{\n        // 每次都取出栈顶元素进行判定\n        n := stack[len(stack)-1]\n        stack = stack[:len(stack)-1]\n\n        if n.Node == nil {\n            continue\n        }\n\n        if n.Color == 0{\n            stack = append(stack,node{0,n.Node.Right})\n            stack = append(stack,node{1,n.Node})\n            stack = append(stack,node{0,n.Node.Left})\n        }else{\n            res = append(res, n.Node.Val)\n        }\n    }\n    return res\n}\n\n```\n\n在这段代码当中，由于标记方式的存在和入栈方式是两次入栈，所以几乎可以是模板样式来解决问题，而且好记忆\n\n在代码当中可以修改的地方只有两处：\n``` golang\n    if n.Color == 0{\n        【第一处】\n        可以修改为不同的深度遍历顺序\n        【前序遍历】：\n        ···\n            stack = append(stack,node{0,n.Node.Right})\n            stack = append(stack,node{0,n.Node.Left}) \n            stack = append(stack,node{1,n.Node})   \n        ···\n        【中序遍历】\n        ···\n            stack = append(stack,node{0,n.Node.Right})\n            stack = append(stack,node{1,n.Node})  \n            stack = append(stack,node{0,n.Node.Left}) \n        ···\n        【后序遍历】\n        ···\n            stack = append(stack,node{1,n.Node})  \n            stack = append(stack,node{0,n.Node.Right})\n            stack = append(stack,node{0,n.Node.Left}) \n        ···\n    }else{\n        【第二处】\n        添加对当前node值的修改函数\n    }\n```\n\n### 递归方法\n\n使用递归最关键还是两条：\n* 递归结束的条件\n* 递归函数的结构\n\n普通的前序遍历数组的代码：\n```golang\n\n\n```\n\n# 常见运算标识\n\n## 最大最小值\n\n以下这两个都是可以接受多个变量参数的求最大最小值\n``` golang\n    func max(args ...int)int{\n        m := args[0]\n        for _,val := range args{\n            if val > m{\n                m = val\n            }\n        }\n        return m\n    }\n\n    func min(args ...int)int{\n        m := args[0]\n        for _,val := range args{\n            if val < m{\n                m = val\n            }\n        }\n        return m\n    }\n```\n\n## 异或，同或\n```golang\nfunc xor(a, b bool) bool {\n    return (a || b) && !(a && b)\n}\n```\n```golang\nfunc xnor(a, b bool) bool {\n    return (a && b) || (!a && !b)\n}\n```\n\n\n## 位运算\n\n### 两数相加\n```golang\nfunc getSum(a int, b int) int {\n    // 异或+与运算:时间复杂度O(logSum) | 空间复杂度O(1)\n    a, b = a ^ b, (a & b) << 1\n    for b != 0 {\n        a, b = a ^ b, (a & b) << 1\n    }\n    return a\n}\n```\n\n### 两数相除\n```golang\nfunc divide(dividend int, divisor int) int {\n    if dividend==0 {return 0}\n    if dividend==math.MinInt32 && divisor==-1 {return math.MaxInt32}\n\n    diffSign:=false\n    if (dividend<0)!=(divisor<0) {\n        diffSign=true\n    }\n\n    i,j,sum := 0,0,0\n    for {\n        tmp:=0\n        if diffSign {\n            tmp=sum-divisor<<j\n        }else{\n            tmp=sum+divisor<<j\n        }\n        if (dividend>0 && tmp>dividend) || (dividend<0 && tmp<dividend) {\n            if j==0 {break}\n            j-- //步长减半\n            continue\n        }\n        sum=tmp\n        i+=1<<j\n        j++ //步长加倍\n    }\n\n    if diffSign {\n        return -i\n    }\n    return i\n}\n```\n\n\n\n## 二维矩阵转置\n``` golang\nfunc transposeMatrix(matrix [][]int) [][]int {\n    // 获取矩阵的行数和列数\n    rows, cols := len(matrix), len(matrix[0])\n    // 定义一个新的二维数组，用于存储转置后的矩阵\n    transposed := make([][]int, cols)\n    for i := range transposed {\n        transposed[i] = make([]int, rows)\n    }\n    // 遍历原矩阵，将其每个元素放置在转置矩阵中的相应位置\n    for i := 0; i < rows; i++ {\n        for j := 0; j < cols; j++ {\n            transposed[j][i] = matrix[i][j]\n        }\n    }\n    return transposed\n}\n```","slug":"Algorithm/算法代码通用模板思考/算法代码通用模板思考","updated":"2023-04-22T13:24:02.176Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgtm6jqb000jlyjxh2kb3amy","content":"<h1 id=\"文档前言\"><a href=\"#文档前言\" class=\"headerlink\" title=\"文档前言\"></a>文档前言</h1><p>当我完成了许多的算法题目以及其扩展题目之后，总是在那几天对于解决这类性特征的问题有着较多的见解，而且发现同类型特征的问题往往有着相似的解法，尤其是在我回顾一些问题却发现他们异常陌生的时候，我察觉到自己不能通过简单的肌肉记忆来提高解决问题的能力，重复和已经解决思考的部分应当有浓缩和归类的操作</p>\n<p>本文档的主要内容将主要包含两个部分：</p>\n<ul>\n<li>基础简单算法的模式化归纳：忽略代码实现的细节和边界条件，将算法当中最主要的公式和代码片段摘出</li>\n<li>特征问题的通解归纳，将具有特征特点的问题归纳出一个通用的范式</li>\n</ul>\n<h1 id=\"二叉树\"><a href=\"#二叉树\" class=\"headerlink\" title=\"二叉树\"></a>二叉树</h1><h2 id=\"二叉树的遍历\"><a href=\"#二叉树的遍历\" class=\"headerlink\" title=\"二叉树的遍历\"></a>二叉树的遍历</h2><p>在树的<strong>深度优先</strong>遍历算法当中（包括前序、中序、后序），常常使用的是递归的方式，也就是：</p>\n<ul>\n<li><font color ='red'>前序遍历：中、左、右 </font></li>\n<li><font color ='red'>中序遍历：左、中、右 </font></li>\n<li><font color ='red'>后序遍历：左、右、中 </font></li>\n</ul>\n<h3 id=\"颜色标记法\"><a href=\"#颜色标记法\" class=\"headerlink\" title=\"颜色标记法\"></a>颜色标记法</h3><p>受到(henry)[<a href=\"https://leetcode.cn/problems/binary-tree-inorder-traversal/solution/yan-se-biao-ji-fa-yi-chong-tong-yong-qie-jian-ming/]\">https://leetcode.cn/problems/binary-tree-inorder-traversal/solution/yan-se-biao-ji-fa-yi-chong-tong-yong-qie-jian-ming/]</a> 解题方法的启发</p>\n<p>将树的遍历问题放到栈的逻辑下面，其实有几点问题：</p>\n<ul>\n<li>入栈的元素只有两种： 指向节点的指针和空指针，类似于：<code>[1,null,2,null,3,null,4,null,5,null,6]</code></li>\n<li>出栈的时候操作的必定是一个有指向地址的指针，那么出栈操作代表些什么</li>\n<li>怎样才能够区别出左子树和右子树呢？</li>\n</ul>\n<p>栈是先进后出的数据结构，与递归和函数调用类似，越是靠近栈底的元素他在树的结构上就越高。而栈的这个特性保证了树的结构，也就是说左/右子树必定是在右/左子树之前弹出，换句话说除了当前遍历的节点node，他的左右在遍历过程其实中代表的是一棵树，继续向栈里推入元素就是在不断地展开他的树节点，而这样的顺序必定是被中间的Node所标志的，如图中所示</p>\n<div style=\"display:flex;flex-direction:row;\"r>\n    <img src='./tree_stack1.jpg' width=\"400\" height=\"200\" style=\"margin-right:10px;\"/>\n    <img src='./tree_stack2.jpg' width=\"400\" height=\"200\" style=\"margin-left:10px;\"/>\n</div>\n\n<p><br>回到上述三个问题来理解就会容易一些</p>\n<ol>\n<li>因为栈存储的是树，而不是节点，所以一些叶节点没有左右子树，这部分依旧还是会以逻辑形式入栈 </li>\n<li>出栈入栈是对应的，所以理解上也应该要对应起来说，第一次入栈只要该节点不是root，那么他必定是以某个节点的左右节点身份入栈的，此时的入栈操作标识的是当前节点为root 的子树，所以第一次出栈是用来将其从树的身份转化为节点，通过将其标记为 1 [有颜色，标志为确实为一个节点]，然后再入栈表示为遍历，当把整棵树放入栈中后，出栈操作则对应节点，此时栈中所有标记为1的部分就是实际遍历的节点，而且按照入栈的顺序表示出中、后、前序.<br>那么按照这样的思路，我们来编写一下对二叉树的中序遍历：</li>\n</ol>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> TreeNode <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">    Right *TreeNode</span><br><span class=\"line\">    Left  *TreeNode</span><br><span class=\"line\">    Val  <span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">traversal</span><span class=\"params\">(root *TreeNode)</span></span> []<span class=\"keyword\">interface</span>&#123;&#125;&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 颜色点，用于标记出入栈</span></span><br><span class=\"line\">    <span class=\"keyword\">type</span> node <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">        Color <span class=\"type\">int</span></span><br><span class=\"line\">        Node *TreeNode</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    stack := <span class=\"built_in\">make</span>([]*node,<span class=\"number\">0</span>)</span><br><span class=\"line\">    stack = <span class=\"built_in\">append</span>(stack,node&#123;<span class=\"number\">0</span>，root&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 需要的结果函数</span></span><br><span class=\"line\">    <span class=\"comment\">//result := make([]interface,0)</span></span><br><span class=\"line\">    res := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"built_in\">len</span>(stack) &gt; <span class=\"number\">0</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 每次都取出栈顶元素进行判定</span></span><br><span class=\"line\">        n := stack[<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>]</span><br><span class=\"line\">        stack = stack[:<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> n.Node == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> n.Color == <span class=\"number\">0</span>&#123;</span><br><span class=\"line\">            stack = <span class=\"built_in\">append</span>(stack,node&#123;<span class=\"number\">0</span>,n.Node.Right&#125;)</span><br><span class=\"line\">            stack = <span class=\"built_in\">append</span>(stack,node&#123;<span class=\"number\">1</span>,n.Node&#125;)</span><br><span class=\"line\">            stack = <span class=\"built_in\">append</span>(stack,node&#123;<span class=\"number\">0</span>,n.Node.Left&#125;)</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            res = <span class=\"built_in\">append</span>(res, n.Node.Val)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>在这段代码当中，由于标记方式的存在和入栈方式是两次入栈，所以几乎可以是模板样式来解决问题，而且好记忆</p>\n<p>在代码当中可以修改的地方只有两处：</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> n.Color == <span class=\"number\">0</span>&#123;</span><br><span class=\"line\">    【第一处】</span><br><span class=\"line\">    可以修改为不同的深度遍历顺序</span><br><span class=\"line\">    【前序遍历】：</span><br><span class=\"line\">    ···</span><br><span class=\"line\">        stack = <span class=\"built_in\">append</span>(stack,node&#123;<span class=\"number\">0</span>,n.Node.Right&#125;)</span><br><span class=\"line\">        stack = <span class=\"built_in\">append</span>(stack,node&#123;<span class=\"number\">0</span>,n.Node.Left&#125;) </span><br><span class=\"line\">        stack = <span class=\"built_in\">append</span>(stack,node&#123;<span class=\"number\">1</span>,n.Node&#125;)   </span><br><span class=\"line\">    ···</span><br><span class=\"line\">    【中序遍历】</span><br><span class=\"line\">    ···</span><br><span class=\"line\">        stack = <span class=\"built_in\">append</span>(stack,node&#123;<span class=\"number\">0</span>,n.Node.Right&#125;)</span><br><span class=\"line\">        stack = <span class=\"built_in\">append</span>(stack,node&#123;<span class=\"number\">1</span>,n.Node&#125;)  </span><br><span class=\"line\">        stack = <span class=\"built_in\">append</span>(stack,node&#123;<span class=\"number\">0</span>,n.Node.Left&#125;) </span><br><span class=\"line\">    ···</span><br><span class=\"line\">    【后序遍历】</span><br><span class=\"line\">    ···</span><br><span class=\"line\">        stack = <span class=\"built_in\">append</span>(stack,node&#123;<span class=\"number\">1</span>,n.Node&#125;)  </span><br><span class=\"line\">        stack = <span class=\"built_in\">append</span>(stack,node&#123;<span class=\"number\">0</span>,n.Node.Right&#125;)</span><br><span class=\"line\">        stack = <span class=\"built_in\">append</span>(stack,node&#123;<span class=\"number\">0</span>,n.Node.Left&#125;) </span><br><span class=\"line\">    ···</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    【第二处】</span><br><span class=\"line\">    添加对当前node值的修改函数</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"递归方法\"><a href=\"#递归方法\" class=\"headerlink\" title=\"递归方法\"></a>递归方法</h3><p>使用递归最关键还是两条：</p>\n<ul>\n<li>递归结束的条件</li>\n<li>递归函数的结构</li>\n</ul>\n<p>普通的前序遍历数组的代码：</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"常见运算标识\"><a href=\"#常见运算标识\" class=\"headerlink\" title=\"常见运算标识\"></a>常见运算标识</h1><h2 id=\"最大最小值\"><a href=\"#最大最小值\" class=\"headerlink\" title=\"最大最小值\"></a>最大最小值</h2><p>以下这两个都是可以接受多个变量参数的求最大最小值</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">max</span><span class=\"params\">(args ...<span class=\"type\">int</span>)</span></span><span class=\"type\">int</span>&#123;</span><br><span class=\"line\">    m := args[<span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _,val := <span class=\"keyword\">range</span> args&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> val &gt; m&#123;</span><br><span class=\"line\">            m = val</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">min</span><span class=\"params\">(args ...<span class=\"type\">int</span>)</span></span><span class=\"type\">int</span>&#123;</span><br><span class=\"line\">    m := args[<span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _,val := <span class=\"keyword\">range</span> args&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> val &lt; m&#123;</span><br><span class=\"line\">            m = val</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"异或，同或\"><a href=\"#异或，同或\" class=\"headerlink\" title=\"异或，同或\"></a>异或，同或</h2><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">xor</span><span class=\"params\">(a, b <span class=\"type\">bool</span>)</span></span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (a || b) &amp;&amp; !(a &amp;&amp; b)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">xnor</span><span class=\"params\">(a, b <span class=\"type\">bool</span>)</span></span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (a &amp;&amp; b) || (!a &amp;&amp; !b)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"位运算\"><a href=\"#位运算\" class=\"headerlink\" title=\"位运算\"></a>位运算</h2><h3 id=\"两数相加\"><a href=\"#两数相加\" class=\"headerlink\" title=\"两数相加\"></a>两数相加</h3><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">getSum</span><span class=\"params\">(a <span class=\"type\">int</span>, b <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 异或+与运算:时间复杂度O(logSum) | 空间复杂度O(1)</span></span><br><span class=\"line\">    a, b = a ^ b, (a &amp; b) &lt;&lt; <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> b != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        a, b = a ^ b, (a &amp; b) &lt;&lt; <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"两数相除\"><a href=\"#两数相除\" class=\"headerlink\" title=\"两数相除\"></a>两数相除</h3><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">divide</span><span class=\"params\">(dividend <span class=\"type\">int</span>, divisor <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> dividend==<span class=\"number\">0</span> &#123;<span class=\"keyword\">return</span> <span class=\"number\">0</span>&#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> dividend==math.MinInt32 &amp;&amp; divisor==<span class=\"number\">-1</span> &#123;<span class=\"keyword\">return</span> math.MaxInt32&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    diffSign:=<span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dividend&lt;<span class=\"number\">0</span>)!=(divisor&lt;<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        diffSign=<span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    i,j,sum := <span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">        tmp:=<span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> diffSign &#123;</span><br><span class=\"line\">            tmp=sum-divisor&lt;&lt;j</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            tmp=sum+divisor&lt;&lt;j</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dividend&gt;<span class=\"number\">0</span> &amp;&amp; tmp&gt;dividend) || (dividend&lt;<span class=\"number\">0</span> &amp;&amp; tmp&lt;dividend) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> j==<span class=\"number\">0</span> &#123;<span class=\"keyword\">break</span>&#125;</span><br><span class=\"line\">            j-- <span class=\"comment\">//步长减半</span></span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sum=tmp</span><br><span class=\"line\">        i+=<span class=\"number\">1</span>&lt;&lt;j</span><br><span class=\"line\">        j++ <span class=\"comment\">//步长加倍</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> diffSign &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -i</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> i</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"二维矩阵转置\"><a href=\"#二维矩阵转置\" class=\"headerlink\" title=\"二维矩阵转置\"></a>二维矩阵转置</h2><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">transposeMatrix</span><span class=\"params\">(matrix [][]<span class=\"type\">int</span>)</span></span> [][]<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取矩阵的行数和列数</span></span><br><span class=\"line\">    rows, cols := <span class=\"built_in\">len</span>(matrix), <span class=\"built_in\">len</span>(matrix[<span class=\"number\">0</span>])</span><br><span class=\"line\">    <span class=\"comment\">// 定义一个新的二维数组，用于存储转置后的矩阵</span></span><br><span class=\"line\">    transposed := <span class=\"built_in\">make</span>([][]<span class=\"type\">int</span>, cols)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> transposed &#123;</span><br><span class=\"line\">        transposed[i] = <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, rows)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 遍历原矩阵，将其每个元素放置在转置矩阵中的相应位置</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; rows; i++ &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j := <span class=\"number\">0</span>; j &lt; cols; j++ &#123;</span><br><span class=\"line\">            transposed[j][i] = matrix[i][j]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> transposed</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"cover":"/img/cover/2077_city.png","cover_type":"img","excerpt":"","more":"<h1 id=\"文档前言\"><a href=\"#文档前言\" class=\"headerlink\" title=\"文档前言\"></a>文档前言</h1><p>当我完成了许多的算法题目以及其扩展题目之后，总是在那几天对于解决这类性特征的问题有着较多的见解，而且发现同类型特征的问题往往有着相似的解法，尤其是在我回顾一些问题却发现他们异常陌生的时候，我察觉到自己不能通过简单的肌肉记忆来提高解决问题的能力，重复和已经解决思考的部分应当有浓缩和归类的操作</p>\n<p>本文档的主要内容将主要包含两个部分：</p>\n<ul>\n<li>基础简单算法的模式化归纳：忽略代码实现的细节和边界条件，将算法当中最主要的公式和代码片段摘出</li>\n<li>特征问题的通解归纳，将具有特征特点的问题归纳出一个通用的范式</li>\n</ul>\n<h1 id=\"二叉树\"><a href=\"#二叉树\" class=\"headerlink\" title=\"二叉树\"></a>二叉树</h1><h2 id=\"二叉树的遍历\"><a href=\"#二叉树的遍历\" class=\"headerlink\" title=\"二叉树的遍历\"></a>二叉树的遍历</h2><p>在树的<strong>深度优先</strong>遍历算法当中（包括前序、中序、后序），常常使用的是递归的方式，也就是：</p>\n<ul>\n<li><font color ='red'>前序遍历：中、左、右 </font></li>\n<li><font color ='red'>中序遍历：左、中、右 </font></li>\n<li><font color ='red'>后序遍历：左、右、中 </font></li>\n</ul>\n<h3 id=\"颜色标记法\"><a href=\"#颜色标记法\" class=\"headerlink\" title=\"颜色标记法\"></a>颜色标记法</h3><p>受到(henry)[<a href=\"https://leetcode.cn/problems/binary-tree-inorder-traversal/solution/yan-se-biao-ji-fa-yi-chong-tong-yong-qie-jian-ming/]\">https://leetcode.cn/problems/binary-tree-inorder-traversal/solution/yan-se-biao-ji-fa-yi-chong-tong-yong-qie-jian-ming/]</a> 解题方法的启发</p>\n<p>将树的遍历问题放到栈的逻辑下面，其实有几点问题：</p>\n<ul>\n<li>入栈的元素只有两种： 指向节点的指针和空指针，类似于：<code>[1,null,2,null,3,null,4,null,5,null,6]</code></li>\n<li>出栈的时候操作的必定是一个有指向地址的指针，那么出栈操作代表些什么</li>\n<li>怎样才能够区别出左子树和右子树呢？</li>\n</ul>\n<p>栈是先进后出的数据结构，与递归和函数调用类似，越是靠近栈底的元素他在树的结构上就越高。而栈的这个特性保证了树的结构，也就是说左/右子树必定是在右/左子树之前弹出，换句话说除了当前遍历的节点node，他的左右在遍历过程其实中代表的是一棵树，继续向栈里推入元素就是在不断地展开他的树节点，而这样的顺序必定是被中间的Node所标志的，如图中所示</p>\n<div style=\"display:flex;flex-direction:row;\"r>\n    <img src='./tree_stack1.jpg' width=\"400\" height=\"200\" style=\"margin-right:10px;\"/>\n    <img src='./tree_stack2.jpg' width=\"400\" height=\"200\" style=\"margin-left:10px;\"/>\n</div>\n\n<p><br>回到上述三个问题来理解就会容易一些</p>\n<ol>\n<li>因为栈存储的是树，而不是节点，所以一些叶节点没有左右子树，这部分依旧还是会以逻辑形式入栈 </li>\n<li>出栈入栈是对应的，所以理解上也应该要对应起来说，第一次入栈只要该节点不是root，那么他必定是以某个节点的左右节点身份入栈的，此时的入栈操作标识的是当前节点为root 的子树，所以第一次出栈是用来将其从树的身份转化为节点，通过将其标记为 1 [有颜色，标志为确实为一个节点]，然后再入栈表示为遍历，当把整棵树放入栈中后，出栈操作则对应节点，此时栈中所有标记为1的部分就是实际遍历的节点，而且按照入栈的顺序表示出中、后、前序.<br>那么按照这样的思路，我们来编写一下对二叉树的中序遍历：</li>\n</ol>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> TreeNode <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">    Right *TreeNode</span><br><span class=\"line\">    Left  *TreeNode</span><br><span class=\"line\">    Val  <span class=\"type\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">traversal</span><span class=\"params\">(root *TreeNode)</span></span> []<span class=\"keyword\">interface</span>&#123;&#125;&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 颜色点，用于标记出入栈</span></span><br><span class=\"line\">    <span class=\"keyword\">type</span> node <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">        Color <span class=\"type\">int</span></span><br><span class=\"line\">        Node *TreeNode</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    stack := <span class=\"built_in\">make</span>([]*node,<span class=\"number\">0</span>)</span><br><span class=\"line\">    stack = <span class=\"built_in\">append</span>(stack,node&#123;<span class=\"number\">0</span>，root&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 需要的结果函数</span></span><br><span class=\"line\">    <span class=\"comment\">//result := make([]interface,0)</span></span><br><span class=\"line\">    res := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"built_in\">len</span>(stack) &gt; <span class=\"number\">0</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 每次都取出栈顶元素进行判定</span></span><br><span class=\"line\">        n := stack[<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>]</span><br><span class=\"line\">        stack = stack[:<span class=\"built_in\">len</span>(stack)<span class=\"number\">-1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> n.Node == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> n.Color == <span class=\"number\">0</span>&#123;</span><br><span class=\"line\">            stack = <span class=\"built_in\">append</span>(stack,node&#123;<span class=\"number\">0</span>,n.Node.Right&#125;)</span><br><span class=\"line\">            stack = <span class=\"built_in\">append</span>(stack,node&#123;<span class=\"number\">1</span>,n.Node&#125;)</span><br><span class=\"line\">            stack = <span class=\"built_in\">append</span>(stack,node&#123;<span class=\"number\">0</span>,n.Node.Left&#125;)</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            res = <span class=\"built_in\">append</span>(res, n.Node.Val)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>在这段代码当中，由于标记方式的存在和入栈方式是两次入栈，所以几乎可以是模板样式来解决问题，而且好记忆</p>\n<p>在代码当中可以修改的地方只有两处：</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> n.Color == <span class=\"number\">0</span>&#123;</span><br><span class=\"line\">    【第一处】</span><br><span class=\"line\">    可以修改为不同的深度遍历顺序</span><br><span class=\"line\">    【前序遍历】：</span><br><span class=\"line\">    ···</span><br><span class=\"line\">        stack = <span class=\"built_in\">append</span>(stack,node&#123;<span class=\"number\">0</span>,n.Node.Right&#125;)</span><br><span class=\"line\">        stack = <span class=\"built_in\">append</span>(stack,node&#123;<span class=\"number\">0</span>,n.Node.Left&#125;) </span><br><span class=\"line\">        stack = <span class=\"built_in\">append</span>(stack,node&#123;<span class=\"number\">1</span>,n.Node&#125;)   </span><br><span class=\"line\">    ···</span><br><span class=\"line\">    【中序遍历】</span><br><span class=\"line\">    ···</span><br><span class=\"line\">        stack = <span class=\"built_in\">append</span>(stack,node&#123;<span class=\"number\">0</span>,n.Node.Right&#125;)</span><br><span class=\"line\">        stack = <span class=\"built_in\">append</span>(stack,node&#123;<span class=\"number\">1</span>,n.Node&#125;)  </span><br><span class=\"line\">        stack = <span class=\"built_in\">append</span>(stack,node&#123;<span class=\"number\">0</span>,n.Node.Left&#125;) </span><br><span class=\"line\">    ···</span><br><span class=\"line\">    【后序遍历】</span><br><span class=\"line\">    ···</span><br><span class=\"line\">        stack = <span class=\"built_in\">append</span>(stack,node&#123;<span class=\"number\">1</span>,n.Node&#125;)  </span><br><span class=\"line\">        stack = <span class=\"built_in\">append</span>(stack,node&#123;<span class=\"number\">0</span>,n.Node.Right&#125;)</span><br><span class=\"line\">        stack = <span class=\"built_in\">append</span>(stack,node&#123;<span class=\"number\">0</span>,n.Node.Left&#125;) </span><br><span class=\"line\">    ···</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    【第二处】</span><br><span class=\"line\">    添加对当前node值的修改函数</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"递归方法\"><a href=\"#递归方法\" class=\"headerlink\" title=\"递归方法\"></a>递归方法</h3><p>使用递归最关键还是两条：</p>\n<ul>\n<li>递归结束的条件</li>\n<li>递归函数的结构</li>\n</ul>\n<p>普通的前序遍历数组的代码：</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"常见运算标识\"><a href=\"#常见运算标识\" class=\"headerlink\" title=\"常见运算标识\"></a>常见运算标识</h1><h2 id=\"最大最小值\"><a href=\"#最大最小值\" class=\"headerlink\" title=\"最大最小值\"></a>最大最小值</h2><p>以下这两个都是可以接受多个变量参数的求最大最小值</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">max</span><span class=\"params\">(args ...<span class=\"type\">int</span>)</span></span><span class=\"type\">int</span>&#123;</span><br><span class=\"line\">    m := args[<span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _,val := <span class=\"keyword\">range</span> args&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> val &gt; m&#123;</span><br><span class=\"line\">            m = val</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">min</span><span class=\"params\">(args ...<span class=\"type\">int</span>)</span></span><span class=\"type\">int</span>&#123;</span><br><span class=\"line\">    m := args[<span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _,val := <span class=\"keyword\">range</span> args&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> val &lt; m&#123;</span><br><span class=\"line\">            m = val</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"异或，同或\"><a href=\"#异或，同或\" class=\"headerlink\" title=\"异或，同或\"></a>异或，同或</h2><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">xor</span><span class=\"params\">(a, b <span class=\"type\">bool</span>)</span></span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (a || b) &amp;&amp; !(a &amp;&amp; b)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">xnor</span><span class=\"params\">(a, b <span class=\"type\">bool</span>)</span></span> <span class=\"type\">bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (a &amp;&amp; b) || (!a &amp;&amp; !b)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"位运算\"><a href=\"#位运算\" class=\"headerlink\" title=\"位运算\"></a>位运算</h2><h3 id=\"两数相加\"><a href=\"#两数相加\" class=\"headerlink\" title=\"两数相加\"></a>两数相加</h3><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">getSum</span><span class=\"params\">(a <span class=\"type\">int</span>, b <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 异或+与运算:时间复杂度O(logSum) | 空间复杂度O(1)</span></span><br><span class=\"line\">    a, b = a ^ b, (a &amp; b) &lt;&lt; <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> b != <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        a, b = a ^ b, (a &amp; b) &lt;&lt; <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"两数相除\"><a href=\"#两数相除\" class=\"headerlink\" title=\"两数相除\"></a>两数相除</h3><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">divide</span><span class=\"params\">(dividend <span class=\"type\">int</span>, divisor <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> dividend==<span class=\"number\">0</span> &#123;<span class=\"keyword\">return</span> <span class=\"number\">0</span>&#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> dividend==math.MinInt32 &amp;&amp; divisor==<span class=\"number\">-1</span> &#123;<span class=\"keyword\">return</span> math.MaxInt32&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    diffSign:=<span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dividend&lt;<span class=\"number\">0</span>)!=(divisor&lt;<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        diffSign=<span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    i,j,sum := <span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">        tmp:=<span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> diffSign &#123;</span><br><span class=\"line\">            tmp=sum-divisor&lt;&lt;j</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            tmp=sum+divisor&lt;&lt;j</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dividend&gt;<span class=\"number\">0</span> &amp;&amp; tmp&gt;dividend) || (dividend&lt;<span class=\"number\">0</span> &amp;&amp; tmp&lt;dividend) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> j==<span class=\"number\">0</span> &#123;<span class=\"keyword\">break</span>&#125;</span><br><span class=\"line\">            j-- <span class=\"comment\">//步长减半</span></span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sum=tmp</span><br><span class=\"line\">        i+=<span class=\"number\">1</span>&lt;&lt;j</span><br><span class=\"line\">        j++ <span class=\"comment\">//步长加倍</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> diffSign &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -i</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> i</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"二维矩阵转置\"><a href=\"#二维矩阵转置\" class=\"headerlink\" title=\"二维矩阵转置\"></a>二维矩阵转置</h2><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">transposeMatrix</span><span class=\"params\">(matrix [][]<span class=\"type\">int</span>)</span></span> [][]<span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取矩阵的行数和列数</span></span><br><span class=\"line\">    rows, cols := <span class=\"built_in\">len</span>(matrix), <span class=\"built_in\">len</span>(matrix[<span class=\"number\">0</span>])</span><br><span class=\"line\">    <span class=\"comment\">// 定义一个新的二维数组，用于存储转置后的矩阵</span></span><br><span class=\"line\">    transposed := <span class=\"built_in\">make</span>([][]<span class=\"type\">int</span>, cols)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> transposed &#123;</span><br><span class=\"line\">        transposed[i] = <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, rows)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 遍历原矩阵，将其每个元素放置在转置矩阵中的相应位置</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; rows; i++ &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j := <span class=\"number\">0</span>; j &lt; cols; j++ &#123;</span><br><span class=\"line\">            transposed[j][i] = matrix[i][j]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> transposed</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"算法简要汇总","catalog":true,"date":"2023-03-27T20:52:12.000Z","subtitle":"南开大学 苏明老师课程讲解","header-img":null,"_content":"\n# 算法\n> the art of data\n\n# [第一节课] 课程背景\n> The theoretical study of computer-program performance and resource usage\n## 为什么研究算法\n\n1. 对性能的研究 --> 告知哪些是可以做到的，哪些是不可能实现的\n\n2. 对算法性能的抽象可以推广到其他计算资源上\n\n3. 程序[逻辑推演]通用一套逻辑\n\n\n## 算法关注的焦点\n\n1. 忽略在哪里实现： 与平台无关\n\n2. 忽略实例的不同：与实例无关\n\n3. 注意问题的增长规模\n\n以排序算法为例：\n算法最为关心其中元素的比较、移动次数\n* 最坏情况: 插入排序当中，如果序列是倒序，解决需要的时间与问题规模呈现 n^2 级别增长 \n* 平均情况: 插入排序当中，最快是序列就是顺序的，平均情况是和最坏情况取平均值\n\n如果要对这个排序算法做优化的话，可以怎么想呢？\n以一个合并排序作为例子来讲解：\n\n通过将问题分解之后，使得合并排序比起插入排序有更快的速度，但却消耗了更多的空间。\n\n学习算法的目标：\n* 灵活运用合适数据结构来解决实际问题\n* 碰到具体的问题，能够分析问题的关键点并进行规划，编写代码输出正确结果\n* 清晰的算法复杂度概念，采用正确的算法是的编写的代码运行更有效率\n* 全面提高编写代码的逻辑\n\n## [第二节课] 引言： 某些特定的问题\n\n### 第一个问题： 稳定匹配\n> College Admission and the Stability of Marriage\n\n#### 双向选择\n> 比如交朋友，南开大学 X 和天津大学 Y 学生相互之间选择，存在一个需求是： X 对于 Y 可能满足或者不满足，Y 对于 X 可能满足或者不满足\n> 关键在于找到一个 **稳定** 的方案尽可能不与 X/Y 的特性和意愿产生矛盾\n\n\n**<font color ='red'> 问题的形式化: 提出本质的、相对简单的问题模型： n 个 X 类型对象中的每一个对 m 个 Y 类型对象提出申请，而每个 Y 类型对象只要单一个 X 对象</font>**\n\n那么**稳定的对象** 就是一个匹配 （X,Y），每一个 X,Y 应该只出现在其中一个组合当中，完美的匹配就是满足所有的 X， Y 对象的需求。\n\n--> 对每组优先表是否存在一个稳定的匹配呢\n--> 给定一组优先表，如果存在稳定匹配，能够有效构造出来吗\n--> 如果存在稳定匹配会有很多吗？\n\n那么是否对于每一类优先列表都存在一个通用的选择方法嘛？\n\n邀请拒绝算法--> 找到 **稳定匹配符合直觉** 的算法\n\n**评价算法的正确性**\n\n* 正确性： 是否满足题目要求\n* 有穷性： 有while循环，是否能够正确退出\n* 输出  ： 输出结构是否符合题目要求\n\n那么如何才能够在代码上实现这个算法呢？\n要点：\n* 要用两个数组记录约会的对象\n\n\n> 小技巧：在多层循环当中，尽量降低内层循环的计算复杂度","source":"_posts/Algorithm/算法课程-南开苏明老师/算法简要汇总.md","raw":"---\ntitle: 算法简要汇总\ncatalog: true\ndate: 2023-03-28 04:52:12\nsubtitle: 南开大学 苏明老师课程讲解\nheader-img:\ntags: 算法， 南开大学，Golang, working\ncategories: 算法[Algrithm]\n---\n\n# 算法\n> the art of data\n\n# [第一节课] 课程背景\n> The theoretical study of computer-program performance and resource usage\n## 为什么研究算法\n\n1. 对性能的研究 --> 告知哪些是可以做到的，哪些是不可能实现的\n\n2. 对算法性能的抽象可以推广到其他计算资源上\n\n3. 程序[逻辑推演]通用一套逻辑\n\n\n## 算法关注的焦点\n\n1. 忽略在哪里实现： 与平台无关\n\n2. 忽略实例的不同：与实例无关\n\n3. 注意问题的增长规模\n\n以排序算法为例：\n算法最为关心其中元素的比较、移动次数\n* 最坏情况: 插入排序当中，如果序列是倒序，解决需要的时间与问题规模呈现 n^2 级别增长 \n* 平均情况: 插入排序当中，最快是序列就是顺序的，平均情况是和最坏情况取平均值\n\n如果要对这个排序算法做优化的话，可以怎么想呢？\n以一个合并排序作为例子来讲解：\n\n通过将问题分解之后，使得合并排序比起插入排序有更快的速度，但却消耗了更多的空间。\n\n学习算法的目标：\n* 灵活运用合适数据结构来解决实际问题\n* 碰到具体的问题，能够分析问题的关键点并进行规划，编写代码输出正确结果\n* 清晰的算法复杂度概念，采用正确的算法是的编写的代码运行更有效率\n* 全面提高编写代码的逻辑\n\n## [第二节课] 引言： 某些特定的问题\n\n### 第一个问题： 稳定匹配\n> College Admission and the Stability of Marriage\n\n#### 双向选择\n> 比如交朋友，南开大学 X 和天津大学 Y 学生相互之间选择，存在一个需求是： X 对于 Y 可能满足或者不满足，Y 对于 X 可能满足或者不满足\n> 关键在于找到一个 **稳定** 的方案尽可能不与 X/Y 的特性和意愿产生矛盾\n\n\n**<font color ='red'> 问题的形式化: 提出本质的、相对简单的问题模型： n 个 X 类型对象中的每一个对 m 个 Y 类型对象提出申请，而每个 Y 类型对象只要单一个 X 对象</font>**\n\n那么**稳定的对象** 就是一个匹配 （X,Y），每一个 X,Y 应该只出现在其中一个组合当中，完美的匹配就是满足所有的 X， Y 对象的需求。\n\n--> 对每组优先表是否存在一个稳定的匹配呢\n--> 给定一组优先表，如果存在稳定匹配，能够有效构造出来吗\n--> 如果存在稳定匹配会有很多吗？\n\n那么是否对于每一类优先列表都存在一个通用的选择方法嘛？\n\n邀请拒绝算法--> 找到 **稳定匹配符合直觉** 的算法\n\n**评价算法的正确性**\n\n* 正确性： 是否满足题目要求\n* 有穷性： 有while循环，是否能够正确退出\n* 输出  ： 输出结构是否符合题目要求\n\n那么如何才能够在代码上实现这个算法呢？\n要点：\n* 要用两个数组记录约会的对象\n\n\n> 小技巧：在多层循环当中，尽量降低内层循环的计算复杂度","slug":"Algorithm/算法课程-南开苏明老师/算法简要汇总","published":1,"updated":"2023-04-22T13:24:02.204Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgtm6jqd000llyjx3m5aauvq","content":"<h1 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h1><blockquote>\n<p>the art of data</p>\n</blockquote>\n<h1 id=\"第一节课-课程背景\"><a href=\"#第一节课-课程背景\" class=\"headerlink\" title=\"[第一节课] 课程背景\"></a>[第一节课] 课程背景</h1><blockquote>\n<p>The theoretical study of computer-program performance and resource usage</p>\n</blockquote>\n<h2 id=\"为什么研究算法\"><a href=\"#为什么研究算法\" class=\"headerlink\" title=\"为什么研究算法\"></a>为什么研究算法</h2><ol>\n<li><p>对性能的研究 –&gt; 告知哪些是可以做到的，哪些是不可能实现的</p>\n</li>\n<li><p>对算法性能的抽象可以推广到其他计算资源上</p>\n</li>\n<li><p>程序[逻辑推演]通用一套逻辑</p>\n</li>\n</ol>\n<h2 id=\"算法关注的焦点\"><a href=\"#算法关注的焦点\" class=\"headerlink\" title=\"算法关注的焦点\"></a>算法关注的焦点</h2><ol>\n<li><p>忽略在哪里实现： 与平台无关</p>\n</li>\n<li><p>忽略实例的不同：与实例无关</p>\n</li>\n<li><p>注意问题的增长规模</p>\n</li>\n</ol>\n<p>以排序算法为例：<br>算法最为关心其中元素的比较、移动次数</p>\n<ul>\n<li>最坏情况: 插入排序当中，如果序列是倒序，解决需要的时间与问题规模呈现 n^2 级别增长 </li>\n<li>平均情况: 插入排序当中，最快是序列就是顺序的，平均情况是和最坏情况取平均值</li>\n</ul>\n<p>如果要对这个排序算法做优化的话，可以怎么想呢？<br>以一个合并排序作为例子来讲解：</p>\n<p>通过将问题分解之后，使得合并排序比起插入排序有更快的速度，但却消耗了更多的空间。</p>\n<p>学习算法的目标：</p>\n<ul>\n<li>灵活运用合适数据结构来解决实际问题</li>\n<li>碰到具体的问题，能够分析问题的关键点并进行规划，编写代码输出正确结果</li>\n<li>清晰的算法复杂度概念，采用正确的算法是的编写的代码运行更有效率</li>\n<li>全面提高编写代码的逻辑</li>\n</ul>\n<h2 id=\"第二节课-引言：-某些特定的问题\"><a href=\"#第二节课-引言：-某些特定的问题\" class=\"headerlink\" title=\"[第二节课] 引言： 某些特定的问题\"></a>[第二节课] 引言： 某些特定的问题</h2><h3 id=\"第一个问题：-稳定匹配\"><a href=\"#第一个问题：-稳定匹配\" class=\"headerlink\" title=\"第一个问题： 稳定匹配\"></a>第一个问题： 稳定匹配</h3><blockquote>\n<p>College Admission and the Stability of Marriage</p>\n</blockquote>\n<h4 id=\"双向选择\"><a href=\"#双向选择\" class=\"headerlink\" title=\"双向选择\"></a>双向选择</h4><blockquote>\n<p>比如交朋友，南开大学 X 和天津大学 Y 学生相互之间选择，存在一个需求是： X 对于 Y 可能满足或者不满足，Y 对于 X 可能满足或者不满足<br>关键在于找到一个 <strong>稳定</strong> 的方案尽可能不与 X/Y 的特性和意愿产生矛盾</p>\n</blockquote>\n<p><strong><font color ='red'> 问题的形式化: 提出本质的、相对简单的问题模型： n 个 X 类型对象中的每一个对 m 个 Y 类型对象提出申请，而每个 Y 类型对象只要单一个 X 对象</font></strong></p>\n<p>那么<strong>稳定的对象</strong> 就是一个匹配 （X,Y），每一个 X,Y 应该只出现在其中一个组合当中，完美的匹配就是满足所有的 X， Y 对象的需求。</p>\n<p>–&gt; 对每组优先表是否存在一个稳定的匹配呢<br>–&gt; 给定一组优先表，如果存在稳定匹配，能够有效构造出来吗<br>–&gt; 如果存在稳定匹配会有很多吗？</p>\n<p>那么是否对于每一类优先列表都存在一个通用的选择方法嘛？</p>\n<p>邀请拒绝算法–&gt; 找到 <strong>稳定匹配符合直觉</strong> 的算法</p>\n<p><strong>评价算法的正确性</strong></p>\n<ul>\n<li>正确性： 是否满足题目要求</li>\n<li>有穷性： 有while循环，是否能够正确退出</li>\n<li>输出  ： 输出结构是否符合题目要求</li>\n</ul>\n<p>那么如何才能够在代码上实现这个算法呢？<br>要点：</p>\n<ul>\n<li>要用两个数组记录约会的对象</li>\n</ul>\n<blockquote>\n<p>小技巧：在多层循环当中，尽量降低内层循环的计算复杂度</p>\n</blockquote>\n","site":{"data":{}},"cover":"/img/cover/2077_city.png","cover_type":"img","excerpt":"","more":"<h1 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h1><blockquote>\n<p>the art of data</p>\n</blockquote>\n<h1 id=\"第一节课-课程背景\"><a href=\"#第一节课-课程背景\" class=\"headerlink\" title=\"[第一节课] 课程背景\"></a>[第一节课] 课程背景</h1><blockquote>\n<p>The theoretical study of computer-program performance and resource usage</p>\n</blockquote>\n<h2 id=\"为什么研究算法\"><a href=\"#为什么研究算法\" class=\"headerlink\" title=\"为什么研究算法\"></a>为什么研究算法</h2><ol>\n<li><p>对性能的研究 –&gt; 告知哪些是可以做到的，哪些是不可能实现的</p>\n</li>\n<li><p>对算法性能的抽象可以推广到其他计算资源上</p>\n</li>\n<li><p>程序[逻辑推演]通用一套逻辑</p>\n</li>\n</ol>\n<h2 id=\"算法关注的焦点\"><a href=\"#算法关注的焦点\" class=\"headerlink\" title=\"算法关注的焦点\"></a>算法关注的焦点</h2><ol>\n<li><p>忽略在哪里实现： 与平台无关</p>\n</li>\n<li><p>忽略实例的不同：与实例无关</p>\n</li>\n<li><p>注意问题的增长规模</p>\n</li>\n</ol>\n<p>以排序算法为例：<br>算法最为关心其中元素的比较、移动次数</p>\n<ul>\n<li>最坏情况: 插入排序当中，如果序列是倒序，解决需要的时间与问题规模呈现 n^2 级别增长 </li>\n<li>平均情况: 插入排序当中，最快是序列就是顺序的，平均情况是和最坏情况取平均值</li>\n</ul>\n<p>如果要对这个排序算法做优化的话，可以怎么想呢？<br>以一个合并排序作为例子来讲解：</p>\n<p>通过将问题分解之后，使得合并排序比起插入排序有更快的速度，但却消耗了更多的空间。</p>\n<p>学习算法的目标：</p>\n<ul>\n<li>灵活运用合适数据结构来解决实际问题</li>\n<li>碰到具体的问题，能够分析问题的关键点并进行规划，编写代码输出正确结果</li>\n<li>清晰的算法复杂度概念，采用正确的算法是的编写的代码运行更有效率</li>\n<li>全面提高编写代码的逻辑</li>\n</ul>\n<h2 id=\"第二节课-引言：-某些特定的问题\"><a href=\"#第二节课-引言：-某些特定的问题\" class=\"headerlink\" title=\"[第二节课] 引言： 某些特定的问题\"></a>[第二节课] 引言： 某些特定的问题</h2><h3 id=\"第一个问题：-稳定匹配\"><a href=\"#第一个问题：-稳定匹配\" class=\"headerlink\" title=\"第一个问题： 稳定匹配\"></a>第一个问题： 稳定匹配</h3><blockquote>\n<p>College Admission and the Stability of Marriage</p>\n</blockquote>\n<h4 id=\"双向选择\"><a href=\"#双向选择\" class=\"headerlink\" title=\"双向选择\"></a>双向选择</h4><blockquote>\n<p>比如交朋友，南开大学 X 和天津大学 Y 学生相互之间选择，存在一个需求是： X 对于 Y 可能满足或者不满足，Y 对于 X 可能满足或者不满足<br>关键在于找到一个 <strong>稳定</strong> 的方案尽可能不与 X/Y 的特性和意愿产生矛盾</p>\n</blockquote>\n<p><strong><font color ='red'> 问题的形式化: 提出本质的、相对简单的问题模型： n 个 X 类型对象中的每一个对 m 个 Y 类型对象提出申请，而每个 Y 类型对象只要单一个 X 对象</font></strong></p>\n<p>那么<strong>稳定的对象</strong> 就是一个匹配 （X,Y），每一个 X,Y 应该只出现在其中一个组合当中，完美的匹配就是满足所有的 X， Y 对象的需求。</p>\n<p>–&gt; 对每组优先表是否存在一个稳定的匹配呢<br>–&gt; 给定一组优先表，如果存在稳定匹配，能够有效构造出来吗<br>–&gt; 如果存在稳定匹配会有很多吗？</p>\n<p>那么是否对于每一类优先列表都存在一个通用的选择方法嘛？</p>\n<p>邀请拒绝算法–&gt; 找到 <strong>稳定匹配符合直觉</strong> 的算法</p>\n<p><strong>评价算法的正确性</strong></p>\n<ul>\n<li>正确性： 是否满足题目要求</li>\n<li>有穷性： 有while循环，是否能够正确退出</li>\n<li>输出  ： 输出结构是否符合题目要求</li>\n</ul>\n<p>那么如何才能够在代码上实现这个算法呢？<br>要点：</p>\n<ul>\n<li>要用两个数组记录约会的对象</li>\n</ul>\n<blockquote>\n<p>小技巧：在多层循环当中，尽量降低内层循环的计算复杂度</p>\n</blockquote>\n"},{"title":"读书笔记--深入理解Linux网络","catalog":true,"date":"2023-04-02T17:47:41.000Z","subtitle":null,"header-img":null,"_content":"","source":"_posts/Book/读书笔记-深入理解Linux网络/读书笔记-深入理解Linux网络.md","raw":"---\ntitle: 读书笔记--深入理解Linux网络\ncatalog: true\ndate: 2023-04-03 01:47:41\nsubtitle:\nheader-img:\ntags:\ncategories:\n---\n","slug":"Book/读书笔记-深入理解Linux网络/读书笔记-深入理解Linux网络","published":1,"updated":"2023-04-22T13:24:02.204Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgtm6jqf000plyjx4g065v4l","content":"","site":{"data":{}},"cover":"/img/cover/elderring.png","cover_type":"img","excerpt":"","more":""},{"title":"zjx-test","date":"2023-04-22T16:28:20.000Z","published":0,"_content":"\n\n","source":"_posts/Common/zjx/test.md","raw":"---\ntitle: zjx-test\ndate: 2023-04-23 00:28:20\ntags:\npublished: false\n---\n\n\n","slug":"Common/zjx/test","updated":"2023-04-23T16:05:25.276Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgtm6jqg000rlyjx3z50b90v","content":"","site":{"data":{}},"cover":"/img/cover/2077_city.png","cover_type":"img","excerpt":"","more":""},{"title":"kubernetes 集群性能测试工具测试","catalog":true,"date":"2023-04-17T18:07:22.000Z","subtitle":null,"header-img":null,"published":0,"_content":"\n# ","source":"_posts/EdgeMesh/cilium与edgemesh性能测试/cilium与edgemesh性能测试.md","raw":"---\ntitle: kubernetes 集群性能测试工具测试\ncatalog: true\ndate: 2023-04-18 02:07:22\nsubtitle:\nheader-img:\ntags: 测试， edgeMesh\ncategories: 测试\npublished: false\n---\n\n# ","slug":"EdgeMesh/cilium与edgemesh性能测试/cilium与edgemesh性能测试","updated":"2023-04-22T13:24:02.204Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgtm6jqi000vlyjxhnnw598r","content":"<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h1>","site":{"data":{}},"cover":"/img/cover/elderring.png","cover_type":"img","excerpt":"","more":"<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h1>"},{"title":"Go Pratical knowledge","catalog":true,"date":"2023-04-09T17:18:26.000Z","subtitle":null,"header-img":null,"published":0,"_content":"\n# \n\n``` golang\nCNI_COMMAND=ADD CNI_CONTAINERID=lab-ns CNI_NETNS=/var/run/netns/lab-ns CNI_IFNAME=eth0 CNI_PATH=`pwd` ./bridge <../conf/lab-br0.conf\n\ncat > lab-br0.conf <<\"EOF\"\n{\n    \"cniVersion\": \"0.4.0\",\n    \"name\": \"lab-br0\",\n    \"type\": \"bridge\",\n    \"bridge\": \"lab-br0\",\n    \"isGateway\": true,\n    \"ipMasq\": true,\n    \"ipam\": {\n        \"type\": \"host-local\",\n        \"subnet\": \"10.15.10.0/24\",\n        \"routes\": [\n            { \"dst\": \"0.0.0.0/0\" }\n        ],\n        \"rangeStart\": \"10.15.10.100\",\n        \"rangeEnd\": \"10.15.10.200\",\n        \"gateway\": \"10.15.10.99\"\n    }\n}\nEOF\n\nCNI_COMMAND=ADD CNI_CONTAINERID=e992e95204096b5f22dd4a8b0b5a3348a503c928d5eca71e84eac4fa96379011 CNI_NETNS=/var/run/docker/netns/ab1949fd7d3d CNI_IFNAME=eth0 CNI_PATH=`pwd` ./bridge <../conf/lab-br1.conf\n```","source":"_posts/Go/Go-Pratical-knowledge/Go-Pratical-knowledge.md","raw":"---\ntitle: Go Pratical knowledge\ncatalog: true\ndate: 2023-04-10 01:18:26\nsubtitle:\nheader-img:\ntags:\ncategories:\npublished: false\n---\n\n# \n\n``` golang\nCNI_COMMAND=ADD CNI_CONTAINERID=lab-ns CNI_NETNS=/var/run/netns/lab-ns CNI_IFNAME=eth0 CNI_PATH=`pwd` ./bridge <../conf/lab-br0.conf\n\ncat > lab-br0.conf <<\"EOF\"\n{\n    \"cniVersion\": \"0.4.0\",\n    \"name\": \"lab-br0\",\n    \"type\": \"bridge\",\n    \"bridge\": \"lab-br0\",\n    \"isGateway\": true,\n    \"ipMasq\": true,\n    \"ipam\": {\n        \"type\": \"host-local\",\n        \"subnet\": \"10.15.10.0/24\",\n        \"routes\": [\n            { \"dst\": \"0.0.0.0/0\" }\n        ],\n        \"rangeStart\": \"10.15.10.100\",\n        \"rangeEnd\": \"10.15.10.200\",\n        \"gateway\": \"10.15.10.99\"\n    }\n}\nEOF\n\nCNI_COMMAND=ADD CNI_CONTAINERID=e992e95204096b5f22dd4a8b0b5a3348a503c928d5eca71e84eac4fa96379011 CNI_NETNS=/var/run/docker/netns/ab1949fd7d3d CNI_IFNAME=eth0 CNI_PATH=`pwd` ./bridge <../conf/lab-br1.conf\n```","slug":"Go/Go-Pratical-knowledge/Go-Pratical-knowledge","updated":"2023-04-22T13:24:02.216Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgtm6jqj000xlyjxg7910loj","content":"<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h1><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CNI_COMMAND=ADD CNI_CONTAINERID=lab-ns CNI_NETNS=/<span class=\"keyword\">var</span>/run/netns/lab-ns CNI_IFNAME=eth0 CNI_PATH=<span class=\"string\">`pwd`</span> ./bridge &lt;../conf/lab-br0.conf</span><br><span class=\"line\"></span><br><span class=\"line\">cat &gt; lab-br0.conf &lt;&lt;<span class=\"string\">&quot;EOF&quot;</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;cniVersion&quot;</span>: <span class=\"string\">&quot;0.4.0&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;name&quot;</span>: <span class=\"string\">&quot;lab-br0&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;type&quot;</span>: <span class=\"string\">&quot;bridge&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;bridge&quot;</span>: <span class=\"string\">&quot;lab-br0&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;isGateway&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;ipMasq&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;ipam&quot;</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;type&quot;</span>: <span class=\"string\">&quot;host-local&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;subnet&quot;</span>: <span class=\"string\">&quot;10.15.10.0/24&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;routes&quot;</span>: [</span><br><span class=\"line\">            &#123; <span class=\"string\">&quot;dst&quot;</span>: <span class=\"string\">&quot;0.0.0.0/0&quot;</span> &#125;</span><br><span class=\"line\">        ],</span><br><span class=\"line\">        <span class=\"string\">&quot;rangeStart&quot;</span>: <span class=\"string\">&quot;10.15.10.100&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;rangeEnd&quot;</span>: <span class=\"string\">&quot;10.15.10.200&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;gateway&quot;</span>: <span class=\"string\">&quot;10.15.10.99&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EOF</span><br><span class=\"line\"></span><br><span class=\"line\">CNI_COMMAND=ADD CNI_CONTAINERID=e992e95204096b5f22dd4a8b0b5a3348a503c928d5eca71e84eac4fa96379011 CNI_NETNS=/<span class=\"keyword\">var</span>/run/docker/netns/ab1949fd7d3d CNI_IFNAME=eth0 CNI_PATH=<span class=\"string\">`pwd`</span> ./bridge &lt;../conf/lab-br1.conf</span><br></pre></td></tr></table></figure>","site":{"data":{}},"cover":"/img/cover/elderring.png","cover_type":"img","excerpt":"","more":"<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h1><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CNI_COMMAND=ADD CNI_CONTAINERID=lab-ns CNI_NETNS=/<span class=\"keyword\">var</span>/run/netns/lab-ns CNI_IFNAME=eth0 CNI_PATH=<span class=\"string\">`pwd`</span> ./bridge &lt;../conf/lab-br0.conf</span><br><span class=\"line\"></span><br><span class=\"line\">cat &gt; lab-br0.conf &lt;&lt;<span class=\"string\">&quot;EOF&quot;</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;cniVersion&quot;</span>: <span class=\"string\">&quot;0.4.0&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;name&quot;</span>: <span class=\"string\">&quot;lab-br0&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;type&quot;</span>: <span class=\"string\">&quot;bridge&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;bridge&quot;</span>: <span class=\"string\">&quot;lab-br0&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;isGateway&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;ipMasq&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;ipam&quot;</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;type&quot;</span>: <span class=\"string\">&quot;host-local&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;subnet&quot;</span>: <span class=\"string\">&quot;10.15.10.0/24&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;routes&quot;</span>: [</span><br><span class=\"line\">            &#123; <span class=\"string\">&quot;dst&quot;</span>: <span class=\"string\">&quot;0.0.0.0/0&quot;</span> &#125;</span><br><span class=\"line\">        ],</span><br><span class=\"line\">        <span class=\"string\">&quot;rangeStart&quot;</span>: <span class=\"string\">&quot;10.15.10.100&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;rangeEnd&quot;</span>: <span class=\"string\">&quot;10.15.10.200&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;gateway&quot;</span>: <span class=\"string\">&quot;10.15.10.99&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EOF</span><br><span class=\"line\"></span><br><span class=\"line\">CNI_COMMAND=ADD CNI_CONTAINERID=e992e95204096b5f22dd4a8b0b5a3348a503c928d5eca71e84eac4fa96379011 CNI_NETNS=/<span class=\"keyword\">var</span>/run/docker/netns/ab1949fd7d3d CNI_IFNAME=eth0 CNI_PATH=<span class=\"string\">`pwd`</span> ./bridge &lt;../conf/lab-br1.conf</span><br></pre></td></tr></table></figure>"},{"title":"Go basic knowledge","catalog":true,"date":"2023-04-09T17:16:19.000Z","subtitle":null,"header-img":null,"_content":"# Go 入门知识\n> 本章节内容基于 https://tour.go-zh.org/  [Go语言测试平台](https://tour.go-zh.org/list) 索引整理完成\n>\n> 答案训练参考：\n>\n> https://gist.github.com/zyxar/2317744\n>\n> https://gist.github.com/CarlosLanderas/11b4f6727deec051883ddc02edf5cd0b\n>\n> 一些有用书籍索引：\n>\n> [Go语言圣经（中文版）](https://books.studygolang.com/gopl-zh/)\n>\n> [Go语言入门教程，Golang入门教程](http://c.biancheng.net/golang/)\n>\n> [《Go语言标准库》](https://books.studygolang.com/The-Golang-Standard-Library-by-Example/)\n\n\n# 1. Go 包相关\n\n## 路径\n\n每个 Go 程序都是由包构成的。\n\n程序从 `main` 包开始运行。\n\n比如通过导入路径 `\"fmt\"` 和 `\"math/rand\"` 来使用这两个包。\n\n按照约定，包名与导入路径的最后一个元素一致。例如，`\"math/rand\"` 包中的源码均以 `package rand` 语句开始。\n\n\n## 导入包\n\n圆括号组合了导入，这是“分组”形式的导入语\n\n\n# 2. 变量\n\n注意类型在变量名之后 \n\n```go\ny int\n```\n\n\n\n`var` 语句用于声明一个变量列表，跟函数的参数列表一样，类型在最后\n\n```go\nvar a ,b c, d int\n```\n\n变量声明可以包含初始值，每个变量对应一个， 逗号隔开，如果初始化值已存在，则可以省略类型；变量会从初始值中获得类型。\n\n```go\nvar i, j int = 1, 2\nvar c, python, java = true, false, \"no!\"\n```\n\n\n简洁赋值语句 `:=` 可在类型明确的地方代替 `var` 声明。\n\n函数外的每个语句都必须以关键字开始（`var`, `func` 等等），因此 ​`:=`​ 结构不能在函数外使用[相较之下 var 可以写到函数外面，在包层级]\n\n```go\n\tk := 3\n\tc, python, java := true, false, \"no!\"\n```\n\n\n**Go 的基本类型有**\n\n```\nbool\n\nstring\n\nint  int8  int16  int32  int64\nuint uint8 uint16 uint32 uint64 uintptr\n\nbyte // uint8 的别名\n\nrune // int32 的别名\n    // 表示一个 Unicode 码点\n\nfloat32 float64\n\ncomplex64 complex128\n```\n\n本例展示了几种类型的变量。 同导入语句一样，变量声明也可以“分组”成一个语法块。\n\n```go\nvar (\n\tToBe   bool       = false\n\tMaxInt uint64     = 1<<64 - 1\n\tz      complex128 = cmplx.Sqrt(-5 + 12i)\n)\n```\n\n`int`, `uint` 和 `uintptr` 在 32 位系统上通常为 32 位宽，在 64 位系统上则为 64 位宽。 当你需要一个整数值时应使用 `int` 类型，除非你有特殊的理由使用固定大小或无符号的整数类型。\n\n\n没有明确初始值的变量声明会被赋予它们的 **零值**。\n\n零值是：\n\n* 数值类型为 `0`，\n* 布尔类型为 `false`，\n* 字符串为 `\"\"`（空字符串）。\n\n\n表达式 `T(v)` 将值 `v` 转换为类型 `T`。\n\n一些关于数值的转换：\n\n```\nvar i int = 42\nvar f float64 = float64(i)\nvar u uint = uint(f)\n```\n\n或者，更加简单的形式：\n\n```\ni := 42\nf := float64(i)\nu := uint(f)\n```\n\n与 C 不同的是，Go 在不同类型的项之间赋值时需要显式转换,，等号右边的数值必须是类型明确的\n\n\n## 常量\n\n常量的声明与变量类似，只不过是使用 `const` 关键字。\n\n常量可以是字符、字符串、布尔值或数值。\n\n常量不能用 `:=` 语法声明。\n\n```go\nconst World = \"世界\"\n//相较之下，这个申明的world是一个变量，也就是可以改变其类型的\nworld := \"世界\"\n\n\tconst World = \"世界\"\n\tfmt.Println(\"Hello\", World)\n\n\tworld := \"世界\"\n\tfmt.Println(\"Go rules?\", world)\n\tworld = \"是吗\"\n\tfmt.Println(\"Go rules?\", world)\n\t结果是：\n\tHello 世界\n\tGo rules? 世界\n\tGo rules? 是吗\n```\n\n\n## 类型推导\n\n在声明一个变量而不指定其类型时（即使用不带类型的 `:=` 语法或 `var =` 表达式语法），变量的类型由右值推导得出。\n\n当右值声明了类型时，新变量的类型与其相同：\n\n```\nvar i int\nj := i // j 也是一个 int\n```\n\n不过当右边包含未指明类型的数值常量时，新变量的类型就可能是 `int`, `float64` 或 `complex128` 了，这取决于常量的精度：\n\n```\ni := 42           // int\nf := 3.142        // float64\ng := 0.867 + 0.5i // complex128\n```\n\n\n## 数值常量\n\n数值常量是高精度的 **值**。\n\n一个未指定类型的常量由上下文来决定其类型。\n\n再尝试一下输出 `needInt(Big)` 吧。\n\n（`int` 类型最大可以存储一个 64 位的整数，有时会更小。）\n\n（`int` 可以存放最大64位的整数，根据平台不同有时会更少。）\n\n```go\nconst (\n\t// 将 1 左移 100 位来创建一个非常大的数字\n\t// 即这个数的二进制是 1 后面跟着 100 个 0\n\tBig = 1 << 100\n\t// 再往右移 99 位，即 Small = 1 << 1，或者说 Small = 2\n\tSmall = Big >> 99\n)\n```\n\n\n\n# 3. 语句\n\n## if\n\nGo 的 `if` 语句与 `for` 循环类似，表达式外无需小括号 `( )` ，而大括号 `{ }` 则是必须的。\n\n```go\nif x < 0 {\n\treturn sqrt(-x) + \"i\"\n}\n```\n\n## for\n\nGo 只有一种循环结构：`for` 循环。\n\n基本的 `for` 循环由三部分组成，它们用分号隔开：\n\n* 初始化语句：在第一次迭代前执行\n* 条件表达式：在每次迭代前求值\n* 后置语句：在每次迭代的结尾执行\n\n初始化语句通常为一句短变量声明，该变量声明仅在 `for` 语句的作用域中可见。\n\n一旦条件表达式的布尔值为 `false`，循环迭代就会终止。\n\n初始化语句和后置语句是可选的，也就是说完全可以只有一个条件，其含义也变成了wihle语句，但是go里面没有while只有for\n\n**注意**：和 C、Java、JavaScript 之类的语言不同，**Go 的 for 语句后面的三个构成部分外没有小括号**， 而包围函数主体的大括号 `{ }` 则是必须的。\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tsum := 0\n\tfor i := 0; i < 10; i++ {\n\t\tsum += i\n\t}\n\tfmt.Println(sum)\n}\n\n\nfunc main() {\n\tsum := 1\n\tfor sum < 1000{\n\t\tsum += sum\n\t}\n\tfmt.Println(sum)\n}\n\n```\n\n\n## if 的简短语句\n\n同 `for` 一样， `if` 语句可以在条件表达式前执行一个简单的语句。\n\n**该语句声明的变量作用域仅在 ​****`if`****​ 之内。**也就是说出了if语句，这个变量就没有了\n\n```go\nfunc pow(x, n, lim float64) float64 {\n\tif v := math.Pow(x, n); v < lim {\n\t\treturn v\n\t}\n\treturn lim\n}\n```\n\n\n## if 和 else\n\n在 `if` 的简短语句中声明的变量同样可以在任何对应的 `else` 块中使用。\n\n```go\nif v := math.Pow(x, n); v < lim {\n\t\treturn v\n\t} else {\n\t\tfmt.Printf(\"%g >= %g\\n\", v, lim)\n\t}\n\n\n//一般格式是：\nif {\n}else if {\n}else {}\n```\n\n\n\n## switch\n\n`switch` 是编写一连串 `if - else` 语句的简便方法。它运行第一个值等于条件表达式的 case 语句。\n\nGo 的 switch 语句类似于 C、C++、Java、JavaScript 和 PHP 中的，不过 Go 只运行选定的 case，而非之后所有的 case。 实际上，Go 自动提供了在这些语言中每个 case 后面所需的 `break` 语句。 除非以 `fallthrough` 语句结束，否则分支会自动终止。 Go 的另一点重要的不同在于 switch 的 case 无需为常量，且取值不必为整数。\n\n```go\n\tswitch os := runtime.GOOS; os {\n\tcase \"darwin\":\n\t\tfmt.Println(\"OS X.\")\n\tcase \"linux\":\n\t\tfmt.Println(\"Linux.\")\n\tdefault:\n\t\t// freebsd, openbsd,\n\t\t// plan9, windows...\n\t\tfmt.Printf(\"%s.\\n\", os)\n\t}\n```\n\n\n## switch 的求值顺序\n\nswitch 的 case 语句从上到下顺次执行，直到匹配成功时停止。\n\n（例如，\n\n```\nswitch i {\ncase 0:\ncase f():\n}\n```\n\n在 `i==0` 时 `f` 不会被调用。\n\n```go\n\ttoday := time.Now().Weekday()\n\tswitch time.Saturday {\n\tcase today + 0:\n\t\tfmt.Println(\"Today.\")\n\tcase today + 1:\n\t\tfmt.Println(\"Tomorrow.\")\n\tcase today + 2:\n\t\tfmt.Println(\"In two days.\")\n\tdefault:\n\t\tfmt.Println(\"Too far away.\")\n\t}\n```\n\n## 没有条件的 switch\n\n没有条件的 switch 同 `switch true` 一样。\n\n这种形式能将一长串 if-then-else 写得更加清晰。\n\n```go\nt := time.Now()\n\tswitch {\n\tcase t.Hour() < 12:\n\t\tfmt.Println(\"Good morning!\")\n\tcase t.Hour() < 17:\n\t\tfmt.Println(\"Good afternoon.\")\n\tdefault:\n\t\tfmt.Println(\"Good evening.\")\n\t}\n```\n\n\n## defer\n\ndefer 语句会将函数推迟到外层函数返回之后执行。\n\n推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用。\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tdefer fmt.Println(\"world\")\n\n\tfmt.Println(\"hello\")\n}\n结果是：\nhello\nworld\n```\n\n\n## defer 栈\n\n推迟的函数调用会被压入一个栈中。当外层函数返回时，被推迟的函数会按照后进先出的顺序调用。\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tfmt.Println(\"counting\")\n\n\tfor i := 0; i < 10; i++ {\n\t\tdefer fmt.Println(i)\n\t}\n\n\tfmt.Println(\"done\")\n}\n由于是按照栈的形式来存的\ncounting\ndone\n9\n8\n7\n6\n5\n4\n3\n2\n1\n0\n```\n\n[Defer，Panic,Recover](https://blog.go-zh.org/defer-panic-and-recover)\n\n\n## 函数返回\n\n函数可以返回任意数量的返回值, 但是结构上需要结合函数形式\n\n```go\nfunc swap(x, y string) (string, string) {\n\treturn y, x\n}\n```\n\n\nGo 的返回值可被命名，它们会被视作定义在函数顶部的变量。\n\n返回值的名称应当具有一定的意义，它可以作为文档使用。","source":"_posts/Go/Go-basic-knowledge/Go-basic-knowledge.md","raw":"---\ntitle: Go basic knowledge\ncatalog: true\ndate: 2023-04-10 01:16:19\nsubtitle:\nheader-img:\ntags:\ncategories: \n\t- Basic\n---\n# Go 入门知识\n> 本章节内容基于 https://tour.go-zh.org/  [Go语言测试平台](https://tour.go-zh.org/list) 索引整理完成\n>\n> 答案训练参考：\n>\n> https://gist.github.com/zyxar/2317744\n>\n> https://gist.github.com/CarlosLanderas/11b4f6727deec051883ddc02edf5cd0b\n>\n> 一些有用书籍索引：\n>\n> [Go语言圣经（中文版）](https://books.studygolang.com/gopl-zh/)\n>\n> [Go语言入门教程，Golang入门教程](http://c.biancheng.net/golang/)\n>\n> [《Go语言标准库》](https://books.studygolang.com/The-Golang-Standard-Library-by-Example/)\n\n\n# 1. Go 包相关\n\n## 路径\n\n每个 Go 程序都是由包构成的。\n\n程序从 `main` 包开始运行。\n\n比如通过导入路径 `\"fmt\"` 和 `\"math/rand\"` 来使用这两个包。\n\n按照约定，包名与导入路径的最后一个元素一致。例如，`\"math/rand\"` 包中的源码均以 `package rand` 语句开始。\n\n\n## 导入包\n\n圆括号组合了导入，这是“分组”形式的导入语\n\n\n# 2. 变量\n\n注意类型在变量名之后 \n\n```go\ny int\n```\n\n\n\n`var` 语句用于声明一个变量列表，跟函数的参数列表一样，类型在最后\n\n```go\nvar a ,b c, d int\n```\n\n变量声明可以包含初始值，每个变量对应一个， 逗号隔开，如果初始化值已存在，则可以省略类型；变量会从初始值中获得类型。\n\n```go\nvar i, j int = 1, 2\nvar c, python, java = true, false, \"no!\"\n```\n\n\n简洁赋值语句 `:=` 可在类型明确的地方代替 `var` 声明。\n\n函数外的每个语句都必须以关键字开始（`var`, `func` 等等），因此 ​`:=`​ 结构不能在函数外使用[相较之下 var 可以写到函数外面，在包层级]\n\n```go\n\tk := 3\n\tc, python, java := true, false, \"no!\"\n```\n\n\n**Go 的基本类型有**\n\n```\nbool\n\nstring\n\nint  int8  int16  int32  int64\nuint uint8 uint16 uint32 uint64 uintptr\n\nbyte // uint8 的别名\n\nrune // int32 的别名\n    // 表示一个 Unicode 码点\n\nfloat32 float64\n\ncomplex64 complex128\n```\n\n本例展示了几种类型的变量。 同导入语句一样，变量声明也可以“分组”成一个语法块。\n\n```go\nvar (\n\tToBe   bool       = false\n\tMaxInt uint64     = 1<<64 - 1\n\tz      complex128 = cmplx.Sqrt(-5 + 12i)\n)\n```\n\n`int`, `uint` 和 `uintptr` 在 32 位系统上通常为 32 位宽，在 64 位系统上则为 64 位宽。 当你需要一个整数值时应使用 `int` 类型，除非你有特殊的理由使用固定大小或无符号的整数类型。\n\n\n没有明确初始值的变量声明会被赋予它们的 **零值**。\n\n零值是：\n\n* 数值类型为 `0`，\n* 布尔类型为 `false`，\n* 字符串为 `\"\"`（空字符串）。\n\n\n表达式 `T(v)` 将值 `v` 转换为类型 `T`。\n\n一些关于数值的转换：\n\n```\nvar i int = 42\nvar f float64 = float64(i)\nvar u uint = uint(f)\n```\n\n或者，更加简单的形式：\n\n```\ni := 42\nf := float64(i)\nu := uint(f)\n```\n\n与 C 不同的是，Go 在不同类型的项之间赋值时需要显式转换,，等号右边的数值必须是类型明确的\n\n\n## 常量\n\n常量的声明与变量类似，只不过是使用 `const` 关键字。\n\n常量可以是字符、字符串、布尔值或数值。\n\n常量不能用 `:=` 语法声明。\n\n```go\nconst World = \"世界\"\n//相较之下，这个申明的world是一个变量，也就是可以改变其类型的\nworld := \"世界\"\n\n\tconst World = \"世界\"\n\tfmt.Println(\"Hello\", World)\n\n\tworld := \"世界\"\n\tfmt.Println(\"Go rules?\", world)\n\tworld = \"是吗\"\n\tfmt.Println(\"Go rules?\", world)\n\t结果是：\n\tHello 世界\n\tGo rules? 世界\n\tGo rules? 是吗\n```\n\n\n## 类型推导\n\n在声明一个变量而不指定其类型时（即使用不带类型的 `:=` 语法或 `var =` 表达式语法），变量的类型由右值推导得出。\n\n当右值声明了类型时，新变量的类型与其相同：\n\n```\nvar i int\nj := i // j 也是一个 int\n```\n\n不过当右边包含未指明类型的数值常量时，新变量的类型就可能是 `int`, `float64` 或 `complex128` 了，这取决于常量的精度：\n\n```\ni := 42           // int\nf := 3.142        // float64\ng := 0.867 + 0.5i // complex128\n```\n\n\n## 数值常量\n\n数值常量是高精度的 **值**。\n\n一个未指定类型的常量由上下文来决定其类型。\n\n再尝试一下输出 `needInt(Big)` 吧。\n\n（`int` 类型最大可以存储一个 64 位的整数，有时会更小。）\n\n（`int` 可以存放最大64位的整数，根据平台不同有时会更少。）\n\n```go\nconst (\n\t// 将 1 左移 100 位来创建一个非常大的数字\n\t// 即这个数的二进制是 1 后面跟着 100 个 0\n\tBig = 1 << 100\n\t// 再往右移 99 位，即 Small = 1 << 1，或者说 Small = 2\n\tSmall = Big >> 99\n)\n```\n\n\n\n# 3. 语句\n\n## if\n\nGo 的 `if` 语句与 `for` 循环类似，表达式外无需小括号 `( )` ，而大括号 `{ }` 则是必须的。\n\n```go\nif x < 0 {\n\treturn sqrt(-x) + \"i\"\n}\n```\n\n## for\n\nGo 只有一种循环结构：`for` 循环。\n\n基本的 `for` 循环由三部分组成，它们用分号隔开：\n\n* 初始化语句：在第一次迭代前执行\n* 条件表达式：在每次迭代前求值\n* 后置语句：在每次迭代的结尾执行\n\n初始化语句通常为一句短变量声明，该变量声明仅在 `for` 语句的作用域中可见。\n\n一旦条件表达式的布尔值为 `false`，循环迭代就会终止。\n\n初始化语句和后置语句是可选的，也就是说完全可以只有一个条件，其含义也变成了wihle语句，但是go里面没有while只有for\n\n**注意**：和 C、Java、JavaScript 之类的语言不同，**Go 的 for 语句后面的三个构成部分外没有小括号**， 而包围函数主体的大括号 `{ }` 则是必须的。\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tsum := 0\n\tfor i := 0; i < 10; i++ {\n\t\tsum += i\n\t}\n\tfmt.Println(sum)\n}\n\n\nfunc main() {\n\tsum := 1\n\tfor sum < 1000{\n\t\tsum += sum\n\t}\n\tfmt.Println(sum)\n}\n\n```\n\n\n## if 的简短语句\n\n同 `for` 一样， `if` 语句可以在条件表达式前执行一个简单的语句。\n\n**该语句声明的变量作用域仅在 ​****`if`****​ 之内。**也就是说出了if语句，这个变量就没有了\n\n```go\nfunc pow(x, n, lim float64) float64 {\n\tif v := math.Pow(x, n); v < lim {\n\t\treturn v\n\t}\n\treturn lim\n}\n```\n\n\n## if 和 else\n\n在 `if` 的简短语句中声明的变量同样可以在任何对应的 `else` 块中使用。\n\n```go\nif v := math.Pow(x, n); v < lim {\n\t\treturn v\n\t} else {\n\t\tfmt.Printf(\"%g >= %g\\n\", v, lim)\n\t}\n\n\n//一般格式是：\nif {\n}else if {\n}else {}\n```\n\n\n\n## switch\n\n`switch` 是编写一连串 `if - else` 语句的简便方法。它运行第一个值等于条件表达式的 case 语句。\n\nGo 的 switch 语句类似于 C、C++、Java、JavaScript 和 PHP 中的，不过 Go 只运行选定的 case，而非之后所有的 case。 实际上，Go 自动提供了在这些语言中每个 case 后面所需的 `break` 语句。 除非以 `fallthrough` 语句结束，否则分支会自动终止。 Go 的另一点重要的不同在于 switch 的 case 无需为常量，且取值不必为整数。\n\n```go\n\tswitch os := runtime.GOOS; os {\n\tcase \"darwin\":\n\t\tfmt.Println(\"OS X.\")\n\tcase \"linux\":\n\t\tfmt.Println(\"Linux.\")\n\tdefault:\n\t\t// freebsd, openbsd,\n\t\t// plan9, windows...\n\t\tfmt.Printf(\"%s.\\n\", os)\n\t}\n```\n\n\n## switch 的求值顺序\n\nswitch 的 case 语句从上到下顺次执行，直到匹配成功时停止。\n\n（例如，\n\n```\nswitch i {\ncase 0:\ncase f():\n}\n```\n\n在 `i==0` 时 `f` 不会被调用。\n\n```go\n\ttoday := time.Now().Weekday()\n\tswitch time.Saturday {\n\tcase today + 0:\n\t\tfmt.Println(\"Today.\")\n\tcase today + 1:\n\t\tfmt.Println(\"Tomorrow.\")\n\tcase today + 2:\n\t\tfmt.Println(\"In two days.\")\n\tdefault:\n\t\tfmt.Println(\"Too far away.\")\n\t}\n```\n\n## 没有条件的 switch\n\n没有条件的 switch 同 `switch true` 一样。\n\n这种形式能将一长串 if-then-else 写得更加清晰。\n\n```go\nt := time.Now()\n\tswitch {\n\tcase t.Hour() < 12:\n\t\tfmt.Println(\"Good morning!\")\n\tcase t.Hour() < 17:\n\t\tfmt.Println(\"Good afternoon.\")\n\tdefault:\n\t\tfmt.Println(\"Good evening.\")\n\t}\n```\n\n\n## defer\n\ndefer 语句会将函数推迟到外层函数返回之后执行。\n\n推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用。\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tdefer fmt.Println(\"world\")\n\n\tfmt.Println(\"hello\")\n}\n结果是：\nhello\nworld\n```\n\n\n## defer 栈\n\n推迟的函数调用会被压入一个栈中。当外层函数返回时，被推迟的函数会按照后进先出的顺序调用。\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tfmt.Println(\"counting\")\n\n\tfor i := 0; i < 10; i++ {\n\t\tdefer fmt.Println(i)\n\t}\n\n\tfmt.Println(\"done\")\n}\n由于是按照栈的形式来存的\ncounting\ndone\n9\n8\n7\n6\n5\n4\n3\n2\n1\n0\n```\n\n[Defer，Panic,Recover](https://blog.go-zh.org/defer-panic-and-recover)\n\n\n## 函数返回\n\n函数可以返回任意数量的返回值, 但是结构上需要结合函数形式\n\n```go\nfunc swap(x, y string) (string, string) {\n\treturn y, x\n}\n```\n\n\nGo 的返回值可被命名，它们会被视作定义在函数顶部的变量。\n\n返回值的名称应当具有一定的意义，它可以作为文档使用。","slug":"Go/Go-basic-knowledge/Go-basic-knowledge","published":1,"updated":"2023-04-23T15:20:25.917Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgtm6jqk0011lyjx4bv1gfx7","content":"<h1 id=\"Go-入门知识\"><a href=\"#Go-入门知识\" class=\"headerlink\" title=\"Go 入门知识\"></a>Go 入门知识</h1><blockquote>\n<p>本章节内容基于 <a href=\"https://tour.go-zh.org/\">https://tour.go-zh.org/</a>  <a href=\"https://tour.go-zh.org/list\">Go语言测试平台</a> 索引整理完成</p>\n<p>答案训练参考：</p>\n<p><a href=\"https://gist.github.com/zyxar/2317744\">https://gist.github.com/zyxar/2317744</a></p>\n<p><a href=\"https://gist.github.com/CarlosLanderas/11b4f6727deec051883ddc02edf5cd0b\">https://gist.github.com/CarlosLanderas/11b4f6727deec051883ddc02edf5cd0b</a></p>\n<p>一些有用书籍索引：</p>\n<p><a href=\"https://books.studygolang.com/gopl-zh/\">Go语言圣经（中文版）</a></p>\n<p><a href=\"http://c.biancheng.net/golang/\">Go语言入门教程，Golang入门教程</a></p>\n<p><a href=\"https://books.studygolang.com/The-Golang-Standard-Library-by-Example/\">《Go语言标准库》</a></p>\n</blockquote>\n<h1 id=\"1-Go-包相关\"><a href=\"#1-Go-包相关\" class=\"headerlink\" title=\"1. Go 包相关\"></a>1. Go 包相关</h1><h2 id=\"路径\"><a href=\"#路径\" class=\"headerlink\" title=\"路径\"></a>路径</h2><p>每个 Go 程序都是由包构成的。</p>\n<p>程序从 <code>main</code> 包开始运行。</p>\n<p>比如通过导入路径 <code>&quot;fmt&quot;</code> 和 <code>&quot;math/rand&quot;</code> 来使用这两个包。</p>\n<p>按照约定，包名与导入路径的最后一个元素一致。例如，<code>&quot;math/rand&quot;</code> 包中的源码均以 <code>package rand</code> 语句开始。</p>\n<h2 id=\"导入包\"><a href=\"#导入包\" class=\"headerlink\" title=\"导入包\"></a>导入包</h2><p>圆括号组合了导入，这是“分组”形式的导入语</p>\n<h1 id=\"2-变量\"><a href=\"#2-变量\" class=\"headerlink\" title=\"2. 变量\"></a>2. 变量</h1><p>注意类型在变量名之后 </p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">y <span class=\"type\">int</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p><code>var</code> 语句用于声明一个变量列表，跟函数的参数列表一样，类型在最后</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a ,b c, d <span class=\"type\">int</span></span><br></pre></td></tr></table></figure>\n\n<p>变量声明可以包含初始值，每个变量对应一个， 逗号隔开，如果初始化值已存在，则可以省略类型；变量会从初始值中获得类型。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> i, j <span class=\"type\">int</span> = <span class=\"number\">1</span>, <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> c, python, java = <span class=\"literal\">true</span>, <span class=\"literal\">false</span>, <span class=\"string\">&quot;no!&quot;</span></span><br></pre></td></tr></table></figure>\n\n\n<p>简洁赋值语句 <code>:=</code> 可在类型明确的地方代替 <code>var</code> 声明。</p>\n<p>函数外的每个语句都必须以关键字开始（<code>var</code>, <code>func</code> 等等），因此 ​<code>:=</code>​ 结构不能在函数外使用[相较之下 var 可以写到函数外面，在包层级]</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">k := <span class=\"number\">3</span></span><br><span class=\"line\">c, python, java := <span class=\"literal\">true</span>, <span class=\"literal\">false</span>, <span class=\"string\">&quot;no!&quot;</span></span><br></pre></td></tr></table></figure>\n\n\n<p><strong>Go 的基本类型有</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bool</span><br><span class=\"line\"></span><br><span class=\"line\">string</span><br><span class=\"line\"></span><br><span class=\"line\">int  int8  int16  int32  int64</span><br><span class=\"line\">uint uint8 uint16 uint32 uint64 uintptr</span><br><span class=\"line\"></span><br><span class=\"line\">byte // uint8 的别名</span><br><span class=\"line\"></span><br><span class=\"line\">rune // int32 的别名</span><br><span class=\"line\">    // 表示一个 Unicode 码点</span><br><span class=\"line\"></span><br><span class=\"line\">float32 float64</span><br><span class=\"line\"></span><br><span class=\"line\">complex64 complex128</span><br></pre></td></tr></table></figure>\n\n<p>本例展示了几种类型的变量。 同导入语句一样，变量声明也可以“分组”成一个语法块。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> (</span><br><span class=\"line\">\tToBe   <span class=\"type\">bool</span>       = <span class=\"literal\">false</span></span><br><span class=\"line\">\tMaxInt <span class=\"type\">uint64</span>     = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">64</span> - <span class=\"number\">1</span></span><br><span class=\"line\">\tz      <span class=\"type\">complex128</span> = cmplx.Sqrt(<span class=\"number\">-5</span> + <span class=\"number\">12i</span>)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p><code>int</code>, <code>uint</code> 和 <code>uintptr</code> 在 32 位系统上通常为 32 位宽，在 64 位系统上则为 64 位宽。 当你需要一个整数值时应使用 <code>int</code> 类型，除非你有特殊的理由使用固定大小或无符号的整数类型。</p>\n<p>没有明确初始值的变量声明会被赋予它们的 <strong>零值</strong>。</p>\n<p>零值是：</p>\n<ul>\n<li>数值类型为 <code>0</code>，</li>\n<li>布尔类型为 <code>false</code>，</li>\n<li>字符串为 <code>&quot;&quot;</code>（空字符串）。</li>\n</ul>\n<p>表达式 <code>T(v)</code> 将值 <code>v</code> 转换为类型 <code>T</code>。</p>\n<p>一些关于数值的转换：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var i int = 42</span><br><span class=\"line\">var f float64 = float64(i)</span><br><span class=\"line\">var u uint = uint(f)</span><br></pre></td></tr></table></figure>\n\n<p>或者，更加简单的形式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i := 42</span><br><span class=\"line\">f := float64(i)</span><br><span class=\"line\">u := uint(f)</span><br></pre></td></tr></table></figure>\n\n<p>与 C 不同的是，Go 在不同类型的项之间赋值时需要显式转换,，等号右边的数值必须是类型明确的</p>\n<h2 id=\"常量\"><a href=\"#常量\" class=\"headerlink\" title=\"常量\"></a>常量</h2><p>常量的声明与变量类似，只不过是使用 <code>const</code> 关键字。</p>\n<p>常量可以是字符、字符串、布尔值或数值。</p>\n<p>常量不能用 <code>:=</code> 语法声明。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> World = <span class=\"string\">&quot;世界&quot;</span></span><br><span class=\"line\"><span class=\"comment\">//相较之下，这个申明的world是一个变量，也就是可以改变其类型的</span></span><br><span class=\"line\">world := <span class=\"string\">&quot;世界&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> World = <span class=\"string\">&quot;世界&quot;</span></span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;Hello&quot;</span>, World)</span><br><span class=\"line\"></span><br><span class=\"line\">\tworld := <span class=\"string\">&quot;世界&quot;</span></span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;Go rules?&quot;</span>, world)</span><br><span class=\"line\">\tworld = <span class=\"string\">&quot;是吗&quot;</span></span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;Go rules?&quot;</span>, world)</span><br><span class=\"line\">\t结果是：</span><br><span class=\"line\">\tHello 世界</span><br><span class=\"line\">\tGo rules? 世界</span><br><span class=\"line\">\tGo rules? 是吗</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"类型推导\"><a href=\"#类型推导\" class=\"headerlink\" title=\"类型推导\"></a>类型推导</h2><p>在声明一个变量而不指定其类型时（即使用不带类型的 <code>:=</code> 语法或 <code>var =</code> 表达式语法），变量的类型由右值推导得出。</p>\n<p>当右值声明了类型时，新变量的类型与其相同：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var i int</span><br><span class=\"line\">j := i // j 也是一个 int</span><br></pre></td></tr></table></figure>\n\n<p>不过当右边包含未指明类型的数值常量时，新变量的类型就可能是 <code>int</code>, <code>float64</code> 或 <code>complex128</code> 了，这取决于常量的精度：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i := 42           // int</span><br><span class=\"line\">f := 3.142        // float64</span><br><span class=\"line\">g := 0.867 + 0.5i // complex128</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"数值常量\"><a href=\"#数值常量\" class=\"headerlink\" title=\"数值常量\"></a>数值常量</h2><p>数值常量是高精度的 <strong>值</strong>。</p>\n<p>一个未指定类型的常量由上下文来决定其类型。</p>\n<p>再尝试一下输出 <code>needInt(Big)</code> 吧。</p>\n<p>（<code>int</code> 类型最大可以存储一个 64 位的整数，有时会更小。）</p>\n<p>（<code>int</code> 可以存放最大64位的整数，根据平台不同有时会更少。）</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">\t<span class=\"comment\">// 将 1 左移 100 位来创建一个非常大的数字</span></span><br><span class=\"line\">\t<span class=\"comment\">// 即这个数的二进制是 1 后面跟着 100 个 0</span></span><br><span class=\"line\">\tBig = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">100</span></span><br><span class=\"line\">\t<span class=\"comment\">// 再往右移 99 位，即 Small = 1 &lt;&lt; 1，或者说 Small = 2</span></span><br><span class=\"line\">\tSmall = Big &gt;&gt; <span class=\"number\">99</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"3-语句\"><a href=\"#3-语句\" class=\"headerlink\" title=\"3. 语句\"></a>3. 语句</h1><h2 id=\"if\"><a href=\"#if\" class=\"headerlink\" title=\"if\"></a>if</h2><p>Go 的 <code>if</code> 语句与 <code>for</code> 循环类似，表达式外无需小括号 <code>( )</code> ，而大括号 <code>&#123; &#125;</code> 则是必须的。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> x &lt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> sqrt(-x) + <span class=\"string\">&quot;i&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"for\"><a href=\"#for\" class=\"headerlink\" title=\"for\"></a>for</h2><p>Go 只有一种循环结构：<code>for</code> 循环。</p>\n<p>基本的 <code>for</code> 循环由三部分组成，它们用分号隔开：</p>\n<ul>\n<li>初始化语句：在第一次迭代前执行</li>\n<li>条件表达式：在每次迭代前求值</li>\n<li>后置语句：在每次迭代的结尾执行</li>\n</ul>\n<p>初始化语句通常为一句短变量声明，该变量声明仅在 <code>for</code> 语句的作用域中可见。</p>\n<p>一旦条件表达式的布尔值为 <code>false</code>，循环迭代就会终止。</p>\n<p>初始化语句和后置语句是可选的，也就是说完全可以只有一个条件，其含义也变成了wihle语句，但是go里面没有while只有for</p>\n<p><strong>注意</strong>：和 C、Java、JavaScript 之类的语言不同，<strong>Go 的 for 语句后面的三个构成部分外没有小括号</strong>， 而包围函数主体的大括号 <code>&#123; &#125;</code> 则是必须的。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tsum := <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++ &#123;</span><br><span class=\"line\">\t\tsum += i</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfmt.Println(sum)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tsum := <span class=\"number\">1</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> sum &lt; <span class=\"number\">1000</span>&#123;</span><br><span class=\"line\">\t\tsum += sum</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfmt.Println(sum)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"if-的简短语句\"><a href=\"#if-的简短语句\" class=\"headerlink\" title=\"if 的简短语句\"></a>if 的简短语句</h2><p>同 <code>for</code> 一样， <code>if</code> 语句可以在条件表达式前执行一个简单的语句。</p>\n<p><strong>该语句声明的变量作用域仅在 ​</strong>**<code>if</code>**<strong>​ 之内。</strong>也就是说出了if语句，这个变量就没有了</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">pow</span><span class=\"params\">(x, n, lim <span class=\"type\">float64</span>)</span></span> <span class=\"type\">float64</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> v := math.Pow(x, n); v &lt; lim &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> v</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> lim</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"if-和-else\"><a href=\"#if-和-else\" class=\"headerlink\" title=\"if 和 else\"></a>if 和 else</h2><p>在 <code>if</code> 的简短语句中声明的变量同样可以在任何对应的 <code>else</code> 块中使用。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> v := math.Pow(x, n); v &lt; lim &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> v</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tfmt.Printf(<span class=\"string\">&quot;%g &gt;= %g\\n&quot;</span>, v, lim)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//一般格式是：</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> &#123;</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> &#123;</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span> &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"switch\"><a href=\"#switch\" class=\"headerlink\" title=\"switch\"></a>switch</h2><p><code>switch</code> 是编写一连串 <code>if - else</code> 语句的简便方法。它运行第一个值等于条件表达式的 case 语句。</p>\n<p>Go 的 switch 语句类似于 C、C++、Java、JavaScript 和 PHP 中的，不过 Go 只运行选定的 case，而非之后所有的 case。 实际上，Go 自动提供了在这些语言中每个 case 后面所需的 <code>break</code> 语句。 除非以 <code>fallthrough</code> 语句结束，否则分支会自动终止。 Go 的另一点重要的不同在于 switch 的 case 无需为常量，且取值不必为整数。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">switch</span> os := runtime.GOOS; os &#123;</span><br><span class=\"line\"><span class=\"keyword\">case</span> <span class=\"string\">&quot;darwin&quot;</span>:</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;OS X.&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">case</span> <span class=\"string\">&quot;linux&quot;</span>:</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;Linux.&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t<span class=\"comment\">// freebsd, openbsd,</span></span><br><span class=\"line\">\t<span class=\"comment\">// plan9, windows...</span></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;%s.\\n&quot;</span>, os)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"switch-的求值顺序\"><a href=\"#switch-的求值顺序\" class=\"headerlink\" title=\"switch 的求值顺序\"></a>switch 的求值顺序</h2><p>switch 的 case 语句从上到下顺次执行，直到匹配成功时停止。</p>\n<p>（例如，</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">switch i &#123;</span><br><span class=\"line\">case 0:</span><br><span class=\"line\">case f():</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在 <code>i==0</code> 时 <code>f</code> 不会被调用。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">today := time.Now().Weekday()</span><br><span class=\"line\"><span class=\"keyword\">switch</span> time.Saturday &#123;</span><br><span class=\"line\"><span class=\"keyword\">case</span> today + <span class=\"number\">0</span>:</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;Today.&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">case</span> today + <span class=\"number\">1</span>:</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;Tomorrow.&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">case</span> today + <span class=\"number\">2</span>:</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;In two days.&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">default</span>:</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;Too far away.&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"没有条件的-switch\"><a href=\"#没有条件的-switch\" class=\"headerlink\" title=\"没有条件的 switch\"></a>没有条件的 switch</h2><p>没有条件的 switch 同 <code>switch true</code> 一样。</p>\n<p>这种形式能将一长串 if-then-else 写得更加清晰。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">t := time.Now()</span><br><span class=\"line\">\t<span class=\"keyword\">switch</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> t.Hour() &lt; <span class=\"number\">12</span>:</span><br><span class=\"line\">\t\tfmt.Println(<span class=\"string\">&quot;Good morning!&quot;</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> t.Hour() &lt; <span class=\"number\">17</span>:</span><br><span class=\"line\">\t\tfmt.Println(<span class=\"string\">&quot;Good afternoon.&quot;</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\tfmt.Println(<span class=\"string\">&quot;Good evening.&quot;</span>)</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"defer\"><a href=\"#defer\" class=\"headerlink\" title=\"defer\"></a>defer</h2><p>defer 语句会将函数推迟到外层函数返回之后执行。</p>\n<p>推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> fmt.Println(<span class=\"string\">&quot;world&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;hello&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">结果是：</span><br><span class=\"line\">hello</span><br><span class=\"line\">world</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"defer-栈\"><a href=\"#defer-栈\" class=\"headerlink\" title=\"defer 栈\"></a>defer 栈</h2><p>推迟的函数调用会被压入一个栈中。当外层函数返回时，被推迟的函数会按照后进先出的顺序调用。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;counting&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++ &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">defer</span> fmt.Println(i)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;done&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">由于是按照栈的形式来存的</span><br><span class=\"line\">counting</span><br><span class=\"line\">done</span><br><span class=\"line\"><span class=\"number\">9</span></span><br><span class=\"line\"><span class=\"number\">8</span></span><br><span class=\"line\"><span class=\"number\">7</span></span><br><span class=\"line\"><span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://blog.go-zh.org/defer-panic-and-recover\">Defer，Panic,Recover</a></p>\n<h2 id=\"函数返回\"><a href=\"#函数返回\" class=\"headerlink\" title=\"函数返回\"></a>函数返回</h2><p>函数可以返回任意数量的返回值, 但是结构上需要结合函数形式</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">swap</span><span class=\"params\">(x, y <span class=\"type\">string</span>)</span></span> (<span class=\"type\">string</span>, <span class=\"type\">string</span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> y, x</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>Go 的返回值可被命名，它们会被视作定义在函数顶部的变量。</p>\n<p>返回值的名称应当具有一定的意义，它可以作为文档使用。</p>\n","site":{"data":{}},"cover":"/img/cover/elderring.png","cover_type":"img","excerpt":"","more":"<h1 id=\"Go-入门知识\"><a href=\"#Go-入门知识\" class=\"headerlink\" title=\"Go 入门知识\"></a>Go 入门知识</h1><blockquote>\n<p>本章节内容基于 <a href=\"https://tour.go-zh.org/\">https://tour.go-zh.org/</a>  <a href=\"https://tour.go-zh.org/list\">Go语言测试平台</a> 索引整理完成</p>\n<p>答案训练参考：</p>\n<p><a href=\"https://gist.github.com/zyxar/2317744\">https://gist.github.com/zyxar/2317744</a></p>\n<p><a href=\"https://gist.github.com/CarlosLanderas/11b4f6727deec051883ddc02edf5cd0b\">https://gist.github.com/CarlosLanderas/11b4f6727deec051883ddc02edf5cd0b</a></p>\n<p>一些有用书籍索引：</p>\n<p><a href=\"https://books.studygolang.com/gopl-zh/\">Go语言圣经（中文版）</a></p>\n<p><a href=\"http://c.biancheng.net/golang/\">Go语言入门教程，Golang入门教程</a></p>\n<p><a href=\"https://books.studygolang.com/The-Golang-Standard-Library-by-Example/\">《Go语言标准库》</a></p>\n</blockquote>\n<h1 id=\"1-Go-包相关\"><a href=\"#1-Go-包相关\" class=\"headerlink\" title=\"1. Go 包相关\"></a>1. Go 包相关</h1><h2 id=\"路径\"><a href=\"#路径\" class=\"headerlink\" title=\"路径\"></a>路径</h2><p>每个 Go 程序都是由包构成的。</p>\n<p>程序从 <code>main</code> 包开始运行。</p>\n<p>比如通过导入路径 <code>&quot;fmt&quot;</code> 和 <code>&quot;math/rand&quot;</code> 来使用这两个包。</p>\n<p>按照约定，包名与导入路径的最后一个元素一致。例如，<code>&quot;math/rand&quot;</code> 包中的源码均以 <code>package rand</code> 语句开始。</p>\n<h2 id=\"导入包\"><a href=\"#导入包\" class=\"headerlink\" title=\"导入包\"></a>导入包</h2><p>圆括号组合了导入，这是“分组”形式的导入语</p>\n<h1 id=\"2-变量\"><a href=\"#2-变量\" class=\"headerlink\" title=\"2. 变量\"></a>2. 变量</h1><p>注意类型在变量名之后 </p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">y <span class=\"type\">int</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p><code>var</code> 语句用于声明一个变量列表，跟函数的参数列表一样，类型在最后</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a ,b c, d <span class=\"type\">int</span></span><br></pre></td></tr></table></figure>\n\n<p>变量声明可以包含初始值，每个变量对应一个， 逗号隔开，如果初始化值已存在，则可以省略类型；变量会从初始值中获得类型。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> i, j <span class=\"type\">int</span> = <span class=\"number\">1</span>, <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> c, python, java = <span class=\"literal\">true</span>, <span class=\"literal\">false</span>, <span class=\"string\">&quot;no!&quot;</span></span><br></pre></td></tr></table></figure>\n\n\n<p>简洁赋值语句 <code>:=</code> 可在类型明确的地方代替 <code>var</code> 声明。</p>\n<p>函数外的每个语句都必须以关键字开始（<code>var</code>, <code>func</code> 等等），因此 ​<code>:=</code>​ 结构不能在函数外使用[相较之下 var 可以写到函数外面，在包层级]</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">k := <span class=\"number\">3</span></span><br><span class=\"line\">c, python, java := <span class=\"literal\">true</span>, <span class=\"literal\">false</span>, <span class=\"string\">&quot;no!&quot;</span></span><br></pre></td></tr></table></figure>\n\n\n<p><strong>Go 的基本类型有</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bool</span><br><span class=\"line\"></span><br><span class=\"line\">string</span><br><span class=\"line\"></span><br><span class=\"line\">int  int8  int16  int32  int64</span><br><span class=\"line\">uint uint8 uint16 uint32 uint64 uintptr</span><br><span class=\"line\"></span><br><span class=\"line\">byte // uint8 的别名</span><br><span class=\"line\"></span><br><span class=\"line\">rune // int32 的别名</span><br><span class=\"line\">    // 表示一个 Unicode 码点</span><br><span class=\"line\"></span><br><span class=\"line\">float32 float64</span><br><span class=\"line\"></span><br><span class=\"line\">complex64 complex128</span><br></pre></td></tr></table></figure>\n\n<p>本例展示了几种类型的变量。 同导入语句一样，变量声明也可以“分组”成一个语法块。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> (</span><br><span class=\"line\">\tToBe   <span class=\"type\">bool</span>       = <span class=\"literal\">false</span></span><br><span class=\"line\">\tMaxInt <span class=\"type\">uint64</span>     = <span class=\"number\">1</span>&lt;&lt;<span class=\"number\">64</span> - <span class=\"number\">1</span></span><br><span class=\"line\">\tz      <span class=\"type\">complex128</span> = cmplx.Sqrt(<span class=\"number\">-5</span> + <span class=\"number\">12i</span>)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p><code>int</code>, <code>uint</code> 和 <code>uintptr</code> 在 32 位系统上通常为 32 位宽，在 64 位系统上则为 64 位宽。 当你需要一个整数值时应使用 <code>int</code> 类型，除非你有特殊的理由使用固定大小或无符号的整数类型。</p>\n<p>没有明确初始值的变量声明会被赋予它们的 <strong>零值</strong>。</p>\n<p>零值是：</p>\n<ul>\n<li>数值类型为 <code>0</code>，</li>\n<li>布尔类型为 <code>false</code>，</li>\n<li>字符串为 <code>&quot;&quot;</code>（空字符串）。</li>\n</ul>\n<p>表达式 <code>T(v)</code> 将值 <code>v</code> 转换为类型 <code>T</code>。</p>\n<p>一些关于数值的转换：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var i int = 42</span><br><span class=\"line\">var f float64 = float64(i)</span><br><span class=\"line\">var u uint = uint(f)</span><br></pre></td></tr></table></figure>\n\n<p>或者，更加简单的形式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i := 42</span><br><span class=\"line\">f := float64(i)</span><br><span class=\"line\">u := uint(f)</span><br></pre></td></tr></table></figure>\n\n<p>与 C 不同的是，Go 在不同类型的项之间赋值时需要显式转换,，等号右边的数值必须是类型明确的</p>\n<h2 id=\"常量\"><a href=\"#常量\" class=\"headerlink\" title=\"常量\"></a>常量</h2><p>常量的声明与变量类似，只不过是使用 <code>const</code> 关键字。</p>\n<p>常量可以是字符、字符串、布尔值或数值。</p>\n<p>常量不能用 <code>:=</code> 语法声明。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> World = <span class=\"string\">&quot;世界&quot;</span></span><br><span class=\"line\"><span class=\"comment\">//相较之下，这个申明的world是一个变量，也就是可以改变其类型的</span></span><br><span class=\"line\">world := <span class=\"string\">&quot;世界&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> World = <span class=\"string\">&quot;世界&quot;</span></span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;Hello&quot;</span>, World)</span><br><span class=\"line\"></span><br><span class=\"line\">\tworld := <span class=\"string\">&quot;世界&quot;</span></span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;Go rules?&quot;</span>, world)</span><br><span class=\"line\">\tworld = <span class=\"string\">&quot;是吗&quot;</span></span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;Go rules?&quot;</span>, world)</span><br><span class=\"line\">\t结果是：</span><br><span class=\"line\">\tHello 世界</span><br><span class=\"line\">\tGo rules? 世界</span><br><span class=\"line\">\tGo rules? 是吗</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"类型推导\"><a href=\"#类型推导\" class=\"headerlink\" title=\"类型推导\"></a>类型推导</h2><p>在声明一个变量而不指定其类型时（即使用不带类型的 <code>:=</code> 语法或 <code>var =</code> 表达式语法），变量的类型由右值推导得出。</p>\n<p>当右值声明了类型时，新变量的类型与其相同：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var i int</span><br><span class=\"line\">j := i // j 也是一个 int</span><br></pre></td></tr></table></figure>\n\n<p>不过当右边包含未指明类型的数值常量时，新变量的类型就可能是 <code>int</code>, <code>float64</code> 或 <code>complex128</code> 了，这取决于常量的精度：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i := 42           // int</span><br><span class=\"line\">f := 3.142        // float64</span><br><span class=\"line\">g := 0.867 + 0.5i // complex128</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"数值常量\"><a href=\"#数值常量\" class=\"headerlink\" title=\"数值常量\"></a>数值常量</h2><p>数值常量是高精度的 <strong>值</strong>。</p>\n<p>一个未指定类型的常量由上下文来决定其类型。</p>\n<p>再尝试一下输出 <code>needInt(Big)</code> 吧。</p>\n<p>（<code>int</code> 类型最大可以存储一个 64 位的整数，有时会更小。）</p>\n<p>（<code>int</code> 可以存放最大64位的整数，根据平台不同有时会更少。）</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">\t<span class=\"comment\">// 将 1 左移 100 位来创建一个非常大的数字</span></span><br><span class=\"line\">\t<span class=\"comment\">// 即这个数的二进制是 1 后面跟着 100 个 0</span></span><br><span class=\"line\">\tBig = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">100</span></span><br><span class=\"line\">\t<span class=\"comment\">// 再往右移 99 位，即 Small = 1 &lt;&lt; 1，或者说 Small = 2</span></span><br><span class=\"line\">\tSmall = Big &gt;&gt; <span class=\"number\">99</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"3-语句\"><a href=\"#3-语句\" class=\"headerlink\" title=\"3. 语句\"></a>3. 语句</h1><h2 id=\"if\"><a href=\"#if\" class=\"headerlink\" title=\"if\"></a>if</h2><p>Go 的 <code>if</code> 语句与 <code>for</code> 循环类似，表达式外无需小括号 <code>( )</code> ，而大括号 <code>&#123; &#125;</code> 则是必须的。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> x &lt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> sqrt(-x) + <span class=\"string\">&quot;i&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"for\"><a href=\"#for\" class=\"headerlink\" title=\"for\"></a>for</h2><p>Go 只有一种循环结构：<code>for</code> 循环。</p>\n<p>基本的 <code>for</code> 循环由三部分组成，它们用分号隔开：</p>\n<ul>\n<li>初始化语句：在第一次迭代前执行</li>\n<li>条件表达式：在每次迭代前求值</li>\n<li>后置语句：在每次迭代的结尾执行</li>\n</ul>\n<p>初始化语句通常为一句短变量声明，该变量声明仅在 <code>for</code> 语句的作用域中可见。</p>\n<p>一旦条件表达式的布尔值为 <code>false</code>，循环迭代就会终止。</p>\n<p>初始化语句和后置语句是可选的，也就是说完全可以只有一个条件，其含义也变成了wihle语句，但是go里面没有while只有for</p>\n<p><strong>注意</strong>：和 C、Java、JavaScript 之类的语言不同，<strong>Go 的 for 语句后面的三个构成部分外没有小括号</strong>， 而包围函数主体的大括号 <code>&#123; &#125;</code> 则是必须的。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tsum := <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++ &#123;</span><br><span class=\"line\">\t\tsum += i</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfmt.Println(sum)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tsum := <span class=\"number\">1</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> sum &lt; <span class=\"number\">1000</span>&#123;</span><br><span class=\"line\">\t\tsum += sum</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfmt.Println(sum)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"if-的简短语句\"><a href=\"#if-的简短语句\" class=\"headerlink\" title=\"if 的简短语句\"></a>if 的简短语句</h2><p>同 <code>for</code> 一样， <code>if</code> 语句可以在条件表达式前执行一个简单的语句。</p>\n<p><strong>该语句声明的变量作用域仅在 ​</strong>**<code>if</code>**<strong>​ 之内。</strong>也就是说出了if语句，这个变量就没有了</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">pow</span><span class=\"params\">(x, n, lim <span class=\"type\">float64</span>)</span></span> <span class=\"type\">float64</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> v := math.Pow(x, n); v &lt; lim &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> v</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> lim</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"if-和-else\"><a href=\"#if-和-else\" class=\"headerlink\" title=\"if 和 else\"></a>if 和 else</h2><p>在 <code>if</code> 的简短语句中声明的变量同样可以在任何对应的 <code>else</code> 块中使用。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> v := math.Pow(x, n); v &lt; lim &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> v</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tfmt.Printf(<span class=\"string\">&quot;%g &gt;= %g\\n&quot;</span>, v, lim)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//一般格式是：</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> &#123;</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> &#123;</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span> &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"switch\"><a href=\"#switch\" class=\"headerlink\" title=\"switch\"></a>switch</h2><p><code>switch</code> 是编写一连串 <code>if - else</code> 语句的简便方法。它运行第一个值等于条件表达式的 case 语句。</p>\n<p>Go 的 switch 语句类似于 C、C++、Java、JavaScript 和 PHP 中的，不过 Go 只运行选定的 case，而非之后所有的 case。 实际上，Go 自动提供了在这些语言中每个 case 后面所需的 <code>break</code> 语句。 除非以 <code>fallthrough</code> 语句结束，否则分支会自动终止。 Go 的另一点重要的不同在于 switch 的 case 无需为常量，且取值不必为整数。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">switch</span> os := runtime.GOOS; os &#123;</span><br><span class=\"line\"><span class=\"keyword\">case</span> <span class=\"string\">&quot;darwin&quot;</span>:</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;OS X.&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">case</span> <span class=\"string\">&quot;linux&quot;</span>:</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;Linux.&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t<span class=\"comment\">// freebsd, openbsd,</span></span><br><span class=\"line\">\t<span class=\"comment\">// plan9, windows...</span></span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;%s.\\n&quot;</span>, os)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"switch-的求值顺序\"><a href=\"#switch-的求值顺序\" class=\"headerlink\" title=\"switch 的求值顺序\"></a>switch 的求值顺序</h2><p>switch 的 case 语句从上到下顺次执行，直到匹配成功时停止。</p>\n<p>（例如，</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">switch i &#123;</span><br><span class=\"line\">case 0:</span><br><span class=\"line\">case f():</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在 <code>i==0</code> 时 <code>f</code> 不会被调用。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">today := time.Now().Weekday()</span><br><span class=\"line\"><span class=\"keyword\">switch</span> time.Saturday &#123;</span><br><span class=\"line\"><span class=\"keyword\">case</span> today + <span class=\"number\">0</span>:</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;Today.&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">case</span> today + <span class=\"number\">1</span>:</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;Tomorrow.&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">case</span> today + <span class=\"number\">2</span>:</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;In two days.&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">default</span>:</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;Too far away.&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"没有条件的-switch\"><a href=\"#没有条件的-switch\" class=\"headerlink\" title=\"没有条件的 switch\"></a>没有条件的 switch</h2><p>没有条件的 switch 同 <code>switch true</code> 一样。</p>\n<p>这种形式能将一长串 if-then-else 写得更加清晰。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">t := time.Now()</span><br><span class=\"line\">\t<span class=\"keyword\">switch</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> t.Hour() &lt; <span class=\"number\">12</span>:</span><br><span class=\"line\">\t\tfmt.Println(<span class=\"string\">&quot;Good morning!&quot;</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> t.Hour() &lt; <span class=\"number\">17</span>:</span><br><span class=\"line\">\t\tfmt.Println(<span class=\"string\">&quot;Good afternoon.&quot;</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">default</span>:</span><br><span class=\"line\">\t\tfmt.Println(<span class=\"string\">&quot;Good evening.&quot;</span>)</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"defer\"><a href=\"#defer\" class=\"headerlink\" title=\"defer\"></a>defer</h2><p>defer 语句会将函数推迟到外层函数返回之后执行。</p>\n<p>推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> fmt.Println(<span class=\"string\">&quot;world&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;hello&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">结果是：</span><br><span class=\"line\">hello</span><br><span class=\"line\">world</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"defer-栈\"><a href=\"#defer-栈\" class=\"headerlink\" title=\"defer 栈\"></a>defer 栈</h2><p>推迟的函数调用会被压入一个栈中。当外层函数返回时，被推迟的函数会按照后进先出的顺序调用。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;counting&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++ &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">defer</span> fmt.Println(i)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;done&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">由于是按照栈的形式来存的</span><br><span class=\"line\">counting</span><br><span class=\"line\">done</span><br><span class=\"line\"><span class=\"number\">9</span></span><br><span class=\"line\"><span class=\"number\">8</span></span><br><span class=\"line\"><span class=\"number\">7</span></span><br><span class=\"line\"><span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://blog.go-zh.org/defer-panic-and-recover\">Defer，Panic,Recover</a></p>\n<h2 id=\"函数返回\"><a href=\"#函数返回\" class=\"headerlink\" title=\"函数返回\"></a>函数返回</h2><p>函数可以返回任意数量的返回值, 但是结构上需要结合函数形式</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">swap</span><span class=\"params\">(x, y <span class=\"type\">string</span>)</span></span> (<span class=\"type\">string</span>, <span class=\"type\">string</span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> y, x</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>Go 的返回值可被命名，它们会被视作定义在函数顶部的变量。</p>\n<p>返回值的名称应当具有一定的意义，它可以作为文档使用。</p>\n"},{"title":"Go-Routine","catalog":true,"date":"2023-04-11T18:36:14.000Z","subtitle":null,"header-img":null,"published":0,"_content":"","source":"_posts/Go/Go-enhanced-knowledge/Go-Goroutine.md","raw":"---\ntitle: Go-Routine\ncatalog: true\ndate: 2023-04-12 02:36:14\nsubtitle:\nheader-img:\ntags:\ncategories:\npublished: false\n---","slug":"Go/Go-enhanced-knowledge/Go-Goroutine","updated":"2023-04-22T13:24:02.216Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgtm6jql0013lyjxagk2arz9","content":"","site":{"data":{}},"cover":"/img/cover/2077_city.png","cover_type":"img","excerpt":"","more":""},{"title":"Go-enhanced-knowledge","catalog":true,"date":"2023-04-11T18:36:14.000Z","subtitle":null,"header-img":null,"published":0,"_content":"","source":"_posts/Go/Go-enhanced-knowledge/Go-enhanced-knowledge.md","raw":"---\ntitle: Go-enhanced-knowledge\ncatalog: true\ndate: 2023-04-12 02:36:14\nsubtitle:\nheader-img:\ntags:\ncategories:\npublished: false\n---\n","slug":"Go/Go-enhanced-knowledge/Go-enhanced-knowledge","updated":"2023-04-22T13:24:02.204Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgtm6jqm0017lyjxfj1i9dpl","content":"","site":{"data":{}},"cover":"/img/cover/2077_city.png","cover_type":"img","excerpt":"","more":""},{"title":"Go 系统知识汇总","catalog":true,"date":"2023-04-01T12:57:34.000Z","subtitle":null,"header-img":null,"_content":"\n# Golang 系统知识回答收集\n\n## Golang 语法方面\n                                                    \n### Golang关键字有哪些\n\n### Golang 当中\n关键字是指被编程语言用作特定目的的保留单词，这些关键字在代码当中具有特殊的含义，不能被用作标识符（例如变量名，函数名，类型名等）。以下是Golang中关键字的列表\n\n```go\nfunc \ntype \n\ninterface \nstruct \nvar\n\nbreak continue \n\ndefault\n\ncase \nselect\ndefer\nswitch\nfor \nrange \ngoto\nelse\nif\n\nconst\nchan \nmap\n\nimport\npackage\n\ngo\nreturn \n\nfallthrough\n\n```\n\n### range 函数的具体使用\n\ngolang当中range 关键字可以用于迭代数组、切片、字符串、map和通道等数据类型\n\n```go\n//迭代数组和切片时候，返回当前元素的索引和值\narr := [3]int{1,2,3}\nfor key,num := range arr{\n\tfmt.Printf(\"now arr[%d] is %d\\n\", key,num)\n}\n\n// map 迭代字符串的时候，每次迭代返回当前字符的索引和Unicode码点\n\ns := \"hello world\"\nfor i, c := range s{\n\tfmt.Printf(\"index:%d, Unicode code ponit : %U\\n\",i,c)\n}\n\n//迭代map结构\nm := map[int]string{\n\t1: \"one\",\n\t2: \"two\",\n\t3: \"three\",\n}\nfor k,v := range m{\n\tfmt.Printf(\"key : %d, value : %s\",k,v)\n\n}\n\n//迭代通道使用range 迭代通道的时候，会不断地从通道当中接受元素，直到通道关闭为止\n\nch := make(chan int)\ngo func() {\n\tfor i := 0;i<5,i++{\n\tch <- i\n\t}\n\tclose(ch)\n}()\n\nfor v := range ch {\n\tfmt.Println(v)\n}\n```\n\n在迭代通道的时候，如果通道没有关闭，那么循环就会一直等待下去，知道程序死锁，因此必须要再写入完所有的数据之后关闭通道，或者使用'select'语句在接受通道数据的时候检查通道是否已经关闭\n\n\n### Slice 扩容机制\n\nGo 1.18 版本之后，当新切片需要的容量cap大于两倍扩容的容量时候，则直接按照新切片需要的容量进行扩容：\n\n* 当原 Slice 容量 < threshold 的时候，新 slice 容量变成原来的2 倍\n* 当原 Slice 容量 > threshold 的时候，进入一个循环，每次容量增加 （旧容量 + 3*threshold）/4\n\n\n### Slice 为什么不是线程安全的\n\n因为 Slice 内部使用了底层数组，数组在内存当中是连续存储的并没有加锁的机制，本身并不支持并发的读写\n\n当多个Goroutine并发访问同一个Slice的时候，可能存在某个Goroutine修改了Slice中的某个元素，其他Goroutine无法立即看到这个修改，也可能会造成竞争问题。可以通过使用((20230318150223-agvrll2 \"互斥锁\"))或者((20230318154221-miv3alf \"原子操作\"))来保证某个Goroutine访问的时候其他goroutine不能够同时访问，另外也可以使用通道来进行同步，通过将Slice的访问权限交给某个Goroutine，从而保障其他的Goroutine无法同时访问该Slice。\n\n\n\n### map的底层原理\n\nmap对象本身是一个指针，占用8个字节（64位计算机），指向`hmap`结构体，hmap包含多个bmap数组（桶）\n\n```go\ntype hmap struct{\n\tcount int // 元素个数，调用len(map)的时候直接返回\n\tflags uint8 // 标志当前map的状态，正在删除元素、添加元素、、、、\n\tB uint8 //单元(buckets)的对数 B=5表示能容纳32个元素  B随着map容量增大而变大\n\n\tnoverflow uint16  //单元(buckets)溢出数量，如果一个单元能存8个key，此时存储了9个，溢出了，就需要再增加一个单元\n\thash0 uint32 //哈希种子\n\tbuckets unsafe.Pointer //指向单元(buckets)数组,大小为2^B，可以为nil\n\toldbuckets unsafe.Pointer //扩容的时候，buckets长度会是oldbuckets的两倍\n\tnevacute uintptr  //指示扩容进度，小于此buckets迁移完成 \n\textra *mapextra //与gc相关 可选字段 \n}\n\ntype bmap struct{\n\ttophash [bucketCnt]uint8 \n}\n//实际上编译期间会生成一个新的数据结构  \ntype bmap struct { \n    topbits [8]uint8     //key hash值前8位 用于快速定位keys的位置\n    keys [8]keytype     //键\n    values [8]valuetype //值\n    pad uintptr \n    overflow uintptr     //指向溢出桶 无符号整形 优化GC\n}\n\n```\n\n\n### map的扩容机制\n\n扩容时机：向map里面插入新的key的时候，会进行条件检测，符合以下两个条件就会触发扩容操作：\n\n扩容条件：\n\n1. 超过负载 map元素个数 > 负载因子 * 桶个数\n2. 溢出桶太多\n\n负载因子是元素个数与桶的数量的比值\n\n当桶总数<2^15^时，如果溢出桶总数>=桶总数，则认为溢出桶过多\n\n当桶总数>2^15^时，如果溢出桶总数>=2^15^，则认为溢出桶过多\n\n\n扩容机制：\n\n* 双倍扩容：针对条件1，新建一个buckets数组，新的buckets大小是原来的2倍，然后旧buckets数据搬迁到新的buckets。\n* 等量扩容：针对条件2，并不扩大容量，buckets数量维持不变，重新做一遍类似双倍扩容的搬迁动作，把松散的键值对重新排列一次，使得同一个 bucket 中的 key 排列地更紧密，节省空间，提高 bucket 利用率，进而保证更快的存取。\n\n* 渐进式扩容： 插入修改删除key的时候，都会尝试进行搬迁桶的工作，每次都会检查oldbucket是否**nil**，如果不是**nil**则每次搬迁**2**个桶，蚂蚁搬家一样渐进式扩容\n\n\n### map的遍历为什么无序\n\nmap  每次遍历，都会从一个随机值序号的桶开始，再从其中随机的cell 开始遍历，并且扩容后，原来桶中的key会落到其他的桶中，本身就会造成失序。\n\n如果想要遍历map，先把key放到切片中排序，再按照key的顺序遍历map\n\n```go\n//请写一段代码验证\nm := map[int]string {\n\t1: \"one\",\n\t2: \"two\",\n\t3: \"three\",\n}\n\nfor key,value := range m{\n\tfmt.Printf(\"data is : %d ---> %S \\n\", key,value)\n}\n\n```\n\n\n### map的底层存储不是连续的\n\n具体来说map 内部存储的是一个桶（bucket）数组，桶数组中的每个元素有事一个指向链表头的指针，他存储的数据并不连续\n\n\n### map 为什么不是线程安全的\n\n多个协程同时对**map**进行并发读写**,**程序会**panic**\n\n想要线程安全，可以使用sync.RWLock锁\n\n在sync.map 这个包当中实现了锁，是线程安全的\n\n\n### Map如何查找\n\n1. 计算hash值\n    key经过哈希函数计算后,得到64bit(64位CPU)\n    10010111 | 101011101010110101010101101010101010 | 10010\n2. 找到hash对应的桶\n    上面64位后5(hmap的B值)位定位所存放的桶\n    如果当前正在扩容中,并且定位到旧桶数据还未完成迁移,则使用旧的桶\n3. 遍历桶查找\n    上面64位前8位用来在tophash数组查找快速判断key是否在当前的桶中,如果不在需要去溢出桶查找\n4. 返回key对应的指针\n\n\n\n### map 冲突解决的方式\n\nGo采用链式地址解决冲突，具体实现就是插入key到map中时，当key定位的桶填满8个元素，将会创建一个溢出桶并且将溢出桶插入到当前桶所在的链表尾部\n\nGolang当中采用链式哈希表（Cahined Hash Table）\n\n在Golang的哈希表实现当中，每一个桶就是一个链表的头指针，桶内每个元素都是哈希链表节点，节点包含了该元素的哈希值、键以及指向下一个节点的指针。\n\n在查找时候，先根据键的哈希值找到对应的桶，然后在该桶对应的链表中顺序查找，指导找到目标元素或者是链表遍历完毕。\n\n\n### map 的负载因子为什么时6.5\n\n> 负载因子 = 哈希表存储的元素个数 / 桶个数\n\nGo 官方发现：装载因子越大，填入的元素越多，空间利用率就越高，但发生哈希冲突的几率就变大。\n装载因子越小，填入的元素越少，冲突发生的几率减小，但空间浪费也会变得更多，而且还会提高扩容操作的次数\n\nGo 官方取了一个相对适中的值，把 Go 中的 map 的负载因子硬编码为 6.5，这就是 6.5 的选择缘由。\n\n这意味着在 Go 语言中，当 map存储的元素个数大于或等于 6.5 * 桶个数 时，就会触发扩容行为。\n\n\n### Map和 Sync.Map哪一个性能好\n\n对比原始map：\n\n和原始map+RWLock的实现并发的方式相比，减少了加锁对性能的影响。\n\n它做了一些优化：可以无锁访问read map，而且会优先操作read map，倘若只操作read map就可以满足要求，那就不用去操作write map(dirty)，所以在某些特定场景中它发生锁竞争的频率会远远小于map+RWLock的实现方式\n\n* 优点：\n  适合读多写少的场景\n* 缺点：\n  写多的场景，会导致 read map 缓存失效，需要加锁，冲突变多，性能急剧下降\n\n\n\n### channel 底层实现原理\n\n通过**var****声明或者是**​**make****函数创建的channel变量**是一个存储在函数栈帧上的指针，占用8个字节，指向堆上的hchan结构体\n\n```go\ntype hchan struct{\n\tclosed uint32 // channel 是否关闭的标志\n\telemtype *_type // channel 中的元素类型\n\n\tbuf unsafe.Pointer //指向底层循环数组的指针（环形缓存区）\n\tqcount uint // 循环数组中的元素数量\n\tdataqsiz uint //循环数组的长度\n\telemsize uint16 //元素的大小\n\tsendx uint // 下一次写下标的位置\n\trecvx uint // 下一次读下标的位置\n\t// 尝试读取channel 或者向channel 写入数据而被阻塞的goroutine\n    \trecvq    waitq  // 读等待队列\n    \tsendq    waitq  // 写等待队列\n    \tlock mutex //互斥锁，保证读写channel时不存在并发竞争问题\n}\n```\n\nchannel 分为无缓冲和有缓冲两种\n\n* 对于有缓冲的channel存储数据，使用了ring buffer(环形缓冲区) 来缓存写入的数据，本质是循环数组。\n\n  为啥是循环数组呢？普通数组不行吗，普通数组容量固定，更适合指定的空间，弹出元素的时候，普通数组需要全部前移。\n\n  `当下标超过数组容量后会回到第一个位置，所以需要有两个字段记录当前读和写的下标位置`\n\n* 对于无缓冲的channel 存储数据\n\n等待队列： \n\n双向链表，包含一个头结点和一个尾结点 每个节点是一个sudog结构体变量，记录哪个协程在等待，等待的是哪个channel，等待发送**/**接收的数据在哪里\n\n```go\ntype wait struct{\n\tfirst *sudog\n\tlast *sudog\n}\n\ntype sudog struct{\n\tg *g\n\tnext *sudog\n\tpre  *sudog\n\telem unsafe.Pointer\n\tc  *hchan\n\t...\n}\n```\n\n\n创建 channel 的时候：\n\n创建时会做一些检查**:** \n\n* 元素大小不能超过 **64**K\n* 元素的对齐大小不能超过 maxAlign 也就是 **8** 字节\n* 计算出来的内存是否超过限制\n\n创建时的策略:\n\n* 如果是无缓冲的channel，会直接给hchan 分配内存\n* 如果是有缓冲的channel，并且元素不包含指针，那么会为 hchan  和底层数组分配一段连续的地址\n\n* 如果是有缓冲的channel，元素包含指针，那么就会为了hchan 和底层数组分别分配地址\n\n发送时：\n\n* 如果 channel 的读队列存在着接收者 goroutine，将唤醒接收的goroutine，将数据**直接发送**给第一个等待的 goroutine\n\n* 如果channel 的读等待队列不存在接收者 goroutine\n\n  * 如果循环数组buffer未满，那么将会把数据发送到循环数组buffer的队尾\n  * 如果循环数组buffer已满，这个时候就会阻塞发送的流程，将当前goroutine加入写等待队列，**并挂起等待唤醒**\n\n接收时：\n\n* 如果 channel 的写等待队列存在发送者 goroutine\n\n  * 如果是无缓冲 channel ，**直接**从第一个发送者goroutine 那里 把数据拷贝给接受变量，**唤醒 发送的goroutine**\n  * 如果是有缓冲的 channel（已满），将循环数组的buffer的队首元素拷贝给接受变量，将第一个发送者goroutine的数据拷贝到buffer循环数组的队尾，**唤醒发送的goroutine**\n* 如果channel 的写等待队列不存在发送者goroutine\n\n  * 如果循环数组buffer非空，将循环数组buffer的队首元素拷贝给接受变量\n  * 如果循环数组buffer为空，这个时候就会阻塞接收的流程，将当前goroutine 加入读等待队列，并**挂起等待唤醒**\n\n\n### channel 有什么特点\n\nchannel是线程安全的\n\nchannel 有两种类型： 无缓冲、有缓冲\n\nchannel 有三种模式： 写操作模式（单向通道）、读操作模式（单向通道）、读写操作模式（双向通道）\n\n```go\n写操作模式    make(chan<- int)\n读操作模式    make(<-chan int)\n读写操作模式    make(chan int)\n```\n\nchannel 有 3 种状态：未初始化、正常、关闭\n\n| 操作 \\ 状态 | 未初始化         | 关闭                               | 正常             |\n| ------------- | ------------------ | ------------------------------------ | ------------------ |\n| 关闭        | panic            | panic                              | 正常             |\n| 发送        | 永远阻塞导致死锁 | panic                              | 阻塞或者成功发送 |\n| 接收        | 永远阻塞导致死锁 | 缓冲区为空则为零值，否则可以继续读 | 阻塞或者成功接收 |\n\n注意点：\n\n* 一个 channel不能多次关闭，会导致painc\n\n* 如果多个 goroutine 都监听同一个 channel，那么 channel 上的数据都可能随机被某一个 goroutine 取走进行消费\n* 如果多个 goroutine 监听同一个 channel，如果这个 channel 被关闭，则所有 goroutine 都能收到退出信号\n\n### Channel 的使用场景\n\n无缓冲 Channel 在并发编程中的具体业务使用场景很多，主要应用于 Go 语言中。以下是一些常见的无缓冲 Channel 的具体业务使用场景及例子：\n\n1. 并发控制：在并发程序中，通过无缓冲 Channel 可以实现多个 Goroutine 之间的**同步和控制**。例如，一个任务需要多个协程协作完成时，可以使用无缓冲 Channel 来传递任务数据和控制信号。\n2. 事件驱动：在事件驱动的编程中，可以使用无缓冲 Channel 来传递事件和执行结果。例如，当一个 HTTP 请求到达时，可以将请求交给一个协程处理，并使用无缓冲 Channel 返回处理结果。\n3. 分布式计算：在分布式计算中，可以使用无缓冲 Channel 来实现节点之间的通信和数据传递。例如，在 MapReduce 算法中，可以使用无缓冲 Channel 来传递 Map 阶段的输出结果并驱动 Reduce 阶段的计算。\n\n有缓冲 Channel 在并发编程中的具体业务使用场景也很多，主要应用于 Go 语言中。以下是一些常见的有缓冲 Channel 的具体业务使用场景及例子：\n\n1. 网络编程：在 TCP 或 UDP 数据处理中，可以使用有缓冲 Channel 缓存数据，**以避免因数据接收太慢而导致发送者被阻塞**。例如，在高并发的 Web 服务器中，可以使用有缓冲 Channel 缓存请求数据以提高吞吐量。\n2. IO 操作：在使用 IO 操作时，如文件读写、数据库访问等，可以使用有缓冲 Channel 缓存数据，以避免因数据处理速度不匹配而导致发送者或接收者被阻塞。例如，**在从数据库获取大量数据时，可以使用有缓冲 Channel 缓存数据，减少数据库连接次数。**\n3. 并发控制：在并发程序中，通过有缓冲 Channel 可以实现多个 Goroutine 之间的同步和控制。例如，一个任务需要多个协程协作完成时，可以使用有缓冲 Channel 来传递任务数据和控制信号，并根据缓冲区的剩余空间来控制协程的执行顺序。\n4. 事件驱动：在事件驱动的编程中，可以使用有缓冲 Channel 来缓存事件和执行结果，并根据缓冲区的剩余空间来控制事件的处理顺序。例如，当一个 HTTP 请求到达时，可以将请求交给一个协程处理，并使用有缓冲 Channel 缓存处理结果，避免处理速度过慢导致请求被阻塞。\n\n\n### channel 为什么是线程安全的\n\n不同协程通过channel进行通信，本身的使用场景就是多线程，为了保证数据的一致性，必须实现线程安全\n\n\nchannel的底层实现中，hchan结构体中采用Mutex锁来保证数据读写安全。在对循环数组buf中的数据进行入队和出队操作时，必须先获取互斥锁，才能操作channel数据\n\n\n### Channel 发送和接收什么情况下会死锁\n\n```go\nfunc deadlock1() {    //无缓冲channel只写不读\n    ch := make(chan int) \n    ch <- 3 //  这里会发生一直阻塞的情况，执行不到下面一句\n}\nfunc deadlock2() { //无缓冲channel读在写后面\n    ch := make(chan int)\n    ch <- 3  //  这里会发生一直阻塞的情况，执行不到下面一句\n    num := <-ch\n    fmt.Println(\"num=\", num)\n}\nfunc deadlock3() { //无缓冲channel读在写后面\n    ch := make(chan int)\n    ch <- 100 //  这里会发生一直阻塞的情况，执行不到下面一句\n    go func() {\n        num := <-ch\n        fmt.Println(\"num=\", num)\n    }()\n    time.Sleep(time.Second)\n}\nfunc deadlock3() {    //有缓冲channel写入超过缓冲区数量\n    ch := make(chan int, 3)\n    ch <- 3\n    ch <- 4\n    ch <- 5\n    ch <- 6  //  这里会发生一直阻塞的情况\n}\nfunc deadlock4() {    //空读\n    ch := make(chan int)\n    // ch := make(chan int, 1)\n    fmt.Println(<-ch)  //  这里会发生一直阻塞的情况\n}\nfunc deadlock5() {    //互相等对方造成死锁\n    ch1 := make(chan int)\n    ch2 := make(chan int)\n    go func() {\n        for {\n        select {\n        case num := <-ch1:\n            fmt.Println(\"num=\", num)\n            ch2 <- 100\n        }\n    }\n    }()\n    for {\n        select {\n        case num := <-ch2:\n            fmt.Println(\"num=\", num)\n            ch1 <- 300\n        }\n    }\n}\n```\n\n### 互斥锁实现原理\n\nGo sync包提供了两种锁类型：互斥锁sync.Mutex 和 读写互斥锁sync.RWMutex，都属于((20230402113517-ppcs0gj \"悲观锁\"))。\n[https://blog.csdn.net/baolingye/article/details/111357407](https://blog.csdn.net/baolingye/article/details/111357407)\n\n在正常模式下，**锁的等待者会按照先进先出的顺序获取锁**。但是刚被唤起的 Goroutine 与新创建的 Goroutine 竞争时，大概率会获取不到锁，在这种情况下，这个被唤醒的 Goroutine 会加入到等待队列的前面。 如果一个等待的 Goroutine 超过1ms 没有获取锁，那么它将会把锁转变为**饥饿模式**。\nGo在1.9中引入优化，目的保证互斥锁的公平性。在饥饿模式中，互斥锁会直接交给等待队列最前面的 Goroutine。新的 Goroutine 在该状态下不能获取锁、也不会进入自旋状态，它们只会在队列的末尾等待。如果一个 Goroutine 获得了互斥锁并且它在队列的末尾或者它等待的时间少于 1ms，那么当前的互斥锁就会切换回正常模式。\n\n\n### 悲观锁与乐观锁\n\n**悲观锁**是基于一种悲观的态度类来防止一切数据冲突，它是以一种预防的姿态在**修改数据之前把数据锁住，然后再对数据进行读写，在它释放锁之前任何人都不能对其数据进行操作，直到前面一个人把锁释放后下一个人数据加锁才可对数据进行加锁，**然后才可以对数据进行操作，一般数据库本身锁的机制都是基于悲观锁的机制实现的;\n\n特点：可以完全保证数据的独占性和正确性，因为每次请求都会先对数据进行加锁， 然后进行数据操作，最后再解锁，而加锁释放锁的过程会造成消耗，所以性能不高;\n\n\n**乐观锁**是对于数据冲突保持一种乐观态度，操作数据时不会对操作的数据进行加锁（这使得多个任务可以并行的对数据进行操作），只有到数据提交的时候才通过一种机制来验证数据是否存在冲突(一般实现方式是通过加版本号然后进行版本号的对比方式实现);\n\n特点：乐观锁是一种并发类型的锁，其本身不对数据进行加锁通而是通过业务实现锁的功能，不对数据进行加锁就意味着允许多个请求同时访问数据，同时也省掉了对数据加锁和解锁的过程，这种方式因为节省了悲观锁加锁的操作，所以可以一定程度的的提高操作的性能，不过在并发非常高的情况下，会导致大量的请求冲突，冲突导致大部分操作无功而返而浪费资源，所以在高并发的场景下，乐观锁的性能却反而不如悲观锁。\n\n\n\n### 原子操作和锁的区别\n\n在并发编程里，Go语言`sync`包里的同步原语`Mutex`是我们经常用来保证并发安全的，那么他跟`atomic`包里的这些操作有啥区别呢？在我看来他们在使用目的和底层实现上都不一样：\n\n* 使用目的：互斥锁是用来保护一段逻辑，原子操作用于对一个变量的更新保护。\n* 底层实现：`Mutex`由**操作系统**的调度器实现，而`atomic`包中的原子操作则由**底层硬件指令**直接提供支持，这些指令在执行的过程中是不允许中断的，因此原子操作可以在`lock-free`的情况下保证并发安全，并且它的性能也能做到随`CPU`个数的增多而线性扩展。\n\n\n\n\n### 互斥锁允许自旋的条件\n\n线程没有获取到锁时常见有2种处理方式：\n\n* 一种是没有获取到锁的线程就会循环等待判断该资源是否已经释放锁，这种锁也叫做自旋锁，它不用将线程阻塞起来， 适用于并发低且程序执行时间短的场景，缺点是cpu占用较高\n* 另外一种处理方式就是把自己阻塞起来，会释放CPU给其他线程，内核会将线程置为「睡眠」状态，等到锁被释放后，内核会在合适的时机唤醒该线程，适用于高并发场景，缺点是有线程上下文切换的开销\n  Go语言中的Mutex实现了自旋与阻塞两种场景，当满足不了自旋条件时，就会进入阻塞\n  **允许自旋的条件：**\n\n1. 锁已被占用，并且锁不处于饥饿模式。\n2. 积累的自旋次数小于最大自旋次数（active_spin=4）。\n3. cpu 核数大于 1。\n4. 有空闲的 P。\n5. 当前 goroutine 所挂载的 P 下，本地待运行队列为空。\n\n\n### 读写锁的实现原理\n\n读写锁的底层是基于互斥锁实现的。\n写锁需要阻塞写锁：一个协程拥有写锁时，其他协程写锁定需要阻塞；\n写锁需要阻塞读锁：一个协程拥有写锁时，其他协程读锁定需要阻塞；\n读锁需要阻塞写锁：一个协程拥有读锁时，其他协程写锁定需要阻塞；\n**读锁不能阻塞读锁：一个协程拥有读锁时，其他协程也可以拥有读锁。**\n\n\n### \"原子操作\"有哪些\n\nGo atomic包是最轻量级的锁（也称无锁结构），可以在不形成临界区和创建互斥量的情况下完成并发安全的值替换操作，不过这个包只支持int32/int64/uint32/uint64/uintptr这几种数据类型的一些基础操作（增减、交换、载入、存储等）\n当我们想要对**某个变量**并发安全的修改，除了使用官方提供的 `mutex`，还可以使用 sync/atomic 包的原子操作，它能够保证对变量的读取或修改期间不被其他的协程所影响。\natomic 包提供的原子操作能够确保任一时刻只有一个goroutine对变量进行操作，善用 atomic 能够避免程序中出现大量的锁操作。\n**常见操作：**\n\n* 增减Add     AddInt32 AddInt64 AddUint32 AddUint64 AddUintptr\n* 载入Load    LoadInt32 LoadInt64    LoadPointer    LoadUint32    LoadUint64    LoadUintptr\n* 比较并交换   CompareAndSwap    CompareAndSwapInt32...\n* 交换Swap    SwapInt32...\n* 存储Store    StoreInt32...\n\n\n### Goroutine 的底层实现原理\n\n```go\ng本质是一个数据结构,真正让 goroutine 运行起来的是调度器\ntype g struct { \n    goid int64  // 唯一的goroutine的ID \n    sched gobuf // goroutine切换时，用于保存g的上下文 \n    stack stack // 栈 \n    gopc // pc of go statement that created this goroutine \n    startpc uintptr  // pc of goroutine function ... \n} \ntype gobuf struct {     //运行时寄存器\n    sp uintptr  // 栈指针位置 \n    pc uintptr  // 运行到的程序位置 \n    g  guintptr // 指向 goroutine \n    ret uintptr // 保存系统调用的返回值 ... \n} \ntype stack struct {     //运行时栈\n    lo uintptr  // 栈的下界内存地址 \n    hi uintptr  // 栈的上界内存地址 \n}\n```\n\n### \n\n### goroutine 和线程的区别\n\n内存占用:\n创建一个 goroutine 的栈内存消耗为 2 KB，实际运行过程中，如果栈空间不够用，会自动进行扩容。创建一个 thread 则需要消耗 1 MB 栈内存。\n创建和销毀:\nThread 创建和销毀需要陷入内核,系统调用。而 goroutine 因为是由 Go runtime 负责管理的，创建和销毁的消耗非常小，是用户级。\n切换:\n当 threads 切换时，需要保存各种寄存器,而 goroutines 切换只需保存三个寄存器：Program Counter, Stack Pointer and BP。一般而言，线程切换会消耗 1000-1500 ns,Goroutine 的切换约为 200 ns,因此，goroutines 切换成本比 threads 要小得多。\n\n\n### Go 线程模型（Go底层怎么实现高并发的）\n\n> 线程协程，进程的区别：\n>\n> [https://zhuanlan.zhihu.com/p/337978321](https://zhuanlan.zhihu.com/p/337978321)\n>\n> [https://www.bilibili.com/read/cv9346691/](https://www.bilibili.com/read/cv9346691/)\n\nGolang的调度器是一个轻量级的协程调度器，主要负责管理和调度协程。Golang 中的调度器采用 **M:N 模型**，即 M 个用户级线程对应 N 个内核线程。\n\n调度器会将 Golang 中的协程（goroutine）调度到不同的线程上运行，以实现并发执行的效果。\n\nM个线程对应N个内核线程的优点：\n\n* 能够利用多核\n* 上下文切换成本低\n* 如果进程中的一个线程被阻塞，不会阻塞其他线程，是能够切换同一进程内的其他线程继续执行\n\n### Golang assertion \n\n## Golang调用方面\n\n### len 统计长度\n<font color = 'red'>len()计算的是字节的长度，和编码无关，对于英文和数组对象等，字节长度等效于实际长度</font>\n当需要计算中文字符长度的时候，就需要调用其他的函数方法：\n`utf8.RuneCountInString(\"中文\")`\n","source":"_posts/Go/Go-面试问答回忆/Go 系统知识汇总.md","raw":"---\ntitle: Go 系统知识汇总\ncatalog: true\ndate: 2023-04-01 20:57:34\nsubtitle:\nheader-img:\ntags:\ncategories:\n---\n\n# Golang 系统知识回答收集\n\n## Golang 语法方面\n                                                    \n### Golang关键字有哪些\n\n### Golang 当中\n关键字是指被编程语言用作特定目的的保留单词，这些关键字在代码当中具有特殊的含义，不能被用作标识符（例如变量名，函数名，类型名等）。以下是Golang中关键字的列表\n\n```go\nfunc \ntype \n\ninterface \nstruct \nvar\n\nbreak continue \n\ndefault\n\ncase \nselect\ndefer\nswitch\nfor \nrange \ngoto\nelse\nif\n\nconst\nchan \nmap\n\nimport\npackage\n\ngo\nreturn \n\nfallthrough\n\n```\n\n### range 函数的具体使用\n\ngolang当中range 关键字可以用于迭代数组、切片、字符串、map和通道等数据类型\n\n```go\n//迭代数组和切片时候，返回当前元素的索引和值\narr := [3]int{1,2,3}\nfor key,num := range arr{\n\tfmt.Printf(\"now arr[%d] is %d\\n\", key,num)\n}\n\n// map 迭代字符串的时候，每次迭代返回当前字符的索引和Unicode码点\n\ns := \"hello world\"\nfor i, c := range s{\n\tfmt.Printf(\"index:%d, Unicode code ponit : %U\\n\",i,c)\n}\n\n//迭代map结构\nm := map[int]string{\n\t1: \"one\",\n\t2: \"two\",\n\t3: \"three\",\n}\nfor k,v := range m{\n\tfmt.Printf(\"key : %d, value : %s\",k,v)\n\n}\n\n//迭代通道使用range 迭代通道的时候，会不断地从通道当中接受元素，直到通道关闭为止\n\nch := make(chan int)\ngo func() {\n\tfor i := 0;i<5,i++{\n\tch <- i\n\t}\n\tclose(ch)\n}()\n\nfor v := range ch {\n\tfmt.Println(v)\n}\n```\n\n在迭代通道的时候，如果通道没有关闭，那么循环就会一直等待下去，知道程序死锁，因此必须要再写入完所有的数据之后关闭通道，或者使用'select'语句在接受通道数据的时候检查通道是否已经关闭\n\n\n### Slice 扩容机制\n\nGo 1.18 版本之后，当新切片需要的容量cap大于两倍扩容的容量时候，则直接按照新切片需要的容量进行扩容：\n\n* 当原 Slice 容量 < threshold 的时候，新 slice 容量变成原来的2 倍\n* 当原 Slice 容量 > threshold 的时候，进入一个循环，每次容量增加 （旧容量 + 3*threshold）/4\n\n\n### Slice 为什么不是线程安全的\n\n因为 Slice 内部使用了底层数组，数组在内存当中是连续存储的并没有加锁的机制，本身并不支持并发的读写\n\n当多个Goroutine并发访问同一个Slice的时候，可能存在某个Goroutine修改了Slice中的某个元素，其他Goroutine无法立即看到这个修改，也可能会造成竞争问题。可以通过使用((20230318150223-agvrll2 \"互斥锁\"))或者((20230318154221-miv3alf \"原子操作\"))来保证某个Goroutine访问的时候其他goroutine不能够同时访问，另外也可以使用通道来进行同步，通过将Slice的访问权限交给某个Goroutine，从而保障其他的Goroutine无法同时访问该Slice。\n\n\n\n### map的底层原理\n\nmap对象本身是一个指针，占用8个字节（64位计算机），指向`hmap`结构体，hmap包含多个bmap数组（桶）\n\n```go\ntype hmap struct{\n\tcount int // 元素个数，调用len(map)的时候直接返回\n\tflags uint8 // 标志当前map的状态，正在删除元素、添加元素、、、、\n\tB uint8 //单元(buckets)的对数 B=5表示能容纳32个元素  B随着map容量增大而变大\n\n\tnoverflow uint16  //单元(buckets)溢出数量，如果一个单元能存8个key，此时存储了9个，溢出了，就需要再增加一个单元\n\thash0 uint32 //哈希种子\n\tbuckets unsafe.Pointer //指向单元(buckets)数组,大小为2^B，可以为nil\n\toldbuckets unsafe.Pointer //扩容的时候，buckets长度会是oldbuckets的两倍\n\tnevacute uintptr  //指示扩容进度，小于此buckets迁移完成 \n\textra *mapextra //与gc相关 可选字段 \n}\n\ntype bmap struct{\n\ttophash [bucketCnt]uint8 \n}\n//实际上编译期间会生成一个新的数据结构  \ntype bmap struct { \n    topbits [8]uint8     //key hash值前8位 用于快速定位keys的位置\n    keys [8]keytype     //键\n    values [8]valuetype //值\n    pad uintptr \n    overflow uintptr     //指向溢出桶 无符号整形 优化GC\n}\n\n```\n\n\n### map的扩容机制\n\n扩容时机：向map里面插入新的key的时候，会进行条件检测，符合以下两个条件就会触发扩容操作：\n\n扩容条件：\n\n1. 超过负载 map元素个数 > 负载因子 * 桶个数\n2. 溢出桶太多\n\n负载因子是元素个数与桶的数量的比值\n\n当桶总数<2^15^时，如果溢出桶总数>=桶总数，则认为溢出桶过多\n\n当桶总数>2^15^时，如果溢出桶总数>=2^15^，则认为溢出桶过多\n\n\n扩容机制：\n\n* 双倍扩容：针对条件1，新建一个buckets数组，新的buckets大小是原来的2倍，然后旧buckets数据搬迁到新的buckets。\n* 等量扩容：针对条件2，并不扩大容量，buckets数量维持不变，重新做一遍类似双倍扩容的搬迁动作，把松散的键值对重新排列一次，使得同一个 bucket 中的 key 排列地更紧密，节省空间，提高 bucket 利用率，进而保证更快的存取。\n\n* 渐进式扩容： 插入修改删除key的时候，都会尝试进行搬迁桶的工作，每次都会检查oldbucket是否**nil**，如果不是**nil**则每次搬迁**2**个桶，蚂蚁搬家一样渐进式扩容\n\n\n### map的遍历为什么无序\n\nmap  每次遍历，都会从一个随机值序号的桶开始，再从其中随机的cell 开始遍历，并且扩容后，原来桶中的key会落到其他的桶中，本身就会造成失序。\n\n如果想要遍历map，先把key放到切片中排序，再按照key的顺序遍历map\n\n```go\n//请写一段代码验证\nm := map[int]string {\n\t1: \"one\",\n\t2: \"two\",\n\t3: \"three\",\n}\n\nfor key,value := range m{\n\tfmt.Printf(\"data is : %d ---> %S \\n\", key,value)\n}\n\n```\n\n\n### map的底层存储不是连续的\n\n具体来说map 内部存储的是一个桶（bucket）数组，桶数组中的每个元素有事一个指向链表头的指针，他存储的数据并不连续\n\n\n### map 为什么不是线程安全的\n\n多个协程同时对**map**进行并发读写**,**程序会**panic**\n\n想要线程安全，可以使用sync.RWLock锁\n\n在sync.map 这个包当中实现了锁，是线程安全的\n\n\n### Map如何查找\n\n1. 计算hash值\n    key经过哈希函数计算后,得到64bit(64位CPU)\n    10010111 | 101011101010110101010101101010101010 | 10010\n2. 找到hash对应的桶\n    上面64位后5(hmap的B值)位定位所存放的桶\n    如果当前正在扩容中,并且定位到旧桶数据还未完成迁移,则使用旧的桶\n3. 遍历桶查找\n    上面64位前8位用来在tophash数组查找快速判断key是否在当前的桶中,如果不在需要去溢出桶查找\n4. 返回key对应的指针\n\n\n\n### map 冲突解决的方式\n\nGo采用链式地址解决冲突，具体实现就是插入key到map中时，当key定位的桶填满8个元素，将会创建一个溢出桶并且将溢出桶插入到当前桶所在的链表尾部\n\nGolang当中采用链式哈希表（Cahined Hash Table）\n\n在Golang的哈希表实现当中，每一个桶就是一个链表的头指针，桶内每个元素都是哈希链表节点，节点包含了该元素的哈希值、键以及指向下一个节点的指针。\n\n在查找时候，先根据键的哈希值找到对应的桶，然后在该桶对应的链表中顺序查找，指导找到目标元素或者是链表遍历完毕。\n\n\n### map 的负载因子为什么时6.5\n\n> 负载因子 = 哈希表存储的元素个数 / 桶个数\n\nGo 官方发现：装载因子越大，填入的元素越多，空间利用率就越高，但发生哈希冲突的几率就变大。\n装载因子越小，填入的元素越少，冲突发生的几率减小，但空间浪费也会变得更多，而且还会提高扩容操作的次数\n\nGo 官方取了一个相对适中的值，把 Go 中的 map 的负载因子硬编码为 6.5，这就是 6.5 的选择缘由。\n\n这意味着在 Go 语言中，当 map存储的元素个数大于或等于 6.5 * 桶个数 时，就会触发扩容行为。\n\n\n### Map和 Sync.Map哪一个性能好\n\n对比原始map：\n\n和原始map+RWLock的实现并发的方式相比，减少了加锁对性能的影响。\n\n它做了一些优化：可以无锁访问read map，而且会优先操作read map，倘若只操作read map就可以满足要求，那就不用去操作write map(dirty)，所以在某些特定场景中它发生锁竞争的频率会远远小于map+RWLock的实现方式\n\n* 优点：\n  适合读多写少的场景\n* 缺点：\n  写多的场景，会导致 read map 缓存失效，需要加锁，冲突变多，性能急剧下降\n\n\n\n### channel 底层实现原理\n\n通过**var****声明或者是**​**make****函数创建的channel变量**是一个存储在函数栈帧上的指针，占用8个字节，指向堆上的hchan结构体\n\n```go\ntype hchan struct{\n\tclosed uint32 // channel 是否关闭的标志\n\telemtype *_type // channel 中的元素类型\n\n\tbuf unsafe.Pointer //指向底层循环数组的指针（环形缓存区）\n\tqcount uint // 循环数组中的元素数量\n\tdataqsiz uint //循环数组的长度\n\telemsize uint16 //元素的大小\n\tsendx uint // 下一次写下标的位置\n\trecvx uint // 下一次读下标的位置\n\t// 尝试读取channel 或者向channel 写入数据而被阻塞的goroutine\n    \trecvq    waitq  // 读等待队列\n    \tsendq    waitq  // 写等待队列\n    \tlock mutex //互斥锁，保证读写channel时不存在并发竞争问题\n}\n```\n\nchannel 分为无缓冲和有缓冲两种\n\n* 对于有缓冲的channel存储数据，使用了ring buffer(环形缓冲区) 来缓存写入的数据，本质是循环数组。\n\n  为啥是循环数组呢？普通数组不行吗，普通数组容量固定，更适合指定的空间，弹出元素的时候，普通数组需要全部前移。\n\n  `当下标超过数组容量后会回到第一个位置，所以需要有两个字段记录当前读和写的下标位置`\n\n* 对于无缓冲的channel 存储数据\n\n等待队列： \n\n双向链表，包含一个头结点和一个尾结点 每个节点是一个sudog结构体变量，记录哪个协程在等待，等待的是哪个channel，等待发送**/**接收的数据在哪里\n\n```go\ntype wait struct{\n\tfirst *sudog\n\tlast *sudog\n}\n\ntype sudog struct{\n\tg *g\n\tnext *sudog\n\tpre  *sudog\n\telem unsafe.Pointer\n\tc  *hchan\n\t...\n}\n```\n\n\n创建 channel 的时候：\n\n创建时会做一些检查**:** \n\n* 元素大小不能超过 **64**K\n* 元素的对齐大小不能超过 maxAlign 也就是 **8** 字节\n* 计算出来的内存是否超过限制\n\n创建时的策略:\n\n* 如果是无缓冲的channel，会直接给hchan 分配内存\n* 如果是有缓冲的channel，并且元素不包含指针，那么会为 hchan  和底层数组分配一段连续的地址\n\n* 如果是有缓冲的channel，元素包含指针，那么就会为了hchan 和底层数组分别分配地址\n\n发送时：\n\n* 如果 channel 的读队列存在着接收者 goroutine，将唤醒接收的goroutine，将数据**直接发送**给第一个等待的 goroutine\n\n* 如果channel 的读等待队列不存在接收者 goroutine\n\n  * 如果循环数组buffer未满，那么将会把数据发送到循环数组buffer的队尾\n  * 如果循环数组buffer已满，这个时候就会阻塞发送的流程，将当前goroutine加入写等待队列，**并挂起等待唤醒**\n\n接收时：\n\n* 如果 channel 的写等待队列存在发送者 goroutine\n\n  * 如果是无缓冲 channel ，**直接**从第一个发送者goroutine 那里 把数据拷贝给接受变量，**唤醒 发送的goroutine**\n  * 如果是有缓冲的 channel（已满），将循环数组的buffer的队首元素拷贝给接受变量，将第一个发送者goroutine的数据拷贝到buffer循环数组的队尾，**唤醒发送的goroutine**\n* 如果channel 的写等待队列不存在发送者goroutine\n\n  * 如果循环数组buffer非空，将循环数组buffer的队首元素拷贝给接受变量\n  * 如果循环数组buffer为空，这个时候就会阻塞接收的流程，将当前goroutine 加入读等待队列，并**挂起等待唤醒**\n\n\n### channel 有什么特点\n\nchannel是线程安全的\n\nchannel 有两种类型： 无缓冲、有缓冲\n\nchannel 有三种模式： 写操作模式（单向通道）、读操作模式（单向通道）、读写操作模式（双向通道）\n\n```go\n写操作模式    make(chan<- int)\n读操作模式    make(<-chan int)\n读写操作模式    make(chan int)\n```\n\nchannel 有 3 种状态：未初始化、正常、关闭\n\n| 操作 \\ 状态 | 未初始化         | 关闭                               | 正常             |\n| ------------- | ------------------ | ------------------------------------ | ------------------ |\n| 关闭        | panic            | panic                              | 正常             |\n| 发送        | 永远阻塞导致死锁 | panic                              | 阻塞或者成功发送 |\n| 接收        | 永远阻塞导致死锁 | 缓冲区为空则为零值，否则可以继续读 | 阻塞或者成功接收 |\n\n注意点：\n\n* 一个 channel不能多次关闭，会导致painc\n\n* 如果多个 goroutine 都监听同一个 channel，那么 channel 上的数据都可能随机被某一个 goroutine 取走进行消费\n* 如果多个 goroutine 监听同一个 channel，如果这个 channel 被关闭，则所有 goroutine 都能收到退出信号\n\n### Channel 的使用场景\n\n无缓冲 Channel 在并发编程中的具体业务使用场景很多，主要应用于 Go 语言中。以下是一些常见的无缓冲 Channel 的具体业务使用场景及例子：\n\n1. 并发控制：在并发程序中，通过无缓冲 Channel 可以实现多个 Goroutine 之间的**同步和控制**。例如，一个任务需要多个协程协作完成时，可以使用无缓冲 Channel 来传递任务数据和控制信号。\n2. 事件驱动：在事件驱动的编程中，可以使用无缓冲 Channel 来传递事件和执行结果。例如，当一个 HTTP 请求到达时，可以将请求交给一个协程处理，并使用无缓冲 Channel 返回处理结果。\n3. 分布式计算：在分布式计算中，可以使用无缓冲 Channel 来实现节点之间的通信和数据传递。例如，在 MapReduce 算法中，可以使用无缓冲 Channel 来传递 Map 阶段的输出结果并驱动 Reduce 阶段的计算。\n\n有缓冲 Channel 在并发编程中的具体业务使用场景也很多，主要应用于 Go 语言中。以下是一些常见的有缓冲 Channel 的具体业务使用场景及例子：\n\n1. 网络编程：在 TCP 或 UDP 数据处理中，可以使用有缓冲 Channel 缓存数据，**以避免因数据接收太慢而导致发送者被阻塞**。例如，在高并发的 Web 服务器中，可以使用有缓冲 Channel 缓存请求数据以提高吞吐量。\n2. IO 操作：在使用 IO 操作时，如文件读写、数据库访问等，可以使用有缓冲 Channel 缓存数据，以避免因数据处理速度不匹配而导致发送者或接收者被阻塞。例如，**在从数据库获取大量数据时，可以使用有缓冲 Channel 缓存数据，减少数据库连接次数。**\n3. 并发控制：在并发程序中，通过有缓冲 Channel 可以实现多个 Goroutine 之间的同步和控制。例如，一个任务需要多个协程协作完成时，可以使用有缓冲 Channel 来传递任务数据和控制信号，并根据缓冲区的剩余空间来控制协程的执行顺序。\n4. 事件驱动：在事件驱动的编程中，可以使用有缓冲 Channel 来缓存事件和执行结果，并根据缓冲区的剩余空间来控制事件的处理顺序。例如，当一个 HTTP 请求到达时，可以将请求交给一个协程处理，并使用有缓冲 Channel 缓存处理结果，避免处理速度过慢导致请求被阻塞。\n\n\n### channel 为什么是线程安全的\n\n不同协程通过channel进行通信，本身的使用场景就是多线程，为了保证数据的一致性，必须实现线程安全\n\n\nchannel的底层实现中，hchan结构体中采用Mutex锁来保证数据读写安全。在对循环数组buf中的数据进行入队和出队操作时，必须先获取互斥锁，才能操作channel数据\n\n\n### Channel 发送和接收什么情况下会死锁\n\n```go\nfunc deadlock1() {    //无缓冲channel只写不读\n    ch := make(chan int) \n    ch <- 3 //  这里会发生一直阻塞的情况，执行不到下面一句\n}\nfunc deadlock2() { //无缓冲channel读在写后面\n    ch := make(chan int)\n    ch <- 3  //  这里会发生一直阻塞的情况，执行不到下面一句\n    num := <-ch\n    fmt.Println(\"num=\", num)\n}\nfunc deadlock3() { //无缓冲channel读在写后面\n    ch := make(chan int)\n    ch <- 100 //  这里会发生一直阻塞的情况，执行不到下面一句\n    go func() {\n        num := <-ch\n        fmt.Println(\"num=\", num)\n    }()\n    time.Sleep(time.Second)\n}\nfunc deadlock3() {    //有缓冲channel写入超过缓冲区数量\n    ch := make(chan int, 3)\n    ch <- 3\n    ch <- 4\n    ch <- 5\n    ch <- 6  //  这里会发生一直阻塞的情况\n}\nfunc deadlock4() {    //空读\n    ch := make(chan int)\n    // ch := make(chan int, 1)\n    fmt.Println(<-ch)  //  这里会发生一直阻塞的情况\n}\nfunc deadlock5() {    //互相等对方造成死锁\n    ch1 := make(chan int)\n    ch2 := make(chan int)\n    go func() {\n        for {\n        select {\n        case num := <-ch1:\n            fmt.Println(\"num=\", num)\n            ch2 <- 100\n        }\n    }\n    }()\n    for {\n        select {\n        case num := <-ch2:\n            fmt.Println(\"num=\", num)\n            ch1 <- 300\n        }\n    }\n}\n```\n\n### 互斥锁实现原理\n\nGo sync包提供了两种锁类型：互斥锁sync.Mutex 和 读写互斥锁sync.RWMutex，都属于((20230402113517-ppcs0gj \"悲观锁\"))。\n[https://blog.csdn.net/baolingye/article/details/111357407](https://blog.csdn.net/baolingye/article/details/111357407)\n\n在正常模式下，**锁的等待者会按照先进先出的顺序获取锁**。但是刚被唤起的 Goroutine 与新创建的 Goroutine 竞争时，大概率会获取不到锁，在这种情况下，这个被唤醒的 Goroutine 会加入到等待队列的前面。 如果一个等待的 Goroutine 超过1ms 没有获取锁，那么它将会把锁转变为**饥饿模式**。\nGo在1.9中引入优化，目的保证互斥锁的公平性。在饥饿模式中，互斥锁会直接交给等待队列最前面的 Goroutine。新的 Goroutine 在该状态下不能获取锁、也不会进入自旋状态，它们只会在队列的末尾等待。如果一个 Goroutine 获得了互斥锁并且它在队列的末尾或者它等待的时间少于 1ms，那么当前的互斥锁就会切换回正常模式。\n\n\n### 悲观锁与乐观锁\n\n**悲观锁**是基于一种悲观的态度类来防止一切数据冲突，它是以一种预防的姿态在**修改数据之前把数据锁住，然后再对数据进行读写，在它释放锁之前任何人都不能对其数据进行操作，直到前面一个人把锁释放后下一个人数据加锁才可对数据进行加锁，**然后才可以对数据进行操作，一般数据库本身锁的机制都是基于悲观锁的机制实现的;\n\n特点：可以完全保证数据的独占性和正确性，因为每次请求都会先对数据进行加锁， 然后进行数据操作，最后再解锁，而加锁释放锁的过程会造成消耗，所以性能不高;\n\n\n**乐观锁**是对于数据冲突保持一种乐观态度，操作数据时不会对操作的数据进行加锁（这使得多个任务可以并行的对数据进行操作），只有到数据提交的时候才通过一种机制来验证数据是否存在冲突(一般实现方式是通过加版本号然后进行版本号的对比方式实现);\n\n特点：乐观锁是一种并发类型的锁，其本身不对数据进行加锁通而是通过业务实现锁的功能，不对数据进行加锁就意味着允许多个请求同时访问数据，同时也省掉了对数据加锁和解锁的过程，这种方式因为节省了悲观锁加锁的操作，所以可以一定程度的的提高操作的性能，不过在并发非常高的情况下，会导致大量的请求冲突，冲突导致大部分操作无功而返而浪费资源，所以在高并发的场景下，乐观锁的性能却反而不如悲观锁。\n\n\n\n### 原子操作和锁的区别\n\n在并发编程里，Go语言`sync`包里的同步原语`Mutex`是我们经常用来保证并发安全的，那么他跟`atomic`包里的这些操作有啥区别呢？在我看来他们在使用目的和底层实现上都不一样：\n\n* 使用目的：互斥锁是用来保护一段逻辑，原子操作用于对一个变量的更新保护。\n* 底层实现：`Mutex`由**操作系统**的调度器实现，而`atomic`包中的原子操作则由**底层硬件指令**直接提供支持，这些指令在执行的过程中是不允许中断的，因此原子操作可以在`lock-free`的情况下保证并发安全，并且它的性能也能做到随`CPU`个数的增多而线性扩展。\n\n\n\n\n### 互斥锁允许自旋的条件\n\n线程没有获取到锁时常见有2种处理方式：\n\n* 一种是没有获取到锁的线程就会循环等待判断该资源是否已经释放锁，这种锁也叫做自旋锁，它不用将线程阻塞起来， 适用于并发低且程序执行时间短的场景，缺点是cpu占用较高\n* 另外一种处理方式就是把自己阻塞起来，会释放CPU给其他线程，内核会将线程置为「睡眠」状态，等到锁被释放后，内核会在合适的时机唤醒该线程，适用于高并发场景，缺点是有线程上下文切换的开销\n  Go语言中的Mutex实现了自旋与阻塞两种场景，当满足不了自旋条件时，就会进入阻塞\n  **允许自旋的条件：**\n\n1. 锁已被占用，并且锁不处于饥饿模式。\n2. 积累的自旋次数小于最大自旋次数（active_spin=4）。\n3. cpu 核数大于 1。\n4. 有空闲的 P。\n5. 当前 goroutine 所挂载的 P 下，本地待运行队列为空。\n\n\n### 读写锁的实现原理\n\n读写锁的底层是基于互斥锁实现的。\n写锁需要阻塞写锁：一个协程拥有写锁时，其他协程写锁定需要阻塞；\n写锁需要阻塞读锁：一个协程拥有写锁时，其他协程读锁定需要阻塞；\n读锁需要阻塞写锁：一个协程拥有读锁时，其他协程写锁定需要阻塞；\n**读锁不能阻塞读锁：一个协程拥有读锁时，其他协程也可以拥有读锁。**\n\n\n### \"原子操作\"有哪些\n\nGo atomic包是最轻量级的锁（也称无锁结构），可以在不形成临界区和创建互斥量的情况下完成并发安全的值替换操作，不过这个包只支持int32/int64/uint32/uint64/uintptr这几种数据类型的一些基础操作（增减、交换、载入、存储等）\n当我们想要对**某个变量**并发安全的修改，除了使用官方提供的 `mutex`，还可以使用 sync/atomic 包的原子操作，它能够保证对变量的读取或修改期间不被其他的协程所影响。\natomic 包提供的原子操作能够确保任一时刻只有一个goroutine对变量进行操作，善用 atomic 能够避免程序中出现大量的锁操作。\n**常见操作：**\n\n* 增减Add     AddInt32 AddInt64 AddUint32 AddUint64 AddUintptr\n* 载入Load    LoadInt32 LoadInt64    LoadPointer    LoadUint32    LoadUint64    LoadUintptr\n* 比较并交换   CompareAndSwap    CompareAndSwapInt32...\n* 交换Swap    SwapInt32...\n* 存储Store    StoreInt32...\n\n\n### Goroutine 的底层实现原理\n\n```go\ng本质是一个数据结构,真正让 goroutine 运行起来的是调度器\ntype g struct { \n    goid int64  // 唯一的goroutine的ID \n    sched gobuf // goroutine切换时，用于保存g的上下文 \n    stack stack // 栈 \n    gopc // pc of go statement that created this goroutine \n    startpc uintptr  // pc of goroutine function ... \n} \ntype gobuf struct {     //运行时寄存器\n    sp uintptr  // 栈指针位置 \n    pc uintptr  // 运行到的程序位置 \n    g  guintptr // 指向 goroutine \n    ret uintptr // 保存系统调用的返回值 ... \n} \ntype stack struct {     //运行时栈\n    lo uintptr  // 栈的下界内存地址 \n    hi uintptr  // 栈的上界内存地址 \n}\n```\n\n### \n\n### goroutine 和线程的区别\n\n内存占用:\n创建一个 goroutine 的栈内存消耗为 2 KB，实际运行过程中，如果栈空间不够用，会自动进行扩容。创建一个 thread 则需要消耗 1 MB 栈内存。\n创建和销毀:\nThread 创建和销毀需要陷入内核,系统调用。而 goroutine 因为是由 Go runtime 负责管理的，创建和销毁的消耗非常小，是用户级。\n切换:\n当 threads 切换时，需要保存各种寄存器,而 goroutines 切换只需保存三个寄存器：Program Counter, Stack Pointer and BP。一般而言，线程切换会消耗 1000-1500 ns,Goroutine 的切换约为 200 ns,因此，goroutines 切换成本比 threads 要小得多。\n\n\n### Go 线程模型（Go底层怎么实现高并发的）\n\n> 线程协程，进程的区别：\n>\n> [https://zhuanlan.zhihu.com/p/337978321](https://zhuanlan.zhihu.com/p/337978321)\n>\n> [https://www.bilibili.com/read/cv9346691/](https://www.bilibili.com/read/cv9346691/)\n\nGolang的调度器是一个轻量级的协程调度器，主要负责管理和调度协程。Golang 中的调度器采用 **M:N 模型**，即 M 个用户级线程对应 N 个内核线程。\n\n调度器会将 Golang 中的协程（goroutine）调度到不同的线程上运行，以实现并发执行的效果。\n\nM个线程对应N个内核线程的优点：\n\n* 能够利用多核\n* 上下文切换成本低\n* 如果进程中的一个线程被阻塞，不会阻塞其他线程，是能够切换同一进程内的其他线程继续执行\n\n### Golang assertion \n\n## Golang调用方面\n\n### len 统计长度\n<font color = 'red'>len()计算的是字节的长度，和编码无关，对于英文和数组对象等，字节长度等效于实际长度</font>\n当需要计算中文字符长度的时候，就需要调用其他的函数方法：\n`utf8.RuneCountInString(\"中文\")`\n","slug":"Go/Go-面试问答回忆/Go 系统知识汇总","published":1,"updated":"2023-04-22T13:24:02.216Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgtm6jqm0018lyjx0fgp5f77","content":"<h1 id=\"Golang-系统知识回答收集\"><a href=\"#Golang-系统知识回答收集\" class=\"headerlink\" title=\"Golang 系统知识回答收集\"></a>Golang 系统知识回答收集</h1><h2 id=\"Golang-语法方面\"><a href=\"#Golang-语法方面\" class=\"headerlink\" title=\"Golang 语法方面\"></a>Golang 语法方面</h2><h3 id=\"Golang关键字有哪些\"><a href=\"#Golang关键字有哪些\" class=\"headerlink\" title=\"Golang关键字有哪些\"></a>Golang关键字有哪些</h3><h3 id=\"Golang-当中\"><a href=\"#Golang-当中\" class=\"headerlink\" title=\"Golang 当中\"></a>Golang 当中</h3><p>关键字是指被编程语言用作特定目的的保留单词，这些关键字在代码当中具有特殊的含义，不能被用作标识符（例如变量名，函数名，类型名等）。以下是Golang中关键字的列表</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span></span> </span><br><span class=\"line\"><span class=\"keyword\">type</span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> </span><br><span class=\"line\"><span class=\"keyword\">struct</span> </span><br><span class=\"line\"><span class=\"keyword\">var</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">break</span> <span class=\"keyword\">continue</span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">default</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">case</span> </span><br><span class=\"line\"><span class=\"keyword\">select</span></span><br><span class=\"line\"><span class=\"keyword\">defer</span></span><br><span class=\"line\"><span class=\"keyword\">switch</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> </span><br><span class=\"line\"><span class=\"keyword\">range</span> </span><br><span class=\"line\"><span class=\"keyword\">goto</span></span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\"><span class=\"keyword\">if</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span></span><br><span class=\"line\"><span class=\"keyword\">chan</span> </span><br><span class=\"line\"><span class=\"keyword\">map</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span></span><br><span class=\"line\"><span class=\"keyword\">package</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">go</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fallthrough</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"range-函数的具体使用\"><a href=\"#range-函数的具体使用\" class=\"headerlink\" title=\"range 函数的具体使用\"></a>range 函数的具体使用</h3><p>golang当中range 关键字可以用于迭代数组、切片、字符串、map和通道等数据类型</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//迭代数组和切片时候，返回当前元素的索引和值</span></span><br><span class=\"line\">arr := [<span class=\"number\">3</span>]<span class=\"type\">int</span>&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> key,num := <span class=\"keyword\">range</span> arr&#123;</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;now arr[%d] is %d\\n&quot;</span>, key,num)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// map 迭代字符串的时候，每次迭代返回当前字符的索引和Unicode码点</span></span><br><span class=\"line\"></span><br><span class=\"line\">s := <span class=\"string\">&quot;hello world&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i, c := <span class=\"keyword\">range</span> s&#123;</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;index:%d, Unicode code ponit : %U\\n&quot;</span>,i,c)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//迭代map结构</span></span><br><span class=\"line\">m := <span class=\"keyword\">map</span>[<span class=\"type\">int</span>]<span class=\"type\">string</span>&#123;</span><br><span class=\"line\">\t<span class=\"number\">1</span>: <span class=\"string\">&quot;one&quot;</span>,</span><br><span class=\"line\">\t<span class=\"number\">2</span>: <span class=\"string\">&quot;two&quot;</span>,</span><br><span class=\"line\">\t<span class=\"number\">3</span>: <span class=\"string\">&quot;three&quot;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> k,v := <span class=\"keyword\">range</span> m&#123;</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;key : %d, value : %s&quot;</span>,k,v)</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//迭代通道使用range 迭代通道的时候，会不断地从通道当中接受元素，直到通道关闭为止</span></span><br><span class=\"line\"></span><br><span class=\"line\">ch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\"><span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>;i&lt;<span class=\"number\">5</span>,i++&#123;</span><br><span class=\"line\">\tch &lt;- i</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">close</span>(ch)</span><br><span class=\"line\">&#125;()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> v := <span class=\"keyword\">range</span> ch &#123;</span><br><span class=\"line\">\tfmt.Println(v)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在迭代通道的时候，如果通道没有关闭，那么循环就会一直等待下去，知道程序死锁，因此必须要再写入完所有的数据之后关闭通道，或者使用’select’语句在接受通道数据的时候检查通道是否已经关闭</p>\n<h3 id=\"Slice-扩容机制\"><a href=\"#Slice-扩容机制\" class=\"headerlink\" title=\"Slice 扩容机制\"></a>Slice 扩容机制</h3><p>Go 1.18 版本之后，当新切片需要的容量cap大于两倍扩容的容量时候，则直接按照新切片需要的容量进行扩容：</p>\n<ul>\n<li>当原 Slice 容量 &lt; threshold 的时候，新 slice 容量变成原来的2 倍</li>\n<li>当原 Slice 容量 &gt; threshold 的时候，进入一个循环，每次容量增加 （旧容量 + 3*threshold）/4</li>\n</ul>\n<h3 id=\"Slice-为什么不是线程安全的\"><a href=\"#Slice-为什么不是线程安全的\" class=\"headerlink\" title=\"Slice 为什么不是线程安全的\"></a>Slice 为什么不是线程安全的</h3><p>因为 Slice 内部使用了底层数组，数组在内存当中是连续存储的并没有加锁的机制，本身并不支持并发的读写</p>\n<p>当多个Goroutine并发访问同一个Slice的时候，可能存在某个Goroutine修改了Slice中的某个元素，其他Goroutine无法立即看到这个修改，也可能会造成竞争问题。可以通过使用((20230318150223-agvrll2 “互斥锁”))或者((20230318154221-miv3alf “原子操作”))来保证某个Goroutine访问的时候其他goroutine不能够同时访问，另外也可以使用通道来进行同步，通过将Slice的访问权限交给某个Goroutine，从而保障其他的Goroutine无法同时访问该Slice。</p>\n<h3 id=\"map的底层原理\"><a href=\"#map的底层原理\" class=\"headerlink\" title=\"map的底层原理\"></a>map的底层原理</h3><p>map对象本身是一个指针，占用8个字节（64位计算机），指向<code>hmap</code>结构体，hmap包含多个bmap数组（桶）</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> hmap <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">\tcount <span class=\"type\">int</span> <span class=\"comment\">// 元素个数，调用len(map)的时候直接返回</span></span><br><span class=\"line\">\tflags <span class=\"type\">uint8</span> <span class=\"comment\">// 标志当前map的状态，正在删除元素、添加元素、、、、</span></span><br><span class=\"line\">\tB <span class=\"type\">uint8</span> <span class=\"comment\">//单元(buckets)的对数 B=5表示能容纳32个元素  B随着map容量增大而变大</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tnoverflow <span class=\"type\">uint16</span>  <span class=\"comment\">//单元(buckets)溢出数量，如果一个单元能存8个key，此时存储了9个，溢出了，就需要再增加一个单元</span></span><br><span class=\"line\">\thash0 <span class=\"type\">uint32</span> <span class=\"comment\">//哈希种子</span></span><br><span class=\"line\">\tbuckets unsafe.Pointer <span class=\"comment\">//指向单元(buckets)数组,大小为2^B，可以为nil</span></span><br><span class=\"line\">\toldbuckets unsafe.Pointer <span class=\"comment\">//扩容的时候，buckets长度会是oldbuckets的两倍</span></span><br><span class=\"line\">\tnevacute <span class=\"type\">uintptr</span>  <span class=\"comment\">//指示扩容进度，小于此buckets迁移完成 </span></span><br><span class=\"line\">\textra *mapextra <span class=\"comment\">//与gc相关 可选字段 </span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> bmap <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">\ttophash [bucketCnt]<span class=\"type\">uint8</span> </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//实际上编译期间会生成一个新的数据结构  </span></span><br><span class=\"line\"><span class=\"keyword\">type</span> bmap <span class=\"keyword\">struct</span> &#123; </span><br><span class=\"line\">    topbits [<span class=\"number\">8</span>]<span class=\"type\">uint8</span>     <span class=\"comment\">//key hash值前8位 用于快速定位keys的位置</span></span><br><span class=\"line\">    keys [<span class=\"number\">8</span>]keytype     <span class=\"comment\">//键</span></span><br><span class=\"line\">    values [<span class=\"number\">8</span>]valuetype <span class=\"comment\">//值</span></span><br><span class=\"line\">    pad <span class=\"type\">uintptr</span> </span><br><span class=\"line\">    overflow <span class=\"type\">uintptr</span>     <span class=\"comment\">//指向溢出桶 无符号整形 优化GC</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"map的扩容机制\"><a href=\"#map的扩容机制\" class=\"headerlink\" title=\"map的扩容机制\"></a>map的扩容机制</h3><p>扩容时机：向map里面插入新的key的时候，会进行条件检测，符合以下两个条件就会触发扩容操作：</p>\n<p>扩容条件：</p>\n<ol>\n<li>超过负载 map元素个数 &gt; 负载因子 * 桶个数</li>\n<li>溢出桶太多</li>\n</ol>\n<p>负载因子是元素个数与桶的数量的比值</p>\n<p>当桶总数&lt;2^15^时，如果溢出桶总数&gt;=桶总数，则认为溢出桶过多</p>\n<p>当桶总数&gt;2^15^时，如果溢出桶总数&gt;=2^15^，则认为溢出桶过多</p>\n<p>扩容机制：</p>\n<ul>\n<li><p>双倍扩容：针对条件1，新建一个buckets数组，新的buckets大小是原来的2倍，然后旧buckets数据搬迁到新的buckets。</p>\n</li>\n<li><p>等量扩容：针对条件2，并不扩大容量，buckets数量维持不变，重新做一遍类似双倍扩容的搬迁动作，把松散的键值对重新排列一次，使得同一个 bucket 中的 key 排列地更紧密，节省空间，提高 bucket 利用率，进而保证更快的存取。</p>\n</li>\n<li><p>渐进式扩容： 插入修改删除key的时候，都会尝试进行搬迁桶的工作，每次都会检查oldbucket是否<strong>nil</strong>，如果不是<strong>nil</strong>则每次搬迁<strong>2</strong>个桶，蚂蚁搬家一样渐进式扩容</p>\n</li>\n</ul>\n<h3 id=\"map的遍历为什么无序\"><a href=\"#map的遍历为什么无序\" class=\"headerlink\" title=\"map的遍历为什么无序\"></a>map的遍历为什么无序</h3><p>map  每次遍历，都会从一个随机值序号的桶开始，再从其中随机的cell 开始遍历，并且扩容后，原来桶中的key会落到其他的桶中，本身就会造成失序。</p>\n<p>如果想要遍历map，先把key放到切片中排序，再按照key的顺序遍历map</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//请写一段代码验证</span></span><br><span class=\"line\">m := <span class=\"keyword\">map</span>[<span class=\"type\">int</span>]<span class=\"type\">string</span> &#123;</span><br><span class=\"line\">\t<span class=\"number\">1</span>: <span class=\"string\">&quot;one&quot;</span>,</span><br><span class=\"line\">\t<span class=\"number\">2</span>: <span class=\"string\">&quot;two&quot;</span>,</span><br><span class=\"line\">\t<span class=\"number\">3</span>: <span class=\"string\">&quot;three&quot;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> key,value := <span class=\"keyword\">range</span> m&#123;</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;data is : %d ---&gt; %S \\n&quot;</span>, key,value)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"map的底层存储不是连续的\"><a href=\"#map的底层存储不是连续的\" class=\"headerlink\" title=\"map的底层存储不是连续的\"></a>map的底层存储不是连续的</h3><p>具体来说map 内部存储的是一个桶（bucket）数组，桶数组中的每个元素有事一个指向链表头的指针，他存储的数据并不连续</p>\n<h3 id=\"map-为什么不是线程安全的\"><a href=\"#map-为什么不是线程安全的\" class=\"headerlink\" title=\"map 为什么不是线程安全的\"></a>map 为什么不是线程安全的</h3><p>多个协程同时对<strong>map</strong>进行并发读写**,<strong>程序会</strong>panic**</p>\n<p>想要线程安全，可以使用sync.RWLock锁</p>\n<p>在sync.map 这个包当中实现了锁，是线程安全的</p>\n<h3 id=\"Map如何查找\"><a href=\"#Map如何查找\" class=\"headerlink\" title=\"Map如何查找\"></a>Map如何查找</h3><ol>\n<li>计算hash值<br> key经过哈希函数计算后,得到64bit(64位CPU)<br> 10010111 | 101011101010110101010101101010101010 | 10010</li>\n<li>找到hash对应的桶<br> 上面64位后5(hmap的B值)位定位所存放的桶<br> 如果当前正在扩容中,并且定位到旧桶数据还未完成迁移,则使用旧的桶</li>\n<li>遍历桶查找<br> 上面64位前8位用来在tophash数组查找快速判断key是否在当前的桶中,如果不在需要去溢出桶查找</li>\n<li>返回key对应的指针</li>\n</ol>\n<h3 id=\"map-冲突解决的方式\"><a href=\"#map-冲突解决的方式\" class=\"headerlink\" title=\"map 冲突解决的方式\"></a>map 冲突解决的方式</h3><p>Go采用链式地址解决冲突，具体实现就是插入key到map中时，当key定位的桶填满8个元素，将会创建一个溢出桶并且将溢出桶插入到当前桶所在的链表尾部</p>\n<p>Golang当中采用链式哈希表（Cahined Hash Table）</p>\n<p>在Golang的哈希表实现当中，每一个桶就是一个链表的头指针，桶内每个元素都是哈希链表节点，节点包含了该元素的哈希值、键以及指向下一个节点的指针。</p>\n<p>在查找时候，先根据键的哈希值找到对应的桶，然后在该桶对应的链表中顺序查找，指导找到目标元素或者是链表遍历完毕。</p>\n<h3 id=\"map-的负载因子为什么时6-5\"><a href=\"#map-的负载因子为什么时6-5\" class=\"headerlink\" title=\"map 的负载因子为什么时6.5\"></a>map 的负载因子为什么时6.5</h3><blockquote>\n<p>负载因子 = 哈希表存储的元素个数 / 桶个数</p>\n</blockquote>\n<p>Go 官方发现：装载因子越大，填入的元素越多，空间利用率就越高，但发生哈希冲突的几率就变大。<br>装载因子越小，填入的元素越少，冲突发生的几率减小，但空间浪费也会变得更多，而且还会提高扩容操作的次数</p>\n<p>Go 官方取了一个相对适中的值，把 Go 中的 map 的负载因子硬编码为 6.5，这就是 6.5 的选择缘由。</p>\n<p>这意味着在 Go 语言中，当 map存储的元素个数大于或等于 6.5 * 桶个数 时，就会触发扩容行为。</p>\n<h3 id=\"Map和-Sync-Map哪一个性能好\"><a href=\"#Map和-Sync-Map哪一个性能好\" class=\"headerlink\" title=\"Map和 Sync.Map哪一个性能好\"></a>Map和 Sync.Map哪一个性能好</h3><p>对比原始map：</p>\n<p>和原始map+RWLock的实现并发的方式相比，减少了加锁对性能的影响。</p>\n<p>它做了一些优化：可以无锁访问read map，而且会优先操作read map，倘若只操作read map就可以满足要求，那就不用去操作write map(dirty)，所以在某些特定场景中它发生锁竞争的频率会远远小于map+RWLock的实现方式</p>\n<ul>\n<li>优点：<br>适合读多写少的场景</li>\n<li>缺点：<br>写多的场景，会导致 read map 缓存失效，需要加锁，冲突变多，性能急剧下降</li>\n</ul>\n<h3 id=\"channel-底层实现原理\"><a href=\"#channel-底层实现原理\" class=\"headerlink\" title=\"channel 底层实现原理\"></a>channel 底层实现原理</h3><p>通过<strong>var****声明或者是</strong>​<strong>make****函数创建的channel变量</strong>是一个存储在函数栈帧上的指针，占用8个字节，指向堆上的hchan结构体</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> hchan <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">\tclosed <span class=\"type\">uint32</span> <span class=\"comment\">// channel 是否关闭的标志</span></span><br><span class=\"line\">\telemtype *_type <span class=\"comment\">// channel 中的元素类型</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tbuf unsafe.Pointer <span class=\"comment\">//指向底层循环数组的指针（环形缓存区）</span></span><br><span class=\"line\">\tqcount <span class=\"type\">uint</span> <span class=\"comment\">// 循环数组中的元素数量</span></span><br><span class=\"line\">\tdataqsiz <span class=\"type\">uint</span> <span class=\"comment\">//循环数组的长度</span></span><br><span class=\"line\">\telemsize <span class=\"type\">uint16</span> <span class=\"comment\">//元素的大小</span></span><br><span class=\"line\">\tsendx <span class=\"type\">uint</span> <span class=\"comment\">// 下一次写下标的位置</span></span><br><span class=\"line\">\trecvx <span class=\"type\">uint</span> <span class=\"comment\">// 下一次读下标的位置</span></span><br><span class=\"line\">\t<span class=\"comment\">// 尝试读取channel 或者向channel 写入数据而被阻塞的goroutine</span></span><br><span class=\"line\">    \trecvq    waitq  <span class=\"comment\">// 读等待队列</span></span><br><span class=\"line\">    \tsendq    waitq  <span class=\"comment\">// 写等待队列</span></span><br><span class=\"line\">    \tlock mutex <span class=\"comment\">//互斥锁，保证读写channel时不存在并发竞争问题</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>channel 分为无缓冲和有缓冲两种</p>\n<ul>\n<li><p>对于有缓冲的channel存储数据，使用了ring buffer(环形缓冲区) 来缓存写入的数据，本质是循环数组。</p>\n<p>为啥是循环数组呢？普通数组不行吗，普通数组容量固定，更适合指定的空间，弹出元素的时候，普通数组需要全部前移。</p>\n<p><code>当下标超过数组容量后会回到第一个位置，所以需要有两个字段记录当前读和写的下标位置</code></p>\n</li>\n<li><p>对于无缓冲的channel 存储数据</p>\n</li>\n</ul>\n<p>等待队列： </p>\n<p>双向链表，包含一个头结点和一个尾结点 每个节点是一个sudog结构体变量，记录哪个协程在等待，等待的是哪个channel，等待发送**/**接收的数据在哪里</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> wait <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">\tfirst *sudog</span><br><span class=\"line\">\tlast *sudog</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> sudog <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">\tg *g</span><br><span class=\"line\">\tnext *sudog</span><br><span class=\"line\">\tpre  *sudog</span><br><span class=\"line\">\telem unsafe.Pointer</span><br><span class=\"line\">\tc  *hchan</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>创建 channel 的时候：</p>\n<p>创建时会做一些检查**:** </p>\n<ul>\n<li>元素大小不能超过 <strong>64</strong>K</li>\n<li>元素的对齐大小不能超过 maxAlign 也就是 <strong>8</strong> 字节</li>\n<li>计算出来的内存是否超过限制</li>\n</ul>\n<p>创建时的策略:</p>\n<ul>\n<li><p>如果是无缓冲的channel，会直接给hchan 分配内存</p>\n</li>\n<li><p>如果是有缓冲的channel，并且元素不包含指针，那么会为 hchan  和底层数组分配一段连续的地址</p>\n</li>\n<li><p>如果是有缓冲的channel，元素包含指针，那么就会为了hchan 和底层数组分别分配地址</p>\n</li>\n</ul>\n<p>发送时：</p>\n<ul>\n<li><p>如果 channel 的读队列存在着接收者 goroutine，将唤醒接收的goroutine，将数据<strong>直接发送</strong>给第一个等待的 goroutine</p>\n</li>\n<li><p>如果channel 的读等待队列不存在接收者 goroutine</p>\n<ul>\n<li>如果循环数组buffer未满，那么将会把数据发送到循环数组buffer的队尾</li>\n<li>如果循环数组buffer已满，这个时候就会阻塞发送的流程，将当前goroutine加入写等待队列，<strong>并挂起等待唤醒</strong></li>\n</ul>\n</li>\n</ul>\n<p>接收时：</p>\n<ul>\n<li><p>如果 channel 的写等待队列存在发送者 goroutine</p>\n<ul>\n<li>如果是无缓冲 channel ，<strong>直接</strong>从第一个发送者goroutine 那里 把数据拷贝给接受变量，<strong>唤醒 发送的goroutine</strong></li>\n<li>如果是有缓冲的 channel（已满），将循环数组的buffer的队首元素拷贝给接受变量，将第一个发送者goroutine的数据拷贝到buffer循环数组的队尾，<strong>唤醒发送的goroutine</strong></li>\n</ul>\n</li>\n<li><p>如果channel 的写等待队列不存在发送者goroutine</p>\n<ul>\n<li>如果循环数组buffer非空，将循环数组buffer的队首元素拷贝给接受变量</li>\n<li>如果循环数组buffer为空，这个时候就会阻塞接收的流程，将当前goroutine 加入读等待队列，并<strong>挂起等待唤醒</strong></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"channel-有什么特点\"><a href=\"#channel-有什么特点\" class=\"headerlink\" title=\"channel 有什么特点\"></a>channel 有什么特点</h3><p>channel是线程安全的</p>\n<p>channel 有两种类型： 无缓冲、有缓冲</p>\n<p>channel 有三种模式： 写操作模式（单向通道）、读操作模式（单向通道）、读写操作模式（双向通道）</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">写操作模式    <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span>&lt;- <span class=\"type\">int</span>)</span><br><span class=\"line\">读操作模式    <span class=\"built_in\">make</span>(&lt;-<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\">读写操作模式    <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br></pre></td></tr></table></figure>\n\n<p>channel 有 3 种状态：未初始化、正常、关闭</p>\n<table>\n<thead>\n<tr>\n<th>操作 \\ 状态</th>\n<th>未初始化</th>\n<th>关闭</th>\n<th>正常</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>关闭</td>\n<td>panic</td>\n<td>panic</td>\n<td>正常</td>\n</tr>\n<tr>\n<td>发送</td>\n<td>永远阻塞导致死锁</td>\n<td>panic</td>\n<td>阻塞或者成功发送</td>\n</tr>\n<tr>\n<td>接收</td>\n<td>永远阻塞导致死锁</td>\n<td>缓冲区为空则为零值，否则可以继续读</td>\n<td>阻塞或者成功接收</td>\n</tr>\n</tbody></table>\n<p>注意点：</p>\n<ul>\n<li><p>一个 channel不能多次关闭，会导致painc</p>\n</li>\n<li><p>如果多个 goroutine 都监听同一个 channel，那么 channel 上的数据都可能随机被某一个 goroutine 取走进行消费</p>\n</li>\n<li><p>如果多个 goroutine 监听同一个 channel，如果这个 channel 被关闭，则所有 goroutine 都能收到退出信号</p>\n</li>\n</ul>\n<h3 id=\"Channel-的使用场景\"><a href=\"#Channel-的使用场景\" class=\"headerlink\" title=\"Channel 的使用场景\"></a>Channel 的使用场景</h3><p>无缓冲 Channel 在并发编程中的具体业务使用场景很多，主要应用于 Go 语言中。以下是一些常见的无缓冲 Channel 的具体业务使用场景及例子：</p>\n<ol>\n<li>并发控制：在并发程序中，通过无缓冲 Channel 可以实现多个 Goroutine 之间的<strong>同步和控制</strong>。例如，一个任务需要多个协程协作完成时，可以使用无缓冲 Channel 来传递任务数据和控制信号。</li>\n<li>事件驱动：在事件驱动的编程中，可以使用无缓冲 Channel 来传递事件和执行结果。例如，当一个 HTTP 请求到达时，可以将请求交给一个协程处理，并使用无缓冲 Channel 返回处理结果。</li>\n<li>分布式计算：在分布式计算中，可以使用无缓冲 Channel 来实现节点之间的通信和数据传递。例如，在 MapReduce 算法中，可以使用无缓冲 Channel 来传递 Map 阶段的输出结果并驱动 Reduce 阶段的计算。</li>\n</ol>\n<p>有缓冲 Channel 在并发编程中的具体业务使用场景也很多，主要应用于 Go 语言中。以下是一些常见的有缓冲 Channel 的具体业务使用场景及例子：</p>\n<ol>\n<li>网络编程：在 TCP 或 UDP 数据处理中，可以使用有缓冲 Channel 缓存数据，<strong>以避免因数据接收太慢而导致发送者被阻塞</strong>。例如，在高并发的 Web 服务器中，可以使用有缓冲 Channel 缓存请求数据以提高吞吐量。</li>\n<li>IO 操作：在使用 IO 操作时，如文件读写、数据库访问等，可以使用有缓冲 Channel 缓存数据，以避免因数据处理速度不匹配而导致发送者或接收者被阻塞。例如，<strong>在从数据库获取大量数据时，可以使用有缓冲 Channel 缓存数据，减少数据库连接次数。</strong></li>\n<li>并发控制：在并发程序中，通过有缓冲 Channel 可以实现多个 Goroutine 之间的同步和控制。例如，一个任务需要多个协程协作完成时，可以使用有缓冲 Channel 来传递任务数据和控制信号，并根据缓冲区的剩余空间来控制协程的执行顺序。</li>\n<li>事件驱动：在事件驱动的编程中，可以使用有缓冲 Channel 来缓存事件和执行结果，并根据缓冲区的剩余空间来控制事件的处理顺序。例如，当一个 HTTP 请求到达时，可以将请求交给一个协程处理，并使用有缓冲 Channel 缓存处理结果，避免处理速度过慢导致请求被阻塞。</li>\n</ol>\n<h3 id=\"channel-为什么是线程安全的\"><a href=\"#channel-为什么是线程安全的\" class=\"headerlink\" title=\"channel 为什么是线程安全的\"></a>channel 为什么是线程安全的</h3><p>不同协程通过channel进行通信，本身的使用场景就是多线程，为了保证数据的一致性，必须实现线程安全</p>\n<p>channel的底层实现中，hchan结构体中采用Mutex锁来保证数据读写安全。在对循环数组buf中的数据进行入队和出队操作时，必须先获取互斥锁，才能操作channel数据</p>\n<h3 id=\"Channel-发送和接收什么情况下会死锁\"><a href=\"#Channel-发送和接收什么情况下会死锁\" class=\"headerlink\" title=\"Channel 发送和接收什么情况下会死锁\"></a>Channel 发送和接收什么情况下会死锁</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">deadlock1</span><span class=\"params\">()</span></span> &#123;    <span class=\"comment\">//无缓冲channel只写不读</span></span><br><span class=\"line\">    ch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>) </span><br><span class=\"line\">    ch &lt;- <span class=\"number\">3</span> <span class=\"comment\">//  这里会发生一直阻塞的情况，执行不到下面一句</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">deadlock2</span><span class=\"params\">()</span></span> &#123; <span class=\"comment\">//无缓冲channel读在写后面</span></span><br><span class=\"line\">    ch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\">    ch &lt;- <span class=\"number\">3</span>  <span class=\"comment\">//  这里会发生一直阻塞的情况，执行不到下面一句</span></span><br><span class=\"line\">    num := &lt;-ch</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;num=&quot;</span>, num)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">deadlock3</span><span class=\"params\">()</span></span> &#123; <span class=\"comment\">//无缓冲channel读在写后面</span></span><br><span class=\"line\">    ch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\">    ch &lt;- <span class=\"number\">100</span> <span class=\"comment\">//  这里会发生一直阻塞的情况，执行不到下面一句</span></span><br><span class=\"line\">    <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        num := &lt;-ch</span><br><span class=\"line\">        fmt.Println(<span class=\"string\">&quot;num=&quot;</span>, num)</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">    time.Sleep(time.Second)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">deadlock3</span><span class=\"params\">()</span></span> &#123;    <span class=\"comment\">//有缓冲channel写入超过缓冲区数量</span></span><br><span class=\"line\">    ch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\">    ch &lt;- <span class=\"number\">3</span></span><br><span class=\"line\">    ch &lt;- <span class=\"number\">4</span></span><br><span class=\"line\">    ch &lt;- <span class=\"number\">5</span></span><br><span class=\"line\">    ch &lt;- <span class=\"number\">6</span>  <span class=\"comment\">//  这里会发生一直阻塞的情况</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">deadlock4</span><span class=\"params\">()</span></span> &#123;    <span class=\"comment\">//空读</span></span><br><span class=\"line\">    ch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\">    <span class=\"comment\">// ch := make(chan int, 1)</span></span><br><span class=\"line\">    fmt.Println(&lt;-ch)  <span class=\"comment\">//  这里会发生一直阻塞的情况</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">deadlock5</span><span class=\"params\">()</span></span> &#123;    <span class=\"comment\">//互相等对方造成死锁</span></span><br><span class=\"line\">    ch1 := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\">    ch2 := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\">    <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> num := &lt;-ch1:</span><br><span class=\"line\">            fmt.Println(<span class=\"string\">&quot;num=&quot;</span>, num)</span><br><span class=\"line\">            ch2 &lt;- <span class=\"number\">100</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> num := &lt;-ch2:</span><br><span class=\"line\">            fmt.Println(<span class=\"string\">&quot;num=&quot;</span>, num)</span><br><span class=\"line\">            ch1 &lt;- <span class=\"number\">300</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"互斥锁实现原理\"><a href=\"#互斥锁实现原理\" class=\"headerlink\" title=\"互斥锁实现原理\"></a>互斥锁实现原理</h3><p>Go sync包提供了两种锁类型：互斥锁sync.Mutex 和 读写互斥锁sync.RWMutex，都属于((20230402113517-ppcs0gj “悲观锁”))。<br><a href=\"https://blog.csdn.net/baolingye/article/details/111357407\">https://blog.csdn.net/baolingye/article/details/111357407</a></p>\n<p>在正常模式下，<strong>锁的等待者会按照先进先出的顺序获取锁</strong>。但是刚被唤起的 Goroutine 与新创建的 Goroutine 竞争时，大概率会获取不到锁，在这种情况下，这个被唤醒的 Goroutine 会加入到等待队列的前面。 如果一个等待的 Goroutine 超过1ms 没有获取锁，那么它将会把锁转变为<strong>饥饿模式</strong>。<br>Go在1.9中引入优化，目的保证互斥锁的公平性。在饥饿模式中，互斥锁会直接交给等待队列最前面的 Goroutine。新的 Goroutine 在该状态下不能获取锁、也不会进入自旋状态，它们只会在队列的末尾等待。如果一个 Goroutine 获得了互斥锁并且它在队列的末尾或者它等待的时间少于 1ms，那么当前的互斥锁就会切换回正常模式。</p>\n<h3 id=\"悲观锁与乐观锁\"><a href=\"#悲观锁与乐观锁\" class=\"headerlink\" title=\"悲观锁与乐观锁\"></a>悲观锁与乐观锁</h3><p><strong>悲观锁</strong>是基于一种悲观的态度类来防止一切数据冲突，它是以一种预防的姿态在<strong>修改数据之前把数据锁住，然后再对数据进行读写，在它释放锁之前任何人都不能对其数据进行操作，直到前面一个人把锁释放后下一个人数据加锁才可对数据进行加锁，</strong>然后才可以对数据进行操作，一般数据库本身锁的机制都是基于悲观锁的机制实现的;</p>\n<p>特点：可以完全保证数据的独占性和正确性，因为每次请求都会先对数据进行加锁， 然后进行数据操作，最后再解锁，而加锁释放锁的过程会造成消耗，所以性能不高;</p>\n<p><strong>乐观锁</strong>是对于数据冲突保持一种乐观态度，操作数据时不会对操作的数据进行加锁（这使得多个任务可以并行的对数据进行操作），只有到数据提交的时候才通过一种机制来验证数据是否存在冲突(一般实现方式是通过加版本号然后进行版本号的对比方式实现);</p>\n<p>特点：乐观锁是一种并发类型的锁，其本身不对数据进行加锁通而是通过业务实现锁的功能，不对数据进行加锁就意味着允许多个请求同时访问数据，同时也省掉了对数据加锁和解锁的过程，这种方式因为节省了悲观锁加锁的操作，所以可以一定程度的的提高操作的性能，不过在并发非常高的情况下，会导致大量的请求冲突，冲突导致大部分操作无功而返而浪费资源，所以在高并发的场景下，乐观锁的性能却反而不如悲观锁。</p>\n<h3 id=\"原子操作和锁的区别\"><a href=\"#原子操作和锁的区别\" class=\"headerlink\" title=\"原子操作和锁的区别\"></a>原子操作和锁的区别</h3><p>在并发编程里，Go语言<code>sync</code>包里的同步原语<code>Mutex</code>是我们经常用来保证并发安全的，那么他跟<code>atomic</code>包里的这些操作有啥区别呢？在我看来他们在使用目的和底层实现上都不一样：</p>\n<ul>\n<li>使用目的：互斥锁是用来保护一段逻辑，原子操作用于对一个变量的更新保护。</li>\n<li>底层实现：<code>Mutex</code>由<strong>操作系统</strong>的调度器实现，而<code>atomic</code>包中的原子操作则由<strong>底层硬件指令</strong>直接提供支持，这些指令在执行的过程中是不允许中断的，因此原子操作可以在<code>lock-free</code>的情况下保证并发安全，并且它的性能也能做到随<code>CPU</code>个数的增多而线性扩展。</li>\n</ul>\n<h3 id=\"互斥锁允许自旋的条件\"><a href=\"#互斥锁允许自旋的条件\" class=\"headerlink\" title=\"互斥锁允许自旋的条件\"></a>互斥锁允许自旋的条件</h3><p>线程没有获取到锁时常见有2种处理方式：</p>\n<ul>\n<li>一种是没有获取到锁的线程就会循环等待判断该资源是否已经释放锁，这种锁也叫做自旋锁，它不用将线程阻塞起来， 适用于并发低且程序执行时间短的场景，缺点是cpu占用较高</li>\n<li>另外一种处理方式就是把自己阻塞起来，会释放CPU给其他线程，内核会将线程置为「睡眠」状态，等到锁被释放后，内核会在合适的时机唤醒该线程，适用于高并发场景，缺点是有线程上下文切换的开销<br>Go语言中的Mutex实现了自旋与阻塞两种场景，当满足不了自旋条件时，就会进入阻塞<br><strong>允许自旋的条件：</strong></li>\n</ul>\n<ol>\n<li>锁已被占用，并且锁不处于饥饿模式。</li>\n<li>积累的自旋次数小于最大自旋次数（active_spin=4）。</li>\n<li>cpu 核数大于 1。</li>\n<li>有空闲的 P。</li>\n<li>当前 goroutine 所挂载的 P 下，本地待运行队列为空。</li>\n</ol>\n<h3 id=\"读写锁的实现原理\"><a href=\"#读写锁的实现原理\" class=\"headerlink\" title=\"读写锁的实现原理\"></a>读写锁的实现原理</h3><p>读写锁的底层是基于互斥锁实现的。<br>写锁需要阻塞写锁：一个协程拥有写锁时，其他协程写锁定需要阻塞；<br>写锁需要阻塞读锁：一个协程拥有写锁时，其他协程读锁定需要阻塞；<br>读锁需要阻塞写锁：一个协程拥有读锁时，其他协程写锁定需要阻塞；<br><strong>读锁不能阻塞读锁：一个协程拥有读锁时，其他协程也可以拥有读锁。</strong></p>\n<h3 id=\"“原子操作”有哪些\"><a href=\"#“原子操作”有哪些\" class=\"headerlink\" title=\"“原子操作”有哪些\"></a>“原子操作”有哪些</h3><p>Go atomic包是最轻量级的锁（也称无锁结构），可以在不形成临界区和创建互斥量的情况下完成并发安全的值替换操作，不过这个包只支持int32/int64/uint32/uint64/uintptr这几种数据类型的一些基础操作（增减、交换、载入、存储等）<br>当我们想要对<strong>某个变量</strong>并发安全的修改，除了使用官方提供的 <code>mutex</code>，还可以使用 sync/atomic 包的原子操作，它能够保证对变量的读取或修改期间不被其他的协程所影响。<br>atomic 包提供的原子操作能够确保任一时刻只有一个goroutine对变量进行操作，善用 atomic 能够避免程序中出现大量的锁操作。<br><strong>常见操作：</strong></p>\n<ul>\n<li>增减Add     AddInt32 AddInt64 AddUint32 AddUint64 AddUintptr</li>\n<li>载入Load    LoadInt32 LoadInt64    LoadPointer    LoadUint32    LoadUint64    LoadUintptr</li>\n<li>比较并交换   CompareAndSwap    CompareAndSwapInt32…</li>\n<li>交换Swap    SwapInt32…</li>\n<li>存储Store    StoreInt32…</li>\n</ul>\n<h3 id=\"Goroutine-的底层实现原理\"><a href=\"#Goroutine-的底层实现原理\" class=\"headerlink\" title=\"Goroutine 的底层实现原理\"></a>Goroutine 的底层实现原理</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">g本质是一个数据结构,真正让 goroutine 运行起来的是调度器</span><br><span class=\"line\"><span class=\"keyword\">type</span> g <span class=\"keyword\">struct</span> &#123; </span><br><span class=\"line\">    goid <span class=\"type\">int64</span>  <span class=\"comment\">// 唯一的goroutine的ID </span></span><br><span class=\"line\">    sched gobuf <span class=\"comment\">// goroutine切换时，用于保存g的上下文 </span></span><br><span class=\"line\">    stack stack <span class=\"comment\">// 栈 </span></span><br><span class=\"line\">    gopc <span class=\"comment\">// pc of go statement that created this goroutine </span></span><br><span class=\"line\">    startpc <span class=\"type\">uintptr</span>  <span class=\"comment\">// pc of goroutine function ... </span></span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"keyword\">type</span> gobuf <span class=\"keyword\">struct</span> &#123;     <span class=\"comment\">//运行时寄存器</span></span><br><span class=\"line\">    sp <span class=\"type\">uintptr</span>  <span class=\"comment\">// 栈指针位置 </span></span><br><span class=\"line\">    pc <span class=\"type\">uintptr</span>  <span class=\"comment\">// 运行到的程序位置 </span></span><br><span class=\"line\">    g  guintptr <span class=\"comment\">// 指向 goroutine </span></span><br><span class=\"line\">    ret <span class=\"type\">uintptr</span> <span class=\"comment\">// 保存系统调用的返回值 ... </span></span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"keyword\">type</span> stack <span class=\"keyword\">struct</span> &#123;     <span class=\"comment\">//运行时栈</span></span><br><span class=\"line\">    lo <span class=\"type\">uintptr</span>  <span class=\"comment\">// 栈的下界内存地址 </span></span><br><span class=\"line\">    hi <span class=\"type\">uintptr</span>  <span class=\"comment\">// 栈的上界内存地址 </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><h3 id=\"goroutine-和线程的区别\"><a href=\"#goroutine-和线程的区别\" class=\"headerlink\" title=\"goroutine 和线程的区别\"></a>goroutine 和线程的区别</h3><p>内存占用:<br>创建一个 goroutine 的栈内存消耗为 2 KB，实际运行过程中，如果栈空间不够用，会自动进行扩容。创建一个 thread 则需要消耗 1 MB 栈内存。<br>创建和销毀:<br>Thread 创建和销毀需要陷入内核,系统调用。而 goroutine 因为是由 Go runtime 负责管理的，创建和销毁的消耗非常小，是用户级。<br>切换:<br>当 threads 切换时，需要保存各种寄存器,而 goroutines 切换只需保存三个寄存器：Program Counter, Stack Pointer and BP。一般而言，线程切换会消耗 1000-1500 ns,Goroutine 的切换约为 200 ns,因此，goroutines 切换成本比 threads 要小得多。</p>\n<h3 id=\"Go-线程模型（Go底层怎么实现高并发的）\"><a href=\"#Go-线程模型（Go底层怎么实现高并发的）\" class=\"headerlink\" title=\"Go 线程模型（Go底层怎么实现高并发的）\"></a>Go 线程模型（Go底层怎么实现高并发的）</h3><blockquote>\n<p>线程协程，进程的区别：</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/337978321\">https://zhuanlan.zhihu.com/p/337978321</a></p>\n<p><a href=\"https://www.bilibili.com/read/cv9346691/\">https://www.bilibili.com/read/cv9346691/</a></p>\n</blockquote>\n<p>Golang的调度器是一个轻量级的协程调度器，主要负责管理和调度协程。Golang 中的调度器采用 <strong>M:N 模型</strong>，即 M 个用户级线程对应 N 个内核线程。</p>\n<p>调度器会将 Golang 中的协程（goroutine）调度到不同的线程上运行，以实现并发执行的效果。</p>\n<p>M个线程对应N个内核线程的优点：</p>\n<ul>\n<li>能够利用多核</li>\n<li>上下文切换成本低</li>\n<li>如果进程中的一个线程被阻塞，不会阻塞其他线程，是能够切换同一进程内的其他线程继续执行</li>\n</ul>\n<h3 id=\"Golang-assertion\"><a href=\"#Golang-assertion\" class=\"headerlink\" title=\"Golang assertion\"></a>Golang assertion</h3><h2 id=\"Golang调用方面\"><a href=\"#Golang调用方面\" class=\"headerlink\" title=\"Golang调用方面\"></a>Golang调用方面</h2><h3 id=\"len-统计长度\"><a href=\"#len-统计长度\" class=\"headerlink\" title=\"len 统计长度\"></a>len 统计长度</h3><p><font color = 'red'>len()计算的是字节的长度，和编码无关，对于英文和数组对象等，字节长度等效于实际长度</font><br>当需要计算中文字符长度的时候，就需要调用其他的函数方法：<br><code>utf8.RuneCountInString(&quot;中文&quot;)</code></p>\n","site":{"data":{}},"cover":"/img/cover/elderring.png","cover_type":"img","excerpt":"","more":"<h1 id=\"Golang-系统知识回答收集\"><a href=\"#Golang-系统知识回答收集\" class=\"headerlink\" title=\"Golang 系统知识回答收集\"></a>Golang 系统知识回答收集</h1><h2 id=\"Golang-语法方面\"><a href=\"#Golang-语法方面\" class=\"headerlink\" title=\"Golang 语法方面\"></a>Golang 语法方面</h2><h3 id=\"Golang关键字有哪些\"><a href=\"#Golang关键字有哪些\" class=\"headerlink\" title=\"Golang关键字有哪些\"></a>Golang关键字有哪些</h3><h3 id=\"Golang-当中\"><a href=\"#Golang-当中\" class=\"headerlink\" title=\"Golang 当中\"></a>Golang 当中</h3><p>关键字是指被编程语言用作特定目的的保留单词，这些关键字在代码当中具有特殊的含义，不能被用作标识符（例如变量名，函数名，类型名等）。以下是Golang中关键字的列表</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span></span> </span><br><span class=\"line\"><span class=\"keyword\">type</span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> </span><br><span class=\"line\"><span class=\"keyword\">struct</span> </span><br><span class=\"line\"><span class=\"keyword\">var</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">break</span> <span class=\"keyword\">continue</span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">default</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">case</span> </span><br><span class=\"line\"><span class=\"keyword\">select</span></span><br><span class=\"line\"><span class=\"keyword\">defer</span></span><br><span class=\"line\"><span class=\"keyword\">switch</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> </span><br><span class=\"line\"><span class=\"keyword\">range</span> </span><br><span class=\"line\"><span class=\"keyword\">goto</span></span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\"><span class=\"keyword\">if</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span></span><br><span class=\"line\"><span class=\"keyword\">chan</span> </span><br><span class=\"line\"><span class=\"keyword\">map</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span></span><br><span class=\"line\"><span class=\"keyword\">package</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">go</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fallthrough</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"range-函数的具体使用\"><a href=\"#range-函数的具体使用\" class=\"headerlink\" title=\"range 函数的具体使用\"></a>range 函数的具体使用</h3><p>golang当中range 关键字可以用于迭代数组、切片、字符串、map和通道等数据类型</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//迭代数组和切片时候，返回当前元素的索引和值</span></span><br><span class=\"line\">arr := [<span class=\"number\">3</span>]<span class=\"type\">int</span>&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> key,num := <span class=\"keyword\">range</span> arr&#123;</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;now arr[%d] is %d\\n&quot;</span>, key,num)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// map 迭代字符串的时候，每次迭代返回当前字符的索引和Unicode码点</span></span><br><span class=\"line\"></span><br><span class=\"line\">s := <span class=\"string\">&quot;hello world&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i, c := <span class=\"keyword\">range</span> s&#123;</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;index:%d, Unicode code ponit : %U\\n&quot;</span>,i,c)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//迭代map结构</span></span><br><span class=\"line\">m := <span class=\"keyword\">map</span>[<span class=\"type\">int</span>]<span class=\"type\">string</span>&#123;</span><br><span class=\"line\">\t<span class=\"number\">1</span>: <span class=\"string\">&quot;one&quot;</span>,</span><br><span class=\"line\">\t<span class=\"number\">2</span>: <span class=\"string\">&quot;two&quot;</span>,</span><br><span class=\"line\">\t<span class=\"number\">3</span>: <span class=\"string\">&quot;three&quot;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> k,v := <span class=\"keyword\">range</span> m&#123;</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;key : %d, value : %s&quot;</span>,k,v)</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//迭代通道使用range 迭代通道的时候，会不断地从通道当中接受元素，直到通道关闭为止</span></span><br><span class=\"line\"></span><br><span class=\"line\">ch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\"><span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>;i&lt;<span class=\"number\">5</span>,i++&#123;</span><br><span class=\"line\">\tch &lt;- i</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">close</span>(ch)</span><br><span class=\"line\">&#125;()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> v := <span class=\"keyword\">range</span> ch &#123;</span><br><span class=\"line\">\tfmt.Println(v)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在迭代通道的时候，如果通道没有关闭，那么循环就会一直等待下去，知道程序死锁，因此必须要再写入完所有的数据之后关闭通道，或者使用’select’语句在接受通道数据的时候检查通道是否已经关闭</p>\n<h3 id=\"Slice-扩容机制\"><a href=\"#Slice-扩容机制\" class=\"headerlink\" title=\"Slice 扩容机制\"></a>Slice 扩容机制</h3><p>Go 1.18 版本之后，当新切片需要的容量cap大于两倍扩容的容量时候，则直接按照新切片需要的容量进行扩容：</p>\n<ul>\n<li>当原 Slice 容量 &lt; threshold 的时候，新 slice 容量变成原来的2 倍</li>\n<li>当原 Slice 容量 &gt; threshold 的时候，进入一个循环，每次容量增加 （旧容量 + 3*threshold）/4</li>\n</ul>\n<h3 id=\"Slice-为什么不是线程安全的\"><a href=\"#Slice-为什么不是线程安全的\" class=\"headerlink\" title=\"Slice 为什么不是线程安全的\"></a>Slice 为什么不是线程安全的</h3><p>因为 Slice 内部使用了底层数组，数组在内存当中是连续存储的并没有加锁的机制，本身并不支持并发的读写</p>\n<p>当多个Goroutine并发访问同一个Slice的时候，可能存在某个Goroutine修改了Slice中的某个元素，其他Goroutine无法立即看到这个修改，也可能会造成竞争问题。可以通过使用((20230318150223-agvrll2 “互斥锁”))或者((20230318154221-miv3alf “原子操作”))来保证某个Goroutine访问的时候其他goroutine不能够同时访问，另外也可以使用通道来进行同步，通过将Slice的访问权限交给某个Goroutine，从而保障其他的Goroutine无法同时访问该Slice。</p>\n<h3 id=\"map的底层原理\"><a href=\"#map的底层原理\" class=\"headerlink\" title=\"map的底层原理\"></a>map的底层原理</h3><p>map对象本身是一个指针，占用8个字节（64位计算机），指向<code>hmap</code>结构体，hmap包含多个bmap数组（桶）</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> hmap <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">\tcount <span class=\"type\">int</span> <span class=\"comment\">// 元素个数，调用len(map)的时候直接返回</span></span><br><span class=\"line\">\tflags <span class=\"type\">uint8</span> <span class=\"comment\">// 标志当前map的状态，正在删除元素、添加元素、、、、</span></span><br><span class=\"line\">\tB <span class=\"type\">uint8</span> <span class=\"comment\">//单元(buckets)的对数 B=5表示能容纳32个元素  B随着map容量增大而变大</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tnoverflow <span class=\"type\">uint16</span>  <span class=\"comment\">//单元(buckets)溢出数量，如果一个单元能存8个key，此时存储了9个，溢出了，就需要再增加一个单元</span></span><br><span class=\"line\">\thash0 <span class=\"type\">uint32</span> <span class=\"comment\">//哈希种子</span></span><br><span class=\"line\">\tbuckets unsafe.Pointer <span class=\"comment\">//指向单元(buckets)数组,大小为2^B，可以为nil</span></span><br><span class=\"line\">\toldbuckets unsafe.Pointer <span class=\"comment\">//扩容的时候，buckets长度会是oldbuckets的两倍</span></span><br><span class=\"line\">\tnevacute <span class=\"type\">uintptr</span>  <span class=\"comment\">//指示扩容进度，小于此buckets迁移完成 </span></span><br><span class=\"line\">\textra *mapextra <span class=\"comment\">//与gc相关 可选字段 </span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> bmap <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">\ttophash [bucketCnt]<span class=\"type\">uint8</span> </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//实际上编译期间会生成一个新的数据结构  </span></span><br><span class=\"line\"><span class=\"keyword\">type</span> bmap <span class=\"keyword\">struct</span> &#123; </span><br><span class=\"line\">    topbits [<span class=\"number\">8</span>]<span class=\"type\">uint8</span>     <span class=\"comment\">//key hash值前8位 用于快速定位keys的位置</span></span><br><span class=\"line\">    keys [<span class=\"number\">8</span>]keytype     <span class=\"comment\">//键</span></span><br><span class=\"line\">    values [<span class=\"number\">8</span>]valuetype <span class=\"comment\">//值</span></span><br><span class=\"line\">    pad <span class=\"type\">uintptr</span> </span><br><span class=\"line\">    overflow <span class=\"type\">uintptr</span>     <span class=\"comment\">//指向溢出桶 无符号整形 优化GC</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"map的扩容机制\"><a href=\"#map的扩容机制\" class=\"headerlink\" title=\"map的扩容机制\"></a>map的扩容机制</h3><p>扩容时机：向map里面插入新的key的时候，会进行条件检测，符合以下两个条件就会触发扩容操作：</p>\n<p>扩容条件：</p>\n<ol>\n<li>超过负载 map元素个数 &gt; 负载因子 * 桶个数</li>\n<li>溢出桶太多</li>\n</ol>\n<p>负载因子是元素个数与桶的数量的比值</p>\n<p>当桶总数&lt;2^15^时，如果溢出桶总数&gt;=桶总数，则认为溢出桶过多</p>\n<p>当桶总数&gt;2^15^时，如果溢出桶总数&gt;=2^15^，则认为溢出桶过多</p>\n<p>扩容机制：</p>\n<ul>\n<li><p>双倍扩容：针对条件1，新建一个buckets数组，新的buckets大小是原来的2倍，然后旧buckets数据搬迁到新的buckets。</p>\n</li>\n<li><p>等量扩容：针对条件2，并不扩大容量，buckets数量维持不变，重新做一遍类似双倍扩容的搬迁动作，把松散的键值对重新排列一次，使得同一个 bucket 中的 key 排列地更紧密，节省空间，提高 bucket 利用率，进而保证更快的存取。</p>\n</li>\n<li><p>渐进式扩容： 插入修改删除key的时候，都会尝试进行搬迁桶的工作，每次都会检查oldbucket是否<strong>nil</strong>，如果不是<strong>nil</strong>则每次搬迁<strong>2</strong>个桶，蚂蚁搬家一样渐进式扩容</p>\n</li>\n</ul>\n<h3 id=\"map的遍历为什么无序\"><a href=\"#map的遍历为什么无序\" class=\"headerlink\" title=\"map的遍历为什么无序\"></a>map的遍历为什么无序</h3><p>map  每次遍历，都会从一个随机值序号的桶开始，再从其中随机的cell 开始遍历，并且扩容后，原来桶中的key会落到其他的桶中，本身就会造成失序。</p>\n<p>如果想要遍历map，先把key放到切片中排序，再按照key的顺序遍历map</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//请写一段代码验证</span></span><br><span class=\"line\">m := <span class=\"keyword\">map</span>[<span class=\"type\">int</span>]<span class=\"type\">string</span> &#123;</span><br><span class=\"line\">\t<span class=\"number\">1</span>: <span class=\"string\">&quot;one&quot;</span>,</span><br><span class=\"line\">\t<span class=\"number\">2</span>: <span class=\"string\">&quot;two&quot;</span>,</span><br><span class=\"line\">\t<span class=\"number\">3</span>: <span class=\"string\">&quot;three&quot;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> key,value := <span class=\"keyword\">range</span> m&#123;</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">&quot;data is : %d ---&gt; %S \\n&quot;</span>, key,value)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"map的底层存储不是连续的\"><a href=\"#map的底层存储不是连续的\" class=\"headerlink\" title=\"map的底层存储不是连续的\"></a>map的底层存储不是连续的</h3><p>具体来说map 内部存储的是一个桶（bucket）数组，桶数组中的每个元素有事一个指向链表头的指针，他存储的数据并不连续</p>\n<h3 id=\"map-为什么不是线程安全的\"><a href=\"#map-为什么不是线程安全的\" class=\"headerlink\" title=\"map 为什么不是线程安全的\"></a>map 为什么不是线程安全的</h3><p>多个协程同时对<strong>map</strong>进行并发读写**,<strong>程序会</strong>panic**</p>\n<p>想要线程安全，可以使用sync.RWLock锁</p>\n<p>在sync.map 这个包当中实现了锁，是线程安全的</p>\n<h3 id=\"Map如何查找\"><a href=\"#Map如何查找\" class=\"headerlink\" title=\"Map如何查找\"></a>Map如何查找</h3><ol>\n<li>计算hash值<br> key经过哈希函数计算后,得到64bit(64位CPU)<br> 10010111 | 101011101010110101010101101010101010 | 10010</li>\n<li>找到hash对应的桶<br> 上面64位后5(hmap的B值)位定位所存放的桶<br> 如果当前正在扩容中,并且定位到旧桶数据还未完成迁移,则使用旧的桶</li>\n<li>遍历桶查找<br> 上面64位前8位用来在tophash数组查找快速判断key是否在当前的桶中,如果不在需要去溢出桶查找</li>\n<li>返回key对应的指针</li>\n</ol>\n<h3 id=\"map-冲突解决的方式\"><a href=\"#map-冲突解决的方式\" class=\"headerlink\" title=\"map 冲突解决的方式\"></a>map 冲突解决的方式</h3><p>Go采用链式地址解决冲突，具体实现就是插入key到map中时，当key定位的桶填满8个元素，将会创建一个溢出桶并且将溢出桶插入到当前桶所在的链表尾部</p>\n<p>Golang当中采用链式哈希表（Cahined Hash Table）</p>\n<p>在Golang的哈希表实现当中，每一个桶就是一个链表的头指针，桶内每个元素都是哈希链表节点，节点包含了该元素的哈希值、键以及指向下一个节点的指针。</p>\n<p>在查找时候，先根据键的哈希值找到对应的桶，然后在该桶对应的链表中顺序查找，指导找到目标元素或者是链表遍历完毕。</p>\n<h3 id=\"map-的负载因子为什么时6-5\"><a href=\"#map-的负载因子为什么时6-5\" class=\"headerlink\" title=\"map 的负载因子为什么时6.5\"></a>map 的负载因子为什么时6.5</h3><blockquote>\n<p>负载因子 = 哈希表存储的元素个数 / 桶个数</p>\n</blockquote>\n<p>Go 官方发现：装载因子越大，填入的元素越多，空间利用率就越高，但发生哈希冲突的几率就变大。<br>装载因子越小，填入的元素越少，冲突发生的几率减小，但空间浪费也会变得更多，而且还会提高扩容操作的次数</p>\n<p>Go 官方取了一个相对适中的值，把 Go 中的 map 的负载因子硬编码为 6.5，这就是 6.5 的选择缘由。</p>\n<p>这意味着在 Go 语言中，当 map存储的元素个数大于或等于 6.5 * 桶个数 时，就会触发扩容行为。</p>\n<h3 id=\"Map和-Sync-Map哪一个性能好\"><a href=\"#Map和-Sync-Map哪一个性能好\" class=\"headerlink\" title=\"Map和 Sync.Map哪一个性能好\"></a>Map和 Sync.Map哪一个性能好</h3><p>对比原始map：</p>\n<p>和原始map+RWLock的实现并发的方式相比，减少了加锁对性能的影响。</p>\n<p>它做了一些优化：可以无锁访问read map，而且会优先操作read map，倘若只操作read map就可以满足要求，那就不用去操作write map(dirty)，所以在某些特定场景中它发生锁竞争的频率会远远小于map+RWLock的实现方式</p>\n<ul>\n<li>优点：<br>适合读多写少的场景</li>\n<li>缺点：<br>写多的场景，会导致 read map 缓存失效，需要加锁，冲突变多，性能急剧下降</li>\n</ul>\n<h3 id=\"channel-底层实现原理\"><a href=\"#channel-底层实现原理\" class=\"headerlink\" title=\"channel 底层实现原理\"></a>channel 底层实现原理</h3><p>通过<strong>var****声明或者是</strong>​<strong>make****函数创建的channel变量</strong>是一个存储在函数栈帧上的指针，占用8个字节，指向堆上的hchan结构体</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> hchan <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">\tclosed <span class=\"type\">uint32</span> <span class=\"comment\">// channel 是否关闭的标志</span></span><br><span class=\"line\">\telemtype *_type <span class=\"comment\">// channel 中的元素类型</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tbuf unsafe.Pointer <span class=\"comment\">//指向底层循环数组的指针（环形缓存区）</span></span><br><span class=\"line\">\tqcount <span class=\"type\">uint</span> <span class=\"comment\">// 循环数组中的元素数量</span></span><br><span class=\"line\">\tdataqsiz <span class=\"type\">uint</span> <span class=\"comment\">//循环数组的长度</span></span><br><span class=\"line\">\telemsize <span class=\"type\">uint16</span> <span class=\"comment\">//元素的大小</span></span><br><span class=\"line\">\tsendx <span class=\"type\">uint</span> <span class=\"comment\">// 下一次写下标的位置</span></span><br><span class=\"line\">\trecvx <span class=\"type\">uint</span> <span class=\"comment\">// 下一次读下标的位置</span></span><br><span class=\"line\">\t<span class=\"comment\">// 尝试读取channel 或者向channel 写入数据而被阻塞的goroutine</span></span><br><span class=\"line\">    \trecvq    waitq  <span class=\"comment\">// 读等待队列</span></span><br><span class=\"line\">    \tsendq    waitq  <span class=\"comment\">// 写等待队列</span></span><br><span class=\"line\">    \tlock mutex <span class=\"comment\">//互斥锁，保证读写channel时不存在并发竞争问题</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>channel 分为无缓冲和有缓冲两种</p>\n<ul>\n<li><p>对于有缓冲的channel存储数据，使用了ring buffer(环形缓冲区) 来缓存写入的数据，本质是循环数组。</p>\n<p>为啥是循环数组呢？普通数组不行吗，普通数组容量固定，更适合指定的空间，弹出元素的时候，普通数组需要全部前移。</p>\n<p><code>当下标超过数组容量后会回到第一个位置，所以需要有两个字段记录当前读和写的下标位置</code></p>\n</li>\n<li><p>对于无缓冲的channel 存储数据</p>\n</li>\n</ul>\n<p>等待队列： </p>\n<p>双向链表，包含一个头结点和一个尾结点 每个节点是一个sudog结构体变量，记录哪个协程在等待，等待的是哪个channel，等待发送**/**接收的数据在哪里</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> wait <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">\tfirst *sudog</span><br><span class=\"line\">\tlast *sudog</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> sudog <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">\tg *g</span><br><span class=\"line\">\tnext *sudog</span><br><span class=\"line\">\tpre  *sudog</span><br><span class=\"line\">\telem unsafe.Pointer</span><br><span class=\"line\">\tc  *hchan</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>创建 channel 的时候：</p>\n<p>创建时会做一些检查**:** </p>\n<ul>\n<li>元素大小不能超过 <strong>64</strong>K</li>\n<li>元素的对齐大小不能超过 maxAlign 也就是 <strong>8</strong> 字节</li>\n<li>计算出来的内存是否超过限制</li>\n</ul>\n<p>创建时的策略:</p>\n<ul>\n<li><p>如果是无缓冲的channel，会直接给hchan 分配内存</p>\n</li>\n<li><p>如果是有缓冲的channel，并且元素不包含指针，那么会为 hchan  和底层数组分配一段连续的地址</p>\n</li>\n<li><p>如果是有缓冲的channel，元素包含指针，那么就会为了hchan 和底层数组分别分配地址</p>\n</li>\n</ul>\n<p>发送时：</p>\n<ul>\n<li><p>如果 channel 的读队列存在着接收者 goroutine，将唤醒接收的goroutine，将数据<strong>直接发送</strong>给第一个等待的 goroutine</p>\n</li>\n<li><p>如果channel 的读等待队列不存在接收者 goroutine</p>\n<ul>\n<li>如果循环数组buffer未满，那么将会把数据发送到循环数组buffer的队尾</li>\n<li>如果循环数组buffer已满，这个时候就会阻塞发送的流程，将当前goroutine加入写等待队列，<strong>并挂起等待唤醒</strong></li>\n</ul>\n</li>\n</ul>\n<p>接收时：</p>\n<ul>\n<li><p>如果 channel 的写等待队列存在发送者 goroutine</p>\n<ul>\n<li>如果是无缓冲 channel ，<strong>直接</strong>从第一个发送者goroutine 那里 把数据拷贝给接受变量，<strong>唤醒 发送的goroutine</strong></li>\n<li>如果是有缓冲的 channel（已满），将循环数组的buffer的队首元素拷贝给接受变量，将第一个发送者goroutine的数据拷贝到buffer循环数组的队尾，<strong>唤醒发送的goroutine</strong></li>\n</ul>\n</li>\n<li><p>如果channel 的写等待队列不存在发送者goroutine</p>\n<ul>\n<li>如果循环数组buffer非空，将循环数组buffer的队首元素拷贝给接受变量</li>\n<li>如果循环数组buffer为空，这个时候就会阻塞接收的流程，将当前goroutine 加入读等待队列，并<strong>挂起等待唤醒</strong></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"channel-有什么特点\"><a href=\"#channel-有什么特点\" class=\"headerlink\" title=\"channel 有什么特点\"></a>channel 有什么特点</h3><p>channel是线程安全的</p>\n<p>channel 有两种类型： 无缓冲、有缓冲</p>\n<p>channel 有三种模式： 写操作模式（单向通道）、读操作模式（单向通道）、读写操作模式（双向通道）</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">写操作模式    <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span>&lt;- <span class=\"type\">int</span>)</span><br><span class=\"line\">读操作模式    <span class=\"built_in\">make</span>(&lt;-<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\">读写操作模式    <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br></pre></td></tr></table></figure>\n\n<p>channel 有 3 种状态：未初始化、正常、关闭</p>\n<table>\n<thead>\n<tr>\n<th>操作 \\ 状态</th>\n<th>未初始化</th>\n<th>关闭</th>\n<th>正常</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>关闭</td>\n<td>panic</td>\n<td>panic</td>\n<td>正常</td>\n</tr>\n<tr>\n<td>发送</td>\n<td>永远阻塞导致死锁</td>\n<td>panic</td>\n<td>阻塞或者成功发送</td>\n</tr>\n<tr>\n<td>接收</td>\n<td>永远阻塞导致死锁</td>\n<td>缓冲区为空则为零值，否则可以继续读</td>\n<td>阻塞或者成功接收</td>\n</tr>\n</tbody></table>\n<p>注意点：</p>\n<ul>\n<li><p>一个 channel不能多次关闭，会导致painc</p>\n</li>\n<li><p>如果多个 goroutine 都监听同一个 channel，那么 channel 上的数据都可能随机被某一个 goroutine 取走进行消费</p>\n</li>\n<li><p>如果多个 goroutine 监听同一个 channel，如果这个 channel 被关闭，则所有 goroutine 都能收到退出信号</p>\n</li>\n</ul>\n<h3 id=\"Channel-的使用场景\"><a href=\"#Channel-的使用场景\" class=\"headerlink\" title=\"Channel 的使用场景\"></a>Channel 的使用场景</h3><p>无缓冲 Channel 在并发编程中的具体业务使用场景很多，主要应用于 Go 语言中。以下是一些常见的无缓冲 Channel 的具体业务使用场景及例子：</p>\n<ol>\n<li>并发控制：在并发程序中，通过无缓冲 Channel 可以实现多个 Goroutine 之间的<strong>同步和控制</strong>。例如，一个任务需要多个协程协作完成时，可以使用无缓冲 Channel 来传递任务数据和控制信号。</li>\n<li>事件驱动：在事件驱动的编程中，可以使用无缓冲 Channel 来传递事件和执行结果。例如，当一个 HTTP 请求到达时，可以将请求交给一个协程处理，并使用无缓冲 Channel 返回处理结果。</li>\n<li>分布式计算：在分布式计算中，可以使用无缓冲 Channel 来实现节点之间的通信和数据传递。例如，在 MapReduce 算法中，可以使用无缓冲 Channel 来传递 Map 阶段的输出结果并驱动 Reduce 阶段的计算。</li>\n</ol>\n<p>有缓冲 Channel 在并发编程中的具体业务使用场景也很多，主要应用于 Go 语言中。以下是一些常见的有缓冲 Channel 的具体业务使用场景及例子：</p>\n<ol>\n<li>网络编程：在 TCP 或 UDP 数据处理中，可以使用有缓冲 Channel 缓存数据，<strong>以避免因数据接收太慢而导致发送者被阻塞</strong>。例如，在高并发的 Web 服务器中，可以使用有缓冲 Channel 缓存请求数据以提高吞吐量。</li>\n<li>IO 操作：在使用 IO 操作时，如文件读写、数据库访问等，可以使用有缓冲 Channel 缓存数据，以避免因数据处理速度不匹配而导致发送者或接收者被阻塞。例如，<strong>在从数据库获取大量数据时，可以使用有缓冲 Channel 缓存数据，减少数据库连接次数。</strong></li>\n<li>并发控制：在并发程序中，通过有缓冲 Channel 可以实现多个 Goroutine 之间的同步和控制。例如，一个任务需要多个协程协作完成时，可以使用有缓冲 Channel 来传递任务数据和控制信号，并根据缓冲区的剩余空间来控制协程的执行顺序。</li>\n<li>事件驱动：在事件驱动的编程中，可以使用有缓冲 Channel 来缓存事件和执行结果，并根据缓冲区的剩余空间来控制事件的处理顺序。例如，当一个 HTTP 请求到达时，可以将请求交给一个协程处理，并使用有缓冲 Channel 缓存处理结果，避免处理速度过慢导致请求被阻塞。</li>\n</ol>\n<h3 id=\"channel-为什么是线程安全的\"><a href=\"#channel-为什么是线程安全的\" class=\"headerlink\" title=\"channel 为什么是线程安全的\"></a>channel 为什么是线程安全的</h3><p>不同协程通过channel进行通信，本身的使用场景就是多线程，为了保证数据的一致性，必须实现线程安全</p>\n<p>channel的底层实现中，hchan结构体中采用Mutex锁来保证数据读写安全。在对循环数组buf中的数据进行入队和出队操作时，必须先获取互斥锁，才能操作channel数据</p>\n<h3 id=\"Channel-发送和接收什么情况下会死锁\"><a href=\"#Channel-发送和接收什么情况下会死锁\" class=\"headerlink\" title=\"Channel 发送和接收什么情况下会死锁\"></a>Channel 发送和接收什么情况下会死锁</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">deadlock1</span><span class=\"params\">()</span></span> &#123;    <span class=\"comment\">//无缓冲channel只写不读</span></span><br><span class=\"line\">    ch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>) </span><br><span class=\"line\">    ch &lt;- <span class=\"number\">3</span> <span class=\"comment\">//  这里会发生一直阻塞的情况，执行不到下面一句</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">deadlock2</span><span class=\"params\">()</span></span> &#123; <span class=\"comment\">//无缓冲channel读在写后面</span></span><br><span class=\"line\">    ch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\">    ch &lt;- <span class=\"number\">3</span>  <span class=\"comment\">//  这里会发生一直阻塞的情况，执行不到下面一句</span></span><br><span class=\"line\">    num := &lt;-ch</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;num=&quot;</span>, num)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">deadlock3</span><span class=\"params\">()</span></span> &#123; <span class=\"comment\">//无缓冲channel读在写后面</span></span><br><span class=\"line\">    ch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\">    ch &lt;- <span class=\"number\">100</span> <span class=\"comment\">//  这里会发生一直阻塞的情况，执行不到下面一句</span></span><br><span class=\"line\">    <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        num := &lt;-ch</span><br><span class=\"line\">        fmt.Println(<span class=\"string\">&quot;num=&quot;</span>, num)</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">    time.Sleep(time.Second)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">deadlock3</span><span class=\"params\">()</span></span> &#123;    <span class=\"comment\">//有缓冲channel写入超过缓冲区数量</span></span><br><span class=\"line\">    ch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\">    ch &lt;- <span class=\"number\">3</span></span><br><span class=\"line\">    ch &lt;- <span class=\"number\">4</span></span><br><span class=\"line\">    ch &lt;- <span class=\"number\">5</span></span><br><span class=\"line\">    ch &lt;- <span class=\"number\">6</span>  <span class=\"comment\">//  这里会发生一直阻塞的情况</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">deadlock4</span><span class=\"params\">()</span></span> &#123;    <span class=\"comment\">//空读</span></span><br><span class=\"line\">    ch := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\">    <span class=\"comment\">// ch := make(chan int, 1)</span></span><br><span class=\"line\">    fmt.Println(&lt;-ch)  <span class=\"comment\">//  这里会发生一直阻塞的情况</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">deadlock5</span><span class=\"params\">()</span></span> &#123;    <span class=\"comment\">//互相等对方造成死锁</span></span><br><span class=\"line\">    ch1 := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\">    ch2 := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"type\">int</span>)</span><br><span class=\"line\">    <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> num := &lt;-ch1:</span><br><span class=\"line\">            fmt.Println(<span class=\"string\">&quot;num=&quot;</span>, num)</span><br><span class=\"line\">            ch2 &lt;- <span class=\"number\">100</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#125;()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">select</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> num := &lt;-ch2:</span><br><span class=\"line\">            fmt.Println(<span class=\"string\">&quot;num=&quot;</span>, num)</span><br><span class=\"line\">            ch1 &lt;- <span class=\"number\">300</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"互斥锁实现原理\"><a href=\"#互斥锁实现原理\" class=\"headerlink\" title=\"互斥锁实现原理\"></a>互斥锁实现原理</h3><p>Go sync包提供了两种锁类型：互斥锁sync.Mutex 和 读写互斥锁sync.RWMutex，都属于((20230402113517-ppcs0gj “悲观锁”))。<br><a href=\"https://blog.csdn.net/baolingye/article/details/111357407\">https://blog.csdn.net/baolingye/article/details/111357407</a></p>\n<p>在正常模式下，<strong>锁的等待者会按照先进先出的顺序获取锁</strong>。但是刚被唤起的 Goroutine 与新创建的 Goroutine 竞争时，大概率会获取不到锁，在这种情况下，这个被唤醒的 Goroutine 会加入到等待队列的前面。 如果一个等待的 Goroutine 超过1ms 没有获取锁，那么它将会把锁转变为<strong>饥饿模式</strong>。<br>Go在1.9中引入优化，目的保证互斥锁的公平性。在饥饿模式中，互斥锁会直接交给等待队列最前面的 Goroutine。新的 Goroutine 在该状态下不能获取锁、也不会进入自旋状态，它们只会在队列的末尾等待。如果一个 Goroutine 获得了互斥锁并且它在队列的末尾或者它等待的时间少于 1ms，那么当前的互斥锁就会切换回正常模式。</p>\n<h3 id=\"悲观锁与乐观锁\"><a href=\"#悲观锁与乐观锁\" class=\"headerlink\" title=\"悲观锁与乐观锁\"></a>悲观锁与乐观锁</h3><p><strong>悲观锁</strong>是基于一种悲观的态度类来防止一切数据冲突，它是以一种预防的姿态在<strong>修改数据之前把数据锁住，然后再对数据进行读写，在它释放锁之前任何人都不能对其数据进行操作，直到前面一个人把锁释放后下一个人数据加锁才可对数据进行加锁，</strong>然后才可以对数据进行操作，一般数据库本身锁的机制都是基于悲观锁的机制实现的;</p>\n<p>特点：可以完全保证数据的独占性和正确性，因为每次请求都会先对数据进行加锁， 然后进行数据操作，最后再解锁，而加锁释放锁的过程会造成消耗，所以性能不高;</p>\n<p><strong>乐观锁</strong>是对于数据冲突保持一种乐观态度，操作数据时不会对操作的数据进行加锁（这使得多个任务可以并行的对数据进行操作），只有到数据提交的时候才通过一种机制来验证数据是否存在冲突(一般实现方式是通过加版本号然后进行版本号的对比方式实现);</p>\n<p>特点：乐观锁是一种并发类型的锁，其本身不对数据进行加锁通而是通过业务实现锁的功能，不对数据进行加锁就意味着允许多个请求同时访问数据，同时也省掉了对数据加锁和解锁的过程，这种方式因为节省了悲观锁加锁的操作，所以可以一定程度的的提高操作的性能，不过在并发非常高的情况下，会导致大量的请求冲突，冲突导致大部分操作无功而返而浪费资源，所以在高并发的场景下，乐观锁的性能却反而不如悲观锁。</p>\n<h3 id=\"原子操作和锁的区别\"><a href=\"#原子操作和锁的区别\" class=\"headerlink\" title=\"原子操作和锁的区别\"></a>原子操作和锁的区别</h3><p>在并发编程里，Go语言<code>sync</code>包里的同步原语<code>Mutex</code>是我们经常用来保证并发安全的，那么他跟<code>atomic</code>包里的这些操作有啥区别呢？在我看来他们在使用目的和底层实现上都不一样：</p>\n<ul>\n<li>使用目的：互斥锁是用来保护一段逻辑，原子操作用于对一个变量的更新保护。</li>\n<li>底层实现：<code>Mutex</code>由<strong>操作系统</strong>的调度器实现，而<code>atomic</code>包中的原子操作则由<strong>底层硬件指令</strong>直接提供支持，这些指令在执行的过程中是不允许中断的，因此原子操作可以在<code>lock-free</code>的情况下保证并发安全，并且它的性能也能做到随<code>CPU</code>个数的增多而线性扩展。</li>\n</ul>\n<h3 id=\"互斥锁允许自旋的条件\"><a href=\"#互斥锁允许自旋的条件\" class=\"headerlink\" title=\"互斥锁允许自旋的条件\"></a>互斥锁允许自旋的条件</h3><p>线程没有获取到锁时常见有2种处理方式：</p>\n<ul>\n<li>一种是没有获取到锁的线程就会循环等待判断该资源是否已经释放锁，这种锁也叫做自旋锁，它不用将线程阻塞起来， 适用于并发低且程序执行时间短的场景，缺点是cpu占用较高</li>\n<li>另外一种处理方式就是把自己阻塞起来，会释放CPU给其他线程，内核会将线程置为「睡眠」状态，等到锁被释放后，内核会在合适的时机唤醒该线程，适用于高并发场景，缺点是有线程上下文切换的开销<br>Go语言中的Mutex实现了自旋与阻塞两种场景，当满足不了自旋条件时，就会进入阻塞<br><strong>允许自旋的条件：</strong></li>\n</ul>\n<ol>\n<li>锁已被占用，并且锁不处于饥饿模式。</li>\n<li>积累的自旋次数小于最大自旋次数（active_spin=4）。</li>\n<li>cpu 核数大于 1。</li>\n<li>有空闲的 P。</li>\n<li>当前 goroutine 所挂载的 P 下，本地待运行队列为空。</li>\n</ol>\n<h3 id=\"读写锁的实现原理\"><a href=\"#读写锁的实现原理\" class=\"headerlink\" title=\"读写锁的实现原理\"></a>读写锁的实现原理</h3><p>读写锁的底层是基于互斥锁实现的。<br>写锁需要阻塞写锁：一个协程拥有写锁时，其他协程写锁定需要阻塞；<br>写锁需要阻塞读锁：一个协程拥有写锁时，其他协程读锁定需要阻塞；<br>读锁需要阻塞写锁：一个协程拥有读锁时，其他协程写锁定需要阻塞；<br><strong>读锁不能阻塞读锁：一个协程拥有读锁时，其他协程也可以拥有读锁。</strong></p>\n<h3 id=\"“原子操作”有哪些\"><a href=\"#“原子操作”有哪些\" class=\"headerlink\" title=\"“原子操作”有哪些\"></a>“原子操作”有哪些</h3><p>Go atomic包是最轻量级的锁（也称无锁结构），可以在不形成临界区和创建互斥量的情况下完成并发安全的值替换操作，不过这个包只支持int32/int64/uint32/uint64/uintptr这几种数据类型的一些基础操作（增减、交换、载入、存储等）<br>当我们想要对<strong>某个变量</strong>并发安全的修改，除了使用官方提供的 <code>mutex</code>，还可以使用 sync/atomic 包的原子操作，它能够保证对变量的读取或修改期间不被其他的协程所影响。<br>atomic 包提供的原子操作能够确保任一时刻只有一个goroutine对变量进行操作，善用 atomic 能够避免程序中出现大量的锁操作。<br><strong>常见操作：</strong></p>\n<ul>\n<li>增减Add     AddInt32 AddInt64 AddUint32 AddUint64 AddUintptr</li>\n<li>载入Load    LoadInt32 LoadInt64    LoadPointer    LoadUint32    LoadUint64    LoadUintptr</li>\n<li>比较并交换   CompareAndSwap    CompareAndSwapInt32…</li>\n<li>交换Swap    SwapInt32…</li>\n<li>存储Store    StoreInt32…</li>\n</ul>\n<h3 id=\"Goroutine-的底层实现原理\"><a href=\"#Goroutine-的底层实现原理\" class=\"headerlink\" title=\"Goroutine 的底层实现原理\"></a>Goroutine 的底层实现原理</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">g本质是一个数据结构,真正让 goroutine 运行起来的是调度器</span><br><span class=\"line\"><span class=\"keyword\">type</span> g <span class=\"keyword\">struct</span> &#123; </span><br><span class=\"line\">    goid <span class=\"type\">int64</span>  <span class=\"comment\">// 唯一的goroutine的ID </span></span><br><span class=\"line\">    sched gobuf <span class=\"comment\">// goroutine切换时，用于保存g的上下文 </span></span><br><span class=\"line\">    stack stack <span class=\"comment\">// 栈 </span></span><br><span class=\"line\">    gopc <span class=\"comment\">// pc of go statement that created this goroutine </span></span><br><span class=\"line\">    startpc <span class=\"type\">uintptr</span>  <span class=\"comment\">// pc of goroutine function ... </span></span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"keyword\">type</span> gobuf <span class=\"keyword\">struct</span> &#123;     <span class=\"comment\">//运行时寄存器</span></span><br><span class=\"line\">    sp <span class=\"type\">uintptr</span>  <span class=\"comment\">// 栈指针位置 </span></span><br><span class=\"line\">    pc <span class=\"type\">uintptr</span>  <span class=\"comment\">// 运行到的程序位置 </span></span><br><span class=\"line\">    g  guintptr <span class=\"comment\">// 指向 goroutine </span></span><br><span class=\"line\">    ret <span class=\"type\">uintptr</span> <span class=\"comment\">// 保存系统调用的返回值 ... </span></span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"keyword\">type</span> stack <span class=\"keyword\">struct</span> &#123;     <span class=\"comment\">//运行时栈</span></span><br><span class=\"line\">    lo <span class=\"type\">uintptr</span>  <span class=\"comment\">// 栈的下界内存地址 </span></span><br><span class=\"line\">    hi <span class=\"type\">uintptr</span>  <span class=\"comment\">// 栈的上界内存地址 </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><h3 id=\"goroutine-和线程的区别\"><a href=\"#goroutine-和线程的区别\" class=\"headerlink\" title=\"goroutine 和线程的区别\"></a>goroutine 和线程的区别</h3><p>内存占用:<br>创建一个 goroutine 的栈内存消耗为 2 KB，实际运行过程中，如果栈空间不够用，会自动进行扩容。创建一个 thread 则需要消耗 1 MB 栈内存。<br>创建和销毀:<br>Thread 创建和销毀需要陷入内核,系统调用。而 goroutine 因为是由 Go runtime 负责管理的，创建和销毁的消耗非常小，是用户级。<br>切换:<br>当 threads 切换时，需要保存各种寄存器,而 goroutines 切换只需保存三个寄存器：Program Counter, Stack Pointer and BP。一般而言，线程切换会消耗 1000-1500 ns,Goroutine 的切换约为 200 ns,因此，goroutines 切换成本比 threads 要小得多。</p>\n<h3 id=\"Go-线程模型（Go底层怎么实现高并发的）\"><a href=\"#Go-线程模型（Go底层怎么实现高并发的）\" class=\"headerlink\" title=\"Go 线程模型（Go底层怎么实现高并发的）\"></a>Go 线程模型（Go底层怎么实现高并发的）</h3><blockquote>\n<p>线程协程，进程的区别：</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/337978321\">https://zhuanlan.zhihu.com/p/337978321</a></p>\n<p><a href=\"https://www.bilibili.com/read/cv9346691/\">https://www.bilibili.com/read/cv9346691/</a></p>\n</blockquote>\n<p>Golang的调度器是一个轻量级的协程调度器，主要负责管理和调度协程。Golang 中的调度器采用 <strong>M:N 模型</strong>，即 M 个用户级线程对应 N 个内核线程。</p>\n<p>调度器会将 Golang 中的协程（goroutine）调度到不同的线程上运行，以实现并发执行的效果。</p>\n<p>M个线程对应N个内核线程的优点：</p>\n<ul>\n<li>能够利用多核</li>\n<li>上下文切换成本低</li>\n<li>如果进程中的一个线程被阻塞，不会阻塞其他线程，是能够切换同一进程内的其他线程继续执行</li>\n</ul>\n<h3 id=\"Golang-assertion\"><a href=\"#Golang-assertion\" class=\"headerlink\" title=\"Golang assertion\"></a>Golang assertion</h3><h2 id=\"Golang调用方面\"><a href=\"#Golang调用方面\" class=\"headerlink\" title=\"Golang调用方面\"></a>Golang调用方面</h2><h3 id=\"len-统计长度\"><a href=\"#len-统计长度\" class=\"headerlink\" title=\"len 统计长度\"></a>len 统计长度</h3><p><font color = 'red'>len()计算的是字节的长度，和编码无关，对于英文和数组对象等，字节长度等效于实际长度</font><br>当需要计算中文字符长度的时候，就需要调用其他的函数方法：<br><code>utf8.RuneCountInString(&quot;中文&quot;)</code></p>\n"},{"title":"Golang Common Knowledege","catalog":true,"date":"2023-04-09T11:24:25.000Z","subtitle":null,"header-img":null,"published":0,"_content":"\n# Golang 常用量\n\n\n\n# Golang 常用函数调用\n\n","source":"_posts/Go/Golang-Common-Knowledege/Golang-Common-Knowledege.md","raw":"---\ntitle: Golang Common Knowledege\ncatalog: true\ndate: 2023-04-09 19:24:25\nsubtitle:\nheader-img:\ntags:\ncategories: Golang\npublished: false\n---\n\n# Golang 常用量\n\n\n\n# Golang 常用函数调用\n\n","slug":"Go/Golang-Common-Knowledege/Golang-Common-Knowledege","updated":"2023-04-22T13:24:02.216Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgtm6jqo001dlyjx2e1h15jx","content":"<h1 id=\"Golang-常用量\"><a href=\"#Golang-常用量\" class=\"headerlink\" title=\"Golang 常用量\"></a>Golang 常用量</h1><h1 id=\"Golang-常用函数调用\"><a href=\"#Golang-常用函数调用\" class=\"headerlink\" title=\"Golang 常用函数调用\"></a>Golang 常用函数调用</h1>","site":{"data":{}},"cover":"/img/cover/2077_city.png","cover_type":"img","excerpt":"","more":"<h1 id=\"Golang-常用量\"><a href=\"#Golang-常用量\" class=\"headerlink\" title=\"Golang 常用量\"></a>Golang 常用量</h1><h1 id=\"Golang-常用函数调用\"><a href=\"#Golang-常用函数调用\" class=\"headerlink\" title=\"Golang 常用函数调用\"></a>Golang 常用函数调用</h1>"},{"title":"Golang moudle","catalog":true,"date":"2023-04-09T17:47:36.000Z","subtitle":null,"header-img":null,"published":0,"_content":"\n\n# \n\n## strconv\n[strconv](/source/_posts/cn/Go/Golang-moudle/strconv.md)","source":"_posts/Go/Golang-moudle/Golang-moudle.md","raw":"---\ntitle: Golang moudle\ncatalog: true\ndate: 2023-04-10 01:47:36\nsubtitle:\nheader-img:\ntags:\ncategories: index\npublished: false\n---\n\n\n# \n\n## strconv\n[strconv](/source/_posts/cn/Go/Golang-moudle/strconv.md)","slug":"Go/Golang-moudle/Golang-moudle","updated":"2023-04-22T13:24:02.216Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgtm6jqo001elyjxekujfw8p","content":"<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h1><h2 id=\"strconv\"><a href=\"#strconv\" class=\"headerlink\" title=\"strconv\"></a>strconv</h2><p><a href=\"/source/_posts/cn/Go/Golang-moudle/strconv.md\">strconv</a></p>\n","site":{"data":{}},"cover":"/img/cover/elderring.png","cover_type":"img","excerpt":"","more":"<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h1><h2 id=\"strconv\"><a href=\"#strconv\" class=\"headerlink\" title=\"strconv\"></a>strconv</h2><p><a href=\"/source/_posts/cn/Go/Golang-moudle/strconv.md\">strconv</a></p>\n"},{"title":"strconv","catalog":true,"date":"2023-04-09T17:47:36.000Z","subtitle":null,"header-img":null,"published":0,"_content":"\n# Strconv 常用方法汇总\n> 主要参考官方文章：[strconv](https://pkg.go.dev/strconv#pkg-index)\n> \n## 类型转换\n\n``` golang\n// 字符串到整数的转换\n    fmt.Println(strconv.Atoi(\"123\")) // 123\n        // 整数到字符串的转换\n    fmt.Println(strconv.Itoa(12345)) // \"12345\"\n\n    // 字符串转其他进制的整数\n    fmt.Println(strconv.ParseInt(\"1100100\", 2, 0))  // 100\n    fmt.Println(strconv.ParseInt(\"7D0\", 16, 0))    // 2000\n    fmt.Println(strconv.ParseInt(\"2147483648\", 10, 64))   // 2147483648\n    fmt.Println(strconv.ParseUint(\"FFFFFFFFFFFFFFFF\", 16, 64)) // 18446744073709551615\n\n    // 其他进制的整数转字符串\n    fmt.Println(strconv.FormatInt(100, 2)) // \"1100100\"\n    fmt.Println(strconv.FormatInt(2000, 16)) // \"7d0\"\n    fmt.Println(strconv.FormatUint(2147483648, 10)) // \"2147483648\"\n\n    // 字符串到浮点数的转换\n    fmt.Println(strconv.ParseFloat(\"3.1415\", 64)) // 3.1415\n\n    // 浮点数到字符串的转换\n    fmt.Println(strconv.FormatFloat(3.1415, 'E', -1, 64)) // 3.141500E+00\n\n    // 输出类型为 bool 的数值字符串\n    fmt.Println(strconv.ParseBool(\"true\"))  // true\n    fmt.Println(strconv.ParseBool(\"False\")) // false\n\n    // 布尔型到字符串的转换\n    fmt.Println(strconv.FormatBool(true)) // \"true\"\n    fmt.Println(strconv.FormatBool(false)) // \"false\"\n```\n\n## 进制转化\n\n``` golang\n    // 十进制转二进制\n    fmt.Printf(\"%b\", 17) // 10001\n\n    // 十进制转十六进制\n    fmt.Printf(\"%x\", 17) // 11\n\n    // 十六进制转十进制\n    i, _ := strconv.ParseInt(\"11\", 16, 0)\n    fmt.Println(i) // 17\n\n    // 十六进制转二进制\n    i, _ = strconv.ParseInt(\"11\", 16, 0)\n    fmt.Printf(\"%b\", i) // 10001\n\n    // 二进制转十进制\n    i, _ = strconv.ParseInt(\"10001\", 2, 0)\n    fmt.Println(i) // 17\n\n    // 二进制转十六进制\n    i, _ = strconv.ParseInt(\"10001\", 2, 0)\n    fmt.Printf(\"%x\", i) // 11\n```","source":"_posts/Go/Golang-moudle/strconv.md","raw":"---\ntitle: strconv\ncatalog: true\ndate: 2023-04-10 01:47:36\nsubtitle:\nheader-img:\ntags:\ncategories: index\npublished: false\n---\n\n# Strconv 常用方法汇总\n> 主要参考官方文章：[strconv](https://pkg.go.dev/strconv#pkg-index)\n> \n## 类型转换\n\n``` golang\n// 字符串到整数的转换\n    fmt.Println(strconv.Atoi(\"123\")) // 123\n        // 整数到字符串的转换\n    fmt.Println(strconv.Itoa(12345)) // \"12345\"\n\n    // 字符串转其他进制的整数\n    fmt.Println(strconv.ParseInt(\"1100100\", 2, 0))  // 100\n    fmt.Println(strconv.ParseInt(\"7D0\", 16, 0))    // 2000\n    fmt.Println(strconv.ParseInt(\"2147483648\", 10, 64))   // 2147483648\n    fmt.Println(strconv.ParseUint(\"FFFFFFFFFFFFFFFF\", 16, 64)) // 18446744073709551615\n\n    // 其他进制的整数转字符串\n    fmt.Println(strconv.FormatInt(100, 2)) // \"1100100\"\n    fmt.Println(strconv.FormatInt(2000, 16)) // \"7d0\"\n    fmt.Println(strconv.FormatUint(2147483648, 10)) // \"2147483648\"\n\n    // 字符串到浮点数的转换\n    fmt.Println(strconv.ParseFloat(\"3.1415\", 64)) // 3.1415\n\n    // 浮点数到字符串的转换\n    fmt.Println(strconv.FormatFloat(3.1415, 'E', -1, 64)) // 3.141500E+00\n\n    // 输出类型为 bool 的数值字符串\n    fmt.Println(strconv.ParseBool(\"true\"))  // true\n    fmt.Println(strconv.ParseBool(\"False\")) // false\n\n    // 布尔型到字符串的转换\n    fmt.Println(strconv.FormatBool(true)) // \"true\"\n    fmt.Println(strconv.FormatBool(false)) // \"false\"\n```\n\n## 进制转化\n\n``` golang\n    // 十进制转二进制\n    fmt.Printf(\"%b\", 17) // 10001\n\n    // 十进制转十六进制\n    fmt.Printf(\"%x\", 17) // 11\n\n    // 十六进制转十进制\n    i, _ := strconv.ParseInt(\"11\", 16, 0)\n    fmt.Println(i) // 17\n\n    // 十六进制转二进制\n    i, _ = strconv.ParseInt(\"11\", 16, 0)\n    fmt.Printf(\"%b\", i) // 10001\n\n    // 二进制转十进制\n    i, _ = strconv.ParseInt(\"10001\", 2, 0)\n    fmt.Println(i) // 17\n\n    // 二进制转十六进制\n    i, _ = strconv.ParseInt(\"10001\", 2, 0)\n    fmt.Printf(\"%x\", i) // 11\n```","slug":"Go/Golang-moudle/strconv","updated":"2023-04-22T13:24:02.216Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgtm6jqp001hlyjx0dlc1u5r","content":"<h1 id=\"Strconv-常用方法汇总\"><a href=\"#Strconv-常用方法汇总\" class=\"headerlink\" title=\"Strconv 常用方法汇总\"></a>Strconv 常用方法汇总</h1><blockquote>\n<p>主要参考官方文章：<a href=\"https://pkg.go.dev/strconv#pkg-index\">strconv</a></p>\n</blockquote>\n<h2 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h2><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 字符串到整数的转换</span></span><br><span class=\"line\">    fmt.Println(strconv.Atoi(<span class=\"string\">&quot;123&quot;</span>)) <span class=\"comment\">// 123</span></span><br><span class=\"line\">        <span class=\"comment\">// 整数到字符串的转换</span></span><br><span class=\"line\">    fmt.Println(strconv.Itoa(<span class=\"number\">12345</span>)) <span class=\"comment\">// &quot;12345&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 字符串转其他进制的整数</span></span><br><span class=\"line\">    fmt.Println(strconv.ParseInt(<span class=\"string\">&quot;1100100&quot;</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>))  <span class=\"comment\">// 100</span></span><br><span class=\"line\">    fmt.Println(strconv.ParseInt(<span class=\"string\">&quot;7D0&quot;</span>, <span class=\"number\">16</span>, <span class=\"number\">0</span>))    <span class=\"comment\">// 2000</span></span><br><span class=\"line\">    fmt.Println(strconv.ParseInt(<span class=\"string\">&quot;2147483648&quot;</span>, <span class=\"number\">10</span>, <span class=\"number\">64</span>))   <span class=\"comment\">// 2147483648</span></span><br><span class=\"line\">    fmt.Println(strconv.ParseUint(<span class=\"string\">&quot;FFFFFFFFFFFFFFFF&quot;</span>, <span class=\"number\">16</span>, <span class=\"number\">64</span>)) <span class=\"comment\">// 18446744073709551615</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 其他进制的整数转字符串</span></span><br><span class=\"line\">    fmt.Println(strconv.FormatInt(<span class=\"number\">100</span>, <span class=\"number\">2</span>)) <span class=\"comment\">// &quot;1100100&quot;</span></span><br><span class=\"line\">    fmt.Println(strconv.FormatInt(<span class=\"number\">2000</span>, <span class=\"number\">16</span>)) <span class=\"comment\">// &quot;7d0&quot;</span></span><br><span class=\"line\">    fmt.Println(strconv.FormatUint(<span class=\"number\">2147483648</span>, <span class=\"number\">10</span>)) <span class=\"comment\">// &quot;2147483648&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 字符串到浮点数的转换</span></span><br><span class=\"line\">    fmt.Println(strconv.ParseFloat(<span class=\"string\">&quot;3.1415&quot;</span>, <span class=\"number\">64</span>)) <span class=\"comment\">// 3.1415</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 浮点数到字符串的转换</span></span><br><span class=\"line\">    fmt.Println(strconv.FormatFloat(<span class=\"number\">3.1415</span>, <span class=\"string\">&#x27;E&#x27;</span>, <span class=\"number\">-1</span>, <span class=\"number\">64</span>)) <span class=\"comment\">// 3.141500E+00</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 输出类型为 bool 的数值字符串</span></span><br><span class=\"line\">    fmt.Println(strconv.ParseBool(<span class=\"string\">&quot;true&quot;</span>))  <span class=\"comment\">// true</span></span><br><span class=\"line\">    fmt.Println(strconv.ParseBool(<span class=\"string\">&quot;False&quot;</span>)) <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 布尔型到字符串的转换</span></span><br><span class=\"line\">    fmt.Println(strconv.FormatBool(<span class=\"literal\">true</span>)) <span class=\"comment\">// &quot;true&quot;</span></span><br><span class=\"line\">    fmt.Println(strconv.FormatBool(<span class=\"literal\">false</span>)) <span class=\"comment\">// &quot;false&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"进制转化\"><a href=\"#进制转化\" class=\"headerlink\" title=\"进制转化\"></a>进制转化</h2><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 十进制转二进制</span></span><br><span class=\"line\">fmt.Printf(<span class=\"string\">&quot;%b&quot;</span>, <span class=\"number\">17</span>) <span class=\"comment\">// 10001</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 十进制转十六进制</span></span><br><span class=\"line\">fmt.Printf(<span class=\"string\">&quot;%x&quot;</span>, <span class=\"number\">17</span>) <span class=\"comment\">// 11</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 十六进制转十进制</span></span><br><span class=\"line\">i, _ := strconv.ParseInt(<span class=\"string\">&quot;11&quot;</span>, <span class=\"number\">16</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">fmt.Println(i) <span class=\"comment\">// 17</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 十六进制转二进制</span></span><br><span class=\"line\">i, _ = strconv.ParseInt(<span class=\"string\">&quot;11&quot;</span>, <span class=\"number\">16</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">&quot;%b&quot;</span>, i) <span class=\"comment\">// 10001</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 二进制转十进制</span></span><br><span class=\"line\">i, _ = strconv.ParseInt(<span class=\"string\">&quot;10001&quot;</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">fmt.Println(i) <span class=\"comment\">// 17</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 二进制转十六进制</span></span><br><span class=\"line\">i, _ = strconv.ParseInt(<span class=\"string\">&quot;10001&quot;</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">&quot;%x&quot;</span>, i) <span class=\"comment\">// 11</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"cover":"/img/cover/2077_city.png","cover_type":"img","excerpt":"","more":"<h1 id=\"Strconv-常用方法汇总\"><a href=\"#Strconv-常用方法汇总\" class=\"headerlink\" title=\"Strconv 常用方法汇总\"></a>Strconv 常用方法汇总</h1><blockquote>\n<p>主要参考官方文章：<a href=\"https://pkg.go.dev/strconv#pkg-index\">strconv</a></p>\n</blockquote>\n<h2 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h2><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 字符串到整数的转换</span></span><br><span class=\"line\">    fmt.Println(strconv.Atoi(<span class=\"string\">&quot;123&quot;</span>)) <span class=\"comment\">// 123</span></span><br><span class=\"line\">        <span class=\"comment\">// 整数到字符串的转换</span></span><br><span class=\"line\">    fmt.Println(strconv.Itoa(<span class=\"number\">12345</span>)) <span class=\"comment\">// &quot;12345&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 字符串转其他进制的整数</span></span><br><span class=\"line\">    fmt.Println(strconv.ParseInt(<span class=\"string\">&quot;1100100&quot;</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>))  <span class=\"comment\">// 100</span></span><br><span class=\"line\">    fmt.Println(strconv.ParseInt(<span class=\"string\">&quot;7D0&quot;</span>, <span class=\"number\">16</span>, <span class=\"number\">0</span>))    <span class=\"comment\">// 2000</span></span><br><span class=\"line\">    fmt.Println(strconv.ParseInt(<span class=\"string\">&quot;2147483648&quot;</span>, <span class=\"number\">10</span>, <span class=\"number\">64</span>))   <span class=\"comment\">// 2147483648</span></span><br><span class=\"line\">    fmt.Println(strconv.ParseUint(<span class=\"string\">&quot;FFFFFFFFFFFFFFFF&quot;</span>, <span class=\"number\">16</span>, <span class=\"number\">64</span>)) <span class=\"comment\">// 18446744073709551615</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 其他进制的整数转字符串</span></span><br><span class=\"line\">    fmt.Println(strconv.FormatInt(<span class=\"number\">100</span>, <span class=\"number\">2</span>)) <span class=\"comment\">// &quot;1100100&quot;</span></span><br><span class=\"line\">    fmt.Println(strconv.FormatInt(<span class=\"number\">2000</span>, <span class=\"number\">16</span>)) <span class=\"comment\">// &quot;7d0&quot;</span></span><br><span class=\"line\">    fmt.Println(strconv.FormatUint(<span class=\"number\">2147483648</span>, <span class=\"number\">10</span>)) <span class=\"comment\">// &quot;2147483648&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 字符串到浮点数的转换</span></span><br><span class=\"line\">    fmt.Println(strconv.ParseFloat(<span class=\"string\">&quot;3.1415&quot;</span>, <span class=\"number\">64</span>)) <span class=\"comment\">// 3.1415</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 浮点数到字符串的转换</span></span><br><span class=\"line\">    fmt.Println(strconv.FormatFloat(<span class=\"number\">3.1415</span>, <span class=\"string\">&#x27;E&#x27;</span>, <span class=\"number\">-1</span>, <span class=\"number\">64</span>)) <span class=\"comment\">// 3.141500E+00</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 输出类型为 bool 的数值字符串</span></span><br><span class=\"line\">    fmt.Println(strconv.ParseBool(<span class=\"string\">&quot;true&quot;</span>))  <span class=\"comment\">// true</span></span><br><span class=\"line\">    fmt.Println(strconv.ParseBool(<span class=\"string\">&quot;False&quot;</span>)) <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 布尔型到字符串的转换</span></span><br><span class=\"line\">    fmt.Println(strconv.FormatBool(<span class=\"literal\">true</span>)) <span class=\"comment\">// &quot;true&quot;</span></span><br><span class=\"line\">    fmt.Println(strconv.FormatBool(<span class=\"literal\">false</span>)) <span class=\"comment\">// &quot;false&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"进制转化\"><a href=\"#进制转化\" class=\"headerlink\" title=\"进制转化\"></a>进制转化</h2><figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 十进制转二进制</span></span><br><span class=\"line\">fmt.Printf(<span class=\"string\">&quot;%b&quot;</span>, <span class=\"number\">17</span>) <span class=\"comment\">// 10001</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 十进制转十六进制</span></span><br><span class=\"line\">fmt.Printf(<span class=\"string\">&quot;%x&quot;</span>, <span class=\"number\">17</span>) <span class=\"comment\">// 11</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 十六进制转十进制</span></span><br><span class=\"line\">i, _ := strconv.ParseInt(<span class=\"string\">&quot;11&quot;</span>, <span class=\"number\">16</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">fmt.Println(i) <span class=\"comment\">// 17</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 十六进制转二进制</span></span><br><span class=\"line\">i, _ = strconv.ParseInt(<span class=\"string\">&quot;11&quot;</span>, <span class=\"number\">16</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">&quot;%b&quot;</span>, i) <span class=\"comment\">// 10001</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 二进制转十进制</span></span><br><span class=\"line\">i, _ = strconv.ParseInt(<span class=\"string\">&quot;10001&quot;</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">fmt.Println(i) <span class=\"comment\">// 17</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 二进制转十六进制</span></span><br><span class=\"line\">i, _ = strconv.ParseInt(<span class=\"string\">&quot;10001&quot;</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">&quot;%x&quot;</span>, i) <span class=\"comment\">// 11</span></span><br></pre></td></tr></table></figure>"},{"title":"Golang 使用链表","catalog":true,"date":"2023-03-27T16:34:11.000Z","subtitle":null,"header-img":null,"published":0,"_content":"\n# Golang 链表的使用\n\n链表是通过指针串联在一起的线性结构，每一个节点都包含两个部分的内容：指针域和数据域；指针域用于存储指向其他节点的指针变量\n\n对于链表而言有俩个最重要的概念：\n* head\n* head.Next\n\n在操作链表的时候非常容易将移动指针和操作节点内容弄混，首先 Head *ListNode 是一个指向节点的指针，本身是一个地址；Head.Next 是节点内的指针变量用于指向其他的节点。当我们在遍历链表结构的时候不断移动的是 Head 变量，而如果要对链表的结构进行改动，就需要修改 Head.Next 的值为其他的节点地址。\n\n但有一个非常简单的方法可以识别出对指针的操作以及他的身份: \n1. Next/Pre(节点内值) 变量在**等号左边**必定是增删修改节点位置，一定要想清楚当前使用Next的节点是哪一个; 在**等号右边**一般就是移动指针的位置，但没有改变链表的结构 \n2. Head 在**等号左边**必定是改变指针位置，移动到其他的节点； 在**等号右边**一般是改变链表的结构或者是让其他的节点指向当前节点。  \n\n所以要改变链表的结构，Head.Next的值一定会改变且在循环中出现在等号的左边，Head 本身应该理解为一个地址指针用于指向要操作内容的节点\n\n\n\n# Golang 链表算法使用\n> leetcode 题目汇总：\n> [1] [https://leetcode.cn/problems/remove-nth-node-from-end-of-list/solution/shan-chu-lian-biao-de-dao-shu-di-nge-jie-dian-b-61/ ]\n>\n\n\n","source":"_posts/Go/Golang-使用链表/Golang-使用链表.md","raw":"---\ntitle: Golang 使用链表\ncatalog: true\ndate: 2023-03-28 00:34:11\nsubtitle:\nheader-img:\ntags: Golang, List\ncategories:\npublished: false\n---\n\n# Golang 链表的使用\n\n链表是通过指针串联在一起的线性结构，每一个节点都包含两个部分的内容：指针域和数据域；指针域用于存储指向其他节点的指针变量\n\n对于链表而言有俩个最重要的概念：\n* head\n* head.Next\n\n在操作链表的时候非常容易将移动指针和操作节点内容弄混，首先 Head *ListNode 是一个指向节点的指针，本身是一个地址；Head.Next 是节点内的指针变量用于指向其他的节点。当我们在遍历链表结构的时候不断移动的是 Head 变量，而如果要对链表的结构进行改动，就需要修改 Head.Next 的值为其他的节点地址。\n\n但有一个非常简单的方法可以识别出对指针的操作以及他的身份: \n1. Next/Pre(节点内值) 变量在**等号左边**必定是增删修改节点位置，一定要想清楚当前使用Next的节点是哪一个; 在**等号右边**一般就是移动指针的位置，但没有改变链表的结构 \n2. Head 在**等号左边**必定是改变指针位置，移动到其他的节点； 在**等号右边**一般是改变链表的结构或者是让其他的节点指向当前节点。  \n\n所以要改变链表的结构，Head.Next的值一定会改变且在循环中出现在等号的左边，Head 本身应该理解为一个地址指针用于指向要操作内容的节点\n\n\n\n# Golang 链表算法使用\n> leetcode 题目汇总：\n> [1] [https://leetcode.cn/problems/remove-nth-node-from-end-of-list/solution/shan-chu-lian-biao-de-dao-shu-di-nge-jie-dian-b-61/ ]\n>\n\n\n","slug":"Go/Golang-使用链表/Golang-使用链表","updated":"2023-04-22T13:24:02.236Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgtm6jqq001klyjxbxycfvbo","content":"<h1 id=\"Golang-链表的使用\"><a href=\"#Golang-链表的使用\" class=\"headerlink\" title=\"Golang 链表的使用\"></a>Golang 链表的使用</h1><p>链表是通过指针串联在一起的线性结构，每一个节点都包含两个部分的内容：指针域和数据域；指针域用于存储指向其他节点的指针变量</p>\n<p>对于链表而言有俩个最重要的概念：</p>\n<ul>\n<li>head</li>\n<li>head.Next</li>\n</ul>\n<p>在操作链表的时候非常容易将移动指针和操作节点内容弄混，首先 Head *ListNode 是一个指向节点的指针，本身是一个地址；Head.Next 是节点内的指针变量用于指向其他的节点。当我们在遍历链表结构的时候不断移动的是 Head 变量，而如果要对链表的结构进行改动，就需要修改 Head.Next 的值为其他的节点地址。</p>\n<p>但有一个非常简单的方法可以识别出对指针的操作以及他的身份: </p>\n<ol>\n<li>Next/Pre(节点内值) 变量在<strong>等号左边</strong>必定是增删修改节点位置，一定要想清楚当前使用Next的节点是哪一个; 在<strong>等号右边</strong>一般就是移动指针的位置，但没有改变链表的结构 </li>\n<li>Head 在<strong>等号左边</strong>必定是改变指针位置，移动到其他的节点； 在<strong>等号右边</strong>一般是改变链表的结构或者是让其他的节点指向当前节点。  </li>\n</ol>\n<p>所以要改变链表的结构，Head.Next的值一定会改变且在循环中出现在等号的左边，Head 本身应该理解为一个地址指针用于指向要操作内容的节点</p>\n<h1 id=\"Golang-链表算法使用\"><a href=\"#Golang-链表算法使用\" class=\"headerlink\" title=\"Golang 链表算法使用\"></a>Golang 链表算法使用</h1><blockquote>\n<p>leetcode 题目汇总：<br>[1] [<a href=\"https://leetcode.cn/problems/remove-nth-node-from-end-of-list/solution/shan-chu-lian-biao-de-dao-shu-di-nge-jie-dian-b-61/\">https://leetcode.cn/problems/remove-nth-node-from-end-of-list/solution/shan-chu-lian-biao-de-dao-shu-di-nge-jie-dian-b-61/</a> ]</p>\n</blockquote>\n","site":{"data":{}},"cover":"/img/cover/elderring.png","cover_type":"img","excerpt":"","more":"<h1 id=\"Golang-链表的使用\"><a href=\"#Golang-链表的使用\" class=\"headerlink\" title=\"Golang 链表的使用\"></a>Golang 链表的使用</h1><p>链表是通过指针串联在一起的线性结构，每一个节点都包含两个部分的内容：指针域和数据域；指针域用于存储指向其他节点的指针变量</p>\n<p>对于链表而言有俩个最重要的概念：</p>\n<ul>\n<li>head</li>\n<li>head.Next</li>\n</ul>\n<p>在操作链表的时候非常容易将移动指针和操作节点内容弄混，首先 Head *ListNode 是一个指向节点的指针，本身是一个地址；Head.Next 是节点内的指针变量用于指向其他的节点。当我们在遍历链表结构的时候不断移动的是 Head 变量，而如果要对链表的结构进行改动，就需要修改 Head.Next 的值为其他的节点地址。</p>\n<p>但有一个非常简单的方法可以识别出对指针的操作以及他的身份: </p>\n<ol>\n<li>Next/Pre(节点内值) 变量在<strong>等号左边</strong>必定是增删修改节点位置，一定要想清楚当前使用Next的节点是哪一个; 在<strong>等号右边</strong>一般就是移动指针的位置，但没有改变链表的结构 </li>\n<li>Head 在<strong>等号左边</strong>必定是改变指针位置，移动到其他的节点； 在<strong>等号右边</strong>一般是改变链表的结构或者是让其他的节点指向当前节点。  </li>\n</ol>\n<p>所以要改变链表的结构，Head.Next的值一定会改变且在循环中出现在等号的左边，Head 本身应该理解为一个地址指针用于指向要操作内容的节点</p>\n<h1 id=\"Golang-链表算法使用\"><a href=\"#Golang-链表算法使用\" class=\"headerlink\" title=\"Golang 链表算法使用\"></a>Golang 链表算法使用</h1><blockquote>\n<p>leetcode 题目汇总：<br>[1] [<a href=\"https://leetcode.cn/problems/remove-nth-node-from-end-of-list/solution/shan-chu-lian-biao-de-dao-shu-di-nge-jie-dian-b-61/\">https://leetcode.cn/problems/remove-nth-node-from-end-of-list/solution/shan-chu-lian-biao-de-dao-shu-di-nge-jie-dian-b-61/</a> ]</p>\n</blockquote>\n"},{"title":"Golang 协程底层原理解析","catalog":true,"date":"2023-03-26T17:09:50.000Z","subtitle":null,"header-img":null,"published":0,"_content":"","source":"_posts/Go/Golang-协程底层原理解析/Golang-协程底层原理解析.md","raw":"---\ntitle: Golang 协程底层原理解析\ncatalog: true\ndate: 2023-03-27 01:09:50\nsubtitle:\nheader-img:\ntags:\ncategories:\npublished: false\n---\n","slug":"Go/Golang-协程底层原理解析/Golang-协程底层原理解析","updated":"2023-04-22T13:24:02.216Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgtm6jqr001llyjxe57ldm8j","content":"","site":{"data":{}},"cover":"/img/cover/elderring.png","cover_type":"img","excerpt":"","more":""},{"title":"Kubernetes 网络插件（CNI）性能测试","catalog":true,"date":"2023-03-26T17:03:57.000Z","subtitle":null,"header-img":null,"published":0,"_content":"","source":"_posts/Kubernetes/Kubernetes-网络插件（CNI）性能测试/Kubernetes-网络插件（CNI）性能测试.md","raw":"---\ntitle: Kubernetes 网络插件（CNI）性能测试\ncatalog: true\ndate: 2023-03-27 01:03:57\nsubtitle:\nheader-img:\ntags:\ncategories:\npublished: false\n---\n","slug":"Kubernetes/Kubernetes-网络插件（CNI）性能测试/Kubernetes-网络插件（CNI）性能测试","updated":"2023-04-22T13:24:02.236Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgtm6jqs001qlyjxd9k3ex0k","content":"","site":{"data":{}},"cover":"/img/cover/2077_city.png","cover_type":"img","excerpt":"","more":""},{"title":"cpolar 使用","catalog":true,"date":"2023-04-18T21:02:23.000Z","subtitle":null,"header-img":null,"published":0,"_content":"\n\n\n使用软件： Cpolar, Nps\n\n[无公网IP，SSH远程连接Linux CentOS【内网穿透】 - cpolar 极点云](https://www.cpolar.com/blog/ssh-remote-linux-centos?channel=0&invite=4M3O)\n\n[cpolar - secure introspectable tunnels to localhost](https://dashboard.cpolar.com/reserved)\n\n","source":"_posts/P2P/cpolar/cpolar 使用.md","raw":"---\ntitle: cpolar 使用\ncatalog: true\ndate: 2023-04-19 05:02:23\nsubtitle:\nheader-img:\ntags: p2p,cpolar\ncategories: p2p\npublished: false\n---\n\n\n\n使用软件： Cpolar, Nps\n\n[无公网IP，SSH远程连接Linux CentOS【内网穿透】 - cpolar 极点云](https://www.cpolar.com/blog/ssh-remote-linux-centos?channel=0&invite=4M3O)\n\n[cpolar - secure introspectable tunnels to localhost](https://dashboard.cpolar.com/reserved)\n\n","slug":"P2P/cpolar/cpolar 使用","updated":"2023-04-23T14:16:40.107Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgtm6jqt001rlyjxbrxeehqm","content":"<p>使用软件： Cpolar, Nps</p>\n<p><a href=\"https://www.cpolar.com/blog/ssh-remote-linux-centos?channel=0&invite=4M3O\">无公网IP，SSH远程连接Linux CentOS【内网穿透】 - cpolar 极点云</a></p>\n<p><a href=\"https://dashboard.cpolar.com/reserved\">cpolar - secure introspectable tunnels to localhost</a></p>\n","site":{"data":{}},"cover":"/img/cover/2077_city.png","cover_type":"img","excerpt":"","more":"<p>使用软件： Cpolar, Nps</p>\n<p><a href=\"https://www.cpolar.com/blog/ssh-remote-linux-centos?channel=0&invite=4M3O\">无公网IP，SSH远程连接Linux CentOS【内网穿透】 - cpolar 极点云</a></p>\n<p><a href=\"https://dashboard.cpolar.com/reserved\">cpolar - secure introspectable tunnels to localhost</a></p>\n"},{"title":"【RPC】Golang 实现简单 RPC","catalog":true,"date":"2023-03-23T18:59:34.000Z","subtitle":null,"header-img":null,"published":0,"_content":"\n# [RPC] Goalng 实现简单的 RPC\n\n## 什么是 RPC \n\n### RPC 定义\nRPC(Remote Procedure Call，远程过程调用)是一种**计算机通信协议**，允许**调用不同进程空间的程序**。RPC 的客户端和服务器可以在一台机器上，也可以在不同的机器上。程序员使用时，就像调用本地程序一样，无需关注内部的实现细节。\n\n### RPC 需要解决的问题\n> core: 为进程运行提供 “overlay” 服务，使得不同团队的进程，不同进程的调用，可以在不同时间、机器、不同规则上实现一体化服务的提供，这对于分布式环境下多个类型公司主体处理同一份数据并给统一团体客户提供多样服务有着重要作用\n>\n> \n\n\n### 设计的简单RPC 需要实现的功能(RoadMap)\n\n参考 (GeeRpc)[https://geektutu.com/post/geerpc.html] 作为基础 rpc 实现\n\n\n\n## 实现服务端和消息编码\n> 目标是：\n> * 使用encoding/gob 实现消息的解编码（序列化和反序列化）\n> * 实现简易的服务端，仅接受消息不处理\n\n\n\n\n---\n\n## 问题集锦\n\n### encode/gob 与 Protobuf\n\n二者都是完成信息做序列化的工作，但是 encode/gob 仅仅是提供了对于Golang语言的支持，要想在不同的平台应用得使用Protobuf\n\n### 什么是工厂模式\n\n\n### Golang 包名字的统一\n\n\n### var _ Codec = (*GobCodec)(nil) 的作用\n> 参考文章：[https://cloud.tencent.com/developer/article/2025793]\n在 Golang 中，var _ 可以用作声明变量但不使用它的占位符。在 var _ Codec = (*GobCodec)(nil) 中，_ 的作用是占位符。它们结合在一起可以起到两个作用：\n\n防止编译器报错：当一个接口类型被定义后，需要确保该接口类型被所有实现都正确实现。编译器可以通过检查是否所有实现都满足该接口的方法来验证这一点。在接口类型和实现之间声明 var _ InterfaceType = (*ImplementType)(nil) 可以防止编译器发出“实现不完整”的警告。\n\n检验类型之间的兼容性：在 var _ Codec = (*GobCodec)(nil) 中，则是要检验 GobCodec 是否实现了 Codec 接口。如果 GobCodec 没有实现 Codec 接口中的所有方法，则编译时将无法通过，从而起到检验类型之间的兼容性的作用。\n\n总之，var _ Codec = (*GobCodec)(nil) 的目的是检验 GobCodec 是否实现了 Codec 接口、避免编译器报错并判断类型之间的兼容性。它通常用于接口类型和实现之间的声明，对于保证代码质量和类型安全是很有帮助的。\n\n","source":"_posts/RPC/【RPC】Golang-实现简单-RPC/【RPC】Golang-实现简单-RPC.md","raw":"---\ntitle: 【RPC】Golang 实现简单 RPC\ncatalog: true\ndate: 2023-03-24 02:59:34\nsubtitle:\nheader-img:\ntags:\ncategories:\npublished: false\n---\n\n# [RPC] Goalng 实现简单的 RPC\n\n## 什么是 RPC \n\n### RPC 定义\nRPC(Remote Procedure Call，远程过程调用)是一种**计算机通信协议**，允许**调用不同进程空间的程序**。RPC 的客户端和服务器可以在一台机器上，也可以在不同的机器上。程序员使用时，就像调用本地程序一样，无需关注内部的实现细节。\n\n### RPC 需要解决的问题\n> core: 为进程运行提供 “overlay” 服务，使得不同团队的进程，不同进程的调用，可以在不同时间、机器、不同规则上实现一体化服务的提供，这对于分布式环境下多个类型公司主体处理同一份数据并给统一团体客户提供多样服务有着重要作用\n>\n> \n\n\n### 设计的简单RPC 需要实现的功能(RoadMap)\n\n参考 (GeeRpc)[https://geektutu.com/post/geerpc.html] 作为基础 rpc 实现\n\n\n\n## 实现服务端和消息编码\n> 目标是：\n> * 使用encoding/gob 实现消息的解编码（序列化和反序列化）\n> * 实现简易的服务端，仅接受消息不处理\n\n\n\n\n---\n\n## 问题集锦\n\n### encode/gob 与 Protobuf\n\n二者都是完成信息做序列化的工作，但是 encode/gob 仅仅是提供了对于Golang语言的支持，要想在不同的平台应用得使用Protobuf\n\n### 什么是工厂模式\n\n\n### Golang 包名字的统一\n\n\n### var _ Codec = (*GobCodec)(nil) 的作用\n> 参考文章：[https://cloud.tencent.com/developer/article/2025793]\n在 Golang 中，var _ 可以用作声明变量但不使用它的占位符。在 var _ Codec = (*GobCodec)(nil) 中，_ 的作用是占位符。它们结合在一起可以起到两个作用：\n\n防止编译器报错：当一个接口类型被定义后，需要确保该接口类型被所有实现都正确实现。编译器可以通过检查是否所有实现都满足该接口的方法来验证这一点。在接口类型和实现之间声明 var _ InterfaceType = (*ImplementType)(nil) 可以防止编译器发出“实现不完整”的警告。\n\n检验类型之间的兼容性：在 var _ Codec = (*GobCodec)(nil) 中，则是要检验 GobCodec 是否实现了 Codec 接口。如果 GobCodec 没有实现 Codec 接口中的所有方法，则编译时将无法通过，从而起到检验类型之间的兼容性的作用。\n\n总之，var _ Codec = (*GobCodec)(nil) 的目的是检验 GobCodec 是否实现了 Codec 接口、避免编译器报错并判断类型之间的兼容性。它通常用于接口类型和实现之间的声明，对于保证代码质量和类型安全是很有帮助的。\n\n","slug":"RPC/【RPC】Golang-实现简单-RPC/【RPC】Golang-实现简单-RPC","updated":"2023-04-22T13:24:02.236Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgtm6jqu001ulyjxa1rf0vjb","content":"<h1 id=\"RPC-Goalng-实现简单的-RPC\"><a href=\"#RPC-Goalng-实现简单的-RPC\" class=\"headerlink\" title=\"[RPC] Goalng 实现简单的 RPC\"></a>[RPC] Goalng 实现简单的 RPC</h1><h2 id=\"什么是-RPC\"><a href=\"#什么是-RPC\" class=\"headerlink\" title=\"什么是 RPC\"></a>什么是 RPC</h2><h3 id=\"RPC-定义\"><a href=\"#RPC-定义\" class=\"headerlink\" title=\"RPC 定义\"></a>RPC 定义</h3><p>RPC(Remote Procedure Call，远程过程调用)是一种<strong>计算机通信协议</strong>，允许<strong>调用不同进程空间的程序</strong>。RPC 的客户端和服务器可以在一台机器上，也可以在不同的机器上。程序员使用时，就像调用本地程序一样，无需关注内部的实现细节。</p>\n<h3 id=\"RPC-需要解决的问题\"><a href=\"#RPC-需要解决的问题\" class=\"headerlink\" title=\"RPC 需要解决的问题\"></a>RPC 需要解决的问题</h3><blockquote>\n<p>core: 为进程运行提供 “overlay” 服务，使得不同团队的进程，不同进程的调用，可以在不同时间、机器、不同规则上实现一体化服务的提供，这对于分布式环境下多个类型公司主体处理同一份数据并给统一团体客户提供多样服务有着重要作用</p>\n</blockquote>\n<h3 id=\"设计的简单RPC-需要实现的功能-RoadMap\"><a href=\"#设计的简单RPC-需要实现的功能-RoadMap\" class=\"headerlink\" title=\"设计的简单RPC 需要实现的功能(RoadMap)\"></a>设计的简单RPC 需要实现的功能(RoadMap)</h3><p>参考 (GeeRpc)[<a href=\"https://geektutu.com/post/geerpc.html]\">https://geektutu.com/post/geerpc.html]</a> 作为基础 rpc 实现</p>\n<h2 id=\"实现服务端和消息编码\"><a href=\"#实现服务端和消息编码\" class=\"headerlink\" title=\"实现服务端和消息编码\"></a>实现服务端和消息编码</h2><blockquote>\n<p>目标是：</p>\n<ul>\n<li>使用encoding/gob 实现消息的解编码（序列化和反序列化）</li>\n<li>实现简易的服务端，仅接受消息不处理</li>\n</ul>\n</blockquote>\n<hr>\n<h2 id=\"问题集锦\"><a href=\"#问题集锦\" class=\"headerlink\" title=\"问题集锦\"></a>问题集锦</h2><h3 id=\"encode-gob-与-Protobuf\"><a href=\"#encode-gob-与-Protobuf\" class=\"headerlink\" title=\"encode/gob 与 Protobuf\"></a>encode/gob 与 Protobuf</h3><p>二者都是完成信息做序列化的工作，但是 encode/gob 仅仅是提供了对于Golang语言的支持，要想在不同的平台应用得使用Protobuf</p>\n<h3 id=\"什么是工厂模式\"><a href=\"#什么是工厂模式\" class=\"headerlink\" title=\"什么是工厂模式\"></a>什么是工厂模式</h3><h3 id=\"Golang-包名字的统一\"><a href=\"#Golang-包名字的统一\" class=\"headerlink\" title=\"Golang 包名字的统一\"></a>Golang 包名字的统一</h3><h3 id=\"var-Codec-GobCodec-nil-的作用\"><a href=\"#var-Codec-GobCodec-nil-的作用\" class=\"headerlink\" title=\"var _ Codec = (*GobCodec)(nil) 的作用\"></a>var _ Codec = (*GobCodec)(nil) 的作用</h3><blockquote>\n<p>参考文章：[<a href=\"https://cloud.tencent.com/developer/article/2025793]\">https://cloud.tencent.com/developer/article/2025793]</a><br>在 Golang 中，var _ 可以用作声明变量但不使用它的占位符。在 var _ Codec = (*GobCodec)(nil) 中，_ 的作用是占位符。它们结合在一起可以起到两个作用：</p>\n</blockquote>\n<p>防止编译器报错：当一个接口类型被定义后，需要确保该接口类型被所有实现都正确实现。编译器可以通过检查是否所有实现都满足该接口的方法来验证这一点。在接口类型和实现之间声明 var _ InterfaceType = (*ImplementType)(nil) 可以防止编译器发出“实现不完整”的警告。</p>\n<p>检验类型之间的兼容性：在 var _ Codec = (*GobCodec)(nil) 中，则是要检验 GobCodec 是否实现了 Codec 接口。如果 GobCodec 没有实现 Codec 接口中的所有方法，则编译时将无法通过，从而起到检验类型之间的兼容性的作用。</p>\n<p>总之，var _ Codec = (*GobCodec)(nil) 的目的是检验 GobCodec 是否实现了 Codec 接口、避免编译器报错并判断类型之间的兼容性。它通常用于接口类型和实现之间的声明，对于保证代码质量和类型安全是很有帮助的。</p>\n","site":{"data":{}},"cover":"/img/cover/2077_city.png","cover_type":"img","excerpt":"","more":"<h1 id=\"RPC-Goalng-实现简单的-RPC\"><a href=\"#RPC-Goalng-实现简单的-RPC\" class=\"headerlink\" title=\"[RPC] Goalng 实现简单的 RPC\"></a>[RPC] Goalng 实现简单的 RPC</h1><h2 id=\"什么是-RPC\"><a href=\"#什么是-RPC\" class=\"headerlink\" title=\"什么是 RPC\"></a>什么是 RPC</h2><h3 id=\"RPC-定义\"><a href=\"#RPC-定义\" class=\"headerlink\" title=\"RPC 定义\"></a>RPC 定义</h3><p>RPC(Remote Procedure Call，远程过程调用)是一种<strong>计算机通信协议</strong>，允许<strong>调用不同进程空间的程序</strong>。RPC 的客户端和服务器可以在一台机器上，也可以在不同的机器上。程序员使用时，就像调用本地程序一样，无需关注内部的实现细节。</p>\n<h3 id=\"RPC-需要解决的问题\"><a href=\"#RPC-需要解决的问题\" class=\"headerlink\" title=\"RPC 需要解决的问题\"></a>RPC 需要解决的问题</h3><blockquote>\n<p>core: 为进程运行提供 “overlay” 服务，使得不同团队的进程，不同进程的调用，可以在不同时间、机器、不同规则上实现一体化服务的提供，这对于分布式环境下多个类型公司主体处理同一份数据并给统一团体客户提供多样服务有着重要作用</p>\n</blockquote>\n<h3 id=\"设计的简单RPC-需要实现的功能-RoadMap\"><a href=\"#设计的简单RPC-需要实现的功能-RoadMap\" class=\"headerlink\" title=\"设计的简单RPC 需要实现的功能(RoadMap)\"></a>设计的简单RPC 需要实现的功能(RoadMap)</h3><p>参考 (GeeRpc)[<a href=\"https://geektutu.com/post/geerpc.html]\">https://geektutu.com/post/geerpc.html]</a> 作为基础 rpc 实现</p>\n<h2 id=\"实现服务端和消息编码\"><a href=\"#实现服务端和消息编码\" class=\"headerlink\" title=\"实现服务端和消息编码\"></a>实现服务端和消息编码</h2><blockquote>\n<p>目标是：</p>\n<ul>\n<li>使用encoding/gob 实现消息的解编码（序列化和反序列化）</li>\n<li>实现简易的服务端，仅接受消息不处理</li>\n</ul>\n</blockquote>\n<hr>\n<h2 id=\"问题集锦\"><a href=\"#问题集锦\" class=\"headerlink\" title=\"问题集锦\"></a>问题集锦</h2><h3 id=\"encode-gob-与-Protobuf\"><a href=\"#encode-gob-与-Protobuf\" class=\"headerlink\" title=\"encode/gob 与 Protobuf\"></a>encode/gob 与 Protobuf</h3><p>二者都是完成信息做序列化的工作，但是 encode/gob 仅仅是提供了对于Golang语言的支持，要想在不同的平台应用得使用Protobuf</p>\n<h3 id=\"什么是工厂模式\"><a href=\"#什么是工厂模式\" class=\"headerlink\" title=\"什么是工厂模式\"></a>什么是工厂模式</h3><h3 id=\"Golang-包名字的统一\"><a href=\"#Golang-包名字的统一\" class=\"headerlink\" title=\"Golang 包名字的统一\"></a>Golang 包名字的统一</h3><h3 id=\"var-Codec-GobCodec-nil-的作用\"><a href=\"#var-Codec-GobCodec-nil-的作用\" class=\"headerlink\" title=\"var _ Codec = (*GobCodec)(nil) 的作用\"></a>var _ Codec = (*GobCodec)(nil) 的作用</h3><blockquote>\n<p>参考文章：[<a href=\"https://cloud.tencent.com/developer/article/2025793]\">https://cloud.tencent.com/developer/article/2025793]</a><br>在 Golang 中，var _ 可以用作声明变量但不使用它的占位符。在 var _ Codec = (*GobCodec)(nil) 中，_ 的作用是占位符。它们结合在一起可以起到两个作用：</p>\n</blockquote>\n<p>防止编译器报错：当一个接口类型被定义后，需要确保该接口类型被所有实现都正确实现。编译器可以通过检查是否所有实现都满足该接口的方法来验证这一点。在接口类型和实现之间声明 var _ InterfaceType = (*ImplementType)(nil) 可以防止编译器发出“实现不完整”的警告。</p>\n<p>检验类型之间的兼容性：在 var _ Codec = (*GobCodec)(nil) 中，则是要检验 GobCodec 是否实现了 Codec 接口。如果 GobCodec 没有实现 Codec 接口中的所有方法，则编译时将无法通过，从而起到检验类型之间的兼容性的作用。</p>\n<p>总之，var _ Codec = (*GobCodec)(nil) 的目的是检验 GobCodec 是否实现了 Codec 接口、避免编译器报错并判断类型之间的兼容性。它通常用于接口类型和实现之间的声明，对于保证代码质量和类型安全是很有帮助的。</p>\n"},{"title":"Golang 双指针","catalog":true,"date":"2023-04-01T16:46:21.000Z","subtitle":null,"header-img":null,"_content":"\n# 双指针：如何掌握最长、定长、最短区间问题的解题诀窍\n> 通常是明明用两个指针在数组/链表上遍历，然后解决满足某种性质的问题\n> 解决问题：\n> **最长区间**\n> **定长区间**\n> **最短区间**\n> <font color = 'red'>1. 弄清楚题目要的是什么样的区间，是上述三种中的哪一类</font>\n> <font color = 'red'>2. 区间需要满足的条件是什么</font>\n\n## **1** &ensp; 区间特性\n\n### 单调性 & 最优\n> 使用双指针需要保证区间的单调性\n\n1. 单调性的定义：\n   区间的单调性： 固定了划分区间的条件之后，遍历区间内的元素，按照一定顺序的时候，区间内的元素应该是都满足某一个条件，且存在问题定义上的大小单调变化。\n   比如： 在一个完全都是正整数的区间里面，划分子集的标准是固定子集右端元素（最右端元素只能是A[i]），集合内元素的和从下标为-1到i-1,均大于某个数，且这个和逐步减少（$\\because 元素都是正数，减少了就变小了$）\n\n2. 快速判断区间属性是否满足单调性的办法\n   <font color = 'red'> 往区间里面添加元素的时候，区间的约束条件可以变化，但不能出现波折</font>\n   理解为： 添加一个元素之后，要么依旧满足条件，符合单调性；要么出现一会不满足一会满足的情况，不符合单调性\n\n> 遍历区间的所有子集可以使用这样的方式： 固定子集的最右边元素为固定元素：\n> 固定右区间集合，把A[i]元素固定为区间的右端点，之变动区间的左边界形成的所有区间，并且按照区间长度需要从长到短排列\n>\n3. 找到最优解\n   <font color = 'red'> 从左向右遍历区间右端固定元素集合中的每个区间，找到一个满足条件的解就停止（因为单调性继续调整依旧满足条件）</font>\n\n### 模板\n1. 寻找以A[i]为有边界的最优解，分为以下三步\n``` golang\nStep 1 :\n将A[i] 加入到区间中，形成新的区间 （left,i]\nroom = append(room,A[i])\n\nStep 2：\n遍历A[i]的固定右区间集，直到找到以A[i]为右端点的最优解\nfor left < i && (left,i] 区间不满足要求 {\n    left++\n} \n\nStep 3:\n此时要么得到一个满足要求的解，要么没有满足单调性的区间\n(left,i]区间满足要求\n```\n2. 题目须具备的条件\n   * 给定一个条件\n   * 求最长区间/最长字串\n   * 题目给出的区间需要具备的单调性\n\n3. 必杀技\n   * left，right 指针\n   * 只有在不满足条件的时候才向右移动left指针\n  \n4. 最长区间的代码模板\n``` golang\nfunc maxLength(A []int) int{\n    // 创建左指针和结果\n    left, ans := -1, 0\n\n    // 从左向右遍历区间\n    for i:= 0; i< len(A); i++{\n        // Assert 在加入 A[i] 之前，(left,i-1] 是一个合法有效的区间，在最开始的时候left = -1，i-1=-1，是空区间，满足条件\n        // Step1 : 直接将A[i]加到区间中，形成(left,i]\n        // step2 : 将A[I]加入之后，依据left的惰性yuanze\n        // TODO: check检查区间状态是否满足条件\n        for check(left,i) {\n            left++// 如果不满足条件，移动左指针\n            // TODO： 修改区间的状态\n        }\n        // assert 此时的(left,i] 必然满足条件\n        ans = max(ans,i-left)\n    }\n    // 返回最优解\n    return ans\n}\n```\n\n时间复杂度为 O(n)\n\n## **2** &ensp; 例题: 区间长度类型\n\n### 不含重复字符的最长区间\n> 单调性： 当找到一个没有重复字符的区间时候，减少区间内元素，新的区间依旧满足没有重复元素\n> https://leetcode.cn/problems/longest-substring-without-repeating-characters/\n>\n``` golang\nfunc lengthOfLongestSubstring(s string) int {\n    // 双指针解决\n    left, ans := -1,0\n    // 存储区间内元素的映射\n    m := make(map[byte]int,0)\n    for i := 0; i <len(s); i++ {\n        m[s[i]] += 1\n        for m[s[i]] > 1 {\n            left++\n            m[s[left]]--\n        }\n        ans = max(ans, i-left)\n    }\n    return ans\n}\n\nfunc max(args ...int)int{\n    m := args[0]\n    for _, val := range args{\n        if val > m {\n            m = val\n        }\n    }\n    return m\n}\n```\n\n### 替换后的最长重复字符\n> 给你一个字符串 s 和一个整数 k 。你可以选择字符串中的任一字符，并将其更改为任何其他大写英文字符。该操作最多可执行 k 次。\n> https://leetcode.cn/problems/longest-repeating-character-replacement/\n> \n在执行上述操作后，返回包含相同字母的最长子字符串的长度。\n示例 1：\n输入：s = \"ABAB\", k = 2\n输出：4\n解释：用两个'A'替换为两个'B',反之亦然。\n示例 2：\n输入：s = \"AABABBA\", k = 1\n输出：4\n解释：\n将中间的一个'A'替换为'B',字符串变为 \"AABBBBA\"。\n子串 \"BBBB\" 有最长重复字母, 答案为 4。\n 提示：\n1 <= s.length <= 105\ns 仅由大写英文字母组成\n0 <= k <= s.length\n\n\n``` golang\nfunc characterReplacement(s string, k int) int {\n    // \n    left, ans := -1,0\n    max_repeat := 0\n    m := make(map[byte]int,0)\n    for i := 0; i < len(s); i++{\n        m[s[i]]++\n\n        max_repeat = max(m[s[i]],max_repeat)\n        for i-left-max_repeat > k{\n            left++\n            m[s[left]]--\n        } \n        ans = max(ans,i-left)\n    }\n    return ans\n}\nfunc max(args ...int)int{\n    m := args[0]\n    for _, val := range args{\n        if val > m {\n            m = val\n        }\n    }\n    return m\n}\n```\n\n\n### 字符流中第一个只出现一次的字符\n> 请实现一个函数用来找出字符流中第一个只出现一次的字符。\n> https://www.acwing.com/problem/content/60/\n例如，当从字符流中只读出前两个字符 go 时，第一个只出现一次的字符是 g。\n当从该字符流中读出前六个字符 google 时，第一个只出现一次的字符是 l。\n如果当前字符流没有存在出现一次的字符，返回 # 字符。\n数据范围\n字符流读入字符数量 [0,1000]\n\n样例\n输入：\"google\"\n输出：\"ggg#ll\"\n解释：每当字符流读入一个字符，就进行一次判断并输出当前的第一个只出现一次的字符。\n\n```golang\ntype Solution struct {\n    left int // 最左侧字符位置\n    cnt  [256]int // 字符个数计数器\n    s    string // 保存输入的字符串\n}\n\nvar s Solution\n\nfunc insert(ch byte) {\n    s.cnt[ch]++ // 将该字符出现次数加1\n    s.s += string(ch) // 将该字符加入到字符串s中\n    // 如果最左侧的字符出现次数大于1，则将最左侧字符的位置向右移动，直到最左侧字符出现次数为1或者left >= right\n    for s.left < len(s.s) && s.cnt[s.s[s.left]] > 1 {\n        s.left++\n    }\n}\n\nfunc firstAppearingOnce() byte {\n    // 如果最左侧字符位置left大于等于字符串s的长度，则返回'#'\n    if s.left >= len(s.s) {\n        return '#'\n    }\n    // 返回最左侧的字符\n    return s.s[s.left]\n}\n```\n\n### 最多有k个不同字符的最长子字符串\n> 给定字符串S，找到最多有k个不同字符的最长子串T。\n> https://www.lintcode.com/problem/386/\n样例\n样例 1:\n\n输入: S = \"eceba\" 并且 k = 3\n输出: 4\n解释: T = \"eceb\"\n样例 2:\n\n输入: S = \"WORLD\" 并且 k = 4\n输出: 4\n解释: T = \"WORL\" 或 \"ORLD\"\n挑战\nO(n) 时间复杂度\n``` golang\n/**\n * @param s: A string\n * @param k: An integer\n * @return: An integer\n */\nfunc LengthOfLongestSubstringKDistinct(s string, k int) int {\n    //\n    left, count,l := -1,0,0\n\n    m := make(map[byte]int,0)\n    for i:=0; i< len(s); i++{\n        if m[s[i]] == 0 {\n            count++\n        }\n        m[s[i]]++\n        for count > k {\n            left++\n            m[s[left]]--\n            if m[s[left]] == 0 {\n                count--\n            }\n        }\n        l = max(l,i-left)\n    }\n    return l\n}\n\nfunc max(args ...int) int{\n    m := args[0]\n    for _, val := range args{\n        if val > m {\n            m = val\n        }\n    }\n    return m\n}\n```\n\n###  数组中的最长山脉\n> https://leetcode.cn/problems/longest-mountain-in-array/description/\n>\n把符合下列属性的数组 arr 称为 山脉数组 ：\n\narr.length >= 3\n存在下标 i（0 < i < arr.length - 1），满足\narr[0] < arr[1] < ... < arr[i - 1] < arr[i]\narr[i] > arr[i + 1] > ... > arr[arr.length - 1]\n给出一个整数数组 arr，返回最长山脉子数组的长度。如果不存在山脉子数组，返回 0 。\n示例 1：\n输入：arr = [2,1,4,7,3,2,5]\n输出：5\n解释：最长的山脉子数组是 [1,4,7,3,2]，长度为 5。\n示例 2：\n\n输入：arr = [2,2,2]\n输出：0\n解释：不存在山脉子数组。\n提示：\n1 <= arr.length <= 104\n0 <= arr[i] <= 104\n \n进阶：\n你可以仅用一趟扫描解决此问题吗？\n你可以用 O(1) 空间解决此问题吗？\n\n``` golang\nfunc longestMountain(A []int) int {\n    N := len(A)\n    if N < 3 {\n        return 0\n    }\n\n    left := -1\n    // -1表示只有一个元素\n    // 0表示正上升\n    // 1表示正下降\n    status := -1\n    preValue := A[0]\n    ans := 0\n\n    // 题目要求必须至少有3个元素，所以不可能从0开始\n    for i := 1; i < N; i++ {\n        x := A[i]\n\n        // 如果要把x加进来\n        // 如果里面还只有一个元素\n        if status == -1 {\n            if x > preValue {\n                // 那么状态改为上升\n                status = 0\n            } else {\n                // 如果相等，或者变小，那么区间只能再变成只有一个元素的了\n                // 状态依然更新为只有一个元素\n                status = -1\n                // 区间更新为(left, i]\n                left = i - 1\n            }\n        }\n        // 如果正在上升\n        if status == 0 {\n            if x > preValue {\n                // nothing\n            } else if x == preValue {\n                // 如果相等，那么区间只能再变成只有一个元素的状态了\n                status = -1\n                left = i - 1\n            } else {\n                // 下降了\n                status = 1\n            }\n        }\n        // 如果正在下降\n        if status == 1 {\n            if x < preValue {\n                // nothing\n            } else if x == preValue {\n                status = -1\n                left = i - 1\n            } else {\n                // 如果正在上升\n                status = 0\n                // 注意这里left要变成(i - 2, i]\n                // 这里已经有两个元素了\n                left = i - 2\n            }\n        }\n\n        preValue = x\n        if status == 1 {\n            ans = max(ans, i-left)\n        }\n    }\n\n    if ans >= 3 {\n        return ans\n    }\n    return 0\n}\n\n\nfunc max(args ...int)int{\n    m := args[0]\n    for _, val := range args{\n        if val > m {\n             m = val\n        }\n    }\n    return m\n}\n```\n\n---\n\n## **3**  &ensp; 例题：区间计数\n\n### 区间计数\n> 区间最优原则表示：当按照区间最右边元素划分区间，并找到最优解之后，left继续向有移动形成的短区间都满足条件\n\n#### 代码模板\n> 在求最长区间代码模板上变式\n```golang\nfunc rangeCounter(A []int){\n    // 区间的左指针\n    left,ans := -1,0\n    // 不变式0： 最开始的区间为(-1，-1] 是一个空区间\n    //          我们认为空区间总是满足条件\n    for i:=0; i<len(A); i++{\n        // 不变式1： 在加入A[i]之前，(left,i-1]是一个合法的有效区间\n        // 需要改变的部分为下：\n        // Step1： 直接将A[i]加入到区间中，形成(left,i]\n        // Step2:  将A[i] 加入之后，依据多性原则判断Left是否移动且移动多少\n        /** TODO: 设计check函数，检查区间是否满足条件\n        */\n        for check(left,i] {\n            // 如果不满足条件，则移动左指针\n            left++\n            /**\n            TODO: 修改区间的状态或者改变区间的性质\n            */\n        }\n        // 不变式2： 此时(left,i]必然合法\n        // 累计区间个数: 以A[i]为有边界的子区间总共有i-left个\n        ans = ans + i-left\n    }\n    return ans\n}\n```","source":"_posts/Algorithm/Golang-算法课程/Golang-双指针/Golang-双指针.md","raw":"---\ntitle: Golang 双指针\ncatalog: true\ndate: 2023-04-02 00:46:21\nsubtitle:\nheader-img:\ntags: 双指针, 算法\ncategories: 算法，Golang\n---\n\n# 双指针：如何掌握最长、定长、最短区间问题的解题诀窍\n> 通常是明明用两个指针在数组/链表上遍历，然后解决满足某种性质的问题\n> 解决问题：\n> **最长区间**\n> **定长区间**\n> **最短区间**\n> <font color = 'red'>1. 弄清楚题目要的是什么样的区间，是上述三种中的哪一类</font>\n> <font color = 'red'>2. 区间需要满足的条件是什么</font>\n\n## **1** &ensp; 区间特性\n\n### 单调性 & 最优\n> 使用双指针需要保证区间的单调性\n\n1. 单调性的定义：\n   区间的单调性： 固定了划分区间的条件之后，遍历区间内的元素，按照一定顺序的时候，区间内的元素应该是都满足某一个条件，且存在问题定义上的大小单调变化。\n   比如： 在一个完全都是正整数的区间里面，划分子集的标准是固定子集右端元素（最右端元素只能是A[i]），集合内元素的和从下标为-1到i-1,均大于某个数，且这个和逐步减少（$\\because 元素都是正数，减少了就变小了$）\n\n2. 快速判断区间属性是否满足单调性的办法\n   <font color = 'red'> 往区间里面添加元素的时候，区间的约束条件可以变化，但不能出现波折</font>\n   理解为： 添加一个元素之后，要么依旧满足条件，符合单调性；要么出现一会不满足一会满足的情况，不符合单调性\n\n> 遍历区间的所有子集可以使用这样的方式： 固定子集的最右边元素为固定元素：\n> 固定右区间集合，把A[i]元素固定为区间的右端点，之变动区间的左边界形成的所有区间，并且按照区间长度需要从长到短排列\n>\n3. 找到最优解\n   <font color = 'red'> 从左向右遍历区间右端固定元素集合中的每个区间，找到一个满足条件的解就停止（因为单调性继续调整依旧满足条件）</font>\n\n### 模板\n1. 寻找以A[i]为有边界的最优解，分为以下三步\n``` golang\nStep 1 :\n将A[i] 加入到区间中，形成新的区间 （left,i]\nroom = append(room,A[i])\n\nStep 2：\n遍历A[i]的固定右区间集，直到找到以A[i]为右端点的最优解\nfor left < i && (left,i] 区间不满足要求 {\n    left++\n} \n\nStep 3:\n此时要么得到一个满足要求的解，要么没有满足单调性的区间\n(left,i]区间满足要求\n```\n2. 题目须具备的条件\n   * 给定一个条件\n   * 求最长区间/最长字串\n   * 题目给出的区间需要具备的单调性\n\n3. 必杀技\n   * left，right 指针\n   * 只有在不满足条件的时候才向右移动left指针\n  \n4. 最长区间的代码模板\n``` golang\nfunc maxLength(A []int) int{\n    // 创建左指针和结果\n    left, ans := -1, 0\n\n    // 从左向右遍历区间\n    for i:= 0; i< len(A); i++{\n        // Assert 在加入 A[i] 之前，(left,i-1] 是一个合法有效的区间，在最开始的时候left = -1，i-1=-1，是空区间，满足条件\n        // Step1 : 直接将A[i]加到区间中，形成(left,i]\n        // step2 : 将A[I]加入之后，依据left的惰性yuanze\n        // TODO: check检查区间状态是否满足条件\n        for check(left,i) {\n            left++// 如果不满足条件，移动左指针\n            // TODO： 修改区间的状态\n        }\n        // assert 此时的(left,i] 必然满足条件\n        ans = max(ans,i-left)\n    }\n    // 返回最优解\n    return ans\n}\n```\n\n时间复杂度为 O(n)\n\n## **2** &ensp; 例题: 区间长度类型\n\n### 不含重复字符的最长区间\n> 单调性： 当找到一个没有重复字符的区间时候，减少区间内元素，新的区间依旧满足没有重复元素\n> https://leetcode.cn/problems/longest-substring-without-repeating-characters/\n>\n``` golang\nfunc lengthOfLongestSubstring(s string) int {\n    // 双指针解决\n    left, ans := -1,0\n    // 存储区间内元素的映射\n    m := make(map[byte]int,0)\n    for i := 0; i <len(s); i++ {\n        m[s[i]] += 1\n        for m[s[i]] > 1 {\n            left++\n            m[s[left]]--\n        }\n        ans = max(ans, i-left)\n    }\n    return ans\n}\n\nfunc max(args ...int)int{\n    m := args[0]\n    for _, val := range args{\n        if val > m {\n            m = val\n        }\n    }\n    return m\n}\n```\n\n### 替换后的最长重复字符\n> 给你一个字符串 s 和一个整数 k 。你可以选择字符串中的任一字符，并将其更改为任何其他大写英文字符。该操作最多可执行 k 次。\n> https://leetcode.cn/problems/longest-repeating-character-replacement/\n> \n在执行上述操作后，返回包含相同字母的最长子字符串的长度。\n示例 1：\n输入：s = \"ABAB\", k = 2\n输出：4\n解释：用两个'A'替换为两个'B',反之亦然。\n示例 2：\n输入：s = \"AABABBA\", k = 1\n输出：4\n解释：\n将中间的一个'A'替换为'B',字符串变为 \"AABBBBA\"。\n子串 \"BBBB\" 有最长重复字母, 答案为 4。\n 提示：\n1 <= s.length <= 105\ns 仅由大写英文字母组成\n0 <= k <= s.length\n\n\n``` golang\nfunc characterReplacement(s string, k int) int {\n    // \n    left, ans := -1,0\n    max_repeat := 0\n    m := make(map[byte]int,0)\n    for i := 0; i < len(s); i++{\n        m[s[i]]++\n\n        max_repeat = max(m[s[i]],max_repeat)\n        for i-left-max_repeat > k{\n            left++\n            m[s[left]]--\n        } \n        ans = max(ans,i-left)\n    }\n    return ans\n}\nfunc max(args ...int)int{\n    m := args[0]\n    for _, val := range args{\n        if val > m {\n            m = val\n        }\n    }\n    return m\n}\n```\n\n\n### 字符流中第一个只出现一次的字符\n> 请实现一个函数用来找出字符流中第一个只出现一次的字符。\n> https://www.acwing.com/problem/content/60/\n例如，当从字符流中只读出前两个字符 go 时，第一个只出现一次的字符是 g。\n当从该字符流中读出前六个字符 google 时，第一个只出现一次的字符是 l。\n如果当前字符流没有存在出现一次的字符，返回 # 字符。\n数据范围\n字符流读入字符数量 [0,1000]\n\n样例\n输入：\"google\"\n输出：\"ggg#ll\"\n解释：每当字符流读入一个字符，就进行一次判断并输出当前的第一个只出现一次的字符。\n\n```golang\ntype Solution struct {\n    left int // 最左侧字符位置\n    cnt  [256]int // 字符个数计数器\n    s    string // 保存输入的字符串\n}\n\nvar s Solution\n\nfunc insert(ch byte) {\n    s.cnt[ch]++ // 将该字符出现次数加1\n    s.s += string(ch) // 将该字符加入到字符串s中\n    // 如果最左侧的字符出现次数大于1，则将最左侧字符的位置向右移动，直到最左侧字符出现次数为1或者left >= right\n    for s.left < len(s.s) && s.cnt[s.s[s.left]] > 1 {\n        s.left++\n    }\n}\n\nfunc firstAppearingOnce() byte {\n    // 如果最左侧字符位置left大于等于字符串s的长度，则返回'#'\n    if s.left >= len(s.s) {\n        return '#'\n    }\n    // 返回最左侧的字符\n    return s.s[s.left]\n}\n```\n\n### 最多有k个不同字符的最长子字符串\n> 给定字符串S，找到最多有k个不同字符的最长子串T。\n> https://www.lintcode.com/problem/386/\n样例\n样例 1:\n\n输入: S = \"eceba\" 并且 k = 3\n输出: 4\n解释: T = \"eceb\"\n样例 2:\n\n输入: S = \"WORLD\" 并且 k = 4\n输出: 4\n解释: T = \"WORL\" 或 \"ORLD\"\n挑战\nO(n) 时间复杂度\n``` golang\n/**\n * @param s: A string\n * @param k: An integer\n * @return: An integer\n */\nfunc LengthOfLongestSubstringKDistinct(s string, k int) int {\n    //\n    left, count,l := -1,0,0\n\n    m := make(map[byte]int,0)\n    for i:=0; i< len(s); i++{\n        if m[s[i]] == 0 {\n            count++\n        }\n        m[s[i]]++\n        for count > k {\n            left++\n            m[s[left]]--\n            if m[s[left]] == 0 {\n                count--\n            }\n        }\n        l = max(l,i-left)\n    }\n    return l\n}\n\nfunc max(args ...int) int{\n    m := args[0]\n    for _, val := range args{\n        if val > m {\n            m = val\n        }\n    }\n    return m\n}\n```\n\n###  数组中的最长山脉\n> https://leetcode.cn/problems/longest-mountain-in-array/description/\n>\n把符合下列属性的数组 arr 称为 山脉数组 ：\n\narr.length >= 3\n存在下标 i（0 < i < arr.length - 1），满足\narr[0] < arr[1] < ... < arr[i - 1] < arr[i]\narr[i] > arr[i + 1] > ... > arr[arr.length - 1]\n给出一个整数数组 arr，返回最长山脉子数组的长度。如果不存在山脉子数组，返回 0 。\n示例 1：\n输入：arr = [2,1,4,7,3,2,5]\n输出：5\n解释：最长的山脉子数组是 [1,4,7,3,2]，长度为 5。\n示例 2：\n\n输入：arr = [2,2,2]\n输出：0\n解释：不存在山脉子数组。\n提示：\n1 <= arr.length <= 104\n0 <= arr[i] <= 104\n \n进阶：\n你可以仅用一趟扫描解决此问题吗？\n你可以用 O(1) 空间解决此问题吗？\n\n``` golang\nfunc longestMountain(A []int) int {\n    N := len(A)\n    if N < 3 {\n        return 0\n    }\n\n    left := -1\n    // -1表示只有一个元素\n    // 0表示正上升\n    // 1表示正下降\n    status := -1\n    preValue := A[0]\n    ans := 0\n\n    // 题目要求必须至少有3个元素，所以不可能从0开始\n    for i := 1; i < N; i++ {\n        x := A[i]\n\n        // 如果要把x加进来\n        // 如果里面还只有一个元素\n        if status == -1 {\n            if x > preValue {\n                // 那么状态改为上升\n                status = 0\n            } else {\n                // 如果相等，或者变小，那么区间只能再变成只有一个元素的了\n                // 状态依然更新为只有一个元素\n                status = -1\n                // 区间更新为(left, i]\n                left = i - 1\n            }\n        }\n        // 如果正在上升\n        if status == 0 {\n            if x > preValue {\n                // nothing\n            } else if x == preValue {\n                // 如果相等，那么区间只能再变成只有一个元素的状态了\n                status = -1\n                left = i - 1\n            } else {\n                // 下降了\n                status = 1\n            }\n        }\n        // 如果正在下降\n        if status == 1 {\n            if x < preValue {\n                // nothing\n            } else if x == preValue {\n                status = -1\n                left = i - 1\n            } else {\n                // 如果正在上升\n                status = 0\n                // 注意这里left要变成(i - 2, i]\n                // 这里已经有两个元素了\n                left = i - 2\n            }\n        }\n\n        preValue = x\n        if status == 1 {\n            ans = max(ans, i-left)\n        }\n    }\n\n    if ans >= 3 {\n        return ans\n    }\n    return 0\n}\n\n\nfunc max(args ...int)int{\n    m := args[0]\n    for _, val := range args{\n        if val > m {\n             m = val\n        }\n    }\n    return m\n}\n```\n\n---\n\n## **3**  &ensp; 例题：区间计数\n\n### 区间计数\n> 区间最优原则表示：当按照区间最右边元素划分区间，并找到最优解之后，left继续向有移动形成的短区间都满足条件\n\n#### 代码模板\n> 在求最长区间代码模板上变式\n```golang\nfunc rangeCounter(A []int){\n    // 区间的左指针\n    left,ans := -1,0\n    // 不变式0： 最开始的区间为(-1，-1] 是一个空区间\n    //          我们认为空区间总是满足条件\n    for i:=0; i<len(A); i++{\n        // 不变式1： 在加入A[i]之前，(left,i-1]是一个合法的有效区间\n        // 需要改变的部分为下：\n        // Step1： 直接将A[i]加入到区间中，形成(left,i]\n        // Step2:  将A[i] 加入之后，依据多性原则判断Left是否移动且移动多少\n        /** TODO: 设计check函数，检查区间是否满足条件\n        */\n        for check(left,i] {\n            // 如果不满足条件，则移动左指针\n            left++\n            /**\n            TODO: 修改区间的状态或者改变区间的性质\n            */\n        }\n        // 不变式2： 此时(left,i]必然合法\n        // 累计区间个数: 以A[i]为有边界的子区间总共有i-left个\n        ans = ans + i-left\n    }\n    return ans\n}\n```","slug":"Algorithm/Golang-算法课程/Golang-双指针/Golang-双指针","published":1,"updated":"2023-04-22T13:24:02.288Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgtm6jqv001xlyjx8fmt1oag","content":"<h1 id=\"双指针：如何掌握最长、定长、最短区间问题的解题诀窍\"><a href=\"#双指针：如何掌握最长、定长、最短区间问题的解题诀窍\" class=\"headerlink\" title=\"双指针：如何掌握最长、定长、最短区间问题的解题诀窍\"></a>双指针：如何掌握最长、定长、最短区间问题的解题诀窍</h1><blockquote>\n<p>通常是明明用两个指针在数组/链表上遍历，然后解决满足某种性质的问题<br>解决问题：<br><strong>最长区间</strong><br><strong>定长区间</strong><br><strong>最短区间</strong><br><font color = 'red'>1. 弄清楚题目要的是什么样的区间，是上述三种中的哪一类</font><br><font color = 'red'>2. 区间需要满足的条件是什么</font></p>\n</blockquote>\n<h2 id=\"1-ensp-区间特性\"><a href=\"#1-ensp-区间特性\" class=\"headerlink\" title=\"1 &ensp; 区间特性\"></a><strong>1</strong> &ensp; 区间特性</h2><h3 id=\"单调性-amp-最优\"><a href=\"#单调性-amp-最优\" class=\"headerlink\" title=\"单调性 &amp; 最优\"></a>单调性 &amp; 最优</h3><blockquote>\n<p>使用双指针需要保证区间的单调性</p>\n</blockquote>\n<ol>\n<li><p>单调性的定义：<br>区间的单调性： 固定了划分区间的条件之后，遍历区间内的元素，按照一定顺序的时候，区间内的元素应该是都满足某一个条件，且存在问题定义上的大小单调变化。<br>比如： 在一个完全都是正整数的区间里面，划分子集的标准是固定子集右端元素（最右端元素只能是A[i]），集合内元素的和从下标为-1到i-1,均大于某个数，且这个和逐步减少（$\\because 元素都是正数，减少了就变小了$）</p>\n</li>\n<li><p>快速判断区间属性是否满足单调性的办法<br><font color = 'red'> 往区间里面添加元素的时候，区间的约束条件可以变化，但不能出现波折</font><br>理解为： 添加一个元素之后，要么依旧满足条件，符合单调性；要么出现一会不满足一会满足的情况，不符合单调性</p>\n</li>\n</ol>\n<blockquote>\n<p>遍历区间的所有子集可以使用这样的方式： 固定子集的最右边元素为固定元素：<br>固定右区间集合，把A[i]元素固定为区间的右端点，之变动区间的左边界形成的所有区间，并且按照区间长度需要从长到短排列</p>\n</blockquote>\n<ol start=\"3\">\n<li>找到最优解<br><font color = 'red'> 从左向右遍历区间右端固定元素集合中的每个区间，找到一个满足条件的解就停止（因为单调性继续调整依旧满足条件）</font></li>\n</ol>\n<h3 id=\"模板\"><a href=\"#模板\" class=\"headerlink\" title=\"模板\"></a>模板</h3><ol>\n<li><p>寻找以A[i]为有边界的最优解，分为以下三步</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Step <span class=\"number\">1</span> :</span><br><span class=\"line\">将A[i] 加入到区间中，形成新的区间 （left,i]</span><br><span class=\"line\">room = <span class=\"built_in\">append</span>(room,A[i])</span><br><span class=\"line\"></span><br><span class=\"line\">Step <span class=\"number\">2</span>：</span><br><span class=\"line\">遍历A[i]的固定右区间集，直到找到以A[i]为右端点的最优解</span><br><span class=\"line\"><span class=\"keyword\">for</span> left &lt; i &amp;&amp; (left,i] 区间不满足要求 &#123;</span><br><span class=\"line\">    left++</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\">Step <span class=\"number\">3</span>:</span><br><span class=\"line\">此时要么得到一个满足要求的解，要么没有满足单调性的区间</span><br><span class=\"line\">(left,i]区间满足要求</span><br></pre></td></tr></table></figure></li>\n<li><p>题目须具备的条件</p>\n<ul>\n<li>给定一个条件</li>\n<li>求最长区间/最长字串</li>\n<li>题目给出的区间需要具备的单调性</li>\n</ul>\n</li>\n<li><p>必杀技</p>\n<ul>\n<li>left，right 指针</li>\n<li>只有在不满足条件的时候才向右移动left指针</li>\n</ul>\n</li>\n<li><p>最长区间的代码模板</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">maxLength</span><span class=\"params\">(A []<span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建左指针和结果</span></span><br><span class=\"line\">    left, ans := <span class=\"number\">-1</span>, <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 从左向右遍历区间</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i:= <span class=\"number\">0</span>; i&lt; <span class=\"built_in\">len</span>(A); i++&#123;</span><br><span class=\"line\">        <span class=\"comment\">// Assert 在加入 A[i] 之前，(left,i-1] 是一个合法有效的区间，在最开始的时候left = -1，i-1=-1，是空区间，满足条件</span></span><br><span class=\"line\">        <span class=\"comment\">// Step1 : 直接将A[i]加到区间中，形成(left,i]</span></span><br><span class=\"line\">        <span class=\"comment\">// step2 : 将A[I]加入之后，依据left的惰性yuanze</span></span><br><span class=\"line\">        <span class=\"comment\">// <span class=\"doctag\">TODO:</span> check检查区间状态是否满足条件</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> check(left,i) &#123;</span><br><span class=\"line\">            left++<span class=\"comment\">// 如果不满足条件，移动左指针</span></span><br><span class=\"line\">            <span class=\"comment\">// TODO： 修改区间的状态</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// assert 此时的(left,i] 必然满足条件</span></span><br><span class=\"line\">        ans = max(ans,i-left)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 返回最优解</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>时间复杂度为 O(n)</p>\n<h2 id=\"2-ensp-例题-区间长度类型\"><a href=\"#2-ensp-例题-区间长度类型\" class=\"headerlink\" title=\"2 &ensp; 例题: 区间长度类型\"></a><strong>2</strong> &ensp; 例题: 区间长度类型</h2><h3 id=\"不含重复字符的最长区间\"><a href=\"#不含重复字符的最长区间\" class=\"headerlink\" title=\"不含重复字符的最长区间\"></a>不含重复字符的最长区间</h3><blockquote>\n<p>单调性： 当找到一个没有重复字符的区间时候，减少区间内元素，新的区间依旧满足没有重复元素<br><a href=\"https://leetcode.cn/problems/longest-substring-without-repeating-characters/\">https://leetcode.cn/problems/longest-substring-without-repeating-characters/</a></p>\n</blockquote>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(s <span class=\"type\">string</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 双指针解决</span></span><br><span class=\"line\">    left, ans := <span class=\"number\">-1</span>,<span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"comment\">// 存储区间内元素的映射</span></span><br><span class=\"line\">    m := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">byte</span>]<span class=\"type\">int</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt;<span class=\"built_in\">len</span>(s); i++ &#123;</span><br><span class=\"line\">        m[s[i]] += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> m[s[i]] &gt; <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">            left++</span><br><span class=\"line\">            m[s[left]]--</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ans = max(ans, i-left)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">max</span><span class=\"params\">(args ...<span class=\"type\">int</span>)</span></span><span class=\"type\">int</span>&#123;</span><br><span class=\"line\">    m := args[<span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, val := <span class=\"keyword\">range</span> args&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> val &gt; m &#123;</span><br><span class=\"line\">            m = val</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"替换后的最长重复字符\"><a href=\"#替换后的最长重复字符\" class=\"headerlink\" title=\"替换后的最长重复字符\"></a>替换后的最长重复字符</h3><blockquote>\n<p>给你一个字符串 s 和一个整数 k 。你可以选择字符串中的任一字符，并将其更改为任何其他大写英文字符。该操作最多可执行 k 次。<br><a href=\"https://leetcode.cn/problems/longest-repeating-character-replacement/\">https://leetcode.cn/problems/longest-repeating-character-replacement/</a></p>\n</blockquote>\n<p>在执行上述操作后，返回包含相同字母的最长子字符串的长度。<br>示例 1：<br>输入：s = “ABAB”, k = 2<br>输出：4<br>解释：用两个’A’替换为两个’B’,反之亦然。<br>示例 2：<br>输入：s = “AABABBA”, k = 1<br>输出：4<br>解释：<br>将中间的一个’A’替换为’B’,字符串变为 “AABBBBA”。<br>子串 “BBBB” 有最长重复字母, 答案为 4。<br> 提示：<br>1 &lt;= s.length &lt;= 105<br>s 仅由大写英文字母组成<br>0 &lt;= k &lt;= s.length</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">characterReplacement</span><span class=\"params\">(s <span class=\"type\">string</span>, k <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// </span></span><br><span class=\"line\">    left, ans := <span class=\"number\">-1</span>,<span class=\"number\">0</span></span><br><span class=\"line\">    max_repeat := <span class=\"number\">0</span></span><br><span class=\"line\">    m := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">byte</span>]<span class=\"type\">int</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(s); i++&#123;</span><br><span class=\"line\">        m[s[i]]++</span><br><span class=\"line\"></span><br><span class=\"line\">        max_repeat = max(m[s[i]],max_repeat)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i-left-max_repeat &gt; k&#123;</span><br><span class=\"line\">            left++</span><br><span class=\"line\">            m[s[left]]--</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        ans = max(ans,i-left)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">max</span><span class=\"params\">(args ...<span class=\"type\">int</span>)</span></span><span class=\"type\">int</span>&#123;</span><br><span class=\"line\">    m := args[<span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, val := <span class=\"keyword\">range</span> args&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> val &gt; m &#123;</span><br><span class=\"line\">            m = val</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"字符流中第一个只出现一次的字符\"><a href=\"#字符流中第一个只出现一次的字符\" class=\"headerlink\" title=\"字符流中第一个只出现一次的字符\"></a>字符流中第一个只出现一次的字符</h3><blockquote>\n<p>请实现一个函数用来找出字符流中第一个只出现一次的字符。<br><a href=\"https://www.acwing.com/problem/content/60/\">https://www.acwing.com/problem/content/60/</a><br>例如，当从字符流中只读出前两个字符 go 时，第一个只出现一次的字符是 g。<br>当从该字符流中读出前六个字符 google 时，第一个只出现一次的字符是 l。<br>如果当前字符流没有存在出现一次的字符，返回 # 字符。<br>数据范围<br>字符流读入字符数量 [0,1000]</p>\n</blockquote>\n<p>样例<br>输入：”google”<br>输出：”ggg#ll”<br>解释：每当字符流读入一个字符，就进行一次判断并输出当前的第一个只出现一次的字符。</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Solution <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    left <span class=\"type\">int</span> <span class=\"comment\">// 最左侧字符位置</span></span><br><span class=\"line\">    cnt  [<span class=\"number\">256</span>]<span class=\"type\">int</span> <span class=\"comment\">// 字符个数计数器</span></span><br><span class=\"line\">    s    <span class=\"type\">string</span> <span class=\"comment\">// 保存输入的字符串</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> s Solution</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">insert</span><span class=\"params\">(ch <span class=\"type\">byte</span>)</span></span> &#123;</span><br><span class=\"line\">    s.cnt[ch]++ <span class=\"comment\">// 将该字符出现次数加1</span></span><br><span class=\"line\">    s.s += <span class=\"type\">string</span>(ch) <span class=\"comment\">// 将该字符加入到字符串s中</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果最左侧的字符出现次数大于1，则将最左侧字符的位置向右移动，直到最左侧字符出现次数为1或者left &gt;= right</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> s.left &lt; <span class=\"built_in\">len</span>(s.s) &amp;&amp; s.cnt[s.s[s.left]] &gt; <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">        s.left++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">firstAppearingOnce</span><span class=\"params\">()</span></span> <span class=\"type\">byte</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果最左侧字符位置left大于等于字符串s的长度，则返回&#x27;#&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> s.left &gt;= <span class=\"built_in\">len</span>(s.s) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&#x27;#&#x27;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 返回最左侧的字符</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> s.s[s.left]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"最多有k个不同字符的最长子字符串\"><a href=\"#最多有k个不同字符的最长子字符串\" class=\"headerlink\" title=\"最多有k个不同字符的最长子字符串\"></a>最多有k个不同字符的最长子字符串</h3><blockquote>\n<p>给定字符串S，找到最多有k个不同字符的最长子串T。<br><a href=\"https://www.lintcode.com/problem/386/\">https://www.lintcode.com/problem/386/</a><br>样例<br>样例 1:</p>\n</blockquote>\n<p>输入: S = “eceba” 并且 k = 3<br>输出: 4<br>解释: T = “eceb”<br>样例 2:</p>\n<p>输入: S = “WORLD” 并且 k = 4<br>输出: 4<br>解释: T = “WORL” 或 “ORLD”<br>挑战<br>O(n) 时间复杂度</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @param s: A string</span></span><br><span class=\"line\"><span class=\"comment\"> * @param k: An integer</span></span><br><span class=\"line\"><span class=\"comment\"> * @return: An integer</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">LengthOfLongestSubstringKDistinct</span><span class=\"params\">(s <span class=\"type\">string</span>, k <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">    left, count,l := <span class=\"number\">-1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    m := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">byte</span>]<span class=\"type\">int</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i:=<span class=\"number\">0</span>; i&lt; <span class=\"built_in\">len</span>(s); i++&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> m[s[i]] == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">            count++</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        m[s[i]]++</span><br><span class=\"line\">        <span class=\"keyword\">for</span> count &gt; k &#123;</span><br><span class=\"line\">            left++</span><br><span class=\"line\">            m[s[left]]--</span><br><span class=\"line\">            <span class=\"keyword\">if</span> m[s[left]] == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">                count--</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        l = max(l,i-left)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> l</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">max</span><span class=\"params\">(args ...<span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span>&#123;</span><br><span class=\"line\">    m := args[<span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, val := <span class=\"keyword\">range</span> args&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> val &gt; m &#123;</span><br><span class=\"line\">            m = val</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"数组中的最长山脉\"><a href=\"#数组中的最长山脉\" class=\"headerlink\" title=\"数组中的最长山脉\"></a>数组中的最长山脉</h3><blockquote>\n<p><a href=\"https://leetcode.cn/problems/longest-mountain-in-array/description/\">https://leetcode.cn/problems/longest-mountain-in-array/description/</a></p>\n</blockquote>\n<p>把符合下列属性的数组 arr 称为 山脉数组 ：</p>\n<p>arr.length &gt;= 3<br>存在下标 i（0 &lt; i &lt; arr.length - 1），满足<br>arr[0] &lt; arr[1] &lt; … &lt; arr[i - 1] &lt; arr[i]<br>arr[i] &gt; arr[i + 1] &gt; … &gt; arr[arr.length - 1]<br>给出一个整数数组 arr，返回最长山脉子数组的长度。如果不存在山脉子数组，返回 0 。<br>示例 1：<br>输入：arr = [2,1,4,7,3,2,5]<br>输出：5<br>解释：最长的山脉子数组是 [1,4,7,3,2]，长度为 5。<br>示例 2：</p>\n<p>输入：arr = [2,2,2]<br>输出：0<br>解释：不存在山脉子数组。<br>提示：<br>1 &lt;= arr.length &lt;= 104<br>0 &lt;= arr[i] &lt;= 104<br> <br>进阶：<br>你可以仅用一趟扫描解决此问题吗？<br>你可以用 O(1) 空间解决此问题吗？</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">longestMountain</span><span class=\"params\">(A []<span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    N := <span class=\"built_in\">len</span>(A)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> N &lt; <span class=\"number\">3</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    left := <span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"comment\">// -1表示只有一个元素</span></span><br><span class=\"line\">    <span class=\"comment\">// 0表示正上升</span></span><br><span class=\"line\">    <span class=\"comment\">// 1表示正下降</span></span><br><span class=\"line\">    status := <span class=\"number\">-1</span></span><br><span class=\"line\">    preValue := A[<span class=\"number\">0</span>]</span><br><span class=\"line\">    ans := <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 题目要求必须至少有3个元素，所以不可能从0开始</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">1</span>; i &lt; N; i++ &#123;</span><br><span class=\"line\">        x := A[i]</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 如果要把x加进来</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果里面还只有一个元素</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> status == <span class=\"number\">-1</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> x &gt; preValue &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 那么状态改为上升</span></span><br><span class=\"line\">                status = <span class=\"number\">0</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 如果相等，或者变小，那么区间只能再变成只有一个元素的了</span></span><br><span class=\"line\">                <span class=\"comment\">// 状态依然更新为只有一个元素</span></span><br><span class=\"line\">                status = <span class=\"number\">-1</span></span><br><span class=\"line\">                <span class=\"comment\">// 区间更新为(left, i]</span></span><br><span class=\"line\">                left = i - <span class=\"number\">1</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 如果正在上升</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> status == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> x &gt; preValue &#123;</span><br><span class=\"line\">                <span class=\"comment\">// nothing</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> x == preValue &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 如果相等，那么区间只能再变成只有一个元素的状态了</span></span><br><span class=\"line\">                status = <span class=\"number\">-1</span></span><br><span class=\"line\">                left = i - <span class=\"number\">1</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 下降了</span></span><br><span class=\"line\">                status = <span class=\"number\">1</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 如果正在下降</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> status == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> x &lt; preValue &#123;</span><br><span class=\"line\">                <span class=\"comment\">// nothing</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> x == preValue &#123;</span><br><span class=\"line\">                status = <span class=\"number\">-1</span></span><br><span class=\"line\">                left = i - <span class=\"number\">1</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 如果正在上升</span></span><br><span class=\"line\">                status = <span class=\"number\">0</span></span><br><span class=\"line\">                <span class=\"comment\">// 注意这里left要变成(i - 2, i]</span></span><br><span class=\"line\">                <span class=\"comment\">// 这里已经有两个元素了</span></span><br><span class=\"line\">                left = i - <span class=\"number\">2</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        preValue = x</span><br><span class=\"line\">        <span class=\"keyword\">if</span> status == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">            ans = max(ans, i-left)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ans &gt;= <span class=\"number\">3</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">max</span><span class=\"params\">(args ...<span class=\"type\">int</span>)</span></span><span class=\"type\">int</span>&#123;</span><br><span class=\"line\">    m := args[<span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, val := <span class=\"keyword\">range</span> args&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> val &gt; m &#123;</span><br><span class=\"line\">             m = val</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"3-ensp-例题：区间计数\"><a href=\"#3-ensp-例题：区间计数\" class=\"headerlink\" title=\"3  &ensp; 例题：区间计数\"></a><strong>3</strong>  &ensp; 例题：区间计数</h2><h3 id=\"区间计数\"><a href=\"#区间计数\" class=\"headerlink\" title=\"区间计数\"></a>区间计数</h3><blockquote>\n<p>区间最优原则表示：当按照区间最右边元素划分区间，并找到最优解之后，left继续向有移动形成的短区间都满足条件</p>\n</blockquote>\n<h4 id=\"代码模板\"><a href=\"#代码模板\" class=\"headerlink\" title=\"代码模板\"></a>代码模板</h4><blockquote>\n<p>在求最长区间代码模板上变式</p>\n</blockquote>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">rangeCounter</span><span class=\"params\">(A []<span class=\"type\">int</span>)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 区间的左指针</span></span><br><span class=\"line\">    left,ans := <span class=\"number\">-1</span>,<span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"comment\">// 不变式0： 最开始的区间为(-1，-1] 是一个空区间</span></span><br><span class=\"line\">    <span class=\"comment\">//          我们认为空区间总是满足条件</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i:=<span class=\"number\">0</span>; i&lt;<span class=\"built_in\">len</span>(A); i++&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 不变式1： 在加入A[i]之前，(left,i-1]是一个合法的有效区间</span></span><br><span class=\"line\">        <span class=\"comment\">// 需要改变的部分为下：</span></span><br><span class=\"line\">        <span class=\"comment\">// Step1： 直接将A[i]加入到区间中，形成(left,i]</span></span><br><span class=\"line\">        <span class=\"comment\">// Step2:  将A[i] 加入之后，依据多性原则判断Left是否移动且移动多少</span></span><br><span class=\"line\">        <span class=\"comment\">/** <span class=\"doctag\">TODO:</span> 设计check函数，检查区间是否满足条件</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> check(left,i] &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果不满足条件，则移动左指针</span></span><br><span class=\"line\">            left++</span><br><span class=\"line\">            <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">            <span class=\"doctag\">TODO:</span> 修改区间的状态或者改变区间的性质</span></span><br><span class=\"line\"><span class=\"comment\">            */</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 不变式2： 此时(left,i]必然合法</span></span><br><span class=\"line\">        <span class=\"comment\">// 累计区间个数: 以A[i]为有边界的子区间总共有i-left个</span></span><br><span class=\"line\">        ans = ans + i-left</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"cover":"/img/cover/elderring.png","cover_type":"img","excerpt":"","more":"<h1 id=\"双指针：如何掌握最长、定长、最短区间问题的解题诀窍\"><a href=\"#双指针：如何掌握最长、定长、最短区间问题的解题诀窍\" class=\"headerlink\" title=\"双指针：如何掌握最长、定长、最短区间问题的解题诀窍\"></a>双指针：如何掌握最长、定长、最短区间问题的解题诀窍</h1><blockquote>\n<p>通常是明明用两个指针在数组/链表上遍历，然后解决满足某种性质的问题<br>解决问题：<br><strong>最长区间</strong><br><strong>定长区间</strong><br><strong>最短区间</strong><br><font color = 'red'>1. 弄清楚题目要的是什么样的区间，是上述三种中的哪一类</font><br><font color = 'red'>2. 区间需要满足的条件是什么</font></p>\n</blockquote>\n<h2 id=\"1-ensp-区间特性\"><a href=\"#1-ensp-区间特性\" class=\"headerlink\" title=\"1 &ensp; 区间特性\"></a><strong>1</strong> &ensp; 区间特性</h2><h3 id=\"单调性-amp-最优\"><a href=\"#单调性-amp-最优\" class=\"headerlink\" title=\"单调性 &amp; 最优\"></a>单调性 &amp; 最优</h3><blockquote>\n<p>使用双指针需要保证区间的单调性</p>\n</blockquote>\n<ol>\n<li><p>单调性的定义：<br>区间的单调性： 固定了划分区间的条件之后，遍历区间内的元素，按照一定顺序的时候，区间内的元素应该是都满足某一个条件，且存在问题定义上的大小单调变化。<br>比如： 在一个完全都是正整数的区间里面，划分子集的标准是固定子集右端元素（最右端元素只能是A[i]），集合内元素的和从下标为-1到i-1,均大于某个数，且这个和逐步减少（$\\because 元素都是正数，减少了就变小了$）</p>\n</li>\n<li><p>快速判断区间属性是否满足单调性的办法<br><font color = 'red'> 往区间里面添加元素的时候，区间的约束条件可以变化，但不能出现波折</font><br>理解为： 添加一个元素之后，要么依旧满足条件，符合单调性；要么出现一会不满足一会满足的情况，不符合单调性</p>\n</li>\n</ol>\n<blockquote>\n<p>遍历区间的所有子集可以使用这样的方式： 固定子集的最右边元素为固定元素：<br>固定右区间集合，把A[i]元素固定为区间的右端点，之变动区间的左边界形成的所有区间，并且按照区间长度需要从长到短排列</p>\n</blockquote>\n<ol start=\"3\">\n<li>找到最优解<br><font color = 'red'> 从左向右遍历区间右端固定元素集合中的每个区间，找到一个满足条件的解就停止（因为单调性继续调整依旧满足条件）</font></li>\n</ol>\n<h3 id=\"模板\"><a href=\"#模板\" class=\"headerlink\" title=\"模板\"></a>模板</h3><ol>\n<li><p>寻找以A[i]为有边界的最优解，分为以下三步</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Step <span class=\"number\">1</span> :</span><br><span class=\"line\">将A[i] 加入到区间中，形成新的区间 （left,i]</span><br><span class=\"line\">room = <span class=\"built_in\">append</span>(room,A[i])</span><br><span class=\"line\"></span><br><span class=\"line\">Step <span class=\"number\">2</span>：</span><br><span class=\"line\">遍历A[i]的固定右区间集，直到找到以A[i]为右端点的最优解</span><br><span class=\"line\"><span class=\"keyword\">for</span> left &lt; i &amp;&amp; (left,i] 区间不满足要求 &#123;</span><br><span class=\"line\">    left++</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\">Step <span class=\"number\">3</span>:</span><br><span class=\"line\">此时要么得到一个满足要求的解，要么没有满足单调性的区间</span><br><span class=\"line\">(left,i]区间满足要求</span><br></pre></td></tr></table></figure></li>\n<li><p>题目须具备的条件</p>\n<ul>\n<li>给定一个条件</li>\n<li>求最长区间/最长字串</li>\n<li>题目给出的区间需要具备的单调性</li>\n</ul>\n</li>\n<li><p>必杀技</p>\n<ul>\n<li>left，right 指针</li>\n<li>只有在不满足条件的时候才向右移动left指针</li>\n</ul>\n</li>\n<li><p>最长区间的代码模板</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">maxLength</span><span class=\"params\">(A []<span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建左指针和结果</span></span><br><span class=\"line\">    left, ans := <span class=\"number\">-1</span>, <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 从左向右遍历区间</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i:= <span class=\"number\">0</span>; i&lt; <span class=\"built_in\">len</span>(A); i++&#123;</span><br><span class=\"line\">        <span class=\"comment\">// Assert 在加入 A[i] 之前，(left,i-1] 是一个合法有效的区间，在最开始的时候left = -1，i-1=-1，是空区间，满足条件</span></span><br><span class=\"line\">        <span class=\"comment\">// Step1 : 直接将A[i]加到区间中，形成(left,i]</span></span><br><span class=\"line\">        <span class=\"comment\">// step2 : 将A[I]加入之后，依据left的惰性yuanze</span></span><br><span class=\"line\">        <span class=\"comment\">// <span class=\"doctag\">TODO:</span> check检查区间状态是否满足条件</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> check(left,i) &#123;</span><br><span class=\"line\">            left++<span class=\"comment\">// 如果不满足条件，移动左指针</span></span><br><span class=\"line\">            <span class=\"comment\">// TODO： 修改区间的状态</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// assert 此时的(left,i] 必然满足条件</span></span><br><span class=\"line\">        ans = max(ans,i-left)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 返回最优解</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>时间复杂度为 O(n)</p>\n<h2 id=\"2-ensp-例题-区间长度类型\"><a href=\"#2-ensp-例题-区间长度类型\" class=\"headerlink\" title=\"2 &ensp; 例题: 区间长度类型\"></a><strong>2</strong> &ensp; 例题: 区间长度类型</h2><h3 id=\"不含重复字符的最长区间\"><a href=\"#不含重复字符的最长区间\" class=\"headerlink\" title=\"不含重复字符的最长区间\"></a>不含重复字符的最长区间</h3><blockquote>\n<p>单调性： 当找到一个没有重复字符的区间时候，减少区间内元素，新的区间依旧满足没有重复元素<br><a href=\"https://leetcode.cn/problems/longest-substring-without-repeating-characters/\">https://leetcode.cn/problems/longest-substring-without-repeating-characters/</a></p>\n</blockquote>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(s <span class=\"type\">string</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 双指针解决</span></span><br><span class=\"line\">    left, ans := <span class=\"number\">-1</span>,<span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"comment\">// 存储区间内元素的映射</span></span><br><span class=\"line\">    m := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">byte</span>]<span class=\"type\">int</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt;<span class=\"built_in\">len</span>(s); i++ &#123;</span><br><span class=\"line\">        m[s[i]] += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> m[s[i]] &gt; <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">            left++</span><br><span class=\"line\">            m[s[left]]--</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ans = max(ans, i-left)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">max</span><span class=\"params\">(args ...<span class=\"type\">int</span>)</span></span><span class=\"type\">int</span>&#123;</span><br><span class=\"line\">    m := args[<span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, val := <span class=\"keyword\">range</span> args&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> val &gt; m &#123;</span><br><span class=\"line\">            m = val</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"替换后的最长重复字符\"><a href=\"#替换后的最长重复字符\" class=\"headerlink\" title=\"替换后的最长重复字符\"></a>替换后的最长重复字符</h3><blockquote>\n<p>给你一个字符串 s 和一个整数 k 。你可以选择字符串中的任一字符，并将其更改为任何其他大写英文字符。该操作最多可执行 k 次。<br><a href=\"https://leetcode.cn/problems/longest-repeating-character-replacement/\">https://leetcode.cn/problems/longest-repeating-character-replacement/</a></p>\n</blockquote>\n<p>在执行上述操作后，返回包含相同字母的最长子字符串的长度。<br>示例 1：<br>输入：s = “ABAB”, k = 2<br>输出：4<br>解释：用两个’A’替换为两个’B’,反之亦然。<br>示例 2：<br>输入：s = “AABABBA”, k = 1<br>输出：4<br>解释：<br>将中间的一个’A’替换为’B’,字符串变为 “AABBBBA”。<br>子串 “BBBB” 有最长重复字母, 答案为 4。<br> 提示：<br>1 &lt;= s.length &lt;= 105<br>s 仅由大写英文字母组成<br>0 &lt;= k &lt;= s.length</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">characterReplacement</span><span class=\"params\">(s <span class=\"type\">string</span>, k <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// </span></span><br><span class=\"line\">    left, ans := <span class=\"number\">-1</span>,<span class=\"number\">0</span></span><br><span class=\"line\">    max_repeat := <span class=\"number\">0</span></span><br><span class=\"line\">    m := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">byte</span>]<span class=\"type\">int</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(s); i++&#123;</span><br><span class=\"line\">        m[s[i]]++</span><br><span class=\"line\"></span><br><span class=\"line\">        max_repeat = max(m[s[i]],max_repeat)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i-left-max_repeat &gt; k&#123;</span><br><span class=\"line\">            left++</span><br><span class=\"line\">            m[s[left]]--</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        ans = max(ans,i-left)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">max</span><span class=\"params\">(args ...<span class=\"type\">int</span>)</span></span><span class=\"type\">int</span>&#123;</span><br><span class=\"line\">    m := args[<span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, val := <span class=\"keyword\">range</span> args&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> val &gt; m &#123;</span><br><span class=\"line\">            m = val</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"字符流中第一个只出现一次的字符\"><a href=\"#字符流中第一个只出现一次的字符\" class=\"headerlink\" title=\"字符流中第一个只出现一次的字符\"></a>字符流中第一个只出现一次的字符</h3><blockquote>\n<p>请实现一个函数用来找出字符流中第一个只出现一次的字符。<br><a href=\"https://www.acwing.com/problem/content/60/\">https://www.acwing.com/problem/content/60/</a><br>例如，当从字符流中只读出前两个字符 go 时，第一个只出现一次的字符是 g。<br>当从该字符流中读出前六个字符 google 时，第一个只出现一次的字符是 l。<br>如果当前字符流没有存在出现一次的字符，返回 # 字符。<br>数据范围<br>字符流读入字符数量 [0,1000]</p>\n</blockquote>\n<p>样例<br>输入：”google”<br>输出：”ggg#ll”<br>解释：每当字符流读入一个字符，就进行一次判断并输出当前的第一个只出现一次的字符。</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Solution <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    left <span class=\"type\">int</span> <span class=\"comment\">// 最左侧字符位置</span></span><br><span class=\"line\">    cnt  [<span class=\"number\">256</span>]<span class=\"type\">int</span> <span class=\"comment\">// 字符个数计数器</span></span><br><span class=\"line\">    s    <span class=\"type\">string</span> <span class=\"comment\">// 保存输入的字符串</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> s Solution</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">insert</span><span class=\"params\">(ch <span class=\"type\">byte</span>)</span></span> &#123;</span><br><span class=\"line\">    s.cnt[ch]++ <span class=\"comment\">// 将该字符出现次数加1</span></span><br><span class=\"line\">    s.s += <span class=\"type\">string</span>(ch) <span class=\"comment\">// 将该字符加入到字符串s中</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果最左侧的字符出现次数大于1，则将最左侧字符的位置向右移动，直到最左侧字符出现次数为1或者left &gt;= right</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> s.left &lt; <span class=\"built_in\">len</span>(s.s) &amp;&amp; s.cnt[s.s[s.left]] &gt; <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">        s.left++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">firstAppearingOnce</span><span class=\"params\">()</span></span> <span class=\"type\">byte</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果最左侧字符位置left大于等于字符串s的长度，则返回&#x27;#&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> s.left &gt;= <span class=\"built_in\">len</span>(s.s) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&#x27;#&#x27;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 返回最左侧的字符</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> s.s[s.left]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"最多有k个不同字符的最长子字符串\"><a href=\"#最多有k个不同字符的最长子字符串\" class=\"headerlink\" title=\"最多有k个不同字符的最长子字符串\"></a>最多有k个不同字符的最长子字符串</h3><blockquote>\n<p>给定字符串S，找到最多有k个不同字符的最长子串T。<br><a href=\"https://www.lintcode.com/problem/386/\">https://www.lintcode.com/problem/386/</a><br>样例<br>样例 1:</p>\n</blockquote>\n<p>输入: S = “eceba” 并且 k = 3<br>输出: 4<br>解释: T = “eceb”<br>样例 2:</p>\n<p>输入: S = “WORLD” 并且 k = 4<br>输出: 4<br>解释: T = “WORL” 或 “ORLD”<br>挑战<br>O(n) 时间复杂度</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @param s: A string</span></span><br><span class=\"line\"><span class=\"comment\"> * @param k: An integer</span></span><br><span class=\"line\"><span class=\"comment\"> * @return: An integer</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">LengthOfLongestSubstringKDistinct</span><span class=\"params\">(s <span class=\"type\">string</span>, k <span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">    left, count,l := <span class=\"number\">-1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    m := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"type\">byte</span>]<span class=\"type\">int</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i:=<span class=\"number\">0</span>; i&lt; <span class=\"built_in\">len</span>(s); i++&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> m[s[i]] == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">            count++</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        m[s[i]]++</span><br><span class=\"line\">        <span class=\"keyword\">for</span> count &gt; k &#123;</span><br><span class=\"line\">            left++</span><br><span class=\"line\">            m[s[left]]--</span><br><span class=\"line\">            <span class=\"keyword\">if</span> m[s[left]] == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">                count--</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        l = max(l,i-left)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> l</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">max</span><span class=\"params\">(args ...<span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span>&#123;</span><br><span class=\"line\">    m := args[<span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, val := <span class=\"keyword\">range</span> args&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> val &gt; m &#123;</span><br><span class=\"line\">            m = val</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"数组中的最长山脉\"><a href=\"#数组中的最长山脉\" class=\"headerlink\" title=\"数组中的最长山脉\"></a>数组中的最长山脉</h3><blockquote>\n<p><a href=\"https://leetcode.cn/problems/longest-mountain-in-array/description/\">https://leetcode.cn/problems/longest-mountain-in-array/description/</a></p>\n</blockquote>\n<p>把符合下列属性的数组 arr 称为 山脉数组 ：</p>\n<p>arr.length &gt;= 3<br>存在下标 i（0 &lt; i &lt; arr.length - 1），满足<br>arr[0] &lt; arr[1] &lt; … &lt; arr[i - 1] &lt; arr[i]<br>arr[i] &gt; arr[i + 1] &gt; … &gt; arr[arr.length - 1]<br>给出一个整数数组 arr，返回最长山脉子数组的长度。如果不存在山脉子数组，返回 0 。<br>示例 1：<br>输入：arr = [2,1,4,7,3,2,5]<br>输出：5<br>解释：最长的山脉子数组是 [1,4,7,3,2]，长度为 5。<br>示例 2：</p>\n<p>输入：arr = [2,2,2]<br>输出：0<br>解释：不存在山脉子数组。<br>提示：<br>1 &lt;= arr.length &lt;= 104<br>0 &lt;= arr[i] &lt;= 104<br> <br>进阶：<br>你可以仅用一趟扫描解决此问题吗？<br>你可以用 O(1) 空间解决此问题吗？</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">longestMountain</span><span class=\"params\">(A []<span class=\"type\">int</span>)</span></span> <span class=\"type\">int</span> &#123;</span><br><span class=\"line\">    N := <span class=\"built_in\">len</span>(A)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> N &lt; <span class=\"number\">3</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    left := <span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"comment\">// -1表示只有一个元素</span></span><br><span class=\"line\">    <span class=\"comment\">// 0表示正上升</span></span><br><span class=\"line\">    <span class=\"comment\">// 1表示正下降</span></span><br><span class=\"line\">    status := <span class=\"number\">-1</span></span><br><span class=\"line\">    preValue := A[<span class=\"number\">0</span>]</span><br><span class=\"line\">    ans := <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 题目要求必须至少有3个元素，所以不可能从0开始</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">1</span>; i &lt; N; i++ &#123;</span><br><span class=\"line\">        x := A[i]</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 如果要把x加进来</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果里面还只有一个元素</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> status == <span class=\"number\">-1</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> x &gt; preValue &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 那么状态改为上升</span></span><br><span class=\"line\">                status = <span class=\"number\">0</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 如果相等，或者变小，那么区间只能再变成只有一个元素的了</span></span><br><span class=\"line\">                <span class=\"comment\">// 状态依然更新为只有一个元素</span></span><br><span class=\"line\">                status = <span class=\"number\">-1</span></span><br><span class=\"line\">                <span class=\"comment\">// 区间更新为(left, i]</span></span><br><span class=\"line\">                left = i - <span class=\"number\">1</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 如果正在上升</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> status == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> x &gt; preValue &#123;</span><br><span class=\"line\">                <span class=\"comment\">// nothing</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> x == preValue &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 如果相等，那么区间只能再变成只有一个元素的状态了</span></span><br><span class=\"line\">                status = <span class=\"number\">-1</span></span><br><span class=\"line\">                left = i - <span class=\"number\">1</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 下降了</span></span><br><span class=\"line\">                status = <span class=\"number\">1</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 如果正在下降</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> status == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> x &lt; preValue &#123;</span><br><span class=\"line\">                <span class=\"comment\">// nothing</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> x == preValue &#123;</span><br><span class=\"line\">                status = <span class=\"number\">-1</span></span><br><span class=\"line\">                left = i - <span class=\"number\">1</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 如果正在上升</span></span><br><span class=\"line\">                status = <span class=\"number\">0</span></span><br><span class=\"line\">                <span class=\"comment\">// 注意这里left要变成(i - 2, i]</span></span><br><span class=\"line\">                <span class=\"comment\">// 这里已经有两个元素了</span></span><br><span class=\"line\">                left = i - <span class=\"number\">2</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        preValue = x</span><br><span class=\"line\">        <span class=\"keyword\">if</span> status == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">            ans = max(ans, i-left)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ans &gt;= <span class=\"number\">3</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">max</span><span class=\"params\">(args ...<span class=\"type\">int</span>)</span></span><span class=\"type\">int</span>&#123;</span><br><span class=\"line\">    m := args[<span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, val := <span class=\"keyword\">range</span> args&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> val &gt; m &#123;</span><br><span class=\"line\">             m = val</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"3-ensp-例题：区间计数\"><a href=\"#3-ensp-例题：区间计数\" class=\"headerlink\" title=\"3  &ensp; 例题：区间计数\"></a><strong>3</strong>  &ensp; 例题：区间计数</h2><h3 id=\"区间计数\"><a href=\"#区间计数\" class=\"headerlink\" title=\"区间计数\"></a>区间计数</h3><blockquote>\n<p>区间最优原则表示：当按照区间最右边元素划分区间，并找到最优解之后，left继续向有移动形成的短区间都满足条件</p>\n</blockquote>\n<h4 id=\"代码模板\"><a href=\"#代码模板\" class=\"headerlink\" title=\"代码模板\"></a>代码模板</h4><blockquote>\n<p>在求最长区间代码模板上变式</p>\n</blockquote>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">rangeCounter</span><span class=\"params\">(A []<span class=\"type\">int</span>)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 区间的左指针</span></span><br><span class=\"line\">    left,ans := <span class=\"number\">-1</span>,<span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"comment\">// 不变式0： 最开始的区间为(-1，-1] 是一个空区间</span></span><br><span class=\"line\">    <span class=\"comment\">//          我们认为空区间总是满足条件</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i:=<span class=\"number\">0</span>; i&lt;<span class=\"built_in\">len</span>(A); i++&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 不变式1： 在加入A[i]之前，(left,i-1]是一个合法的有效区间</span></span><br><span class=\"line\">        <span class=\"comment\">// 需要改变的部分为下：</span></span><br><span class=\"line\">        <span class=\"comment\">// Step1： 直接将A[i]加入到区间中，形成(left,i]</span></span><br><span class=\"line\">        <span class=\"comment\">// Step2:  将A[i] 加入之后，依据多性原则判断Left是否移动且移动多少</span></span><br><span class=\"line\">        <span class=\"comment\">/** <span class=\"doctag\">TODO:</span> 设计check函数，检查区间是否满足条件</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> check(left,i] &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果不满足条件，则移动左指针</span></span><br><span class=\"line\">            left++</span><br><span class=\"line\">            <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">            <span class=\"doctag\">TODO:</span> 修改区间的状态或者改变区间的性质</span></span><br><span class=\"line\"><span class=\"comment\">            */</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 不变式2： 此时(left,i]必然合法</span></span><br><span class=\"line\">        <span class=\"comment\">// 累计区间个数: 以A[i]为有边界的子区间总共有i-left个</span></span><br><span class=\"line\">        ans = ans + i-left</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"2023 ospp fighting","catalog":true,"date":"2023-04-18T21:02:23.000Z","subtitle":null,"header-img":null,"_content":"\n\n\n> 本文档用于整理申请 2023ospp edgeMesh CNI 项目的准备和奋战过程\n\n\n\n# 时间线记录\n\n\n\n##  1. 项目申请准备阶段\n\n> 4/19 \n\n​\t调研并整理 CNI 相关内容\n\n\n\n","source":"_posts/EdgeMesh/cilium与edgemesh性能测试/2023-ospp-fighting/2023-ospp-fighting.md","raw":"---\ntitle: 2023 ospp fighting\ncatalog: true\ndate: 2023-04-19 05:02:23\nsubtitle:\nheader-img:\ntags: ospp, edgemesh\ncategories: ospp\n---\n\n\n\n> 本文档用于整理申请 2023ospp edgeMesh CNI 项目的准备和奋战过程\n\n\n\n# 时间线记录\n\n\n\n##  1. 项目申请准备阶段\n\n> 4/19 \n\n​\t调研并整理 CNI 相关内容\n\n\n\n","slug":"EdgeMesh/cilium与edgemesh性能测试/2023-ospp-fighting/2023-ospp-fighting","published":1,"updated":"2023-04-23T14:16:47.027Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgtm6jqv0020lyjx3b7wdi1a","content":"<blockquote>\n<p>本文档用于整理申请 2023ospp edgeMesh CNI 项目的准备和奋战过程</p>\n</blockquote>\n<h1 id=\"时间线记录\"><a href=\"#时间线记录\" class=\"headerlink\" title=\"时间线记录\"></a>时间线记录</h1><h2 id=\"1-项目申请准备阶段\"><a href=\"#1-项目申请准备阶段\" class=\"headerlink\" title=\"1. 项目申请准备阶段\"></a>1. 项目申请准备阶段</h2><blockquote>\n<p>4/19 </p>\n</blockquote>\n<p>​    调研并整理 CNI 相关内容</p>\n","site":{"data":{}},"cover":"/img/cover/elderring.png","cover_type":"img","excerpt":"","more":"<blockquote>\n<p>本文档用于整理申请 2023ospp edgeMesh CNI 项目的准备和奋战过程</p>\n</blockquote>\n<h1 id=\"时间线记录\"><a href=\"#时间线记录\" class=\"headerlink\" title=\"时间线记录\"></a>时间线记录</h1><h2 id=\"1-项目申请准备阶段\"><a href=\"#1-项目申请准备阶段\" class=\"headerlink\" title=\"1. 项目申请准备阶段\"></a>1. 项目申请准备阶段</h2><blockquote>\n<p>4/19 </p>\n</blockquote>\n<p>​    调研并整理 CNI 相关内容</p>\n"},{"title":"CNI 概述","catalog":true,"date":"2023-04-18T21:02:23.000Z","subtitle":null,"header-img":null,"_content":"\n<!-- @import \"[TOC]\" {cmd=\"toc\" depthFrom=1 depthTo=6 orderedList=false} -->\n- [CNI 概述](#cni-概述)\n  - [什么是 CNI](#什么是-cni)\n  - [CNI 的功能](#cni-的功能)\n  - [CNI 统一的网络配置文件](#cni-统一的网络配置文件)\n    - [CNI 运行时协议](#cni-运行时协议)\n  - [CNI 与插件](#cni-与插件)\n- [CNI 配置文件样例分析](#cni-配置文件样例分析)\n  - [CNI 配置文件语法](#cni-配置文件语法)\n- [相关仓库及文献](#相关仓库及文献)\n\n\n# CNI 概述\n\n## 什么是 CNI \n\n> CNI的全称是 Container Network Interface，它为**容器提供了一种基于插件结构的标准化网络解决方案**。以往，容器的网络层是和具体的底层网络环境高度相关的，不同的网络服务提供商有不同的实现。**CNI从网络服务里抽象出了一套标准接口**，从而屏蔽了上层网络和底层网络提供商的网络实现之间的差异。并且，通过插件结构，它让容器在网络层的具体实现变得可插拔了，所以非常灵活。\n\n首先 CNI 是一套标准接口，它隶属于[CNCF(Cloud Native Computing Foundation)](https://cncf.io/)，依照这个标准所实现的为 CNI Plugins, 他们彼此独立，也可以组合起来一起使用，由一组用于配置 Linux 容器的网络接口的规范和库组成，同时还包含了一些插件，CNI 仅关心容器创建时的网络分配，和当容器被删除时释放网络资源。\n\n其次 依据 CNI 的[规范](https://github.com/containernetworking/cni/blob/master/SPEC.md)，CNI 具有以下几点特征：\n\n- CNI 需提供网络管理员**定义网络配置的文件格式**\n- CNI 需提供 Container Runtime（CRI） 调用功能的**协议/API**。\n- 当 CNI 被 CRI 调用时，需依据配置文件执行网络配置功能\n- CNI 需预留可调用其他插件的能力\n- CNI 需规范统一返回给CRI 的数据格式\n\n依据这样的特征和要求，可以明确实现一个CNI插件需要包含以下部分：\n\n* 可执行文件\n  * cni plugins\n  * IPAM\n* 网络配置文件\n\n\n\n## CNI 的功能\n\nCNI 插件首先得实现一个可以被容器管理系统（CRI），比如rkt、Kubernetes 所调用的可执行文件——cni plugins，这个插件首先需要提供**基础的 Linux 网络联通服务**，比如创建 veth 或者 bridge 并将 veth 对的一端插入容器的 network namespace，一端插入 bridge，使得容器之间可以相互通信。然后**将IP 分配给接口**，并通过调用 **IPAM **插件来设置和管理IP地址，使得集群内的容器IP地址相互不重复，或者是结合其他的插件来实现更加复杂的网络路由管理功能等等。\n\n那么接下来，依据对于这几项功能的要求，来具体看看 CNI 的标准\n\n\n\n## CNI 统一的网络配置文件\n\nCNI 为容器网络管理员(操作人员、网络插件、网络编排系统)定义了一种网络配置格式。它包含了供 CRI 和 CNI 插件使用的指令。在插件执行时，这种配置格式由 CRI 解释，并转化为代码数据结构，传递给 CNI 插件。\n\n一般来说配置文件主要是以 JSON 文件为主，且包含以下几个键值：\n\n- `cniVersion`: 指定CNI规范的版本，这样 CRI 和 CNI 才能读懂彼此\n- `Name`: 网络名字，这在一个主机（或其他管理域）的所有网络配置中应该是唯一的。必须以一个字母数字字符开始，后面可以选择由一个或多个字母数字字符、下划线、点（.）或连字符（-）的任何组合。\n- `disableCheck`: 是否禁用检查网络，如果为true,则 `container runtime` 不会调用 Check 方法进行网络检查。\n- `plugin`: cni插件及其配置列表，可以配置多个插件。\n\n接着展开说明一下 plugin 当中的参数，这也与实现 CNI 的功能息息相关，CRI 解析出配置文件当中的这个字段，是必须要一个字不漏地完整交给 CNI 插件来做网络管理\n\n1. 必须配置的键值\n\n   `type` :  指定目前系统目录当中所使用的 CNI 插件，一般是 cni 可执行文件的目录索引\n\n   至少得有一个基础的 cni 插件来完成最基础的 Linux 网络配置的功能\n\n2. 可选键值，由 CRI 依据协议发送的 request 指定\n\n   `capabilities`:  如果 CNI_ARGS 中没有指定此项功能时候来补充的\n\n3. 预留键值，由 CRI 在执行时产生的\n\n   - `runtimeConfig` :  比如 CNI 自己设置的 isGateway == true 就表明告诉插件，作为网关，给bridge指定一个IP地址。这样，连接到bridge的容器就可以拿它当网关来用了。\n   - `args`\n   - 或者是任何以 `cni.dev/`开头的\n\n4. 可选键值,由容器网络管理员添加\n\n   `ipMasq`: 为目标网络配上Outbound Masquerade(地址伪装)，即：由容器内部通过网关向外发送数据包时，对数据包的源IP地址进行修改。\n\n   当我们的容器以宿主机作为网关时，这个参数是必须要设置的。否则，从容器内部发出的数据包就没有办法通过网关路由到其他网段。因为容器内部的IP地址无法被目标网段识别，所以这些数据包最终会被丢弃掉。\n\n   `ipam`: PAM(IP Adderss Management)即IP地址管理，提供了一系列方法用于对IP和路由进行管理。实际上，它对应的是由CNI提供的一组标准IPAM插件，比如像host-local，dhcp，static等。如果要对整个集群的地址做管理，让pod具有单独的ip地址，就需要在这里添加额外的插件\n\n   > 例子1当中：\n   >\n   > - type：指定所用IPAM插件的名称，在例子里，用的是host-local。\n   > - subnet：为目标网络分配网段，包括网络ID和子网掩码，以CIDR形式标记。在例子里为`10.15.10.0/24`，也就是目标网段为`10.15.10.0`，子网掩码为`255.255.255.0`。\n   > - routes：用于指定路由规则，插件会在容器的路由表里生成相应的规则。其中，dst表示希望到达的目标网段，以CIDR形式标记。gw对应网关的IP地址，也就是要到达目标网段所要经过的“next hop(下一跳)”。如果省略gw的话，那么插件会自动帮容器选择默认网关。在例子里，gw选择的是默认网关，而dst为`0.0.0.0/0`则代表“任何网络”，表示数据包将通过默认网关发往任何网络。实际上，这对应的是一条默认路由规则，即：当所有其他路由规则都不匹配时，将选择该路由。\n   > - rangeStart：允许分配的IP地址范围的起始值\n   > - rangeEnd：允许分配的IP地址范围的结束值\n   > - gateway：为网关（也就是将要在宿主机上创建的bridge）指定的IP地址。如果省略的话，那么插件会自动从允许分配的IP地址范围内选择起始值作为网关的IP地址。\n\n配置文件例子如下：\n\n例子1：\n\n```json\n{\n    \"cniVersion\": \"0.4.0\",\n    \"name\": \"lab-br0\",\n    \"type\": \"bridge\",\n    \"bridge\": \"lab-br0\",\n    \"isGateway\": true,\n    \"ipMasq\": true,\n    \"ipam\": {\n        \"type\": \"host-local\",\n        \"subnet\": \"10.15.10.0/24\",\n        \"routes\": [\n            { \"dst\": \"0.0.0.0/0\" }\n        ],\n        \"rangeStart\": \"10.15.10.100\",\n        \"rangeEnd\": \"10.15.10.200\",\n        \"gateway\": \"10.15.10.99\"\n    }\n}\n```\n\n例子2：\n\n```json\n{\n  \"cniVersion\": \"1.0.0\",\n  \"name\": \"dbnet\",\n  \"plugins\": [\n    {\n      \"type\": \"bridge\",\n      // plugin specific parameters\n      \"bridge\": \"cni0\",\n      \"keyA\": [\"some more\", \"plugin specific\", \"configuration\"],\n      \n      \"ipam\": {\n        \"type\": \"host-local\",\n        // ipam specific\n        \"subnet\": \"10.1.0.0/16\",\n        \"gateway\": \"10.1.0.1\",\n        \"routes\": [\n            {\"dst\": \"0.0.0.0/0\"}\n        ]\n      },\n      \"dns\": {\n        \"nameservers\": [ \"10.1.0.1\" ]\n      }\n    },\n    {\n      \"type\": \"tuning\",\n      \"capabilities\": {\n        \"mac\": true\n      },\n      \"sysctl\": {\n        \"net.core.somaxconn\": \"500\"\n      }\n    },\n    {\n        \"type\": \"portmap\",\n        \"capabilities\": {\"portMappings\": true}\n    }\n  ]\n}\n```\n\n\n\n### CNI 运行时协议\n\nCNI协议是基于由 CRI 的调用请求来告诉 CNI 该做些什么。\n\n主要的协议参数定义如下：\n\n* CNI_COMMAND：表示所需的操作；ADD、DEL、CHECK、或VERSION。\n* CNI_CONTAINERID：容器ID。告诉CNI插件，将要加入目标网络的容器所对应的network namespace的ID,容器的唯一的标识符，由 CRI 分配。不能是空的。必须以一个字母数字字符开始，后面可以选择一个或多个字母数字字符、下划线（）、点（.）或连字符（-）的任何组合。\n* CNI_NETNS：容器对应的network namespace在宿主机上的文件路径。（例如：/run/netns/[nsname]）。\n* CNI_IFNAME：作为veth pair在容器一端的网络接口,一般是在容器内创建的接口的名称；如果 CNI 插件无法使用这个接口名称，那么就必须返回一个错误。\n* CNI_ARGS：用户在调用时传入的额外参数。用分号分隔的字母数字键值对；例如，\"FOO=BAR;ABC=123\"\n* CNI_PATH: 表示 CNI 插件可执行文件的路径列表。路径由操作系统特定的列表分隔符分隔；例如Linux上的':'和Windows上的'；'。\n\n告诉CNI插件要执行的命令，允许的命令有ADD，DEL，CHECK，VERSION。\n\n对于支持CNI规范的容器系统而言，当容器启动的时候，系统就会自动调用相应的CNI插件，并设置CNI_COMMAND为ADD。相应地，DEL是在容器被销毁时调用的，用于清除在执行ADD阶段分配的网络资源。CHECK用于检查容器网络是否正常。VERSION则用来显示插件的版本。具体的操作如下：\n\n* ADD\n\n  - 将容器添加到网络中，或将新的配置修改应用到已有的集群当中。\n\n  - 一个CNI插件在收到ADD命令后，应该选择\n\n    - 在 CNI_NETNS 的容器内创建由 CNI_IFNAME 定义的接口，\n\n    - 调整容器内 CNI_NETNS 处由CNI_IFNAME定义的接口的配置\n\n      如果CNI插件成功，必须要返回一个处理结果，要么打印出来，要么修改传入的参数。\n\n* DELETE\n\n  * 将容器删除出网络，或将新的配置修改应用到已有的集群当中。\n\n    功能与ADD 相对\n\n* CHECK\n\n  * 查找类型字段中指定的可执行文件，如果没找到返回错误\n  * 当 Plugins （CNI调用的其他的Plugins）返回错误时，将其返回给调用者\n\n---\n\n## CNI 与插件\n\n为了解决容器网络的各项需求和问题，将所有的功能单独集中在 CNI 单个程序中是不现实的，而且难以兼容不同的上层系统和底层的网络管理，于是一个显然的想法就是将这些功能独立出来，使用插件（Plugins）的形式来执行。\n\n一个常见的例子就是 IP 地址管理，这就是IP地址管理插件（IPAM插件），它必须设置容器和虚拟网络设备的接口 ，IP / 子网，网关和路由，然后将此信息返回给“主”插件（CNI本体）来执行，换句话说 IPAM 做逻辑上的网络地址管理然后告诉本体 CNI 去执行 `ADD`,`DELETE`。 \n\nCNI 本体调用这些插件的形式也是通过路径找到这些插件的可执行文件来实现的，一般这些插件的位置也都一起放置在 `CNI_PATH`之下。同时插件和 CNI 本体都是通过 stdin 接收网络配置，也通过 stdout 输出结果。\n\n如此看来 CNI 的工作流程就是一条链状的调用过程，但调用链中的每一个可执行程序所接收的配置文件信息并不相同。\n\n---\n\n# CNI 配置文件样例分析\n\n> 参考[cni/SPEC.md at spec-v1.0.0 · containernetworking/cni (github.com)](https://github.com/containernetworking/cni/blob/spec-v1.0.0/SPEC.md) 的 Appendix: Examples\n\n借助 Github 所给的 SPEC 例子，要求 CRI 生成 portmap 和mac 相关的参数，同时使用CNI_IFNAME=eth0。假设目前 CRI 接收到的 json 文件如下：\n\n``` json\n{\n  \"cniVersion\": \"1.0.0\",\n  \"name\": \"dbnet\",\n  \"plugins\": [\n    {\n      \"type\": \"bridge\",\n      // plugin specific parameters\n      \"bridge\": \"cni0\",\n      \"keyA\": [\"some more\", \"plugin specific\", \"configuration\"],\n      \n      \"ipam\": {\n        \"type\": \"host-local\",\n        // ipam specific\n        \"subnet\": \"10.1.0.0/16\",\n        \"gateway\": \"10.1.0.1\",\n        \"routes\": [\n            {\"dst\": \"0.0.0.0/0\"}\n        ]\n      },\n      \"dns\": {\n        \"nameservers\": [ \"10.1.0.1\" ]\n      }\n    },\n    {\n      \"type\": \"tuning\",\n      \"capabilities\": {\n        \"mac\": true\n      },\n      \"sysctl\": {\n        \"net.core.somaxconn\": \"500\"\n      }\n    },\n    {\n        \"type\": \"portmap\",\n        \"capabilities\": {\"portMappings\": true}\n    }\n  ]\n}\n```\n\n我把它简化一下，提取出重要的配置参数，按照插件的调用链来作解释。\n\n对于 `ADD` 操作，配置文件所看到的主体为如下所示，提供信息表明 cni 标准为： \"1.0.0\", 并创建一个名为dbnet的网络空间，这个网络空间并不是指 network namespace,应该把它理解为一个局域网络的名字，比如插件使用的是 `bridge`创建，那么这个名字就是创建的网桥名字，也就是`ifconfig` 看到的网络设备名字；同时配置文件规定了整个 CNI plugins 的调用链，包括从 `bridge`到`tuning`再到`portmap`，然后完成这个网络空间的创建即 `ADD` 操作\n\n```json\n{\n  \"cniVersion\": \"1.0.0\",\n  \"name\": \"dbnet\",\n  \"plugins\": [\n    {\"type\": \"bridge\",\"bridge\": \"cni0\",\"ipam\": {},\"dns\": {}},\n    {\"type\": \"tuning\"},\n    {\"type\": \"portmap\"}\n  ]\n}\n```\n\n首先 CRI 会调用 `bridge` 插件( CNI ) ,传入 `CNI_COMMAND=ADD`参数，并传入以下 json 信息:\n\n``` json\n{\n    \"cniVersion\": \"1.0.0\",\n    \"name\": \"dbnet\",\n    \"type\": \"bridge\",\n    \"bridge\": \"cni0\",\n    \"keyA\": [\"some more\", \"plugin specific\", \"configuration\"],\n    \"ipam\": {\n        \"type\": \"host-local\",\n        \"subnet\": \"10.1.0.0/16\",\n        \"gateway\": \"10.1.0.1\"\n    },\n    \"dns\": {\n        \"nameservers\": [ \"10.1.0.1\" ]\n    }\n}\n```\n\n被调用的 CNI 插件 bridge ，首先会去调用他所管的 IPAM 插件 `host-local`，并传入与它收到的配置信息和 ADD指令参数，也就是下面两行,创建一个 `10.1.0.0/16`的子网，同时设置 `10.1.0.1 为`网关（`gateway`表示对应网关的IP地址，也就是要到达目标网段所要经过的“next hop(下一跳)），地址为`10.1.0.1`。\n\n``` json\n        \"subnet\": \"10.1.0.0/16\",\n        \"gateway\": \"10.1.0.1\"\n```\n\n设置成功，IPAM 插件应该返回以下的结果给 bridge，但这个设置的概念与不同的 CNI 实现有关，一般来说单独的 IPAM 设置指的是数据层面的管理，这个 IPAM 会为容器端的网络接口分配IP地址，比如通过调用`net.ParseCIDR`函数，对传入的`ipAddress`进行解析，依据节点环境并生成`ipv4Addr`和`ipv4Net`对象，并返回数据，但是并没有调用 Linux 的接口生成对象。\n\n```json\n{\n    \"ips\": [\n        {\n          \"address\": \"10.1.0.5/16\",\n          \"gateway\": \"10.1.0.1\"\n        }\n    ],\n    \"routes\": [\n      {\n        \"dst\": \"0.0.0.0/0\"\n      }\n    ],\n    \"dns\": {\n      \"nameservers\": [ \"10.1.0.1\" ]\n    }\n}\n```\n\n新增加的两条信息：\n\n1. `routes` 表示路由规则，如果在配置日志文件当中设置好，IPAM 插件会为 CNI 在容器的路由表里生成相应的规则。其中，`dst`表示希望到达的目标网段，以CIDR形式标记，在例子里 dst 为`0.0.0.0/0`，代表“任何网络”，表示数据包将通过默认网关发往任何网络，实际上，这对应的是一条默认路由规则，即：当所有其他路由规则都不匹配时，将选择该路由。\n\n2. `dns` 表示设置的 dns 服务由网关提供\n\nbridge 插件得到配置地址的结果和参数之后，就会依据 IPAM 所给的信息来设置节点的网络情况，一般是这个时候来来调用 `setupVeth` 以及 `netlink` 的函数方法，创建并写入对象信息，就像是指令来执行 `ip link add`,`ip link set ... up`等等。\n\n当创建过程结束之后，bridge 插件就会返回以下结果：\n\n```json\n{\n    \"ips\": [\n        {\n          \"address\": \"10.1.0.5/16\",\n          \"gateway\": \"10.1.0.1\",\n          \"interface\": 2\n        }\n    ],\n    \"routes\": [\n      {\n        \"dst\": \"0.0.0.0/0\"\n      }\n    ],\n    \"interfaces\": [\n        {\n            \"name\": \"cni0\",\n            \"mac\": \"00:11:22:33:44:55\"\n        },\n        {\n            \"name\": \"veth3243\",\n            \"mac\": \"55:44:33:22:11:11\"\n        },\n        {\n            \"name\": \"eth0\",\n            \"mac\": \"99:88:77:66:55:44\",\n            \"sandbox\": \"/var/run/netns/blue\"\n        }\n    ],\n    \"dns\": {\n      \"nameservers\": [ \"10.1.0.1\" ]\n    }\n}\n```\n\n其实上面已经是相对完整的调用过程了，但是例子当中的插件还继续调用了```tuning```,\n   ```portmap```,流程是相同的，但是关键在于传入的参数。\n\n`tuning` 接收的参数包括 `CNI_COMMAND=ADD`,原本的配置文件加上 **bridge 插件返回的结果**，结合下来 `tuning`接收到的配置文件为：\n\n```json\n{\n  \"cniVersion\": \"1.0.0\",\n  \"name\": \"dbnet\",\n  \"type\": \"tuning\",\n  \"sysctl\": {\n    \"net.core.somaxconn\": \"500\"\n  },\n  \"runtimeConfig\": {\n    \"mac\": \"00:11:22:33:44:66\"\n  },\n  \"prevResult\": {\n    \"ips\": [\n        {\n          \"address\": \"10.1.0.5/16\",\n          \"gateway\": \"10.1.0.1\",\n          \"interface\": 2\n        }\n    ],\n    \"routes\": [\n      {\n        \"dst\": \"0.0.0.0/0\"\n      }\n    ],\n    \"interfaces\": [\n        {\n            \"name\": \"cni0\",\n            \"mac\": \"00:11:22:33:44:55\"\n        },\n        {\n            \"name\": \"veth3243\",\n            \"mac\": \"55:44:33:22:11:11\"\n        },\n        {\n            \"name\": \"eth0\",\n            \"mac\": \"99:88:77:66:55:44\",\n            \"sandbox\": \"/var/run/netns/blue\"\n        }\n    ],\n    \"dns\": {\n      \"nameservers\": [ \"10.1.0.1\" ]\n    }\n  }\n}\n```\n\n可以看到它所接收的文件内容当中，新增了之前一个插件产生的结果 `prevResult`。\n\n标准的部分就到这里了结束了，但可以看到标准更多地还是定义了 CRI ，网络管理者 和 CNI 之间的通信形式，但是这并非完全满足了 Pod 网络管理的需求，尤其是作为 IPAM 的 `host-local` 插件仅能够确保同一台宿主机上运行的所有容器，IP地址一定都是彼此唯一的；无法做到让这个 IP 地址在集群当中唯一。更多的功能需要进一步去研究各个 CNI 插件具体提供的功能。\n\n## CNI 配置文件语法\n\n做填空题目就可以：\n\n```json\n{\n  \"cniVersion\": ,\n  \"name\": ,\n  \"disableCheck\":\n  \"plugins\": [\n    {\n      \"type\": ,\n      \"bridge\":,\n      \"ipMasq\":,\n      \"ipam\": {\n        \"type\": ,\n      },\n      \"dns\": {\n        \"nameservers\": [],\n        \"domain\":,\n        \"search\":,\n        \"options\":,\n      }\n    }\n}\n```\n\n\n\n---\n\n# 相关仓库及文献\n\n[cni/SPEC.md at spec-v1.0.0 · containernetworking/cni (github.com)](https://github.com/containernetworking/cni/blob/spec-v1.0.0/SPEC.md)\n\n[Kubernetes网络之CNI规范解读 | LRF (lengrongfu.github.io)](https://lengrongfu.github.io/2022-05-11-k8s之CNI规范解读/)\n\n[A brief overview of the Container Network Interface (CNI) in Kubernetes | Enable Sysadmin (redhat.com)](https://www.redhat.com/sysadmin/cni-kubernetes)\n\n[Bring your own Container Network Interface (CNI) plugin - Azure Kubernetes Service | Microsoft Learn](https://learn.microsoft.com/en-us/azure/aks/use-byo-cni?tabs=azure-cli)\n\n[Network Plugins | Kubernetes](https://kubernetes.io/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/)\n\n[Kubernetes CNI Explained (tigera.io)](https://www.tigera.io/learn/guides/kubernetes-networking/kubernetes-cni/)\n","source":"_posts/EdgeMesh/cilium与edgemesh性能测试/2023-ospp-fighting/Kubernetes 容器网络 CNI — CNI .md","raw":"---\ntitle: CNI 概述\ncatalog: true\ndate: 2023-04-19 05:02:23\nsubtitle:\nheader-img:\ntags: ospp, CNI, Linux, Spec\ncategories: CNI\n---\n\n<!-- @import \"[TOC]\" {cmd=\"toc\" depthFrom=1 depthTo=6 orderedList=false} -->\n- [CNI 概述](#cni-概述)\n  - [什么是 CNI](#什么是-cni)\n  - [CNI 的功能](#cni-的功能)\n  - [CNI 统一的网络配置文件](#cni-统一的网络配置文件)\n    - [CNI 运行时协议](#cni-运行时协议)\n  - [CNI 与插件](#cni-与插件)\n- [CNI 配置文件样例分析](#cni-配置文件样例分析)\n  - [CNI 配置文件语法](#cni-配置文件语法)\n- [相关仓库及文献](#相关仓库及文献)\n\n\n# CNI 概述\n\n## 什么是 CNI \n\n> CNI的全称是 Container Network Interface，它为**容器提供了一种基于插件结构的标准化网络解决方案**。以往，容器的网络层是和具体的底层网络环境高度相关的，不同的网络服务提供商有不同的实现。**CNI从网络服务里抽象出了一套标准接口**，从而屏蔽了上层网络和底层网络提供商的网络实现之间的差异。并且，通过插件结构，它让容器在网络层的具体实现变得可插拔了，所以非常灵活。\n\n首先 CNI 是一套标准接口，它隶属于[CNCF(Cloud Native Computing Foundation)](https://cncf.io/)，依照这个标准所实现的为 CNI Plugins, 他们彼此独立，也可以组合起来一起使用，由一组用于配置 Linux 容器的网络接口的规范和库组成，同时还包含了一些插件，CNI 仅关心容器创建时的网络分配，和当容器被删除时释放网络资源。\n\n其次 依据 CNI 的[规范](https://github.com/containernetworking/cni/blob/master/SPEC.md)，CNI 具有以下几点特征：\n\n- CNI 需提供网络管理员**定义网络配置的文件格式**\n- CNI 需提供 Container Runtime（CRI） 调用功能的**协议/API**。\n- 当 CNI 被 CRI 调用时，需依据配置文件执行网络配置功能\n- CNI 需预留可调用其他插件的能力\n- CNI 需规范统一返回给CRI 的数据格式\n\n依据这样的特征和要求，可以明确实现一个CNI插件需要包含以下部分：\n\n* 可执行文件\n  * cni plugins\n  * IPAM\n* 网络配置文件\n\n\n\n## CNI 的功能\n\nCNI 插件首先得实现一个可以被容器管理系统（CRI），比如rkt、Kubernetes 所调用的可执行文件——cni plugins，这个插件首先需要提供**基础的 Linux 网络联通服务**，比如创建 veth 或者 bridge 并将 veth 对的一端插入容器的 network namespace，一端插入 bridge，使得容器之间可以相互通信。然后**将IP 分配给接口**，并通过调用 **IPAM **插件来设置和管理IP地址，使得集群内的容器IP地址相互不重复，或者是结合其他的插件来实现更加复杂的网络路由管理功能等等。\n\n那么接下来，依据对于这几项功能的要求，来具体看看 CNI 的标准\n\n\n\n## CNI 统一的网络配置文件\n\nCNI 为容器网络管理员(操作人员、网络插件、网络编排系统)定义了一种网络配置格式。它包含了供 CRI 和 CNI 插件使用的指令。在插件执行时，这种配置格式由 CRI 解释，并转化为代码数据结构，传递给 CNI 插件。\n\n一般来说配置文件主要是以 JSON 文件为主，且包含以下几个键值：\n\n- `cniVersion`: 指定CNI规范的版本，这样 CRI 和 CNI 才能读懂彼此\n- `Name`: 网络名字，这在一个主机（或其他管理域）的所有网络配置中应该是唯一的。必须以一个字母数字字符开始，后面可以选择由一个或多个字母数字字符、下划线、点（.）或连字符（-）的任何组合。\n- `disableCheck`: 是否禁用检查网络，如果为true,则 `container runtime` 不会调用 Check 方法进行网络检查。\n- `plugin`: cni插件及其配置列表，可以配置多个插件。\n\n接着展开说明一下 plugin 当中的参数，这也与实现 CNI 的功能息息相关，CRI 解析出配置文件当中的这个字段，是必须要一个字不漏地完整交给 CNI 插件来做网络管理\n\n1. 必须配置的键值\n\n   `type` :  指定目前系统目录当中所使用的 CNI 插件，一般是 cni 可执行文件的目录索引\n\n   至少得有一个基础的 cni 插件来完成最基础的 Linux 网络配置的功能\n\n2. 可选键值，由 CRI 依据协议发送的 request 指定\n\n   `capabilities`:  如果 CNI_ARGS 中没有指定此项功能时候来补充的\n\n3. 预留键值，由 CRI 在执行时产生的\n\n   - `runtimeConfig` :  比如 CNI 自己设置的 isGateway == true 就表明告诉插件，作为网关，给bridge指定一个IP地址。这样，连接到bridge的容器就可以拿它当网关来用了。\n   - `args`\n   - 或者是任何以 `cni.dev/`开头的\n\n4. 可选键值,由容器网络管理员添加\n\n   `ipMasq`: 为目标网络配上Outbound Masquerade(地址伪装)，即：由容器内部通过网关向外发送数据包时，对数据包的源IP地址进行修改。\n\n   当我们的容器以宿主机作为网关时，这个参数是必须要设置的。否则，从容器内部发出的数据包就没有办法通过网关路由到其他网段。因为容器内部的IP地址无法被目标网段识别，所以这些数据包最终会被丢弃掉。\n\n   `ipam`: PAM(IP Adderss Management)即IP地址管理，提供了一系列方法用于对IP和路由进行管理。实际上，它对应的是由CNI提供的一组标准IPAM插件，比如像host-local，dhcp，static等。如果要对整个集群的地址做管理，让pod具有单独的ip地址，就需要在这里添加额外的插件\n\n   > 例子1当中：\n   >\n   > - type：指定所用IPAM插件的名称，在例子里，用的是host-local。\n   > - subnet：为目标网络分配网段，包括网络ID和子网掩码，以CIDR形式标记。在例子里为`10.15.10.0/24`，也就是目标网段为`10.15.10.0`，子网掩码为`255.255.255.0`。\n   > - routes：用于指定路由规则，插件会在容器的路由表里生成相应的规则。其中，dst表示希望到达的目标网段，以CIDR形式标记。gw对应网关的IP地址，也就是要到达目标网段所要经过的“next hop(下一跳)”。如果省略gw的话，那么插件会自动帮容器选择默认网关。在例子里，gw选择的是默认网关，而dst为`0.0.0.0/0`则代表“任何网络”，表示数据包将通过默认网关发往任何网络。实际上，这对应的是一条默认路由规则，即：当所有其他路由规则都不匹配时，将选择该路由。\n   > - rangeStart：允许分配的IP地址范围的起始值\n   > - rangeEnd：允许分配的IP地址范围的结束值\n   > - gateway：为网关（也就是将要在宿主机上创建的bridge）指定的IP地址。如果省略的话，那么插件会自动从允许分配的IP地址范围内选择起始值作为网关的IP地址。\n\n配置文件例子如下：\n\n例子1：\n\n```json\n{\n    \"cniVersion\": \"0.4.0\",\n    \"name\": \"lab-br0\",\n    \"type\": \"bridge\",\n    \"bridge\": \"lab-br0\",\n    \"isGateway\": true,\n    \"ipMasq\": true,\n    \"ipam\": {\n        \"type\": \"host-local\",\n        \"subnet\": \"10.15.10.0/24\",\n        \"routes\": [\n            { \"dst\": \"0.0.0.0/0\" }\n        ],\n        \"rangeStart\": \"10.15.10.100\",\n        \"rangeEnd\": \"10.15.10.200\",\n        \"gateway\": \"10.15.10.99\"\n    }\n}\n```\n\n例子2：\n\n```json\n{\n  \"cniVersion\": \"1.0.0\",\n  \"name\": \"dbnet\",\n  \"plugins\": [\n    {\n      \"type\": \"bridge\",\n      // plugin specific parameters\n      \"bridge\": \"cni0\",\n      \"keyA\": [\"some more\", \"plugin specific\", \"configuration\"],\n      \n      \"ipam\": {\n        \"type\": \"host-local\",\n        // ipam specific\n        \"subnet\": \"10.1.0.0/16\",\n        \"gateway\": \"10.1.0.1\",\n        \"routes\": [\n            {\"dst\": \"0.0.0.0/0\"}\n        ]\n      },\n      \"dns\": {\n        \"nameservers\": [ \"10.1.0.1\" ]\n      }\n    },\n    {\n      \"type\": \"tuning\",\n      \"capabilities\": {\n        \"mac\": true\n      },\n      \"sysctl\": {\n        \"net.core.somaxconn\": \"500\"\n      }\n    },\n    {\n        \"type\": \"portmap\",\n        \"capabilities\": {\"portMappings\": true}\n    }\n  ]\n}\n```\n\n\n\n### CNI 运行时协议\n\nCNI协议是基于由 CRI 的调用请求来告诉 CNI 该做些什么。\n\n主要的协议参数定义如下：\n\n* CNI_COMMAND：表示所需的操作；ADD、DEL、CHECK、或VERSION。\n* CNI_CONTAINERID：容器ID。告诉CNI插件，将要加入目标网络的容器所对应的network namespace的ID,容器的唯一的标识符，由 CRI 分配。不能是空的。必须以一个字母数字字符开始，后面可以选择一个或多个字母数字字符、下划线（）、点（.）或连字符（-）的任何组合。\n* CNI_NETNS：容器对应的network namespace在宿主机上的文件路径。（例如：/run/netns/[nsname]）。\n* CNI_IFNAME：作为veth pair在容器一端的网络接口,一般是在容器内创建的接口的名称；如果 CNI 插件无法使用这个接口名称，那么就必须返回一个错误。\n* CNI_ARGS：用户在调用时传入的额外参数。用分号分隔的字母数字键值对；例如，\"FOO=BAR;ABC=123\"\n* CNI_PATH: 表示 CNI 插件可执行文件的路径列表。路径由操作系统特定的列表分隔符分隔；例如Linux上的':'和Windows上的'；'。\n\n告诉CNI插件要执行的命令，允许的命令有ADD，DEL，CHECK，VERSION。\n\n对于支持CNI规范的容器系统而言，当容器启动的时候，系统就会自动调用相应的CNI插件，并设置CNI_COMMAND为ADD。相应地，DEL是在容器被销毁时调用的，用于清除在执行ADD阶段分配的网络资源。CHECK用于检查容器网络是否正常。VERSION则用来显示插件的版本。具体的操作如下：\n\n* ADD\n\n  - 将容器添加到网络中，或将新的配置修改应用到已有的集群当中。\n\n  - 一个CNI插件在收到ADD命令后，应该选择\n\n    - 在 CNI_NETNS 的容器内创建由 CNI_IFNAME 定义的接口，\n\n    - 调整容器内 CNI_NETNS 处由CNI_IFNAME定义的接口的配置\n\n      如果CNI插件成功，必须要返回一个处理结果，要么打印出来，要么修改传入的参数。\n\n* DELETE\n\n  * 将容器删除出网络，或将新的配置修改应用到已有的集群当中。\n\n    功能与ADD 相对\n\n* CHECK\n\n  * 查找类型字段中指定的可执行文件，如果没找到返回错误\n  * 当 Plugins （CNI调用的其他的Plugins）返回错误时，将其返回给调用者\n\n---\n\n## CNI 与插件\n\n为了解决容器网络的各项需求和问题，将所有的功能单独集中在 CNI 单个程序中是不现实的，而且难以兼容不同的上层系统和底层的网络管理，于是一个显然的想法就是将这些功能独立出来，使用插件（Plugins）的形式来执行。\n\n一个常见的例子就是 IP 地址管理，这就是IP地址管理插件（IPAM插件），它必须设置容器和虚拟网络设备的接口 ，IP / 子网，网关和路由，然后将此信息返回给“主”插件（CNI本体）来执行，换句话说 IPAM 做逻辑上的网络地址管理然后告诉本体 CNI 去执行 `ADD`,`DELETE`。 \n\nCNI 本体调用这些插件的形式也是通过路径找到这些插件的可执行文件来实现的，一般这些插件的位置也都一起放置在 `CNI_PATH`之下。同时插件和 CNI 本体都是通过 stdin 接收网络配置，也通过 stdout 输出结果。\n\n如此看来 CNI 的工作流程就是一条链状的调用过程，但调用链中的每一个可执行程序所接收的配置文件信息并不相同。\n\n---\n\n# CNI 配置文件样例分析\n\n> 参考[cni/SPEC.md at spec-v1.0.0 · containernetworking/cni (github.com)](https://github.com/containernetworking/cni/blob/spec-v1.0.0/SPEC.md) 的 Appendix: Examples\n\n借助 Github 所给的 SPEC 例子，要求 CRI 生成 portmap 和mac 相关的参数，同时使用CNI_IFNAME=eth0。假设目前 CRI 接收到的 json 文件如下：\n\n``` json\n{\n  \"cniVersion\": \"1.0.0\",\n  \"name\": \"dbnet\",\n  \"plugins\": [\n    {\n      \"type\": \"bridge\",\n      // plugin specific parameters\n      \"bridge\": \"cni0\",\n      \"keyA\": [\"some more\", \"plugin specific\", \"configuration\"],\n      \n      \"ipam\": {\n        \"type\": \"host-local\",\n        // ipam specific\n        \"subnet\": \"10.1.0.0/16\",\n        \"gateway\": \"10.1.0.1\",\n        \"routes\": [\n            {\"dst\": \"0.0.0.0/0\"}\n        ]\n      },\n      \"dns\": {\n        \"nameservers\": [ \"10.1.0.1\" ]\n      }\n    },\n    {\n      \"type\": \"tuning\",\n      \"capabilities\": {\n        \"mac\": true\n      },\n      \"sysctl\": {\n        \"net.core.somaxconn\": \"500\"\n      }\n    },\n    {\n        \"type\": \"portmap\",\n        \"capabilities\": {\"portMappings\": true}\n    }\n  ]\n}\n```\n\n我把它简化一下，提取出重要的配置参数，按照插件的调用链来作解释。\n\n对于 `ADD` 操作，配置文件所看到的主体为如下所示，提供信息表明 cni 标准为： \"1.0.0\", 并创建一个名为dbnet的网络空间，这个网络空间并不是指 network namespace,应该把它理解为一个局域网络的名字，比如插件使用的是 `bridge`创建，那么这个名字就是创建的网桥名字，也就是`ifconfig` 看到的网络设备名字；同时配置文件规定了整个 CNI plugins 的调用链，包括从 `bridge`到`tuning`再到`portmap`，然后完成这个网络空间的创建即 `ADD` 操作\n\n```json\n{\n  \"cniVersion\": \"1.0.0\",\n  \"name\": \"dbnet\",\n  \"plugins\": [\n    {\"type\": \"bridge\",\"bridge\": \"cni0\",\"ipam\": {},\"dns\": {}},\n    {\"type\": \"tuning\"},\n    {\"type\": \"portmap\"}\n  ]\n}\n```\n\n首先 CRI 会调用 `bridge` 插件( CNI ) ,传入 `CNI_COMMAND=ADD`参数，并传入以下 json 信息:\n\n``` json\n{\n    \"cniVersion\": \"1.0.0\",\n    \"name\": \"dbnet\",\n    \"type\": \"bridge\",\n    \"bridge\": \"cni0\",\n    \"keyA\": [\"some more\", \"plugin specific\", \"configuration\"],\n    \"ipam\": {\n        \"type\": \"host-local\",\n        \"subnet\": \"10.1.0.0/16\",\n        \"gateway\": \"10.1.0.1\"\n    },\n    \"dns\": {\n        \"nameservers\": [ \"10.1.0.1\" ]\n    }\n}\n```\n\n被调用的 CNI 插件 bridge ，首先会去调用他所管的 IPAM 插件 `host-local`，并传入与它收到的配置信息和 ADD指令参数，也就是下面两行,创建一个 `10.1.0.0/16`的子网，同时设置 `10.1.0.1 为`网关（`gateway`表示对应网关的IP地址，也就是要到达目标网段所要经过的“next hop(下一跳)），地址为`10.1.0.1`。\n\n``` json\n        \"subnet\": \"10.1.0.0/16\",\n        \"gateway\": \"10.1.0.1\"\n```\n\n设置成功，IPAM 插件应该返回以下的结果给 bridge，但这个设置的概念与不同的 CNI 实现有关，一般来说单独的 IPAM 设置指的是数据层面的管理，这个 IPAM 会为容器端的网络接口分配IP地址，比如通过调用`net.ParseCIDR`函数，对传入的`ipAddress`进行解析，依据节点环境并生成`ipv4Addr`和`ipv4Net`对象，并返回数据，但是并没有调用 Linux 的接口生成对象。\n\n```json\n{\n    \"ips\": [\n        {\n          \"address\": \"10.1.0.5/16\",\n          \"gateway\": \"10.1.0.1\"\n        }\n    ],\n    \"routes\": [\n      {\n        \"dst\": \"0.0.0.0/0\"\n      }\n    ],\n    \"dns\": {\n      \"nameservers\": [ \"10.1.0.1\" ]\n    }\n}\n```\n\n新增加的两条信息：\n\n1. `routes` 表示路由规则，如果在配置日志文件当中设置好，IPAM 插件会为 CNI 在容器的路由表里生成相应的规则。其中，`dst`表示希望到达的目标网段，以CIDR形式标记，在例子里 dst 为`0.0.0.0/0`，代表“任何网络”，表示数据包将通过默认网关发往任何网络，实际上，这对应的是一条默认路由规则，即：当所有其他路由规则都不匹配时，将选择该路由。\n\n2. `dns` 表示设置的 dns 服务由网关提供\n\nbridge 插件得到配置地址的结果和参数之后，就会依据 IPAM 所给的信息来设置节点的网络情况，一般是这个时候来来调用 `setupVeth` 以及 `netlink` 的函数方法，创建并写入对象信息，就像是指令来执行 `ip link add`,`ip link set ... up`等等。\n\n当创建过程结束之后，bridge 插件就会返回以下结果：\n\n```json\n{\n    \"ips\": [\n        {\n          \"address\": \"10.1.0.5/16\",\n          \"gateway\": \"10.1.0.1\",\n          \"interface\": 2\n        }\n    ],\n    \"routes\": [\n      {\n        \"dst\": \"0.0.0.0/0\"\n      }\n    ],\n    \"interfaces\": [\n        {\n            \"name\": \"cni0\",\n            \"mac\": \"00:11:22:33:44:55\"\n        },\n        {\n            \"name\": \"veth3243\",\n            \"mac\": \"55:44:33:22:11:11\"\n        },\n        {\n            \"name\": \"eth0\",\n            \"mac\": \"99:88:77:66:55:44\",\n            \"sandbox\": \"/var/run/netns/blue\"\n        }\n    ],\n    \"dns\": {\n      \"nameservers\": [ \"10.1.0.1\" ]\n    }\n}\n```\n\n其实上面已经是相对完整的调用过程了，但是例子当中的插件还继续调用了```tuning```,\n   ```portmap```,流程是相同的，但是关键在于传入的参数。\n\n`tuning` 接收的参数包括 `CNI_COMMAND=ADD`,原本的配置文件加上 **bridge 插件返回的结果**，结合下来 `tuning`接收到的配置文件为：\n\n```json\n{\n  \"cniVersion\": \"1.0.0\",\n  \"name\": \"dbnet\",\n  \"type\": \"tuning\",\n  \"sysctl\": {\n    \"net.core.somaxconn\": \"500\"\n  },\n  \"runtimeConfig\": {\n    \"mac\": \"00:11:22:33:44:66\"\n  },\n  \"prevResult\": {\n    \"ips\": [\n        {\n          \"address\": \"10.1.0.5/16\",\n          \"gateway\": \"10.1.0.1\",\n          \"interface\": 2\n        }\n    ],\n    \"routes\": [\n      {\n        \"dst\": \"0.0.0.0/0\"\n      }\n    ],\n    \"interfaces\": [\n        {\n            \"name\": \"cni0\",\n            \"mac\": \"00:11:22:33:44:55\"\n        },\n        {\n            \"name\": \"veth3243\",\n            \"mac\": \"55:44:33:22:11:11\"\n        },\n        {\n            \"name\": \"eth0\",\n            \"mac\": \"99:88:77:66:55:44\",\n            \"sandbox\": \"/var/run/netns/blue\"\n        }\n    ],\n    \"dns\": {\n      \"nameservers\": [ \"10.1.0.1\" ]\n    }\n  }\n}\n```\n\n可以看到它所接收的文件内容当中，新增了之前一个插件产生的结果 `prevResult`。\n\n标准的部分就到这里了结束了，但可以看到标准更多地还是定义了 CRI ，网络管理者 和 CNI 之间的通信形式，但是这并非完全满足了 Pod 网络管理的需求，尤其是作为 IPAM 的 `host-local` 插件仅能够确保同一台宿主机上运行的所有容器，IP地址一定都是彼此唯一的；无法做到让这个 IP 地址在集群当中唯一。更多的功能需要进一步去研究各个 CNI 插件具体提供的功能。\n\n## CNI 配置文件语法\n\n做填空题目就可以：\n\n```json\n{\n  \"cniVersion\": ,\n  \"name\": ,\n  \"disableCheck\":\n  \"plugins\": [\n    {\n      \"type\": ,\n      \"bridge\":,\n      \"ipMasq\":,\n      \"ipam\": {\n        \"type\": ,\n      },\n      \"dns\": {\n        \"nameservers\": [],\n        \"domain\":,\n        \"search\":,\n        \"options\":,\n      }\n    }\n}\n```\n\n\n\n---\n\n# 相关仓库及文献\n\n[cni/SPEC.md at spec-v1.0.0 · containernetworking/cni (github.com)](https://github.com/containernetworking/cni/blob/spec-v1.0.0/SPEC.md)\n\n[Kubernetes网络之CNI规范解读 | LRF (lengrongfu.github.io)](https://lengrongfu.github.io/2022-05-11-k8s之CNI规范解读/)\n\n[A brief overview of the Container Network Interface (CNI) in Kubernetes | Enable Sysadmin (redhat.com)](https://www.redhat.com/sysadmin/cni-kubernetes)\n\n[Bring your own Container Network Interface (CNI) plugin - Azure Kubernetes Service | Microsoft Learn](https://learn.microsoft.com/en-us/azure/aks/use-byo-cni?tabs=azure-cli)\n\n[Network Plugins | Kubernetes](https://kubernetes.io/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/)\n\n[Kubernetes CNI Explained (tigera.io)](https://www.tigera.io/learn/guides/kubernetes-networking/kubernetes-cni/)\n","slug":"EdgeMesh/cilium与edgemesh性能测试/2023-ospp-fighting/Kubernetes 容器网络 CNI — CNI ","published":1,"updated":"2023-04-23T15:11:53.489Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgtm6jqw0021lyjx4r8q61jd","content":"<!-- @import \"[TOC]\" {cmd=\"toc\" depthFrom=1 depthTo=6 orderedList=false} -->\n<ul>\n<li><a href=\"#cni-%E6%A6%82%E8%BF%B0\">CNI 概述</a><ul>\n<li><a href=\"#%E4%BB%80%E4%B9%88%E6%98%AF-cni\">什么是 CNI</a></li>\n<li><a href=\"#cni-%E7%9A%84%E5%8A%9F%E8%83%BD\">CNI 的功能</a></li>\n<li><a href=\"#cni-%E7%BB%9F%E4%B8%80%E7%9A%84%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6\">CNI 统一的网络配置文件</a><ul>\n<li><a href=\"#cni-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8D%8F%E8%AE%AE\">CNI 运行时协议</a></li>\n</ul>\n</li>\n<li><a href=\"#cni-%E4%B8%8E%E6%8F%92%E4%BB%B6\">CNI 与插件</a></li>\n</ul>\n</li>\n<li><a href=\"#cni-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%A0%B7%E4%BE%8B%E5%88%86%E6%9E%90\">CNI 配置文件样例分析</a><ul>\n<li><a href=\"#cni-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%AD%E6%B3%95\">CNI 配置文件语法</a></li>\n</ul>\n</li>\n<li><a href=\"#%E7%9B%B8%E5%85%B3%E4%BB%93%E5%BA%93%E5%8F%8A%E6%96%87%E7%8C%AE\">相关仓库及文献</a></li>\n</ul>\n<h1 id=\"CNI-概述\"><a href=\"#CNI-概述\" class=\"headerlink\" title=\"CNI 概述\"></a>CNI 概述</h1><h2 id=\"什么是-CNI\"><a href=\"#什么是-CNI\" class=\"headerlink\" title=\"什么是 CNI\"></a>什么是 CNI</h2><blockquote>\n<p>CNI的全称是 Container Network Interface，它为<strong>容器提供了一种基于插件结构的标准化网络解决方案</strong>。以往，容器的网络层是和具体的底层网络环境高度相关的，不同的网络服务提供商有不同的实现。<strong>CNI从网络服务里抽象出了一套标准接口</strong>，从而屏蔽了上层网络和底层网络提供商的网络实现之间的差异。并且，通过插件结构，它让容器在网络层的具体实现变得可插拔了，所以非常灵活。</p>\n</blockquote>\n<p>首先 CNI 是一套标准接口，它隶属于<a href=\"https://cncf.io/\">CNCF(Cloud Native Computing Foundation)</a>，依照这个标准所实现的为 CNI Plugins, 他们彼此独立，也可以组合起来一起使用，由一组用于配置 Linux 容器的网络接口的规范和库组成，同时还包含了一些插件，CNI 仅关心容器创建时的网络分配，和当容器被删除时释放网络资源。</p>\n<p>其次 依据 CNI 的<a href=\"https://github.com/containernetworking/cni/blob/master/SPEC.md\">规范</a>，CNI 具有以下几点特征：</p>\n<ul>\n<li>CNI 需提供网络管理员<strong>定义网络配置的文件格式</strong></li>\n<li>CNI 需提供 Container Runtime（CRI） 调用功能的<strong>协议/API</strong>。</li>\n<li>当 CNI 被 CRI 调用时，需依据配置文件执行网络配置功能</li>\n<li>CNI 需预留可调用其他插件的能力</li>\n<li>CNI 需规范统一返回给CRI 的数据格式</li>\n</ul>\n<p>依据这样的特征和要求，可以明确实现一个CNI插件需要包含以下部分：</p>\n<ul>\n<li>可执行文件<ul>\n<li>cni plugins</li>\n<li>IPAM</li>\n</ul>\n</li>\n<li>网络配置文件</li>\n</ul>\n<h2 id=\"CNI-的功能\"><a href=\"#CNI-的功能\" class=\"headerlink\" title=\"CNI 的功能\"></a>CNI 的功能</h2><p>CNI 插件首先得实现一个可以被容器管理系统（CRI），比如rkt、Kubernetes 所调用的可执行文件——cni plugins，这个插件首先需要提供<strong>基础的 Linux 网络联通服务</strong>，比如创建 veth 或者 bridge 并将 veth 对的一端插入容器的 network namespace，一端插入 bridge，使得容器之间可以相互通信。然后<strong>将IP 分配给接口</strong>，并通过调用 **IPAM **插件来设置和管理IP地址，使得集群内的容器IP地址相互不重复，或者是结合其他的插件来实现更加复杂的网络路由管理功能等等。</p>\n<p>那么接下来，依据对于这几项功能的要求，来具体看看 CNI 的标准</p>\n<h2 id=\"CNI-统一的网络配置文件\"><a href=\"#CNI-统一的网络配置文件\" class=\"headerlink\" title=\"CNI 统一的网络配置文件\"></a>CNI 统一的网络配置文件</h2><p>CNI 为容器网络管理员(操作人员、网络插件、网络编排系统)定义了一种网络配置格式。它包含了供 CRI 和 CNI 插件使用的指令。在插件执行时，这种配置格式由 CRI 解释，并转化为代码数据结构，传递给 CNI 插件。</p>\n<p>一般来说配置文件主要是以 JSON 文件为主，且包含以下几个键值：</p>\n<ul>\n<li><code>cniVersion</code>: 指定CNI规范的版本，这样 CRI 和 CNI 才能读懂彼此</li>\n<li><code>Name</code>: 网络名字，这在一个主机（或其他管理域）的所有网络配置中应该是唯一的。必须以一个字母数字字符开始，后面可以选择由一个或多个字母数字字符、下划线、点（.）或连字符（-）的任何组合。</li>\n<li><code>disableCheck</code>: 是否禁用检查网络，如果为true,则 <code>container runtime</code> 不会调用 Check 方法进行网络检查。</li>\n<li><code>plugin</code>: cni插件及其配置列表，可以配置多个插件。</li>\n</ul>\n<p>接着展开说明一下 plugin 当中的参数，这也与实现 CNI 的功能息息相关，CRI 解析出配置文件当中的这个字段，是必须要一个字不漏地完整交给 CNI 插件来做网络管理</p>\n<ol>\n<li><p>必须配置的键值</p>\n<p><code>type</code> :  指定目前系统目录当中所使用的 CNI 插件，一般是 cni 可执行文件的目录索引</p>\n<p>至少得有一个基础的 cni 插件来完成最基础的 Linux 网络配置的功能</p>\n</li>\n<li><p>可选键值，由 CRI 依据协议发送的 request 指定</p>\n<p><code>capabilities</code>:  如果 CNI_ARGS 中没有指定此项功能时候来补充的</p>\n</li>\n<li><p>预留键值，由 CRI 在执行时产生的</p>\n<ul>\n<li><code>runtimeConfig</code> :  比如 CNI 自己设置的 isGateway == true 就表明告诉插件，作为网关，给bridge指定一个IP地址。这样，连接到bridge的容器就可以拿它当网关来用了。</li>\n<li><code>args</code></li>\n<li>或者是任何以 <code>cni.dev/</code>开头的</li>\n</ul>\n</li>\n<li><p>可选键值,由容器网络管理员添加</p>\n<p><code>ipMasq</code>: 为目标网络配上Outbound Masquerade(地址伪装)，即：由容器内部通过网关向外发送数据包时，对数据包的源IP地址进行修改。</p>\n<p>当我们的容器以宿主机作为网关时，这个参数是必须要设置的。否则，从容器内部发出的数据包就没有办法通过网关路由到其他网段。因为容器内部的IP地址无法被目标网段识别，所以这些数据包最终会被丢弃掉。</p>\n<p><code>ipam</code>: PAM(IP Adderss Management)即IP地址管理，提供了一系列方法用于对IP和路由进行管理。实际上，它对应的是由CNI提供的一组标准IPAM插件，比如像host-local，dhcp，static等。如果要对整个集群的地址做管理，让pod具有单独的ip地址，就需要在这里添加额外的插件</p>\n<blockquote>\n<p>例子1当中：</p>\n<ul>\n<li>type：指定所用IPAM插件的名称，在例子里，用的是host-local。</li>\n<li>subnet：为目标网络分配网段，包括网络ID和子网掩码，以CIDR形式标记。在例子里为<code>10.15.10.0/24</code>，也就是目标网段为<code>10.15.10.0</code>，子网掩码为<code>255.255.255.0</code>。</li>\n<li>routes：用于指定路由规则，插件会在容器的路由表里生成相应的规则。其中，dst表示希望到达的目标网段，以CIDR形式标记。gw对应网关的IP地址，也就是要到达目标网段所要经过的“next hop(下一跳)”。如果省略gw的话，那么插件会自动帮容器选择默认网关。在例子里，gw选择的是默认网关，而dst为<code>0.0.0.0/0</code>则代表“任何网络”，表示数据包将通过默认网关发往任何网络。实际上，这对应的是一条默认路由规则，即：当所有其他路由规则都不匹配时，将选择该路由。</li>\n<li>rangeStart：允许分配的IP地址范围的起始值</li>\n<li>rangeEnd：允许分配的IP地址范围的结束值</li>\n<li>gateway：为网关（也就是将要在宿主机上创建的bridge）指定的IP地址。如果省略的话，那么插件会自动从允许分配的IP地址范围内选择起始值作为网关的IP地址。</li>\n</ul>\n</blockquote>\n</li>\n</ol>\n<p>配置文件例子如下：</p>\n<p>例子1：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;cniVersion&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;0.4.0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;lab-br0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;bridge&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;bridge&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;lab-br0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;isGateway&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;ipMasq&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;ipam&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;host-local&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;subnet&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;10.15.10.0/24&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;routes&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">            <span class=\"punctuation\">&#123;</span> <span class=\"attr\">&quot;dst&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;0.0.0.0/0&quot;</span> <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">        <span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;rangeStart&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;10.15.10.100&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;rangeEnd&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;10.15.10.200&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;gateway&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;10.15.10.99&quot;</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>例子2：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;cniVersion&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;1.0.0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;dbnet&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;plugins&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;bridge&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"comment\">// plugin specific parameters</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;bridge&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;cni0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;keyA&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span><span class=\"string\">&quot;some more&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;plugin specific&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;configuration&quot;</span><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"attr\">&quot;ipam&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;host-local&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"comment\">// ipam specific</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;subnet&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;10.1.0.0/16&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;gateway&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;10.1.0.1&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;routes&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">            <span class=\"punctuation\">&#123;</span><span class=\"attr\">&quot;dst&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;0.0.0.0/0&quot;</span><span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">        <span class=\"punctuation\">]</span></span><br><span class=\"line\">      <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;dns&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;nameservers&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span> <span class=\"string\">&quot;10.1.0.1&quot;</span> <span class=\"punctuation\">]</span></span><br><span class=\"line\">      <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;tuning&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;capabilities&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;mac&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span></span><br><span class=\"line\">      <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;sysctl&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;net.core.somaxconn&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;500&quot;</span></span><br><span class=\"line\">      <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;portmap&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;capabilities&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span><span class=\"attr\">&quot;portMappings&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">  <span class=\"punctuation\">]</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"CNI-运行时协议\"><a href=\"#CNI-运行时协议\" class=\"headerlink\" title=\"CNI 运行时协议\"></a>CNI 运行时协议</h3><p>CNI协议是基于由 CRI 的调用请求来告诉 CNI 该做些什么。</p>\n<p>主要的协议参数定义如下：</p>\n<ul>\n<li>CNI_COMMAND：表示所需的操作；ADD、DEL、CHECK、或VERSION。</li>\n<li>CNI_CONTAINERID：容器ID。告诉CNI插件，将要加入目标网络的容器所对应的network namespace的ID,容器的唯一的标识符，由 CRI 分配。不能是空的。必须以一个字母数字字符开始，后面可以选择一个或多个字母数字字符、下划线（）、点（.）或连字符（-）的任何组合。</li>\n<li>CNI_NETNS：容器对应的network namespace在宿主机上的文件路径。（例如：/run/netns/[nsname]）。</li>\n<li>CNI_IFNAME：作为veth pair在容器一端的网络接口,一般是在容器内创建的接口的名称；如果 CNI 插件无法使用这个接口名称，那么就必须返回一个错误。</li>\n<li>CNI_ARGS：用户在调用时传入的额外参数。用分号分隔的字母数字键值对；例如，”FOO=BAR;ABC=123”</li>\n<li>CNI_PATH: 表示 CNI 插件可执行文件的路径列表。路径由操作系统特定的列表分隔符分隔；例如Linux上的’:’和Windows上的’；’。</li>\n</ul>\n<p>告诉CNI插件要执行的命令，允许的命令有ADD，DEL，CHECK，VERSION。</p>\n<p>对于支持CNI规范的容器系统而言，当容器启动的时候，系统就会自动调用相应的CNI插件，并设置CNI_COMMAND为ADD。相应地，DEL是在容器被销毁时调用的，用于清除在执行ADD阶段分配的网络资源。CHECK用于检查容器网络是否正常。VERSION则用来显示插件的版本。具体的操作如下：</p>\n<ul>\n<li><p>ADD</p>\n<ul>\n<li><p>将容器添加到网络中，或将新的配置修改应用到已有的集群当中。</p>\n</li>\n<li><p>一个CNI插件在收到ADD命令后，应该选择</p>\n<ul>\n<li><p>在 CNI_NETNS 的容器内创建由 CNI_IFNAME 定义的接口，</p>\n</li>\n<li><p>调整容器内 CNI_NETNS 处由CNI_IFNAME定义的接口的配置</p>\n<p>如果CNI插件成功，必须要返回一个处理结果，要么打印出来，要么修改传入的参数。</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>DELETE</p>\n<ul>\n<li><p>将容器删除出网络，或将新的配置修改应用到已有的集群当中。</p>\n<p>功能与ADD 相对</p>\n</li>\n</ul>\n</li>\n<li><p>CHECK</p>\n<ul>\n<li>查找类型字段中指定的可执行文件，如果没找到返回错误</li>\n<li>当 Plugins （CNI调用的其他的Plugins）返回错误时，将其返回给调用者</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"CNI-与插件\"><a href=\"#CNI-与插件\" class=\"headerlink\" title=\"CNI 与插件\"></a>CNI 与插件</h2><p>为了解决容器网络的各项需求和问题，将所有的功能单独集中在 CNI 单个程序中是不现实的，而且难以兼容不同的上层系统和底层的网络管理，于是一个显然的想法就是将这些功能独立出来，使用插件（Plugins）的形式来执行。</p>\n<p>一个常见的例子就是 IP 地址管理，这就是IP地址管理插件（IPAM插件），它必须设置容器和虚拟网络设备的接口 ，IP / 子网，网关和路由，然后将此信息返回给“主”插件（CNI本体）来执行，换句话说 IPAM 做逻辑上的网络地址管理然后告诉本体 CNI 去执行 <code>ADD</code>,<code>DELETE</code>。 </p>\n<p>CNI 本体调用这些插件的形式也是通过路径找到这些插件的可执行文件来实现的，一般这些插件的位置也都一起放置在 <code>CNI_PATH</code>之下。同时插件和 CNI 本体都是通过 stdin 接收网络配置，也通过 stdout 输出结果。</p>\n<p>如此看来 CNI 的工作流程就是一条链状的调用过程，但调用链中的每一个可执行程序所接收的配置文件信息并不相同。</p>\n<hr>\n<h1 id=\"CNI-配置文件样例分析\"><a href=\"#CNI-配置文件样例分析\" class=\"headerlink\" title=\"CNI 配置文件样例分析\"></a>CNI 配置文件样例分析</h1><blockquote>\n<p>参考<a href=\"https://github.com/containernetworking/cni/blob/spec-v1.0.0/SPEC.md\">cni/SPEC.md at spec-v1.0.0 · containernetworking/cni (github.com)</a> 的 Appendix: Examples</p>\n</blockquote>\n<p>借助 Github 所给的 SPEC 例子，要求 CRI 生成 portmap 和mac 相关的参数，同时使用CNI_IFNAME=eth0。假设目前 CRI 接收到的 json 文件如下：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;cniVersion&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;1.0.0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;dbnet&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;plugins&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;bridge&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"comment\">// plugin specific parameters</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;bridge&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;cni0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;keyA&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span><span class=\"string\">&quot;some more&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;plugin specific&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;configuration&quot;</span><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"attr\">&quot;ipam&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;host-local&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"comment\">// ipam specific</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;subnet&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;10.1.0.0/16&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;gateway&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;10.1.0.1&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;routes&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">            <span class=\"punctuation\">&#123;</span><span class=\"attr\">&quot;dst&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;0.0.0.0/0&quot;</span><span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">        <span class=\"punctuation\">]</span></span><br><span class=\"line\">      <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;dns&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;nameservers&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span> <span class=\"string\">&quot;10.1.0.1&quot;</span> <span class=\"punctuation\">]</span></span><br><span class=\"line\">      <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;tuning&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;capabilities&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;mac&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span></span><br><span class=\"line\">      <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;sysctl&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;net.core.somaxconn&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;500&quot;</span></span><br><span class=\"line\">      <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;portmap&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;capabilities&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span><span class=\"attr\">&quot;portMappings&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">  <span class=\"punctuation\">]</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>我把它简化一下，提取出重要的配置参数，按照插件的调用链来作解释。</p>\n<p>对于 <code>ADD</code> 操作，配置文件所看到的主体为如下所示，提供信息表明 cni 标准为： “1.0.0”, 并创建一个名为dbnet的网络空间，这个网络空间并不是指 network namespace,应该把它理解为一个局域网络的名字，比如插件使用的是 <code>bridge</code>创建，那么这个名字就是创建的网桥名字，也就是<code>ifconfig</code> 看到的网络设备名字；同时配置文件规定了整个 CNI plugins 的调用链，包括从 <code>bridge</code>到<code>tuning</code>再到<code>portmap</code>，然后完成这个网络空间的创建即 <code>ADD</code> 操作</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;cniVersion&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;1.0.0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;dbnet&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;plugins&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span><span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;bridge&quot;</span><span class=\"punctuation\">,</span><span class=\"attr\">&quot;bridge&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;cni0&quot;</span><span class=\"punctuation\">,</span><span class=\"attr\">&quot;ipam&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span><span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span><span class=\"attr\">&quot;dns&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span><span class=\"punctuation\">&#125;</span><span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span><span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;tuning&quot;</span><span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span><span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;portmap&quot;</span><span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">  <span class=\"punctuation\">]</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>首先 CRI 会调用 <code>bridge</code> 插件( CNI ) ,传入 <code>CNI_COMMAND=ADD</code>参数，并传入以下 json 信息:</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;cniVersion&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;1.0.0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;dbnet&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;bridge&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;bridge&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;cni0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;keyA&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span><span class=\"string\">&quot;some more&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;plugin specific&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;configuration&quot;</span><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;ipam&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;host-local&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;subnet&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;10.1.0.0/16&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;gateway&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;10.1.0.1&quot;</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;dns&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;nameservers&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span> <span class=\"string\">&quot;10.1.0.1&quot;</span> <span class=\"punctuation\">]</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>被调用的 CNI 插件 bridge ，首先会去调用他所管的 IPAM 插件 <code>host-local</code>，并传入与它收到的配置信息和 ADD指令参数，也就是下面两行,创建一个 <code>10.1.0.0/16</code>的子网，同时设置 <code>10.1.0.1 为</code>网关（<code>gateway</code>表示对应网关的IP地址，也就是要到达目标网段所要经过的“next hop(下一跳)），地址为<code>10.1.0.1</code>。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">&quot;subnet&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;10.1.0.0/16&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"><span class=\"attr\">&quot;gateway&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;10.1.0.1&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>设置成功，IPAM 插件应该返回以下的结果给 bridge，但这个设置的概念与不同的 CNI 实现有关，一般来说单独的 IPAM 设置指的是数据层面的管理，这个 IPAM 会为容器端的网络接口分配IP地址，比如通过调用<code>net.ParseCIDR</code>函数，对传入的<code>ipAddress</code>进行解析，依据节点环境并生成<code>ipv4Addr</code>和<code>ipv4Net</code>对象，并返回数据，但是并没有调用 Linux 的接口生成对象。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;ips&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">          <span class=\"attr\">&quot;address&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;10.1.0.5/16&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">          <span class=\"attr\">&quot;gateway&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;10.1.0.1&quot;</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">    <span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;routes&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">      <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;dst&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;0.0.0.0/0&quot;</span></span><br><span class=\"line\">      <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">    <span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;dns&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;nameservers&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span> <span class=\"string\">&quot;10.1.0.1&quot;</span> <span class=\"punctuation\">]</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>新增加的两条信息：</p>\n<ol>\n<li><p><code>routes</code> 表示路由规则，如果在配置日志文件当中设置好，IPAM 插件会为 CNI 在容器的路由表里生成相应的规则。其中，<code>dst</code>表示希望到达的目标网段，以CIDR形式标记，在例子里 dst 为<code>0.0.0.0/0</code>，代表“任何网络”，表示数据包将通过默认网关发往任何网络，实际上，这对应的是一条默认路由规则，即：当所有其他路由规则都不匹配时，将选择该路由。</p>\n</li>\n<li><p><code>dns</code> 表示设置的 dns 服务由网关提供</p>\n</li>\n</ol>\n<p>bridge 插件得到配置地址的结果和参数之后，就会依据 IPAM 所给的信息来设置节点的网络情况，一般是这个时候来来调用 <code>setupVeth</code> 以及 <code>netlink</code> 的函数方法，创建并写入对象信息，就像是指令来执行 <code>ip link add</code>,<code>ip link set ... up</code>等等。</p>\n<p>当创建过程结束之后，bridge 插件就会返回以下结果：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;ips&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">          <span class=\"attr\">&quot;address&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;10.1.0.5/16&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">          <span class=\"attr\">&quot;gateway&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;10.1.0.1&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">          <span class=\"attr\">&quot;interface&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">2</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">    <span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;routes&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">      <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;dst&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;0.0.0.0/0&quot;</span></span><br><span class=\"line\">      <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">    <span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;interfaces&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;cni0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;mac&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;00:11:22:33:44:55&quot;</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;veth3243&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;mac&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;55:44:33:22:11:11&quot;</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;eth0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;mac&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;99:88:77:66:55:44&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;sandbox&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;/var/run/netns/blue&quot;</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">    <span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;dns&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;nameservers&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span> <span class=\"string\">&quot;10.1.0.1&quot;</span> <span class=\"punctuation\">]</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>其实上面已经是相对完整的调用过程了，但是例子当中的插件还继续调用了<code>tuning</code>,<br>   <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">`tuning` 接收的参数包括 `CNI_COMMAND=ADD`,原本的配置文件加上 **bridge 插件返回的结果**，结合下来 `tuning`接收到的配置文件为：</span><br><span class=\"line\"></span><br><span class=\"line\">```json</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;cniVersion&quot;: &quot;1.0.0&quot;,</span><br><span class=\"line\">  &quot;name&quot;: &quot;dbnet&quot;,</span><br><span class=\"line\">  &quot;type&quot;: &quot;tuning&quot;,</span><br><span class=\"line\">  &quot;sysctl&quot;: &#123;</span><br><span class=\"line\">    &quot;net.core.somaxconn&quot;: &quot;500&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;runtimeConfig&quot;: &#123;</span><br><span class=\"line\">    &quot;mac&quot;: &quot;00:11:22:33:44:66&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;prevResult&quot;: &#123;</span><br><span class=\"line\">    &quot;ips&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;address&quot;: &quot;10.1.0.5/16&quot;,</span><br><span class=\"line\">          &quot;gateway&quot;: &quot;10.1.0.1&quot;,</span><br><span class=\"line\">          &quot;interface&quot;: 2</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;routes&quot;: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;dst&quot;: &quot;0.0.0.0/0&quot;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;interfaces&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;cni0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;00:11:22:33:44:55&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;veth3243&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;55:44:33:22:11:11&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;eth0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;99:88:77:66:55:44&quot;,</span><br><span class=\"line\">            &quot;sandbox&quot;: &quot;/var/run/netns/blue&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;dns&quot;: &#123;</span><br><span class=\"line\">      &quot;nameservers&quot;: [ &quot;10.1.0.1&quot; ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到它所接收的文件内容当中，新增了之前一个插件产生的结果 <code>prevResult</code>。</p>\n<p>标准的部分就到这里了结束了，但可以看到标准更多地还是定义了 CRI ，网络管理者 和 CNI 之间的通信形式，但是这并非完全满足了 Pod 网络管理的需求，尤其是作为 IPAM 的 <code>host-local</code> 插件仅能够确保同一台宿主机上运行的所有容器，IP地址一定都是彼此唯一的；无法做到让这个 IP 地址在集群当中唯一。更多的功能需要进一步去研究各个 CNI 插件具体提供的功能。</p>\n<h2 id=\"CNI-配置文件语法\"><a href=\"#CNI-配置文件语法\" class=\"headerlink\" title=\"CNI 配置文件语法\"></a>CNI 配置文件语法</h2><p>做填空题目就可以：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;cniVersion&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;disableCheck&quot;</span><span class=\"punctuation\">:</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;plugins&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;bridge&quot;</span><span class=\"punctuation\">:</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;ipMasq&quot;</span><span class=\"punctuation\">:</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;ipam&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;dns&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;nameservers&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;domain&quot;</span><span class=\"punctuation\">:</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;search&quot;</span><span class=\"punctuation\">:</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;options&quot;</span><span class=\"punctuation\">:</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<hr>\n<h1 id=\"相关仓库及文献\"><a href=\"#相关仓库及文献\" class=\"headerlink\" title=\"相关仓库及文献\"></a>相关仓库及文献</h1><p><a href=\"https://github.com/containernetworking/cni/blob/spec-v1.0.0/SPEC.md\">cni/SPEC.md at spec-v1.0.0 · containernetworking/cni (github.com)</a></p>\n<p><a href=\"https://lengrongfu.github.io/2022-05-11-k8s%E4%B9%8BCNI%E8%A7%84%E8%8C%83%E8%A7%A3%E8%AF%BB/\">Kubernetes网络之CNI规范解读 | LRF (lengrongfu.github.io)</a></p>\n<p><a href=\"https://www.redhat.com/sysadmin/cni-kubernetes\">A brief overview of the Container Network Interface (CNI) in Kubernetes | Enable Sysadmin (redhat.com)</a></p>\n<p><a href=\"https://learn.microsoft.com/en-us/azure/aks/use-byo-cni?tabs=azure-cli\">Bring your own Container Network Interface (CNI) plugin - Azure Kubernetes Service | Microsoft Learn</a></p>\n<p><a href=\"https://kubernetes.io/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/\">Network Plugins | Kubernetes</a></p>\n<p><a href=\"https://www.tigera.io/learn/guides/kubernetes-networking/kubernetes-cni/\">Kubernetes CNI Explained (tigera.io)</a></p>\n","site":{"data":{}},"cover":"/img/cover/2077_city.png","cover_type":"img","excerpt":"","more":"<!-- @import \"[TOC]\" {cmd=\"toc\" depthFrom=1 depthTo=6 orderedList=false} -->\n<ul>\n<li><a href=\"#cni-%E6%A6%82%E8%BF%B0\">CNI 概述</a><ul>\n<li><a href=\"#%E4%BB%80%E4%B9%88%E6%98%AF-cni\">什么是 CNI</a></li>\n<li><a href=\"#cni-%E7%9A%84%E5%8A%9F%E8%83%BD\">CNI 的功能</a></li>\n<li><a href=\"#cni-%E7%BB%9F%E4%B8%80%E7%9A%84%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6\">CNI 统一的网络配置文件</a><ul>\n<li><a href=\"#cni-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8D%8F%E8%AE%AE\">CNI 运行时协议</a></li>\n</ul>\n</li>\n<li><a href=\"#cni-%E4%B8%8E%E6%8F%92%E4%BB%B6\">CNI 与插件</a></li>\n</ul>\n</li>\n<li><a href=\"#cni-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%A0%B7%E4%BE%8B%E5%88%86%E6%9E%90\">CNI 配置文件样例分析</a><ul>\n<li><a href=\"#cni-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%AD%E6%B3%95\">CNI 配置文件语法</a></li>\n</ul>\n</li>\n<li><a href=\"#%E7%9B%B8%E5%85%B3%E4%BB%93%E5%BA%93%E5%8F%8A%E6%96%87%E7%8C%AE\">相关仓库及文献</a></li>\n</ul>\n<h1 id=\"CNI-概述\"><a href=\"#CNI-概述\" class=\"headerlink\" title=\"CNI 概述\"></a>CNI 概述</h1><h2 id=\"什么是-CNI\"><a href=\"#什么是-CNI\" class=\"headerlink\" title=\"什么是 CNI\"></a>什么是 CNI</h2><blockquote>\n<p>CNI的全称是 Container Network Interface，它为<strong>容器提供了一种基于插件结构的标准化网络解决方案</strong>。以往，容器的网络层是和具体的底层网络环境高度相关的，不同的网络服务提供商有不同的实现。<strong>CNI从网络服务里抽象出了一套标准接口</strong>，从而屏蔽了上层网络和底层网络提供商的网络实现之间的差异。并且，通过插件结构，它让容器在网络层的具体实现变得可插拔了，所以非常灵活。</p>\n</blockquote>\n<p>首先 CNI 是一套标准接口，它隶属于<a href=\"https://cncf.io/\">CNCF(Cloud Native Computing Foundation)</a>，依照这个标准所实现的为 CNI Plugins, 他们彼此独立，也可以组合起来一起使用，由一组用于配置 Linux 容器的网络接口的规范和库组成，同时还包含了一些插件，CNI 仅关心容器创建时的网络分配，和当容器被删除时释放网络资源。</p>\n<p>其次 依据 CNI 的<a href=\"https://github.com/containernetworking/cni/blob/master/SPEC.md\">规范</a>，CNI 具有以下几点特征：</p>\n<ul>\n<li>CNI 需提供网络管理员<strong>定义网络配置的文件格式</strong></li>\n<li>CNI 需提供 Container Runtime（CRI） 调用功能的<strong>协议/API</strong>。</li>\n<li>当 CNI 被 CRI 调用时，需依据配置文件执行网络配置功能</li>\n<li>CNI 需预留可调用其他插件的能力</li>\n<li>CNI 需规范统一返回给CRI 的数据格式</li>\n</ul>\n<p>依据这样的特征和要求，可以明确实现一个CNI插件需要包含以下部分：</p>\n<ul>\n<li>可执行文件<ul>\n<li>cni plugins</li>\n<li>IPAM</li>\n</ul>\n</li>\n<li>网络配置文件</li>\n</ul>\n<h2 id=\"CNI-的功能\"><a href=\"#CNI-的功能\" class=\"headerlink\" title=\"CNI 的功能\"></a>CNI 的功能</h2><p>CNI 插件首先得实现一个可以被容器管理系统（CRI），比如rkt、Kubernetes 所调用的可执行文件——cni plugins，这个插件首先需要提供<strong>基础的 Linux 网络联通服务</strong>，比如创建 veth 或者 bridge 并将 veth 对的一端插入容器的 network namespace，一端插入 bridge，使得容器之间可以相互通信。然后<strong>将IP 分配给接口</strong>，并通过调用 **IPAM **插件来设置和管理IP地址，使得集群内的容器IP地址相互不重复，或者是结合其他的插件来实现更加复杂的网络路由管理功能等等。</p>\n<p>那么接下来，依据对于这几项功能的要求，来具体看看 CNI 的标准</p>\n<h2 id=\"CNI-统一的网络配置文件\"><a href=\"#CNI-统一的网络配置文件\" class=\"headerlink\" title=\"CNI 统一的网络配置文件\"></a>CNI 统一的网络配置文件</h2><p>CNI 为容器网络管理员(操作人员、网络插件、网络编排系统)定义了一种网络配置格式。它包含了供 CRI 和 CNI 插件使用的指令。在插件执行时，这种配置格式由 CRI 解释，并转化为代码数据结构，传递给 CNI 插件。</p>\n<p>一般来说配置文件主要是以 JSON 文件为主，且包含以下几个键值：</p>\n<ul>\n<li><code>cniVersion</code>: 指定CNI规范的版本，这样 CRI 和 CNI 才能读懂彼此</li>\n<li><code>Name</code>: 网络名字，这在一个主机（或其他管理域）的所有网络配置中应该是唯一的。必须以一个字母数字字符开始，后面可以选择由一个或多个字母数字字符、下划线、点（.）或连字符（-）的任何组合。</li>\n<li><code>disableCheck</code>: 是否禁用检查网络，如果为true,则 <code>container runtime</code> 不会调用 Check 方法进行网络检查。</li>\n<li><code>plugin</code>: cni插件及其配置列表，可以配置多个插件。</li>\n</ul>\n<p>接着展开说明一下 plugin 当中的参数，这也与实现 CNI 的功能息息相关，CRI 解析出配置文件当中的这个字段，是必须要一个字不漏地完整交给 CNI 插件来做网络管理</p>\n<ol>\n<li><p>必须配置的键值</p>\n<p><code>type</code> :  指定目前系统目录当中所使用的 CNI 插件，一般是 cni 可执行文件的目录索引</p>\n<p>至少得有一个基础的 cni 插件来完成最基础的 Linux 网络配置的功能</p>\n</li>\n<li><p>可选键值，由 CRI 依据协议发送的 request 指定</p>\n<p><code>capabilities</code>:  如果 CNI_ARGS 中没有指定此项功能时候来补充的</p>\n</li>\n<li><p>预留键值，由 CRI 在执行时产生的</p>\n<ul>\n<li><code>runtimeConfig</code> :  比如 CNI 自己设置的 isGateway == true 就表明告诉插件，作为网关，给bridge指定一个IP地址。这样，连接到bridge的容器就可以拿它当网关来用了。</li>\n<li><code>args</code></li>\n<li>或者是任何以 <code>cni.dev/</code>开头的</li>\n</ul>\n</li>\n<li><p>可选键值,由容器网络管理员添加</p>\n<p><code>ipMasq</code>: 为目标网络配上Outbound Masquerade(地址伪装)，即：由容器内部通过网关向外发送数据包时，对数据包的源IP地址进行修改。</p>\n<p>当我们的容器以宿主机作为网关时，这个参数是必须要设置的。否则，从容器内部发出的数据包就没有办法通过网关路由到其他网段。因为容器内部的IP地址无法被目标网段识别，所以这些数据包最终会被丢弃掉。</p>\n<p><code>ipam</code>: PAM(IP Adderss Management)即IP地址管理，提供了一系列方法用于对IP和路由进行管理。实际上，它对应的是由CNI提供的一组标准IPAM插件，比如像host-local，dhcp，static等。如果要对整个集群的地址做管理，让pod具有单独的ip地址，就需要在这里添加额外的插件</p>\n<blockquote>\n<p>例子1当中：</p>\n<ul>\n<li>type：指定所用IPAM插件的名称，在例子里，用的是host-local。</li>\n<li>subnet：为目标网络分配网段，包括网络ID和子网掩码，以CIDR形式标记。在例子里为<code>10.15.10.0/24</code>，也就是目标网段为<code>10.15.10.0</code>，子网掩码为<code>255.255.255.0</code>。</li>\n<li>routes：用于指定路由规则，插件会在容器的路由表里生成相应的规则。其中，dst表示希望到达的目标网段，以CIDR形式标记。gw对应网关的IP地址，也就是要到达目标网段所要经过的“next hop(下一跳)”。如果省略gw的话，那么插件会自动帮容器选择默认网关。在例子里，gw选择的是默认网关，而dst为<code>0.0.0.0/0</code>则代表“任何网络”，表示数据包将通过默认网关发往任何网络。实际上，这对应的是一条默认路由规则，即：当所有其他路由规则都不匹配时，将选择该路由。</li>\n<li>rangeStart：允许分配的IP地址范围的起始值</li>\n<li>rangeEnd：允许分配的IP地址范围的结束值</li>\n<li>gateway：为网关（也就是将要在宿主机上创建的bridge）指定的IP地址。如果省略的话，那么插件会自动从允许分配的IP地址范围内选择起始值作为网关的IP地址。</li>\n</ul>\n</blockquote>\n</li>\n</ol>\n<p>配置文件例子如下：</p>\n<p>例子1：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;cniVersion&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;0.4.0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;lab-br0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;bridge&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;bridge&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;lab-br0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;isGateway&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;ipMasq&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;ipam&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;host-local&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;subnet&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;10.15.10.0/24&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;routes&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">            <span class=\"punctuation\">&#123;</span> <span class=\"attr\">&quot;dst&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;0.0.0.0/0&quot;</span> <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">        <span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;rangeStart&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;10.15.10.100&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;rangeEnd&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;10.15.10.200&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;gateway&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;10.15.10.99&quot;</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>例子2：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;cniVersion&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;1.0.0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;dbnet&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;plugins&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;bridge&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"comment\">// plugin specific parameters</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;bridge&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;cni0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;keyA&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span><span class=\"string\">&quot;some more&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;plugin specific&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;configuration&quot;</span><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"attr\">&quot;ipam&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;host-local&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"comment\">// ipam specific</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;subnet&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;10.1.0.0/16&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;gateway&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;10.1.0.1&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;routes&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">            <span class=\"punctuation\">&#123;</span><span class=\"attr\">&quot;dst&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;0.0.0.0/0&quot;</span><span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">        <span class=\"punctuation\">]</span></span><br><span class=\"line\">      <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;dns&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;nameservers&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span> <span class=\"string\">&quot;10.1.0.1&quot;</span> <span class=\"punctuation\">]</span></span><br><span class=\"line\">      <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;tuning&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;capabilities&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;mac&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span></span><br><span class=\"line\">      <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;sysctl&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;net.core.somaxconn&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;500&quot;</span></span><br><span class=\"line\">      <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;portmap&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;capabilities&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span><span class=\"attr\">&quot;portMappings&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">  <span class=\"punctuation\">]</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"CNI-运行时协议\"><a href=\"#CNI-运行时协议\" class=\"headerlink\" title=\"CNI 运行时协议\"></a>CNI 运行时协议</h3><p>CNI协议是基于由 CRI 的调用请求来告诉 CNI 该做些什么。</p>\n<p>主要的协议参数定义如下：</p>\n<ul>\n<li>CNI_COMMAND：表示所需的操作；ADD、DEL、CHECK、或VERSION。</li>\n<li>CNI_CONTAINERID：容器ID。告诉CNI插件，将要加入目标网络的容器所对应的network namespace的ID,容器的唯一的标识符，由 CRI 分配。不能是空的。必须以一个字母数字字符开始，后面可以选择一个或多个字母数字字符、下划线（）、点（.）或连字符（-）的任何组合。</li>\n<li>CNI_NETNS：容器对应的network namespace在宿主机上的文件路径。（例如：/run/netns/[nsname]）。</li>\n<li>CNI_IFNAME：作为veth pair在容器一端的网络接口,一般是在容器内创建的接口的名称；如果 CNI 插件无法使用这个接口名称，那么就必须返回一个错误。</li>\n<li>CNI_ARGS：用户在调用时传入的额外参数。用分号分隔的字母数字键值对；例如，”FOO=BAR;ABC=123”</li>\n<li>CNI_PATH: 表示 CNI 插件可执行文件的路径列表。路径由操作系统特定的列表分隔符分隔；例如Linux上的’:’和Windows上的’；’。</li>\n</ul>\n<p>告诉CNI插件要执行的命令，允许的命令有ADD，DEL，CHECK，VERSION。</p>\n<p>对于支持CNI规范的容器系统而言，当容器启动的时候，系统就会自动调用相应的CNI插件，并设置CNI_COMMAND为ADD。相应地，DEL是在容器被销毁时调用的，用于清除在执行ADD阶段分配的网络资源。CHECK用于检查容器网络是否正常。VERSION则用来显示插件的版本。具体的操作如下：</p>\n<ul>\n<li><p>ADD</p>\n<ul>\n<li><p>将容器添加到网络中，或将新的配置修改应用到已有的集群当中。</p>\n</li>\n<li><p>一个CNI插件在收到ADD命令后，应该选择</p>\n<ul>\n<li><p>在 CNI_NETNS 的容器内创建由 CNI_IFNAME 定义的接口，</p>\n</li>\n<li><p>调整容器内 CNI_NETNS 处由CNI_IFNAME定义的接口的配置</p>\n<p>如果CNI插件成功，必须要返回一个处理结果，要么打印出来，要么修改传入的参数。</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>DELETE</p>\n<ul>\n<li><p>将容器删除出网络，或将新的配置修改应用到已有的集群当中。</p>\n<p>功能与ADD 相对</p>\n</li>\n</ul>\n</li>\n<li><p>CHECK</p>\n<ul>\n<li>查找类型字段中指定的可执行文件，如果没找到返回错误</li>\n<li>当 Plugins （CNI调用的其他的Plugins）返回错误时，将其返回给调用者</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"CNI-与插件\"><a href=\"#CNI-与插件\" class=\"headerlink\" title=\"CNI 与插件\"></a>CNI 与插件</h2><p>为了解决容器网络的各项需求和问题，将所有的功能单独集中在 CNI 单个程序中是不现实的，而且难以兼容不同的上层系统和底层的网络管理，于是一个显然的想法就是将这些功能独立出来，使用插件（Plugins）的形式来执行。</p>\n<p>一个常见的例子就是 IP 地址管理，这就是IP地址管理插件（IPAM插件），它必须设置容器和虚拟网络设备的接口 ，IP / 子网，网关和路由，然后将此信息返回给“主”插件（CNI本体）来执行，换句话说 IPAM 做逻辑上的网络地址管理然后告诉本体 CNI 去执行 <code>ADD</code>,<code>DELETE</code>。 </p>\n<p>CNI 本体调用这些插件的形式也是通过路径找到这些插件的可执行文件来实现的，一般这些插件的位置也都一起放置在 <code>CNI_PATH</code>之下。同时插件和 CNI 本体都是通过 stdin 接收网络配置，也通过 stdout 输出结果。</p>\n<p>如此看来 CNI 的工作流程就是一条链状的调用过程，但调用链中的每一个可执行程序所接收的配置文件信息并不相同。</p>\n<hr>\n<h1 id=\"CNI-配置文件样例分析\"><a href=\"#CNI-配置文件样例分析\" class=\"headerlink\" title=\"CNI 配置文件样例分析\"></a>CNI 配置文件样例分析</h1><blockquote>\n<p>参考<a href=\"https://github.com/containernetworking/cni/blob/spec-v1.0.0/SPEC.md\">cni/SPEC.md at spec-v1.0.0 · containernetworking/cni (github.com)</a> 的 Appendix: Examples</p>\n</blockquote>\n<p>借助 Github 所给的 SPEC 例子，要求 CRI 生成 portmap 和mac 相关的参数，同时使用CNI_IFNAME=eth0。假设目前 CRI 接收到的 json 文件如下：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;cniVersion&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;1.0.0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;dbnet&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;plugins&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;bridge&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"comment\">// plugin specific parameters</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;bridge&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;cni0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;keyA&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span><span class=\"string\">&quot;some more&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;plugin specific&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;configuration&quot;</span><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"attr\">&quot;ipam&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;host-local&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"comment\">// ipam specific</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;subnet&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;10.1.0.0/16&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;gateway&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;10.1.0.1&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;routes&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">            <span class=\"punctuation\">&#123;</span><span class=\"attr\">&quot;dst&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;0.0.0.0/0&quot;</span><span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">        <span class=\"punctuation\">]</span></span><br><span class=\"line\">      <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;dns&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;nameservers&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span> <span class=\"string\">&quot;10.1.0.1&quot;</span> <span class=\"punctuation\">]</span></span><br><span class=\"line\">      <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;tuning&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;capabilities&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;mac&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span></span><br><span class=\"line\">      <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;sysctl&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;net.core.somaxconn&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;500&quot;</span></span><br><span class=\"line\">      <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;portmap&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;capabilities&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span><span class=\"attr\">&quot;portMappings&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">  <span class=\"punctuation\">]</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>我把它简化一下，提取出重要的配置参数，按照插件的调用链来作解释。</p>\n<p>对于 <code>ADD</code> 操作，配置文件所看到的主体为如下所示，提供信息表明 cni 标准为： “1.0.0”, 并创建一个名为dbnet的网络空间，这个网络空间并不是指 network namespace,应该把它理解为一个局域网络的名字，比如插件使用的是 <code>bridge</code>创建，那么这个名字就是创建的网桥名字，也就是<code>ifconfig</code> 看到的网络设备名字；同时配置文件规定了整个 CNI plugins 的调用链，包括从 <code>bridge</code>到<code>tuning</code>再到<code>portmap</code>，然后完成这个网络空间的创建即 <code>ADD</code> 操作</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;cniVersion&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;1.0.0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;dbnet&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;plugins&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span><span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;bridge&quot;</span><span class=\"punctuation\">,</span><span class=\"attr\">&quot;bridge&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;cni0&quot;</span><span class=\"punctuation\">,</span><span class=\"attr\">&quot;ipam&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span><span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span><span class=\"attr\">&quot;dns&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span><span class=\"punctuation\">&#125;</span><span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span><span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;tuning&quot;</span><span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span><span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;portmap&quot;</span><span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">  <span class=\"punctuation\">]</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>首先 CRI 会调用 <code>bridge</code> 插件( CNI ) ,传入 <code>CNI_COMMAND=ADD</code>参数，并传入以下 json 信息:</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;cniVersion&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;1.0.0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;dbnet&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;bridge&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;bridge&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;cni0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;keyA&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span><span class=\"string\">&quot;some more&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;plugin specific&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;configuration&quot;</span><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;ipam&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;host-local&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;subnet&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;10.1.0.0/16&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;gateway&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;10.1.0.1&quot;</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;dns&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;nameservers&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span> <span class=\"string\">&quot;10.1.0.1&quot;</span> <span class=\"punctuation\">]</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>被调用的 CNI 插件 bridge ，首先会去调用他所管的 IPAM 插件 <code>host-local</code>，并传入与它收到的配置信息和 ADD指令参数，也就是下面两行,创建一个 <code>10.1.0.0/16</code>的子网，同时设置 <code>10.1.0.1 为</code>网关（<code>gateway</code>表示对应网关的IP地址，也就是要到达目标网段所要经过的“next hop(下一跳)），地址为<code>10.1.0.1</code>。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">&quot;subnet&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;10.1.0.0/16&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"><span class=\"attr\">&quot;gateway&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;10.1.0.1&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>设置成功，IPAM 插件应该返回以下的结果给 bridge，但这个设置的概念与不同的 CNI 实现有关，一般来说单独的 IPAM 设置指的是数据层面的管理，这个 IPAM 会为容器端的网络接口分配IP地址，比如通过调用<code>net.ParseCIDR</code>函数，对传入的<code>ipAddress</code>进行解析，依据节点环境并生成<code>ipv4Addr</code>和<code>ipv4Net</code>对象，并返回数据，但是并没有调用 Linux 的接口生成对象。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;ips&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">          <span class=\"attr\">&quot;address&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;10.1.0.5/16&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">          <span class=\"attr\">&quot;gateway&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;10.1.0.1&quot;</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">    <span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;routes&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">      <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;dst&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;0.0.0.0/0&quot;</span></span><br><span class=\"line\">      <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">    <span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;dns&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;nameservers&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span> <span class=\"string\">&quot;10.1.0.1&quot;</span> <span class=\"punctuation\">]</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>新增加的两条信息：</p>\n<ol>\n<li><p><code>routes</code> 表示路由规则，如果在配置日志文件当中设置好，IPAM 插件会为 CNI 在容器的路由表里生成相应的规则。其中，<code>dst</code>表示希望到达的目标网段，以CIDR形式标记，在例子里 dst 为<code>0.0.0.0/0</code>，代表“任何网络”，表示数据包将通过默认网关发往任何网络，实际上，这对应的是一条默认路由规则，即：当所有其他路由规则都不匹配时，将选择该路由。</p>\n</li>\n<li><p><code>dns</code> 表示设置的 dns 服务由网关提供</p>\n</li>\n</ol>\n<p>bridge 插件得到配置地址的结果和参数之后，就会依据 IPAM 所给的信息来设置节点的网络情况，一般是这个时候来来调用 <code>setupVeth</code> 以及 <code>netlink</code> 的函数方法，创建并写入对象信息，就像是指令来执行 <code>ip link add</code>,<code>ip link set ... up</code>等等。</p>\n<p>当创建过程结束之后，bridge 插件就会返回以下结果：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;ips&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">          <span class=\"attr\">&quot;address&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;10.1.0.5/16&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">          <span class=\"attr\">&quot;gateway&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;10.1.0.1&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">          <span class=\"attr\">&quot;interface&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">2</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">    <span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;routes&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">      <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;dst&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;0.0.0.0/0&quot;</span></span><br><span class=\"line\">      <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">    <span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;interfaces&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;cni0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;mac&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;00:11:22:33:44:55&quot;</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;veth3243&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;mac&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;55:44:33:22:11:11&quot;</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;eth0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;mac&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;99:88:77:66:55:44&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;sandbox&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;/var/run/netns/blue&quot;</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">    <span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;dns&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;nameservers&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span> <span class=\"string\">&quot;10.1.0.1&quot;</span> <span class=\"punctuation\">]</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>其实上面已经是相对完整的调用过程了，但是例子当中的插件还继续调用了<code>tuning</code>,<br>   <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">`tuning` 接收的参数包括 `CNI_COMMAND=ADD`,原本的配置文件加上 **bridge 插件返回的结果**，结合下来 `tuning`接收到的配置文件为：</span><br><span class=\"line\"></span><br><span class=\"line\">```json</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;cniVersion&quot;: &quot;1.0.0&quot;,</span><br><span class=\"line\">  &quot;name&quot;: &quot;dbnet&quot;,</span><br><span class=\"line\">  &quot;type&quot;: &quot;tuning&quot;,</span><br><span class=\"line\">  &quot;sysctl&quot;: &#123;</span><br><span class=\"line\">    &quot;net.core.somaxconn&quot;: &quot;500&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;runtimeConfig&quot;: &#123;</span><br><span class=\"line\">    &quot;mac&quot;: &quot;00:11:22:33:44:66&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;prevResult&quot;: &#123;</span><br><span class=\"line\">    &quot;ips&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          &quot;address&quot;: &quot;10.1.0.5/16&quot;,</span><br><span class=\"line\">          &quot;gateway&quot;: &quot;10.1.0.1&quot;,</span><br><span class=\"line\">          &quot;interface&quot;: 2</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;routes&quot;: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &quot;dst&quot;: &quot;0.0.0.0/0&quot;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;interfaces&quot;: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;cni0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;00:11:22:33:44:55&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;veth3243&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;55:44:33:22:11:11&quot;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &quot;name&quot;: &quot;eth0&quot;,</span><br><span class=\"line\">            &quot;mac&quot;: &quot;99:88:77:66:55:44&quot;,</span><br><span class=\"line\">            &quot;sandbox&quot;: &quot;/var/run/netns/blue&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;dns&quot;: &#123;</span><br><span class=\"line\">      &quot;nameservers&quot;: [ &quot;10.1.0.1&quot; ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到它所接收的文件内容当中，新增了之前一个插件产生的结果 <code>prevResult</code>。</p>\n<p>标准的部分就到这里了结束了，但可以看到标准更多地还是定义了 CRI ，网络管理者 和 CNI 之间的通信形式，但是这并非完全满足了 Pod 网络管理的需求，尤其是作为 IPAM 的 <code>host-local</code> 插件仅能够确保同一台宿主机上运行的所有容器，IP地址一定都是彼此唯一的；无法做到让这个 IP 地址在集群当中唯一。更多的功能需要进一步去研究各个 CNI 插件具体提供的功能。</p>\n<h2 id=\"CNI-配置文件语法\"><a href=\"#CNI-配置文件语法\" class=\"headerlink\" title=\"CNI 配置文件语法\"></a>CNI 配置文件语法</h2><p>做填空题目就可以：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;cniVersion&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;disableCheck&quot;</span><span class=\"punctuation\">:</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;plugins&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;bridge&quot;</span><span class=\"punctuation\">:</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;ipMasq&quot;</span><span class=\"punctuation\">:</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;ipam&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;dns&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;nameservers&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;domain&quot;</span><span class=\"punctuation\">:</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;search&quot;</span><span class=\"punctuation\">:</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;options&quot;</span><span class=\"punctuation\">:</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">      <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<hr>\n<h1 id=\"相关仓库及文献\"><a href=\"#相关仓库及文献\" class=\"headerlink\" title=\"相关仓库及文献\"></a>相关仓库及文献</h1><p><a href=\"https://github.com/containernetworking/cni/blob/spec-v1.0.0/SPEC.md\">cni/SPEC.md at spec-v1.0.0 · containernetworking/cni (github.com)</a></p>\n<p><a href=\"https://lengrongfu.github.io/2022-05-11-k8s%E4%B9%8BCNI%E8%A7%84%E8%8C%83%E8%A7%A3%E8%AF%BB/\">Kubernetes网络之CNI规范解读 | LRF (lengrongfu.github.io)</a></p>\n<p><a href=\"https://www.redhat.com/sysadmin/cni-kubernetes\">A brief overview of the Container Network Interface (CNI) in Kubernetes | Enable Sysadmin (redhat.com)</a></p>\n<p><a href=\"https://learn.microsoft.com/en-us/azure/aks/use-byo-cni?tabs=azure-cli\">Bring your own Container Network Interface (CNI) plugin - Azure Kubernetes Service | Microsoft Learn</a></p>\n<p><a href=\"https://kubernetes.io/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/\">Network Plugins | Kubernetes</a></p>\n<p><a href=\"https://www.tigera.io/learn/guides/kubernetes-networking/kubernetes-cni/\">Kubernetes CNI Explained (tigera.io)</a></p>\n"},{"title":"CNI 与  Pod 容器网络—— Linux 网络","catalog":true,"date":"2023-04-18T21:02:23.000Z","subtitle":null,"header-img":null,"_content":"\n# CNI 与  Pod 容器网络—— Linux 网络\n\n> Pod 容器在 kubernetes 网络中是怎样获取他的地址的呢? \n>\n> 如何保障 Pod IP 在整个集群当中的唯一性？\n>\n> 容器流量如何在所给的IP之间相互转发？\n\n---\n\n## 从 namespace 开始\n\nnamespace 技术是 Linux 内核提供的一项非常重要的功能，也是容器虚拟化的基础技术，通过构建系统资源的边界，形成一个相对封闭的资源区域，也就是大家认识的容器。Linux 提供的 namespace 包括以下几个方面：\n\n``` bash\n       Linux provides the following namespaces:\n\n       Namespace   Constant          Isolates\n       Cgroup      CLONE_NEWCGROUP   Cgroup root directory\n       IPC         CLONE_NEWIPC      System V IPC, POSIX message queues\n       Network     CLONE_NEWNET      Network devices, stacks, ports, etc.\n       Mount       CLONE_NEWNS       Mount points\n       PID         CLONE_NEWPID      Process IDs\n       User        CLONE_NEWUSER     User and group IDs\n       UTS         CLONE_NEWUTS      Hostname and NIS domain name\n```\n\n其中网络名字空间(network namespace)是网络虚拟化技术的基础，也是本文最为关注的部分；现有的各项容器技术在实现他们各自的网络连接时所依赖的核心，所以要探究 Pod 网络和 CNI 就必须先从 network namespace 入手。\n\n在 Linux 系统当中，每一个 network  namespace  都有他自己的网络设置，包括（routing table）路由表、（network interface）网络设备、（IP address）IP 地址等等，这样隔离的一个典型好处就是在不同的network namespace 之下程序可以绑定到同一个端口并保持各自的网络约束不变。与其他的 namespace 一样, network namspace 也可以调用 clone() API创建一个通用的 namespace, 然后传入 CLONE_NEWNET 参数来创建 network namespace。不过就简单配置来说， 可以使用 **netns** 执行对 networkname space  的各项增删改查。\n\n依据 network namspace 划分出网络区域就像是创建网络通信的对端，但光有隔离出来的对象并不能构成网络；容器还要和外界进行网络联通才能提供服务。与实际网络场景不相同的是，没有物理实体的交换机和路由器，甚至可用的物理网卡也是受限的，那么如何能够在划分隔离出的区域之间提供通信呢？同时如何能够定位这些区域并让数据包能够正确地从一个 netns 中传输到另一个 netns呢？\n\n---\n\n## veth 的创建和连接\n\n首先要清楚 veth-pairs， veth 是虚拟以太网卡（virtual Ethernet）的缩写，veth 设备总是成对出现的，也因此称之为 veth-pair。可以通过` ip link add veth0 type veth peer name veth1` 等指令来创建管理这些虚拟网卡，eg ：[从docker0开始](https://morningspace.github.io/tech/k8s-net-docker0/) ，[Deep dive into Linux Networking and Docker | Medium](https://medium.com/techlog/diving-into-linux-networking-and-docker-bridge-veth-and-iptables-a05eb27b1e72) 等文章就有讲到其作用和类似操作，不再复述。\n\n但关键在于对于系统来说，veth到底是什么呢？是一个文件，进程还是描述符,他是否直接和物理网卡相关？它的工作原理是什么，是怎样来让容器之间相互通信的呢？接着来深入研究其内核当中的实现，具体参考：[veth(4) - Linux manual page (man7.org)](https://man7.org/linux/man-pages/man4/veth.4.html)，[linux/veth.c at master · torvalds/linux (github.com)](https://github.com/torvalds/linux/blob/master/drivers/net/veth.c)\n\nveth的相关源码位于 `drivers/net/veth.c`中，其中的初始化入口是`veth_init`\n\n``` c\nstatic __init int veth_init(void)\n{\n\treturn rtnl_link_register(&veth_link_ops);\n}\n```\n\n初始化函数注册了`veth_link_ops`(veth 设备的操作方法)，它包含了 veth 设备的创建启动和删除等回调函数，具体结构如下:\n\n```c\nstatic struct rtnl_link_ops veth_link_ops = {\n\t.kind\t\t= DRV_NAME,\n\t.priv_size\t= sizeof(struct veth_priv),\n\t.setup\t\t= veth_setup,\n\t.validate\t= veth_validate,\n\t.newlink\t= veth_newlink,\n\t.dellink\t= veth_dellink,\n\t.policy\t\t= veth_policy,\n\t.maxtype\t= VETH_INFO_MAX,\n\t.get_link_net\t= veth_get_link_net,\n\t.get_num_tx_queues\t= veth_get_num_queues,\n\t.get_num_rx_queues\t= veth_get_num_queues,\n};\n```\n\n从 `kind` 到 `setup` 都是创建对应的数据结构并写入常量参数,所以创建的关键还是在 `veth_newlink`,`veth_dellink`，但二者的执行逻辑相关，所以只看其中一个。 \n\n首先是 `veth_newlink`, 不过他的实现较长，只能抓取一部分关键拆分开来看：\n\n```c\nstatic int veth_newlink(struct net *src_net, struct net_device *dev,\n\t\t\tstruct nlattr *tb[], struct nlattr *data[],\n\t\t\tstruct netlink_ext_ack *extack)\n{\n    ...\n    // 由于虚拟网络设备对是由两个网络设备组成,\n    // dev 是虚拟网络设备对的其中一个网络设备，不可能创建单独的设备，那就需要创建一个临时的对端 peer\n    // 因而调用 rtnl_create_link 函数创建对端网络设备的逻辑对象 peer \n\tpeer = rtnl_create_link(net, ifname, name_assign_type,\n\t\t\t\t&veth_link_ops, tbp, extack);\n\terr = register_netdevice(peer);\n    ...\n    // 注册 dev 对象，本质上就在内存里面建立一个 struct 并将信息从文件映射过去\n\terr = register_netdevice(dev);\n\n    ...\n    // 把 peer 和 dev 关联到一起\n\tpriv = netdev_priv(dev);               // 获取 dev 的私有数据部分\n\trcu_assign_pointer(priv->peer, peer);  // 将其 peer 字段指向 dev\n\terr = veth_init_queues(dev, tb);\n\tpriv = netdev_priv(peer);              // 获取 peer 的私有数据部分\n\trcu_assign_pointer(priv->peer, dev);   // 将其 peer 字段指向 dev\n    ...\n\terr = veth_init_queues(peer, tb);\n    \n    // 添加 XDP 访问支持 --> veth 在内核运行流程中接近网卡\n    ...\n\t/* update XDP supported features */\n\tveth_set_xdp_features(dev);\n\tveth_set_xdp_features(peer);\n    ...\n}\n```\n\n在`veth_newlink`当中通过**`register_netdevice`** 注册了两个网络虚拟设备： `peer` 和 `dev`，并通过让 `dev` 的 peer 指针指向创建的 peer，让`peer` 的 peer  指针指向 dev，来完成了 veth 设备的结对。这个过程是符合 veth 的工作逻辑的，由于  veth 总是成对出现，所以在生成新的 veth 时候就需要指定它所连接对端  peer，当然这个过程发生在内核运行当中，并不是有物理上的连接关系，直白来说就是依据文件信息写入到内存，开辟一个空间来存储对应的信息，然后修改指针指向来表示连接关系。\n\n创建完成之后，veth 又是怎么来传输数据的呢？回到之前的 `veth_setup`,启动 veth 的流程，也是将各类函数注册指定到 veth 对象当中\n\n```C\nstatic void veth_setup(struct net_device *dev)\n{\n\tether_setup(dev);\n    ...\n\tdev->netdev_ops = &veth_netdev_ops;\n\tdev->xdp_metadata_ops = &veth_xdp_metadata_ops;\n\tdev->ethtool_ops = &veth_ethtool_ops;\n    ...\n}\n```\n\n可以看到是 veth 对象的操作列表包含三类：`veth_netdev_ops`,`veth_xdp_metadata_ops`,`veth_ethtool_ops`, 具体的列表如下：\n\nnet_device_ops 结构是网络设备的操作函数集结构, 包含了 Linux 网络设备对象的各项操作行为列表，也是  veth 对象调用实现功能的具体行为。\n\n从以下列表其实可以知道，Linux 设备是通用一个网卡的代码数据操作流程及对象的，以下的操作函数对于 ebpf xdp 程序直接操作有一定参考，是EdgeMesh 为来优化的对象，故进一步深入探究。\n\n```C\nstatic const struct net_device_ops veth_netdev_ops = {\n\t.ndo_init            = veth_dev_init,\n\t.ndo_open            = veth_open,\n\t.ndo_stop            = veth_close,\n\t.ndo_start_xmit      = veth_xmit,\n\t.ndo_get_stats64     = veth_get_stats64,\n\t.ndo_set_rx_mode     = veth_set_multicast_list,\n\t.ndo_set_mac_address = eth_mac_addr,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t= veth_poll_controller,\n#endif\n\t.ndo_get_iflink\t\t= veth_get_iflink,\n\t.ndo_fix_features\t= veth_fix_features,\n\t.ndo_set_features\t= veth_set_features,\n\t.ndo_features_check\t= passthru_features_check,\n\t.ndo_set_rx_headroom\t= veth_set_rx_headroom,\n\t.ndo_bpf\t\t= veth_xdp,\n\t.ndo_xdp_xmit\t\t= veth_ndo_xdp_xmit,\n\t.ndo_get_peer_dev\t= veth_peer_dev,\n};\n```\n\n这些函数的具体作用如下整理：\n\n- `ndo_init`: 该函数指向 `veth_dev_init`，网络设备初始化函数，由驱动程序实现，在网卡设备分配之后调用。\n\n- `ndo_open`: 该函数指向 `veth_open`，被调用以打开虚拟网络设备并将其加入网络协议栈，由驱动程序实现，用于开启网络设备并为进程提供网络访问。\n- `ndo_stop`：该函数指向 `veth_close`，由驱动程序实现，被调用以停止虚拟网络设备并将其从网络协议栈中移除。\n- ==`ndo_start_xmit`：该函数指向 `veth_xmit`，由驱动程序实现，用于将给定的网络数据帧发送到指定的网络设备上。==\n- `ndo_get_stats64`：该函数指向 `veth_get_stats64`，由驱动程序实现，用于获取虚拟网络设备当前的统计信息。\n- `ndo_set_rx_mode`：该函数指向 `veth_set_multicast_list`，由驱动程序实现，用于设置网络设备接收模式。\n- `ndo_set_mac_address`：该函数指向 `eth_mac_addr`，用于设置虚拟网络设备的MAC地址。\n- `ndo_poll_controller`：该函数指向 `veth_poll_controller`，由驱动程序实现，veth调用之后触发软中断从 Ringbuffer 当中 poll 数据包\n- `ndo_get_iflink`：该函数指向 `veth_get_iflink`，用于获取虚拟网络设备的网络接口索引号。\n- `ndo_fix_features`：该函数指向 `veth_fix_features`，用于设置虚拟网络设备的特性参数；\n- `ndo_set_features`：该函数指向 `veth_set_features`，用于修改或更新虚拟网络设备已经打开的特性参数。\n- `ndo_features_check`：该函数指向 `passthru_features_check`，检查虚拟网络设备是否包含由 ETS（Enhanced Traffic Service）要求的特征。\n- `ndo_set_rx_headroom`: 该函数指向 `veth_set_rx_headroom`，用于设置虚拟网络设备中下行数据帧包头部的大小。\n- `ndo_bpf`：该函数指向 `veth_xdp`，用于添加eBPF扩展程序入口并进行初始化。\n- `ndo_xdp_xmit`: 该函数指向 `veth_ndo_xdp_xmit`，驱动程序的XDP传输方法入口，将网络数据帧发送到用户提供的XDP扩展程序。\n- `ndo_get_peer_dev`: 该函数指向 `veth_peer_dev`，用于获取与虚拟网络设备配对的网络设备。 \n\n`ethtool_ops`结构则代表了与`ethtool`工具相关的网络设备操作函数集合。`ethtool`用于获取和设置与`ethtool`兼容设备的驱动程序和硬件信息，同时实现均衡网速，流量控制等功能。\n\n``` C\nstatic const struct ethtool_ops veth_ethtool_ops = {\n\t.get_drvinfo\t\t= veth_get_drvinfo,\n\t.get_link\t\t= ethtool_op_get_link,\n\t.get_strings\t\t= veth_get_strings,\n\t.get_sset_count\t\t= veth_get_sset_count,\n\t.get_ethtool_stats\t= veth_get_ethtool_stats,\n\t.get_link_ksettings\t= veth_get_link_ksettings,\n\t.get_ts_info\t\t= ethtool_op_get_ts_info,\n\t.get_channels\t\t= veth_get_channels,\n\t.set_channels\t\t= veth_set_channels,\n};\n```\n\n`xdp_metadata_ops`结构体定义了XDP（eBPF based packet processing）元数据的操作集合，在实现高性能网络数据包处理、过滤和转发的过程中起到重要作用。该操作集与XDP引擎密切相关，包括xsk_frame_parse（对接收的数据包的元数据进行解析）和xsk_frame_init（初始化元数据）等。\n\n```c\nstatic const struct xdp_metadata_ops veth_xdp_metadata_ops = {\n\t.xmo_rx_timestamp\t\t= veth_xdp_rx_timestamp,\n\t.xmo_rx_hash\t\t\t= veth_xdp_rx_hash,\n};\n```\n\n- `xmo_rx_timestamp` ： 该函数指针指向 `veth_xdp_rx_timestamp` 函数，用于获取 XDP 包的接收时间戳，即处理 XDP 包的内核进程把包抓取的时间。该时间可以在 eBPF 程序中使用，例如可用于实现延迟测量(metric)，排除处理器竞争以及路由表测量等。\n\n- `xmo_rx_hash`：该函数指针指向 `veth_xdp_rx_hash`，用于获取 XDP 数据包的接收哈希值。通过接收哈希值，可以在 eBPF 中就各个数据包的接收位置和网络环境进行更好的控制和调节，以优化网络性能。例如在基于哈希的负载均衡中，可以使用哈希值来决定要将数据包路由到哪个接收 CPU 或内核上。\n\n在 Linux 中，这些函数指针被定义为可选项，也就是说并非每个驱动程序都会实现这两个函数指针。`xdp_metadata_ops` 使驱动程序与 eBPF程序 在处理特定的数据包和流量时更加灵活；但反过来说也需要配备一定的环境才能够实现这些调用的功能。\n\n到这里，veth 的创建和各项功能在 Linux 视角的样子就全部呈现了，总的来说 veth 本身是 Linux 中创建的 `net_device` 结构，通过注册所需的初始化和操作行为等特定函数以及对其进行相应的参数配置，最终实例化为 veth 对象，用于虚拟网络的构建。同时更明确了 veth 是工作在二层的数据结构，他传输数据会调用驱动程序实现的 `ndo_start_xmit`函数，在指定了对端之后，数据包发送会存入 skb 并插入 `softnet_data->input_pkt_queue`中，出发软中断，接下来就是对称一般的内核接收过程。\n\n---\n\n## 网桥的连接和传输\n\nveth 可以感性地认知为网卡，它给予了所划分出的 network namspace 一个出入的门，此前的结构如果将 veth 分别指向两个网络空间，就能够实现这二者的通信，但是当所划分的网络空间区域增加的时候，这样子点对点的连接方式显然就很难支撑了。\n\n这样就需要解决单节点大量容器之间的网络互连问题。\n\n参考实际物理网络的结构，Linux 实现并提供了一个完全由软件虚拟出来的交换机，它可以提供很多的虚拟端口，把许多的 veth 连接在一个平面的网络，通过自己的转发功能让虚拟机网卡之间可以通信，这个技术就叫做 bridge。\n\n如何使用 bridge 连接不同的网络空间呢？[Introduction to Linux interfaces for virtual networking | Red Hat Developer](https://developers.redhat.com/blog/2018/10/22/introduction-to-linux-interfaces-for-virtual-networking#team_device)，[Deep dive into Linux Networking and Docker - Bridge, vETH and IPTables - DEV Community](https://dev.to/arriqaaq/diving-into-linux-networking-and-docker-bridge-veth-and-iptables-419a)  等文章也有详尽阐述，不再复述。\n\n其中要关注的点是： bridge 的工作源码都是在 /net/core/dev.c 或者是 /net/bridge 目录下面，也就是说他是工作在二层上的设备（这一点与物理交换相同），但所给的实验来验证连通性是依靠 ping 指令从IP来看的，但这并不意味着 bridge 是依靠 IP  来做转发的。\n\n为了验证这一点，深入来看 bridge 的内核实现\n\n从外部网络到达节点时候，数据包会被网卡先送到 RingBuffer 中，然后依次经过硬中断、软中断处理，在软中断中再以此把包送到设备层（连接bridge）、协议栈，最后唤醒应用程序。\n\n从节点内的应用程序到达外部的时候，会从应用程序调用系统调用，在进入协议栈（传输层、网络层），再进入邻居子系统到网络设备子系统（bridge），之后调用驱动程序触发硬中断到网卡。\n\n在这个过程中，bridge 输入数据包处理工作流程在 `/net/bridge/br_input.c` 中 `br_handle_frame_finish`函数里\n\n```c\nint br_handle_frame_finish(struct net *net, struct sock *sk, struct sk_buff *skb)\n{\n    // 获取 veth 所连接的网桥端口以及 bridge 设备\n\tstruct net_bridge_port *p = br_port_get_rcu(skb->dev);\n    // 创建转发表对象\n\tstruct net_bridge_fdb_entry *dst = NULL;\n    \n\tstruct net_bridge_mcast_port *pmctx;\n\tstruct net_bridge_mdb_entry *mdst;\n\tstruct net_bridge_vlan *vlan;\n\tstruct net_bridge *br;\n\tbr = p->br;\n    \n    // 查找并更新转发表，这个转发表使用的地址是eth_hdr(skb)->h_source\n\tbr_fdb_update(br, p, eth_hdr(skb)->h_source,vid, BIT(BR_FDB_LOCKED));\t\n\tdst = br_fdb_find_rcu(br, eth_hdr(skb)->h_dest, vid);\n    \n    // 转发\n\tif (dst) {\n\t\tbr_forward(dst->dst, skb, local_rcv, false);\n    // 本机访问\n\tif (local_rcv)\n\t\treturn br_pass_frame_up(skb);\n}\n```\n\n其中查找和转发使用的地址是eth_hdr(skb)->h_dest，和物理环境当中的交换机会自动学习端口所对应的节点mac地址一样，软件模拟的 bridge 也会自学习 veth 与 eth_hdr 的对应关系。\n\n总的来说，当创建了 bridge 并把 veth 设备放入其中，网桥就能够为连接的网络空间提供一个平面的网络连接服务。\n\n其实到目前为止，所涉及的网络设备都工作在二层，对应到物理环境就是都使用的 MAC 地址进行寻址和交换信息，这样的网络服务就是 Linux  基本网络服务，能够实现单节点上的网络空间连通性。\n\n可只是这样是无法满足Kubernetes 集群的网络寻址和路由需求的，现有的网络追求平面式的连接服务但是底层依旧还是得通过IP进行寻址；回到容器网络当中，这也意味着希望在容器网络当中的实体能够拥有各自独立、唯一的IP地址，可以是容器、物理机或者是其他的网络设备（比如虚拟路由器）等，容器可以被添加到一个或多个网络中或从一个或多个网络中删除。这就是接下来 CNI 需要满足的功能之一。\n\n---\n\n\n\n## 再看 Namespace\n","source":"_posts/EdgeMesh/cilium与edgemesh性能测试/2023-ospp-fighting/Kubernetes 容器网络 CNI — Linux 网络虚拟化.md","raw":"---\ntitle: CNI 与  Pod 容器网络—— Linux 网络\ncatalog: true\ndate: 2023-04-19 05:02:23\nsubtitle:\nheader-img:\ntags: ospp, Linux, Network\ncategories: Linux, Container\n---\n\n# CNI 与  Pod 容器网络—— Linux 网络\n\n> Pod 容器在 kubernetes 网络中是怎样获取他的地址的呢? \n>\n> 如何保障 Pod IP 在整个集群当中的唯一性？\n>\n> 容器流量如何在所给的IP之间相互转发？\n\n---\n\n## 从 namespace 开始\n\nnamespace 技术是 Linux 内核提供的一项非常重要的功能，也是容器虚拟化的基础技术，通过构建系统资源的边界，形成一个相对封闭的资源区域，也就是大家认识的容器。Linux 提供的 namespace 包括以下几个方面：\n\n``` bash\n       Linux provides the following namespaces:\n\n       Namespace   Constant          Isolates\n       Cgroup      CLONE_NEWCGROUP   Cgroup root directory\n       IPC         CLONE_NEWIPC      System V IPC, POSIX message queues\n       Network     CLONE_NEWNET      Network devices, stacks, ports, etc.\n       Mount       CLONE_NEWNS       Mount points\n       PID         CLONE_NEWPID      Process IDs\n       User        CLONE_NEWUSER     User and group IDs\n       UTS         CLONE_NEWUTS      Hostname and NIS domain name\n```\n\n其中网络名字空间(network namespace)是网络虚拟化技术的基础，也是本文最为关注的部分；现有的各项容器技术在实现他们各自的网络连接时所依赖的核心，所以要探究 Pod 网络和 CNI 就必须先从 network namespace 入手。\n\n在 Linux 系统当中，每一个 network  namespace  都有他自己的网络设置，包括（routing table）路由表、（network interface）网络设备、（IP address）IP 地址等等，这样隔离的一个典型好处就是在不同的network namespace 之下程序可以绑定到同一个端口并保持各自的网络约束不变。与其他的 namespace 一样, network namspace 也可以调用 clone() API创建一个通用的 namespace, 然后传入 CLONE_NEWNET 参数来创建 network namespace。不过就简单配置来说， 可以使用 **netns** 执行对 networkname space  的各项增删改查。\n\n依据 network namspace 划分出网络区域就像是创建网络通信的对端，但光有隔离出来的对象并不能构成网络；容器还要和外界进行网络联通才能提供服务。与实际网络场景不相同的是，没有物理实体的交换机和路由器，甚至可用的物理网卡也是受限的，那么如何能够在划分隔离出的区域之间提供通信呢？同时如何能够定位这些区域并让数据包能够正确地从一个 netns 中传输到另一个 netns呢？\n\n---\n\n## veth 的创建和连接\n\n首先要清楚 veth-pairs， veth 是虚拟以太网卡（virtual Ethernet）的缩写，veth 设备总是成对出现的，也因此称之为 veth-pair。可以通过` ip link add veth0 type veth peer name veth1` 等指令来创建管理这些虚拟网卡，eg ：[从docker0开始](https://morningspace.github.io/tech/k8s-net-docker0/) ，[Deep dive into Linux Networking and Docker | Medium](https://medium.com/techlog/diving-into-linux-networking-and-docker-bridge-veth-and-iptables-a05eb27b1e72) 等文章就有讲到其作用和类似操作，不再复述。\n\n但关键在于对于系统来说，veth到底是什么呢？是一个文件，进程还是描述符,他是否直接和物理网卡相关？它的工作原理是什么，是怎样来让容器之间相互通信的呢？接着来深入研究其内核当中的实现，具体参考：[veth(4) - Linux manual page (man7.org)](https://man7.org/linux/man-pages/man4/veth.4.html)，[linux/veth.c at master · torvalds/linux (github.com)](https://github.com/torvalds/linux/blob/master/drivers/net/veth.c)\n\nveth的相关源码位于 `drivers/net/veth.c`中，其中的初始化入口是`veth_init`\n\n``` c\nstatic __init int veth_init(void)\n{\n\treturn rtnl_link_register(&veth_link_ops);\n}\n```\n\n初始化函数注册了`veth_link_ops`(veth 设备的操作方法)，它包含了 veth 设备的创建启动和删除等回调函数，具体结构如下:\n\n```c\nstatic struct rtnl_link_ops veth_link_ops = {\n\t.kind\t\t= DRV_NAME,\n\t.priv_size\t= sizeof(struct veth_priv),\n\t.setup\t\t= veth_setup,\n\t.validate\t= veth_validate,\n\t.newlink\t= veth_newlink,\n\t.dellink\t= veth_dellink,\n\t.policy\t\t= veth_policy,\n\t.maxtype\t= VETH_INFO_MAX,\n\t.get_link_net\t= veth_get_link_net,\n\t.get_num_tx_queues\t= veth_get_num_queues,\n\t.get_num_rx_queues\t= veth_get_num_queues,\n};\n```\n\n从 `kind` 到 `setup` 都是创建对应的数据结构并写入常量参数,所以创建的关键还是在 `veth_newlink`,`veth_dellink`，但二者的执行逻辑相关，所以只看其中一个。 \n\n首先是 `veth_newlink`, 不过他的实现较长，只能抓取一部分关键拆分开来看：\n\n```c\nstatic int veth_newlink(struct net *src_net, struct net_device *dev,\n\t\t\tstruct nlattr *tb[], struct nlattr *data[],\n\t\t\tstruct netlink_ext_ack *extack)\n{\n    ...\n    // 由于虚拟网络设备对是由两个网络设备组成,\n    // dev 是虚拟网络设备对的其中一个网络设备，不可能创建单独的设备，那就需要创建一个临时的对端 peer\n    // 因而调用 rtnl_create_link 函数创建对端网络设备的逻辑对象 peer \n\tpeer = rtnl_create_link(net, ifname, name_assign_type,\n\t\t\t\t&veth_link_ops, tbp, extack);\n\terr = register_netdevice(peer);\n    ...\n    // 注册 dev 对象，本质上就在内存里面建立一个 struct 并将信息从文件映射过去\n\terr = register_netdevice(dev);\n\n    ...\n    // 把 peer 和 dev 关联到一起\n\tpriv = netdev_priv(dev);               // 获取 dev 的私有数据部分\n\trcu_assign_pointer(priv->peer, peer);  // 将其 peer 字段指向 dev\n\terr = veth_init_queues(dev, tb);\n\tpriv = netdev_priv(peer);              // 获取 peer 的私有数据部分\n\trcu_assign_pointer(priv->peer, dev);   // 将其 peer 字段指向 dev\n    ...\n\terr = veth_init_queues(peer, tb);\n    \n    // 添加 XDP 访问支持 --> veth 在内核运行流程中接近网卡\n    ...\n\t/* update XDP supported features */\n\tveth_set_xdp_features(dev);\n\tveth_set_xdp_features(peer);\n    ...\n}\n```\n\n在`veth_newlink`当中通过**`register_netdevice`** 注册了两个网络虚拟设备： `peer` 和 `dev`，并通过让 `dev` 的 peer 指针指向创建的 peer，让`peer` 的 peer  指针指向 dev，来完成了 veth 设备的结对。这个过程是符合 veth 的工作逻辑的，由于  veth 总是成对出现，所以在生成新的 veth 时候就需要指定它所连接对端  peer，当然这个过程发生在内核运行当中，并不是有物理上的连接关系，直白来说就是依据文件信息写入到内存，开辟一个空间来存储对应的信息，然后修改指针指向来表示连接关系。\n\n创建完成之后，veth 又是怎么来传输数据的呢？回到之前的 `veth_setup`,启动 veth 的流程，也是将各类函数注册指定到 veth 对象当中\n\n```C\nstatic void veth_setup(struct net_device *dev)\n{\n\tether_setup(dev);\n    ...\n\tdev->netdev_ops = &veth_netdev_ops;\n\tdev->xdp_metadata_ops = &veth_xdp_metadata_ops;\n\tdev->ethtool_ops = &veth_ethtool_ops;\n    ...\n}\n```\n\n可以看到是 veth 对象的操作列表包含三类：`veth_netdev_ops`,`veth_xdp_metadata_ops`,`veth_ethtool_ops`, 具体的列表如下：\n\nnet_device_ops 结构是网络设备的操作函数集结构, 包含了 Linux 网络设备对象的各项操作行为列表，也是  veth 对象调用实现功能的具体行为。\n\n从以下列表其实可以知道，Linux 设备是通用一个网卡的代码数据操作流程及对象的，以下的操作函数对于 ebpf xdp 程序直接操作有一定参考，是EdgeMesh 为来优化的对象，故进一步深入探究。\n\n```C\nstatic const struct net_device_ops veth_netdev_ops = {\n\t.ndo_init            = veth_dev_init,\n\t.ndo_open            = veth_open,\n\t.ndo_stop            = veth_close,\n\t.ndo_start_xmit      = veth_xmit,\n\t.ndo_get_stats64     = veth_get_stats64,\n\t.ndo_set_rx_mode     = veth_set_multicast_list,\n\t.ndo_set_mac_address = eth_mac_addr,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t= veth_poll_controller,\n#endif\n\t.ndo_get_iflink\t\t= veth_get_iflink,\n\t.ndo_fix_features\t= veth_fix_features,\n\t.ndo_set_features\t= veth_set_features,\n\t.ndo_features_check\t= passthru_features_check,\n\t.ndo_set_rx_headroom\t= veth_set_rx_headroom,\n\t.ndo_bpf\t\t= veth_xdp,\n\t.ndo_xdp_xmit\t\t= veth_ndo_xdp_xmit,\n\t.ndo_get_peer_dev\t= veth_peer_dev,\n};\n```\n\n这些函数的具体作用如下整理：\n\n- `ndo_init`: 该函数指向 `veth_dev_init`，网络设备初始化函数，由驱动程序实现，在网卡设备分配之后调用。\n\n- `ndo_open`: 该函数指向 `veth_open`，被调用以打开虚拟网络设备并将其加入网络协议栈，由驱动程序实现，用于开启网络设备并为进程提供网络访问。\n- `ndo_stop`：该函数指向 `veth_close`，由驱动程序实现，被调用以停止虚拟网络设备并将其从网络协议栈中移除。\n- ==`ndo_start_xmit`：该函数指向 `veth_xmit`，由驱动程序实现，用于将给定的网络数据帧发送到指定的网络设备上。==\n- `ndo_get_stats64`：该函数指向 `veth_get_stats64`，由驱动程序实现，用于获取虚拟网络设备当前的统计信息。\n- `ndo_set_rx_mode`：该函数指向 `veth_set_multicast_list`，由驱动程序实现，用于设置网络设备接收模式。\n- `ndo_set_mac_address`：该函数指向 `eth_mac_addr`，用于设置虚拟网络设备的MAC地址。\n- `ndo_poll_controller`：该函数指向 `veth_poll_controller`，由驱动程序实现，veth调用之后触发软中断从 Ringbuffer 当中 poll 数据包\n- `ndo_get_iflink`：该函数指向 `veth_get_iflink`，用于获取虚拟网络设备的网络接口索引号。\n- `ndo_fix_features`：该函数指向 `veth_fix_features`，用于设置虚拟网络设备的特性参数；\n- `ndo_set_features`：该函数指向 `veth_set_features`，用于修改或更新虚拟网络设备已经打开的特性参数。\n- `ndo_features_check`：该函数指向 `passthru_features_check`，检查虚拟网络设备是否包含由 ETS（Enhanced Traffic Service）要求的特征。\n- `ndo_set_rx_headroom`: 该函数指向 `veth_set_rx_headroom`，用于设置虚拟网络设备中下行数据帧包头部的大小。\n- `ndo_bpf`：该函数指向 `veth_xdp`，用于添加eBPF扩展程序入口并进行初始化。\n- `ndo_xdp_xmit`: 该函数指向 `veth_ndo_xdp_xmit`，驱动程序的XDP传输方法入口，将网络数据帧发送到用户提供的XDP扩展程序。\n- `ndo_get_peer_dev`: 该函数指向 `veth_peer_dev`，用于获取与虚拟网络设备配对的网络设备。 \n\n`ethtool_ops`结构则代表了与`ethtool`工具相关的网络设备操作函数集合。`ethtool`用于获取和设置与`ethtool`兼容设备的驱动程序和硬件信息，同时实现均衡网速，流量控制等功能。\n\n``` C\nstatic const struct ethtool_ops veth_ethtool_ops = {\n\t.get_drvinfo\t\t= veth_get_drvinfo,\n\t.get_link\t\t= ethtool_op_get_link,\n\t.get_strings\t\t= veth_get_strings,\n\t.get_sset_count\t\t= veth_get_sset_count,\n\t.get_ethtool_stats\t= veth_get_ethtool_stats,\n\t.get_link_ksettings\t= veth_get_link_ksettings,\n\t.get_ts_info\t\t= ethtool_op_get_ts_info,\n\t.get_channels\t\t= veth_get_channels,\n\t.set_channels\t\t= veth_set_channels,\n};\n```\n\n`xdp_metadata_ops`结构体定义了XDP（eBPF based packet processing）元数据的操作集合，在实现高性能网络数据包处理、过滤和转发的过程中起到重要作用。该操作集与XDP引擎密切相关，包括xsk_frame_parse（对接收的数据包的元数据进行解析）和xsk_frame_init（初始化元数据）等。\n\n```c\nstatic const struct xdp_metadata_ops veth_xdp_metadata_ops = {\n\t.xmo_rx_timestamp\t\t= veth_xdp_rx_timestamp,\n\t.xmo_rx_hash\t\t\t= veth_xdp_rx_hash,\n};\n```\n\n- `xmo_rx_timestamp` ： 该函数指针指向 `veth_xdp_rx_timestamp` 函数，用于获取 XDP 包的接收时间戳，即处理 XDP 包的内核进程把包抓取的时间。该时间可以在 eBPF 程序中使用，例如可用于实现延迟测量(metric)，排除处理器竞争以及路由表测量等。\n\n- `xmo_rx_hash`：该函数指针指向 `veth_xdp_rx_hash`，用于获取 XDP 数据包的接收哈希值。通过接收哈希值，可以在 eBPF 中就各个数据包的接收位置和网络环境进行更好的控制和调节，以优化网络性能。例如在基于哈希的负载均衡中，可以使用哈希值来决定要将数据包路由到哪个接收 CPU 或内核上。\n\n在 Linux 中，这些函数指针被定义为可选项，也就是说并非每个驱动程序都会实现这两个函数指针。`xdp_metadata_ops` 使驱动程序与 eBPF程序 在处理特定的数据包和流量时更加灵活；但反过来说也需要配备一定的环境才能够实现这些调用的功能。\n\n到这里，veth 的创建和各项功能在 Linux 视角的样子就全部呈现了，总的来说 veth 本身是 Linux 中创建的 `net_device` 结构，通过注册所需的初始化和操作行为等特定函数以及对其进行相应的参数配置，最终实例化为 veth 对象，用于虚拟网络的构建。同时更明确了 veth 是工作在二层的数据结构，他传输数据会调用驱动程序实现的 `ndo_start_xmit`函数，在指定了对端之后，数据包发送会存入 skb 并插入 `softnet_data->input_pkt_queue`中，出发软中断，接下来就是对称一般的内核接收过程。\n\n---\n\n## 网桥的连接和传输\n\nveth 可以感性地认知为网卡，它给予了所划分出的 network namspace 一个出入的门，此前的结构如果将 veth 分别指向两个网络空间，就能够实现这二者的通信，但是当所划分的网络空间区域增加的时候，这样子点对点的连接方式显然就很难支撑了。\n\n这样就需要解决单节点大量容器之间的网络互连问题。\n\n参考实际物理网络的结构，Linux 实现并提供了一个完全由软件虚拟出来的交换机，它可以提供很多的虚拟端口，把许多的 veth 连接在一个平面的网络，通过自己的转发功能让虚拟机网卡之间可以通信，这个技术就叫做 bridge。\n\n如何使用 bridge 连接不同的网络空间呢？[Introduction to Linux interfaces for virtual networking | Red Hat Developer](https://developers.redhat.com/blog/2018/10/22/introduction-to-linux-interfaces-for-virtual-networking#team_device)，[Deep dive into Linux Networking and Docker - Bridge, vETH and IPTables - DEV Community](https://dev.to/arriqaaq/diving-into-linux-networking-and-docker-bridge-veth-and-iptables-419a)  等文章也有详尽阐述，不再复述。\n\n其中要关注的点是： bridge 的工作源码都是在 /net/core/dev.c 或者是 /net/bridge 目录下面，也就是说他是工作在二层上的设备（这一点与物理交换相同），但所给的实验来验证连通性是依靠 ping 指令从IP来看的，但这并不意味着 bridge 是依靠 IP  来做转发的。\n\n为了验证这一点，深入来看 bridge 的内核实现\n\n从外部网络到达节点时候，数据包会被网卡先送到 RingBuffer 中，然后依次经过硬中断、软中断处理，在软中断中再以此把包送到设备层（连接bridge）、协议栈，最后唤醒应用程序。\n\n从节点内的应用程序到达外部的时候，会从应用程序调用系统调用，在进入协议栈（传输层、网络层），再进入邻居子系统到网络设备子系统（bridge），之后调用驱动程序触发硬中断到网卡。\n\n在这个过程中，bridge 输入数据包处理工作流程在 `/net/bridge/br_input.c` 中 `br_handle_frame_finish`函数里\n\n```c\nint br_handle_frame_finish(struct net *net, struct sock *sk, struct sk_buff *skb)\n{\n    // 获取 veth 所连接的网桥端口以及 bridge 设备\n\tstruct net_bridge_port *p = br_port_get_rcu(skb->dev);\n    // 创建转发表对象\n\tstruct net_bridge_fdb_entry *dst = NULL;\n    \n\tstruct net_bridge_mcast_port *pmctx;\n\tstruct net_bridge_mdb_entry *mdst;\n\tstruct net_bridge_vlan *vlan;\n\tstruct net_bridge *br;\n\tbr = p->br;\n    \n    // 查找并更新转发表，这个转发表使用的地址是eth_hdr(skb)->h_source\n\tbr_fdb_update(br, p, eth_hdr(skb)->h_source,vid, BIT(BR_FDB_LOCKED));\t\n\tdst = br_fdb_find_rcu(br, eth_hdr(skb)->h_dest, vid);\n    \n    // 转发\n\tif (dst) {\n\t\tbr_forward(dst->dst, skb, local_rcv, false);\n    // 本机访问\n\tif (local_rcv)\n\t\treturn br_pass_frame_up(skb);\n}\n```\n\n其中查找和转发使用的地址是eth_hdr(skb)->h_dest，和物理环境当中的交换机会自动学习端口所对应的节点mac地址一样，软件模拟的 bridge 也会自学习 veth 与 eth_hdr 的对应关系。\n\n总的来说，当创建了 bridge 并把 veth 设备放入其中，网桥就能够为连接的网络空间提供一个平面的网络连接服务。\n\n其实到目前为止，所涉及的网络设备都工作在二层，对应到物理环境就是都使用的 MAC 地址进行寻址和交换信息，这样的网络服务就是 Linux  基本网络服务，能够实现单节点上的网络空间连通性。\n\n可只是这样是无法满足Kubernetes 集群的网络寻址和路由需求的，现有的网络追求平面式的连接服务但是底层依旧还是得通过IP进行寻址；回到容器网络当中，这也意味着希望在容器网络当中的实体能够拥有各自独立、唯一的IP地址，可以是容器、物理机或者是其他的网络设备（比如虚拟路由器）等，容器可以被添加到一个或多个网络中或从一个或多个网络中删除。这就是接下来 CNI 需要满足的功能之一。\n\n---\n\n\n\n## 再看 Namespace\n","slug":"EdgeMesh/cilium与edgemesh性能测试/2023-ospp-fighting/Kubernetes 容器网络 CNI — Linux 网络虚拟化","published":1,"updated":"2023-04-23T10:06:29.042Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgtm6jqx0026lyjxdcb236ve","content":"<h1 id=\"CNI-与-Pod-容器网络——-Linux-网络\"><a href=\"#CNI-与-Pod-容器网络——-Linux-网络\" class=\"headerlink\" title=\"CNI 与  Pod 容器网络—— Linux 网络\"></a>CNI 与  Pod 容器网络—— Linux 网络</h1><blockquote>\n<p>Pod 容器在 kubernetes 网络中是怎样获取他的地址的呢? </p>\n<p>如何保障 Pod IP 在整个集群当中的唯一性？</p>\n<p>容器流量如何在所给的IP之间相互转发？</p>\n</blockquote>\n<hr>\n<h2 id=\"从-namespace-开始\"><a href=\"#从-namespace-开始\" class=\"headerlink\" title=\"从 namespace 开始\"></a>从 namespace 开始</h2><p>namespace 技术是 Linux 内核提供的一项非常重要的功能，也是容器虚拟化的基础技术，通过构建系统资源的边界，形成一个相对封闭的资源区域，也就是大家认识的容器。Linux 提供的 namespace 包括以下几个方面：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Linux provides the following namespaces:</span><br><span class=\"line\"></span><br><span class=\"line\">Namespace   Constant          Isolates</span><br><span class=\"line\">Cgroup      CLONE_NEWCGROUP   Cgroup root directory</span><br><span class=\"line\">IPC         CLONE_NEWIPC      System V IPC, POSIX message queues</span><br><span class=\"line\">Network     CLONE_NEWNET      Network devices, stacks, ports, etc.</span><br><span class=\"line\">Mount       CLONE_NEWNS       Mount points</span><br><span class=\"line\">PID         CLONE_NEWPID      Process IDs</span><br><span class=\"line\">User        CLONE_NEWUSER     User and group IDs</span><br><span class=\"line\">UTS         CLONE_NEWUTS      Hostname and NIS domain name</span><br></pre></td></tr></table></figure>\n\n<p>其中网络名字空间(network namespace)是网络虚拟化技术的基础，也是本文最为关注的部分；现有的各项容器技术在实现他们各自的网络连接时所依赖的核心，所以要探究 Pod 网络和 CNI 就必须先从 network namespace 入手。</p>\n<p>在 Linux 系统当中，每一个 network  namespace  都有他自己的网络设置，包括（routing table）路由表、（network interface）网络设备、（IP address）IP 地址等等，这样隔离的一个典型好处就是在不同的network namespace 之下程序可以绑定到同一个端口并保持各自的网络约束不变。与其他的 namespace 一样, network namspace 也可以调用 clone() API创建一个通用的 namespace, 然后传入 CLONE_NEWNET 参数来创建 network namespace。不过就简单配置来说， 可以使用 <strong>netns</strong> 执行对 networkname space  的各项增删改查。</p>\n<p>依据 network namspace 划分出网络区域就像是创建网络通信的对端，但光有隔离出来的对象并不能构成网络；容器还要和外界进行网络联通才能提供服务。与实际网络场景不相同的是，没有物理实体的交换机和路由器，甚至可用的物理网卡也是受限的，那么如何能够在划分隔离出的区域之间提供通信呢？同时如何能够定位这些区域并让数据包能够正确地从一个 netns 中传输到另一个 netns呢？</p>\n<hr>\n<h2 id=\"veth-的创建和连接\"><a href=\"#veth-的创建和连接\" class=\"headerlink\" title=\"veth 的创建和连接\"></a>veth 的创建和连接</h2><p>首先要清楚 veth-pairs， veth 是虚拟以太网卡（virtual Ethernet）的缩写，veth 设备总是成对出现的，也因此称之为 veth-pair。可以通过<code> ip link add veth0 type veth peer name veth1</code> 等指令来创建管理这些虚拟网卡，eg ：<a href=\"https://morningspace.github.io/tech/k8s-net-docker0/\">从docker0开始</a> ，<a href=\"https://medium.com/techlog/diving-into-linux-networking-and-docker-bridge-veth-and-iptables-a05eb27b1e72\">Deep dive into Linux Networking and Docker | Medium</a> 等文章就有讲到其作用和类似操作，不再复述。</p>\n<p>但关键在于对于系统来说，veth到底是什么呢？是一个文件，进程还是描述符,他是否直接和物理网卡相关？它的工作原理是什么，是怎样来让容器之间相互通信的呢？接着来深入研究其内核当中的实现，具体参考：<a href=\"https://man7.org/linux/man-pages/man4/veth.4.html\">veth(4) - Linux manual page (man7.org)</a>，<a href=\"https://github.com/torvalds/linux/blob/master/drivers/net/veth.c\">linux/veth.c at master · torvalds/linux (github.com)</a></p>\n<p>veth的相关源码位于 <code>drivers/net/veth.c</code>中，其中的初始化入口是<code>veth_init</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> __init <span class=\"type\">int</span> <span class=\"title function_\">veth_init</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> rtnl_link_register(&amp;veth_link_ops);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>初始化函数注册了<code>veth_link_ops</code>(veth 设备的操作方法)，它包含了 veth 设备的创建启动和删除等回调函数，具体结构如下:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">rtnl_link_ops</span> <span class=\"title\">veth_link_ops</span> =</span> &#123;</span><br><span class=\"line\">\t.kind\t\t= DRV_NAME,</span><br><span class=\"line\">\t.priv_size\t= <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> veth_priv),</span><br><span class=\"line\">\t.setup\t\t= veth_setup,</span><br><span class=\"line\">\t.validate\t= veth_validate,</span><br><span class=\"line\">\t.newlink\t= veth_newlink,</span><br><span class=\"line\">\t.dellink\t= veth_dellink,</span><br><span class=\"line\">\t.policy\t\t= veth_policy,</span><br><span class=\"line\">\t.maxtype\t= VETH_INFO_MAX,</span><br><span class=\"line\">\t.get_link_net\t= veth_get_link_net,</span><br><span class=\"line\">\t.get_num_tx_queues\t= veth_get_num_queues,</span><br><span class=\"line\">\t.get_num_rx_queues\t= veth_get_num_queues,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>从 <code>kind</code> 到 <code>setup</code> 都是创建对应的数据结构并写入常量参数,所以创建的关键还是在 <code>veth_newlink</code>,<code>veth_dellink</code>，但二者的执行逻辑相关，所以只看其中一个。 </p>\n<p>首先是 <code>veth_newlink</code>, 不过他的实现较长，只能抓取一部分关键拆分开来看：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">veth_newlink</span><span class=\"params\">(<span class=\"keyword\">struct</span> net *src_net, <span class=\"keyword\">struct</span> net_device *dev,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t<span class=\"keyword\">struct</span> nlattr *tb[], <span class=\"keyword\">struct</span> nlattr *data[],</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t<span class=\"keyword\">struct</span> netlink_ext_ack *extack)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// 由于虚拟网络设备对是由两个网络设备组成,</span></span><br><span class=\"line\">    <span class=\"comment\">// dev 是虚拟网络设备对的其中一个网络设备，不可能创建单独的设备，那就需要创建一个临时的对端 peer</span></span><br><span class=\"line\">    <span class=\"comment\">// 因而调用 rtnl_create_link 函数创建对端网络设备的逻辑对象 peer </span></span><br><span class=\"line\">\tpeer = rtnl_create_link(net, ifname, name_assign_type,</span><br><span class=\"line\">\t\t\t\t&amp;veth_link_ops, tbp, extack);</span><br><span class=\"line\">\terr = register_netdevice(peer);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// 注册 dev 对象，本质上就在内存里面建立一个 struct 并将信息从文件映射过去</span></span><br><span class=\"line\">\terr = register_netdevice(dev);</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// 把 peer 和 dev 关联到一起</span></span><br><span class=\"line\">\tpriv = netdev_priv(dev);               <span class=\"comment\">// 获取 dev 的私有数据部分</span></span><br><span class=\"line\">\trcu_assign_pointer(priv-&gt;peer, peer);  <span class=\"comment\">// 将其 peer 字段指向 dev</span></span><br><span class=\"line\">\terr = veth_init_queues(dev, tb);</span><br><span class=\"line\">\tpriv = netdev_priv(peer);              <span class=\"comment\">// 获取 peer 的私有数据部分</span></span><br><span class=\"line\">\trcu_assign_pointer(priv-&gt;peer, dev);   <span class=\"comment\">// 将其 peer 字段指向 dev</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">\terr = veth_init_queues(peer, tb);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 添加 XDP 访问支持 --&gt; veth 在内核运行流程中接近网卡</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">\t<span class=\"comment\">/* update XDP supported features */</span></span><br><span class=\"line\">\tveth_set_xdp_features(dev);</span><br><span class=\"line\">\tveth_set_xdp_features(peer);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在<code>veth_newlink</code>当中通过**<code>register_netdevice</code>** 注册了两个网络虚拟设备： <code>peer</code> 和 <code>dev</code>，并通过让 <code>dev</code> 的 peer 指针指向创建的 peer，让<code>peer</code> 的 peer  指针指向 dev，来完成了 veth 设备的结对。这个过程是符合 veth 的工作逻辑的，由于  veth 总是成对出现，所以在生成新的 veth 时候就需要指定它所连接对端  peer，当然这个过程发生在内核运行当中，并不是有物理上的连接关系，直白来说就是依据文件信息写入到内存，开辟一个空间来存储对应的信息，然后修改指针指向来表示连接关系。</p>\n<p>创建完成之后，veth 又是怎么来传输数据的呢？回到之前的 <code>veth_setup</code>,启动 veth 的流程，也是将各类函数注册指定到 veth 对象当中</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">veth_setup</span><span class=\"params\">(<span class=\"keyword\">struct</span> net_device *dev)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tether_setup(dev);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">\tdev-&gt;netdev_ops = &amp;veth_netdev_ops;</span><br><span class=\"line\">\tdev-&gt;xdp_metadata_ops = &amp;veth_xdp_metadata_ops;</span><br><span class=\"line\">\tdev-&gt;ethtool_ops = &amp;veth_ethtool_ops;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到是 veth 对象的操作列表包含三类：<code>veth_netdev_ops</code>,<code>veth_xdp_metadata_ops</code>,<code>veth_ethtool_ops</code>, 具体的列表如下：</p>\n<p>net_device_ops 结构是网络设备的操作函数集结构, 包含了 Linux 网络设备对象的各项操作行为列表，也是  veth 对象调用实现功能的具体行为。</p>\n<p>从以下列表其实可以知道，Linux 设备是通用一个网卡的代码数据操作流程及对象的，以下的操作函数对于 ebpf xdp 程序直接操作有一定参考，是EdgeMesh 为来优化的对象，故进一步深入探究。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">net_device_ops</span> <span class=\"title\">veth_netdev_ops</span> =</span> &#123;</span><br><span class=\"line\">\t.ndo_init            = veth_dev_init,</span><br><span class=\"line\">\t.ndo_open            = veth_open,</span><br><span class=\"line\">\t.ndo_stop            = veth_close,</span><br><span class=\"line\">\t.ndo_start_xmit      = veth_xmit,</span><br><span class=\"line\">\t.ndo_get_stats64     = veth_get_stats64,</span><br><span class=\"line\">\t.ndo_set_rx_mode     = veth_set_multicast_list,</span><br><span class=\"line\">\t.ndo_set_mac_address = eth_mac_addr,</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> CONFIG_NET_POLL_CONTROLLER</span></span><br><span class=\"line\">\t.ndo_poll_controller\t= veth_poll_controller,</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">\t.ndo_get_iflink\t\t= veth_get_iflink,</span><br><span class=\"line\">\t.ndo_fix_features\t= veth_fix_features,</span><br><span class=\"line\">\t.ndo_set_features\t= veth_set_features,</span><br><span class=\"line\">\t.ndo_features_check\t= passthru_features_check,</span><br><span class=\"line\">\t.ndo_set_rx_headroom\t= veth_set_rx_headroom,</span><br><span class=\"line\">\t.ndo_bpf\t\t= veth_xdp,</span><br><span class=\"line\">\t.ndo_xdp_xmit\t\t= veth_ndo_xdp_xmit,</span><br><span class=\"line\">\t.ndo_get_peer_dev\t= veth_peer_dev,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这些函数的具体作用如下整理：</p>\n<ul>\n<li><p><code>ndo_init</code>: 该函数指向 <code>veth_dev_init</code>，网络设备初始化函数，由驱动程序实现，在网卡设备分配之后调用。</p>\n</li>\n<li><p><code>ndo_open</code>: 该函数指向 <code>veth_open</code>，被调用以打开虚拟网络设备并将其加入网络协议栈，由驱动程序实现，用于开启网络设备并为进程提供网络访问。</p>\n</li>\n<li><p><code>ndo_stop</code>：该函数指向 <code>veth_close</code>，由驱动程序实现，被调用以停止虚拟网络设备并将其从网络协议栈中移除。</p>\n</li>\n<li><p>==<code>ndo_start_xmit</code>：该函数指向 <code>veth_xmit</code>，由驱动程序实现，用于将给定的网络数据帧发送到指定的网络设备上。==</p>\n</li>\n<li><p><code>ndo_get_stats64</code>：该函数指向 <code>veth_get_stats64</code>，由驱动程序实现，用于获取虚拟网络设备当前的统计信息。</p>\n</li>\n<li><p><code>ndo_set_rx_mode</code>：该函数指向 <code>veth_set_multicast_list</code>，由驱动程序实现，用于设置网络设备接收模式。</p>\n</li>\n<li><p><code>ndo_set_mac_address</code>：该函数指向 <code>eth_mac_addr</code>，用于设置虚拟网络设备的MAC地址。</p>\n</li>\n<li><p><code>ndo_poll_controller</code>：该函数指向 <code>veth_poll_controller</code>，由驱动程序实现，veth调用之后触发软中断从 Ringbuffer 当中 poll 数据包</p>\n</li>\n<li><p><code>ndo_get_iflink</code>：该函数指向 <code>veth_get_iflink</code>，用于获取虚拟网络设备的网络接口索引号。</p>\n</li>\n<li><p><code>ndo_fix_features</code>：该函数指向 <code>veth_fix_features</code>，用于设置虚拟网络设备的特性参数；</p>\n</li>\n<li><p><code>ndo_set_features</code>：该函数指向 <code>veth_set_features</code>，用于修改或更新虚拟网络设备已经打开的特性参数。</p>\n</li>\n<li><p><code>ndo_features_check</code>：该函数指向 <code>passthru_features_check</code>，检查虚拟网络设备是否包含由 ETS（Enhanced Traffic Service）要求的特征。</p>\n</li>\n<li><p><code>ndo_set_rx_headroom</code>: 该函数指向 <code>veth_set_rx_headroom</code>，用于设置虚拟网络设备中下行数据帧包头部的大小。</p>\n</li>\n<li><p><code>ndo_bpf</code>：该函数指向 <code>veth_xdp</code>，用于添加eBPF扩展程序入口并进行初始化。</p>\n</li>\n<li><p><code>ndo_xdp_xmit</code>: 该函数指向 <code>veth_ndo_xdp_xmit</code>，驱动程序的XDP传输方法入口，将网络数据帧发送到用户提供的XDP扩展程序。</p>\n</li>\n<li><p><code>ndo_get_peer_dev</code>: 该函数指向 <code>veth_peer_dev</code>，用于获取与虚拟网络设备配对的网络设备。 </p>\n</li>\n</ul>\n<p><code>ethtool_ops</code>结构则代表了与<code>ethtool</code>工具相关的网络设备操作函数集合。<code>ethtool</code>用于获取和设置与<code>ethtool</code>兼容设备的驱动程序和硬件信息，同时实现均衡网速，流量控制等功能。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ethtool_ops</span> <span class=\"title\">veth_ethtool_ops</span> =</span> &#123;</span><br><span class=\"line\">\t.get_drvinfo\t\t= veth_get_drvinfo,</span><br><span class=\"line\">\t.get_link\t\t= ethtool_op_get_link,</span><br><span class=\"line\">\t.get_strings\t\t= veth_get_strings,</span><br><span class=\"line\">\t.get_sset_count\t\t= veth_get_sset_count,</span><br><span class=\"line\">\t.get_ethtool_stats\t= veth_get_ethtool_stats,</span><br><span class=\"line\">\t.get_link_ksettings\t= veth_get_link_ksettings,</span><br><span class=\"line\">\t.get_ts_info\t\t= ethtool_op_get_ts_info,</span><br><span class=\"line\">\t.get_channels\t\t= veth_get_channels,</span><br><span class=\"line\">\t.set_channels\t\t= veth_set_channels,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><code>xdp_metadata_ops</code>结构体定义了XDP（eBPF based packet processing）元数据的操作集合，在实现高性能网络数据包处理、过滤和转发的过程中起到重要作用。该操作集与XDP引擎密切相关，包括xsk_frame_parse（对接收的数据包的元数据进行解析）和xsk_frame_init（初始化元数据）等。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">xdp_metadata_ops</span> <span class=\"title\">veth_xdp_metadata_ops</span> =</span> &#123;</span><br><span class=\"line\">\t.xmo_rx_timestamp\t\t= veth_xdp_rx_timestamp,</span><br><span class=\"line\">\t.xmo_rx_hash\t\t\t= veth_xdp_rx_hash,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><code>xmo_rx_timestamp</code> ： 该函数指针指向 <code>veth_xdp_rx_timestamp</code> 函数，用于获取 XDP 包的接收时间戳，即处理 XDP 包的内核进程把包抓取的时间。该时间可以在 eBPF 程序中使用，例如可用于实现延迟测量(metric)，排除处理器竞争以及路由表测量等。</p>\n</li>\n<li><p><code>xmo_rx_hash</code>：该函数指针指向 <code>veth_xdp_rx_hash</code>，用于获取 XDP 数据包的接收哈希值。通过接收哈希值，可以在 eBPF 中就各个数据包的接收位置和网络环境进行更好的控制和调节，以优化网络性能。例如在基于哈希的负载均衡中，可以使用哈希值来决定要将数据包路由到哪个接收 CPU 或内核上。</p>\n</li>\n</ul>\n<p>在 Linux 中，这些函数指针被定义为可选项，也就是说并非每个驱动程序都会实现这两个函数指针。<code>xdp_metadata_ops</code> 使驱动程序与 eBPF程序 在处理特定的数据包和流量时更加灵活；但反过来说也需要配备一定的环境才能够实现这些调用的功能。</p>\n<p>到这里，veth 的创建和各项功能在 Linux 视角的样子就全部呈现了，总的来说 veth 本身是 Linux 中创建的 <code>net_device</code> 结构，通过注册所需的初始化和操作行为等特定函数以及对其进行相应的参数配置，最终实例化为 veth 对象，用于虚拟网络的构建。同时更明确了 veth 是工作在二层的数据结构，他传输数据会调用驱动程序实现的 <code>ndo_start_xmit</code>函数，在指定了对端之后，数据包发送会存入 skb 并插入 <code>softnet_data-&gt;input_pkt_queue</code>中，出发软中断，接下来就是对称一般的内核接收过程。</p>\n<hr>\n<h2 id=\"网桥的连接和传输\"><a href=\"#网桥的连接和传输\" class=\"headerlink\" title=\"网桥的连接和传输\"></a>网桥的连接和传输</h2><p>veth 可以感性地认知为网卡，它给予了所划分出的 network namspace 一个出入的门，此前的结构如果将 veth 分别指向两个网络空间，就能够实现这二者的通信，但是当所划分的网络空间区域增加的时候，这样子点对点的连接方式显然就很难支撑了。</p>\n<p>这样就需要解决单节点大量容器之间的网络互连问题。</p>\n<p>参考实际物理网络的结构，Linux 实现并提供了一个完全由软件虚拟出来的交换机，它可以提供很多的虚拟端口，把许多的 veth 连接在一个平面的网络，通过自己的转发功能让虚拟机网卡之间可以通信，这个技术就叫做 bridge。</p>\n<p>如何使用 bridge 连接不同的网络空间呢？<a href=\"https://developers.redhat.com/blog/2018/10/22/introduction-to-linux-interfaces-for-virtual-networking#team_device\">Introduction to Linux interfaces for virtual networking | Red Hat Developer</a>，<a href=\"https://dev.to/arriqaaq/diving-into-linux-networking-and-docker-bridge-veth-and-iptables-419a\">Deep dive into Linux Networking and Docker - Bridge, vETH and IPTables - DEV Community</a>  等文章也有详尽阐述，不再复述。</p>\n<p>其中要关注的点是： bridge 的工作源码都是在 /net/core/dev.c 或者是 /net/bridge 目录下面，也就是说他是工作在二层上的设备（这一点与物理交换相同），但所给的实验来验证连通性是依靠 ping 指令从IP来看的，但这并不意味着 bridge 是依靠 IP  来做转发的。</p>\n<p>为了验证这一点，深入来看 bridge 的内核实现</p>\n<p>从外部网络到达节点时候，数据包会被网卡先送到 RingBuffer 中，然后依次经过硬中断、软中断处理，在软中断中再以此把包送到设备层（连接bridge）、协议栈，最后唤醒应用程序。</p>\n<p>从节点内的应用程序到达外部的时候，会从应用程序调用系统调用，在进入协议栈（传输层、网络层），再进入邻居子系统到网络设备子系统（bridge），之后调用驱动程序触发硬中断到网卡。</p>\n<p>在这个过程中，bridge 输入数据包处理工作流程在 <code>/net/bridge/br_input.c</code> 中 <code>br_handle_frame_finish</code>函数里</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">br_handle_frame_finish</span><span class=\"params\">(<span class=\"keyword\">struct</span> net *net, <span class=\"keyword\">struct</span> sock *sk, <span class=\"keyword\">struct</span> sk_buff *skb)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取 veth 所连接的网桥端口以及 bridge 设备</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">net_bridge_port</span> *<span class=\"title\">p</span> =</span> br_port_get_rcu(skb-&gt;dev);</span><br><span class=\"line\">    <span class=\"comment\">// 创建转发表对象</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">net_bridge_fdb_entry</span> *<span class=\"title\">dst</span> =</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">net_bridge_mcast_port</span> *<span class=\"title\">pmctx</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">net_bridge_mdb_entry</span> *<span class=\"title\">mdst</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">net_bridge_vlan</span> *<span class=\"title\">vlan</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">net_bridge</span> *<span class=\"title\">br</span>;</span></span><br><span class=\"line\">\tbr = p-&gt;br;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 查找并更新转发表，这个转发表使用的地址是eth_hdr(skb)-&gt;h_source</span></span><br><span class=\"line\">\tbr_fdb_update(br, p, eth_hdr(skb)-&gt;h_source,vid, BIT(BR_FDB_LOCKED));\t</span><br><span class=\"line\">\tdst = br_fdb_find_rcu(br, eth_hdr(skb)-&gt;h_dest, vid);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 转发</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (dst) &#123;</span><br><span class=\"line\">\t\tbr_forward(dst-&gt;dst, skb, local_rcv, <span class=\"literal\">false</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 本机访问</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (local_rcv)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> br_pass_frame_up(skb);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中查找和转发使用的地址是eth_hdr(skb)-&gt;h_dest，和物理环境当中的交换机会自动学习端口所对应的节点mac地址一样，软件模拟的 bridge 也会自学习 veth 与 eth_hdr 的对应关系。</p>\n<p>总的来说，当创建了 bridge 并把 veth 设备放入其中，网桥就能够为连接的网络空间提供一个平面的网络连接服务。</p>\n<p>其实到目前为止，所涉及的网络设备都工作在二层，对应到物理环境就是都使用的 MAC 地址进行寻址和交换信息，这样的网络服务就是 Linux  基本网络服务，能够实现单节点上的网络空间连通性。</p>\n<p>可只是这样是无法满足Kubernetes 集群的网络寻址和路由需求的，现有的网络追求平面式的连接服务但是底层依旧还是得通过IP进行寻址；回到容器网络当中，这也意味着希望在容器网络当中的实体能够拥有各自独立、唯一的IP地址，可以是容器、物理机或者是其他的网络设备（比如虚拟路由器）等，容器可以被添加到一个或多个网络中或从一个或多个网络中删除。这就是接下来 CNI 需要满足的功能之一。</p>\n<hr>\n<h2 id=\"再看-Namespace\"><a href=\"#再看-Namespace\" class=\"headerlink\" title=\"再看 Namespace\"></a>再看 Namespace</h2>","site":{"data":{}},"cover":"/img/cover/2077_city.png","cover_type":"img","excerpt":"","more":"<h1 id=\"CNI-与-Pod-容器网络——-Linux-网络\"><a href=\"#CNI-与-Pod-容器网络——-Linux-网络\" class=\"headerlink\" title=\"CNI 与  Pod 容器网络—— Linux 网络\"></a>CNI 与  Pod 容器网络—— Linux 网络</h1><blockquote>\n<p>Pod 容器在 kubernetes 网络中是怎样获取他的地址的呢? </p>\n<p>如何保障 Pod IP 在整个集群当中的唯一性？</p>\n<p>容器流量如何在所给的IP之间相互转发？</p>\n</blockquote>\n<hr>\n<h2 id=\"从-namespace-开始\"><a href=\"#从-namespace-开始\" class=\"headerlink\" title=\"从 namespace 开始\"></a>从 namespace 开始</h2><p>namespace 技术是 Linux 内核提供的一项非常重要的功能，也是容器虚拟化的基础技术，通过构建系统资源的边界，形成一个相对封闭的资源区域，也就是大家认识的容器。Linux 提供的 namespace 包括以下几个方面：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Linux provides the following namespaces:</span><br><span class=\"line\"></span><br><span class=\"line\">Namespace   Constant          Isolates</span><br><span class=\"line\">Cgroup      CLONE_NEWCGROUP   Cgroup root directory</span><br><span class=\"line\">IPC         CLONE_NEWIPC      System V IPC, POSIX message queues</span><br><span class=\"line\">Network     CLONE_NEWNET      Network devices, stacks, ports, etc.</span><br><span class=\"line\">Mount       CLONE_NEWNS       Mount points</span><br><span class=\"line\">PID         CLONE_NEWPID      Process IDs</span><br><span class=\"line\">User        CLONE_NEWUSER     User and group IDs</span><br><span class=\"line\">UTS         CLONE_NEWUTS      Hostname and NIS domain name</span><br></pre></td></tr></table></figure>\n\n<p>其中网络名字空间(network namespace)是网络虚拟化技术的基础，也是本文最为关注的部分；现有的各项容器技术在实现他们各自的网络连接时所依赖的核心，所以要探究 Pod 网络和 CNI 就必须先从 network namespace 入手。</p>\n<p>在 Linux 系统当中，每一个 network  namespace  都有他自己的网络设置，包括（routing table）路由表、（network interface）网络设备、（IP address）IP 地址等等，这样隔离的一个典型好处就是在不同的network namespace 之下程序可以绑定到同一个端口并保持各自的网络约束不变。与其他的 namespace 一样, network namspace 也可以调用 clone() API创建一个通用的 namespace, 然后传入 CLONE_NEWNET 参数来创建 network namespace。不过就简单配置来说， 可以使用 <strong>netns</strong> 执行对 networkname space  的各项增删改查。</p>\n<p>依据 network namspace 划分出网络区域就像是创建网络通信的对端，但光有隔离出来的对象并不能构成网络；容器还要和外界进行网络联通才能提供服务。与实际网络场景不相同的是，没有物理实体的交换机和路由器，甚至可用的物理网卡也是受限的，那么如何能够在划分隔离出的区域之间提供通信呢？同时如何能够定位这些区域并让数据包能够正确地从一个 netns 中传输到另一个 netns呢？</p>\n<hr>\n<h2 id=\"veth-的创建和连接\"><a href=\"#veth-的创建和连接\" class=\"headerlink\" title=\"veth 的创建和连接\"></a>veth 的创建和连接</h2><p>首先要清楚 veth-pairs， veth 是虚拟以太网卡（virtual Ethernet）的缩写，veth 设备总是成对出现的，也因此称之为 veth-pair。可以通过<code> ip link add veth0 type veth peer name veth1</code> 等指令来创建管理这些虚拟网卡，eg ：<a href=\"https://morningspace.github.io/tech/k8s-net-docker0/\">从docker0开始</a> ，<a href=\"https://medium.com/techlog/diving-into-linux-networking-and-docker-bridge-veth-and-iptables-a05eb27b1e72\">Deep dive into Linux Networking and Docker | Medium</a> 等文章就有讲到其作用和类似操作，不再复述。</p>\n<p>但关键在于对于系统来说，veth到底是什么呢？是一个文件，进程还是描述符,他是否直接和物理网卡相关？它的工作原理是什么，是怎样来让容器之间相互通信的呢？接着来深入研究其内核当中的实现，具体参考：<a href=\"https://man7.org/linux/man-pages/man4/veth.4.html\">veth(4) - Linux manual page (man7.org)</a>，<a href=\"https://github.com/torvalds/linux/blob/master/drivers/net/veth.c\">linux/veth.c at master · torvalds/linux (github.com)</a></p>\n<p>veth的相关源码位于 <code>drivers/net/veth.c</code>中，其中的初始化入口是<code>veth_init</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> __init <span class=\"type\">int</span> <span class=\"title function_\">veth_init</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> rtnl_link_register(&amp;veth_link_ops);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>初始化函数注册了<code>veth_link_ops</code>(veth 设备的操作方法)，它包含了 veth 设备的创建启动和删除等回调函数，具体结构如下:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">rtnl_link_ops</span> <span class=\"title\">veth_link_ops</span> =</span> &#123;</span><br><span class=\"line\">\t.kind\t\t= DRV_NAME,</span><br><span class=\"line\">\t.priv_size\t= <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> veth_priv),</span><br><span class=\"line\">\t.setup\t\t= veth_setup,</span><br><span class=\"line\">\t.validate\t= veth_validate,</span><br><span class=\"line\">\t.newlink\t= veth_newlink,</span><br><span class=\"line\">\t.dellink\t= veth_dellink,</span><br><span class=\"line\">\t.policy\t\t= veth_policy,</span><br><span class=\"line\">\t.maxtype\t= VETH_INFO_MAX,</span><br><span class=\"line\">\t.get_link_net\t= veth_get_link_net,</span><br><span class=\"line\">\t.get_num_tx_queues\t= veth_get_num_queues,</span><br><span class=\"line\">\t.get_num_rx_queues\t= veth_get_num_queues,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>从 <code>kind</code> 到 <code>setup</code> 都是创建对应的数据结构并写入常量参数,所以创建的关键还是在 <code>veth_newlink</code>,<code>veth_dellink</code>，但二者的执行逻辑相关，所以只看其中一个。 </p>\n<p>首先是 <code>veth_newlink</code>, 不过他的实现较长，只能抓取一部分关键拆分开来看：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">veth_newlink</span><span class=\"params\">(<span class=\"keyword\">struct</span> net *src_net, <span class=\"keyword\">struct</span> net_device *dev,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t<span class=\"keyword\">struct</span> nlattr *tb[], <span class=\"keyword\">struct</span> nlattr *data[],</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t<span class=\"keyword\">struct</span> netlink_ext_ack *extack)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// 由于虚拟网络设备对是由两个网络设备组成,</span></span><br><span class=\"line\">    <span class=\"comment\">// dev 是虚拟网络设备对的其中一个网络设备，不可能创建单独的设备，那就需要创建一个临时的对端 peer</span></span><br><span class=\"line\">    <span class=\"comment\">// 因而调用 rtnl_create_link 函数创建对端网络设备的逻辑对象 peer </span></span><br><span class=\"line\">\tpeer = rtnl_create_link(net, ifname, name_assign_type,</span><br><span class=\"line\">\t\t\t\t&amp;veth_link_ops, tbp, extack);</span><br><span class=\"line\">\terr = register_netdevice(peer);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// 注册 dev 对象，本质上就在内存里面建立一个 struct 并将信息从文件映射过去</span></span><br><span class=\"line\">\terr = register_netdevice(dev);</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// 把 peer 和 dev 关联到一起</span></span><br><span class=\"line\">\tpriv = netdev_priv(dev);               <span class=\"comment\">// 获取 dev 的私有数据部分</span></span><br><span class=\"line\">\trcu_assign_pointer(priv-&gt;peer, peer);  <span class=\"comment\">// 将其 peer 字段指向 dev</span></span><br><span class=\"line\">\terr = veth_init_queues(dev, tb);</span><br><span class=\"line\">\tpriv = netdev_priv(peer);              <span class=\"comment\">// 获取 peer 的私有数据部分</span></span><br><span class=\"line\">\trcu_assign_pointer(priv-&gt;peer, dev);   <span class=\"comment\">// 将其 peer 字段指向 dev</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">\terr = veth_init_queues(peer, tb);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 添加 XDP 访问支持 --&gt; veth 在内核运行流程中接近网卡</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">\t<span class=\"comment\">/* update XDP supported features */</span></span><br><span class=\"line\">\tveth_set_xdp_features(dev);</span><br><span class=\"line\">\tveth_set_xdp_features(peer);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在<code>veth_newlink</code>当中通过**<code>register_netdevice</code>** 注册了两个网络虚拟设备： <code>peer</code> 和 <code>dev</code>，并通过让 <code>dev</code> 的 peer 指针指向创建的 peer，让<code>peer</code> 的 peer  指针指向 dev，来完成了 veth 设备的结对。这个过程是符合 veth 的工作逻辑的，由于  veth 总是成对出现，所以在生成新的 veth 时候就需要指定它所连接对端  peer，当然这个过程发生在内核运行当中，并不是有物理上的连接关系，直白来说就是依据文件信息写入到内存，开辟一个空间来存储对应的信息，然后修改指针指向来表示连接关系。</p>\n<p>创建完成之后，veth 又是怎么来传输数据的呢？回到之前的 <code>veth_setup</code>,启动 veth 的流程，也是将各类函数注册指定到 veth 对象当中</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title function_\">veth_setup</span><span class=\"params\">(<span class=\"keyword\">struct</span> net_device *dev)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tether_setup(dev);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">\tdev-&gt;netdev_ops = &amp;veth_netdev_ops;</span><br><span class=\"line\">\tdev-&gt;xdp_metadata_ops = &amp;veth_xdp_metadata_ops;</span><br><span class=\"line\">\tdev-&gt;ethtool_ops = &amp;veth_ethtool_ops;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到是 veth 对象的操作列表包含三类：<code>veth_netdev_ops</code>,<code>veth_xdp_metadata_ops</code>,<code>veth_ethtool_ops</code>, 具体的列表如下：</p>\n<p>net_device_ops 结构是网络设备的操作函数集结构, 包含了 Linux 网络设备对象的各项操作行为列表，也是  veth 对象调用实现功能的具体行为。</p>\n<p>从以下列表其实可以知道，Linux 设备是通用一个网卡的代码数据操作流程及对象的，以下的操作函数对于 ebpf xdp 程序直接操作有一定参考，是EdgeMesh 为来优化的对象，故进一步深入探究。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">net_device_ops</span> <span class=\"title\">veth_netdev_ops</span> =</span> &#123;</span><br><span class=\"line\">\t.ndo_init            = veth_dev_init,</span><br><span class=\"line\">\t.ndo_open            = veth_open,</span><br><span class=\"line\">\t.ndo_stop            = veth_close,</span><br><span class=\"line\">\t.ndo_start_xmit      = veth_xmit,</span><br><span class=\"line\">\t.ndo_get_stats64     = veth_get_stats64,</span><br><span class=\"line\">\t.ndo_set_rx_mode     = veth_set_multicast_list,</span><br><span class=\"line\">\t.ndo_set_mac_address = eth_mac_addr,</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> CONFIG_NET_POLL_CONTROLLER</span></span><br><span class=\"line\">\t.ndo_poll_controller\t= veth_poll_controller,</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">\t.ndo_get_iflink\t\t= veth_get_iflink,</span><br><span class=\"line\">\t.ndo_fix_features\t= veth_fix_features,</span><br><span class=\"line\">\t.ndo_set_features\t= veth_set_features,</span><br><span class=\"line\">\t.ndo_features_check\t= passthru_features_check,</span><br><span class=\"line\">\t.ndo_set_rx_headroom\t= veth_set_rx_headroom,</span><br><span class=\"line\">\t.ndo_bpf\t\t= veth_xdp,</span><br><span class=\"line\">\t.ndo_xdp_xmit\t\t= veth_ndo_xdp_xmit,</span><br><span class=\"line\">\t.ndo_get_peer_dev\t= veth_peer_dev,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这些函数的具体作用如下整理：</p>\n<ul>\n<li><p><code>ndo_init</code>: 该函数指向 <code>veth_dev_init</code>，网络设备初始化函数，由驱动程序实现，在网卡设备分配之后调用。</p>\n</li>\n<li><p><code>ndo_open</code>: 该函数指向 <code>veth_open</code>，被调用以打开虚拟网络设备并将其加入网络协议栈，由驱动程序实现，用于开启网络设备并为进程提供网络访问。</p>\n</li>\n<li><p><code>ndo_stop</code>：该函数指向 <code>veth_close</code>，由驱动程序实现，被调用以停止虚拟网络设备并将其从网络协议栈中移除。</p>\n</li>\n<li><p>==<code>ndo_start_xmit</code>：该函数指向 <code>veth_xmit</code>，由驱动程序实现，用于将给定的网络数据帧发送到指定的网络设备上。==</p>\n</li>\n<li><p><code>ndo_get_stats64</code>：该函数指向 <code>veth_get_stats64</code>，由驱动程序实现，用于获取虚拟网络设备当前的统计信息。</p>\n</li>\n<li><p><code>ndo_set_rx_mode</code>：该函数指向 <code>veth_set_multicast_list</code>，由驱动程序实现，用于设置网络设备接收模式。</p>\n</li>\n<li><p><code>ndo_set_mac_address</code>：该函数指向 <code>eth_mac_addr</code>，用于设置虚拟网络设备的MAC地址。</p>\n</li>\n<li><p><code>ndo_poll_controller</code>：该函数指向 <code>veth_poll_controller</code>，由驱动程序实现，veth调用之后触发软中断从 Ringbuffer 当中 poll 数据包</p>\n</li>\n<li><p><code>ndo_get_iflink</code>：该函数指向 <code>veth_get_iflink</code>，用于获取虚拟网络设备的网络接口索引号。</p>\n</li>\n<li><p><code>ndo_fix_features</code>：该函数指向 <code>veth_fix_features</code>，用于设置虚拟网络设备的特性参数；</p>\n</li>\n<li><p><code>ndo_set_features</code>：该函数指向 <code>veth_set_features</code>，用于修改或更新虚拟网络设备已经打开的特性参数。</p>\n</li>\n<li><p><code>ndo_features_check</code>：该函数指向 <code>passthru_features_check</code>，检查虚拟网络设备是否包含由 ETS（Enhanced Traffic Service）要求的特征。</p>\n</li>\n<li><p><code>ndo_set_rx_headroom</code>: 该函数指向 <code>veth_set_rx_headroom</code>，用于设置虚拟网络设备中下行数据帧包头部的大小。</p>\n</li>\n<li><p><code>ndo_bpf</code>：该函数指向 <code>veth_xdp</code>，用于添加eBPF扩展程序入口并进行初始化。</p>\n</li>\n<li><p><code>ndo_xdp_xmit</code>: 该函数指向 <code>veth_ndo_xdp_xmit</code>，驱动程序的XDP传输方法入口，将网络数据帧发送到用户提供的XDP扩展程序。</p>\n</li>\n<li><p><code>ndo_get_peer_dev</code>: 该函数指向 <code>veth_peer_dev</code>，用于获取与虚拟网络设备配对的网络设备。 </p>\n</li>\n</ul>\n<p><code>ethtool_ops</code>结构则代表了与<code>ethtool</code>工具相关的网络设备操作函数集合。<code>ethtool</code>用于获取和设置与<code>ethtool</code>兼容设备的驱动程序和硬件信息，同时实现均衡网速，流量控制等功能。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ethtool_ops</span> <span class=\"title\">veth_ethtool_ops</span> =</span> &#123;</span><br><span class=\"line\">\t.get_drvinfo\t\t= veth_get_drvinfo,</span><br><span class=\"line\">\t.get_link\t\t= ethtool_op_get_link,</span><br><span class=\"line\">\t.get_strings\t\t= veth_get_strings,</span><br><span class=\"line\">\t.get_sset_count\t\t= veth_get_sset_count,</span><br><span class=\"line\">\t.get_ethtool_stats\t= veth_get_ethtool_stats,</span><br><span class=\"line\">\t.get_link_ksettings\t= veth_get_link_ksettings,</span><br><span class=\"line\">\t.get_ts_info\t\t= ethtool_op_get_ts_info,</span><br><span class=\"line\">\t.get_channels\t\t= veth_get_channels,</span><br><span class=\"line\">\t.set_channels\t\t= veth_set_channels,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><code>xdp_metadata_ops</code>结构体定义了XDP（eBPF based packet processing）元数据的操作集合，在实现高性能网络数据包处理、过滤和转发的过程中起到重要作用。该操作集与XDP引擎密切相关，包括xsk_frame_parse（对接收的数据包的元数据进行解析）和xsk_frame_init（初始化元数据）等。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">xdp_metadata_ops</span> <span class=\"title\">veth_xdp_metadata_ops</span> =</span> &#123;</span><br><span class=\"line\">\t.xmo_rx_timestamp\t\t= veth_xdp_rx_timestamp,</span><br><span class=\"line\">\t.xmo_rx_hash\t\t\t= veth_xdp_rx_hash,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><code>xmo_rx_timestamp</code> ： 该函数指针指向 <code>veth_xdp_rx_timestamp</code> 函数，用于获取 XDP 包的接收时间戳，即处理 XDP 包的内核进程把包抓取的时间。该时间可以在 eBPF 程序中使用，例如可用于实现延迟测量(metric)，排除处理器竞争以及路由表测量等。</p>\n</li>\n<li><p><code>xmo_rx_hash</code>：该函数指针指向 <code>veth_xdp_rx_hash</code>，用于获取 XDP 数据包的接收哈希值。通过接收哈希值，可以在 eBPF 中就各个数据包的接收位置和网络环境进行更好的控制和调节，以优化网络性能。例如在基于哈希的负载均衡中，可以使用哈希值来决定要将数据包路由到哪个接收 CPU 或内核上。</p>\n</li>\n</ul>\n<p>在 Linux 中，这些函数指针被定义为可选项，也就是说并非每个驱动程序都会实现这两个函数指针。<code>xdp_metadata_ops</code> 使驱动程序与 eBPF程序 在处理特定的数据包和流量时更加灵活；但反过来说也需要配备一定的环境才能够实现这些调用的功能。</p>\n<p>到这里，veth 的创建和各项功能在 Linux 视角的样子就全部呈现了，总的来说 veth 本身是 Linux 中创建的 <code>net_device</code> 结构，通过注册所需的初始化和操作行为等特定函数以及对其进行相应的参数配置，最终实例化为 veth 对象，用于虚拟网络的构建。同时更明确了 veth 是工作在二层的数据结构，他传输数据会调用驱动程序实现的 <code>ndo_start_xmit</code>函数，在指定了对端之后，数据包发送会存入 skb 并插入 <code>softnet_data-&gt;input_pkt_queue</code>中，出发软中断，接下来就是对称一般的内核接收过程。</p>\n<hr>\n<h2 id=\"网桥的连接和传输\"><a href=\"#网桥的连接和传输\" class=\"headerlink\" title=\"网桥的连接和传输\"></a>网桥的连接和传输</h2><p>veth 可以感性地认知为网卡，它给予了所划分出的 network namspace 一个出入的门，此前的结构如果将 veth 分别指向两个网络空间，就能够实现这二者的通信，但是当所划分的网络空间区域增加的时候，这样子点对点的连接方式显然就很难支撑了。</p>\n<p>这样就需要解决单节点大量容器之间的网络互连问题。</p>\n<p>参考实际物理网络的结构，Linux 实现并提供了一个完全由软件虚拟出来的交换机，它可以提供很多的虚拟端口，把许多的 veth 连接在一个平面的网络，通过自己的转发功能让虚拟机网卡之间可以通信，这个技术就叫做 bridge。</p>\n<p>如何使用 bridge 连接不同的网络空间呢？<a href=\"https://developers.redhat.com/blog/2018/10/22/introduction-to-linux-interfaces-for-virtual-networking#team_device\">Introduction to Linux interfaces for virtual networking | Red Hat Developer</a>，<a href=\"https://dev.to/arriqaaq/diving-into-linux-networking-and-docker-bridge-veth-and-iptables-419a\">Deep dive into Linux Networking and Docker - Bridge, vETH and IPTables - DEV Community</a>  等文章也有详尽阐述，不再复述。</p>\n<p>其中要关注的点是： bridge 的工作源码都是在 /net/core/dev.c 或者是 /net/bridge 目录下面，也就是说他是工作在二层上的设备（这一点与物理交换相同），但所给的实验来验证连通性是依靠 ping 指令从IP来看的，但这并不意味着 bridge 是依靠 IP  来做转发的。</p>\n<p>为了验证这一点，深入来看 bridge 的内核实现</p>\n<p>从外部网络到达节点时候，数据包会被网卡先送到 RingBuffer 中，然后依次经过硬中断、软中断处理，在软中断中再以此把包送到设备层（连接bridge）、协议栈，最后唤醒应用程序。</p>\n<p>从节点内的应用程序到达外部的时候，会从应用程序调用系统调用，在进入协议栈（传输层、网络层），再进入邻居子系统到网络设备子系统（bridge），之后调用驱动程序触发硬中断到网卡。</p>\n<p>在这个过程中，bridge 输入数据包处理工作流程在 <code>/net/bridge/br_input.c</code> 中 <code>br_handle_frame_finish</code>函数里</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">br_handle_frame_finish</span><span class=\"params\">(<span class=\"keyword\">struct</span> net *net, <span class=\"keyword\">struct</span> sock *sk, <span class=\"keyword\">struct</span> sk_buff *skb)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取 veth 所连接的网桥端口以及 bridge 设备</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">net_bridge_port</span> *<span class=\"title\">p</span> =</span> br_port_get_rcu(skb-&gt;dev);</span><br><span class=\"line\">    <span class=\"comment\">// 创建转发表对象</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">net_bridge_fdb_entry</span> *<span class=\"title\">dst</span> =</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">net_bridge_mcast_port</span> *<span class=\"title\">pmctx</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">net_bridge_mdb_entry</span> *<span class=\"title\">mdst</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">net_bridge_vlan</span> *<span class=\"title\">vlan</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">net_bridge</span> *<span class=\"title\">br</span>;</span></span><br><span class=\"line\">\tbr = p-&gt;br;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 查找并更新转发表，这个转发表使用的地址是eth_hdr(skb)-&gt;h_source</span></span><br><span class=\"line\">\tbr_fdb_update(br, p, eth_hdr(skb)-&gt;h_source,vid, BIT(BR_FDB_LOCKED));\t</span><br><span class=\"line\">\tdst = br_fdb_find_rcu(br, eth_hdr(skb)-&gt;h_dest, vid);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 转发</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (dst) &#123;</span><br><span class=\"line\">\t\tbr_forward(dst-&gt;dst, skb, local_rcv, <span class=\"literal\">false</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 本机访问</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (local_rcv)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> br_pass_frame_up(skb);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中查找和转发使用的地址是eth_hdr(skb)-&gt;h_dest，和物理环境当中的交换机会自动学习端口所对应的节点mac地址一样，软件模拟的 bridge 也会自学习 veth 与 eth_hdr 的对应关系。</p>\n<p>总的来说，当创建了 bridge 并把 veth 设备放入其中，网桥就能够为连接的网络空间提供一个平面的网络连接服务。</p>\n<p>其实到目前为止，所涉及的网络设备都工作在二层，对应到物理环境就是都使用的 MAC 地址进行寻址和交换信息，这样的网络服务就是 Linux  基本网络服务，能够实现单节点上的网络空间连通性。</p>\n<p>可只是这样是无法满足Kubernetes 集群的网络寻址和路由需求的，现有的网络追求平面式的连接服务但是底层依旧还是得通过IP进行寻址；回到容器网络当中，这也意味着希望在容器网络当中的实体能够拥有各自独立、唯一的IP地址，可以是容器、物理机或者是其他的网络设备（比如虚拟路由器）等，容器可以被添加到一个或多个网络中或从一个或多个网络中删除。这就是接下来 CNI 需要满足的功能之一。</p>\n<hr>\n<h2 id=\"再看-Namespace\"><a href=\"#再看-Namespace\" class=\"headerlink\" title=\"再看 Namespace\"></a>再看 Namespace</h2>"},{"title":"2023 ospp fighting","catalog":true,"date":"2023-04-18T21:02:23.000Z","subtitle":null,"header-img":null,"published":0,"_content":"","source":"_posts/EdgeMesh/cilium与edgemesh性能测试/2023-ospp-fighting/Kubernetes 容器网络 CNI — Pod 容器网络.md","raw":"---\ntitle: 2023 ospp fighting\ncatalog: true\ndate: 2023-04-19 05:02:23\nsubtitle:\nheader-img:\ntags: ospp, edgemesh，Pod\ncategories: Pod, Linux\npublished: false\n---","slug":"EdgeMesh/cilium与edgemesh性能测试/2023-ospp-fighting/Kubernetes 容器网络 CNI — Pod 容器网络","updated":"2023-04-22T14:58:05.391Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgtm6jqy0028lyjxc7f76lhe","content":"","site":{"data":{}},"cover":"/img/cover/elderring.png","cover_type":"img","excerpt":"","more":""},{"title":"2023 ospp fighting","catalog":true,"date":"2023-04-18T21:02:23.000Z","subtitle":null,"header-img":null,"_content":"\n# CNI Plugins 调研\n\n## 1. 通用 CNI 插件\n\n> 主要基于 [containernetworking/plugins: Some reference and example networking plugins, maintained by the CNI team. (github.com)](https://github.com/containernetworking/plugins) ，[CNI](https://www.cni.dev/plugins/current/)\n\n由CNI 官方社区维护的 CNI plugins 主要分为三类：\n\n* `Main: interface-creating`: 主进程 CNI ,直接与 Linux 交流，创建接口、网络空间、对象等\n* `IPAM: IP address allocation`:  地址管理插件，主要负责 IP 地址管理和分配\n* `Meta: other plugins`: 其他的功能插件\n\n\n\n### Main: interface-creating  主进程 CNI \n\n### [`bridge`](https://www.cni.dev/plugins/current/main/bridge/) \n\n​\t创建虚拟网桥，并把本机（host）和容器（更准确说是network namespace）添加到其中\n\n### [`macvlan`](https://www.cni.dev/plugins/current/main/macvlan/)\n\n​\t创建一个新的 MAC 地址，将相关容器的所有流量都转发到该地址\n\n### [`ipvlan`](https://www.cni.dev/plugins/current/main/ipvlan/) \n\n​\t类似于 `macvlan`创建虚拟局域网连接，给容器增加 [ipvlan ](https://www.kernel.org/doc/Documentation/networking/ipvlan.txt)接口，他主要有两种模式：\n\n- L2 模式： 这个模式创建的容器网络与本机共享同一个 L2 设备，也就是说本机的广播数据包能够到达容器网络\n- L3 模式：\n\n这个模式创建对象的例子\n\n``` c\n  +=============================================================+\n  |  Host: host1                                                |\n  |                                                             |\n  |   +----------------------+      +----------------------+    |\n  |   |   NS:ns0             |      |  NS:ns1              |    |\n  |   |                      |      |                      |    |\n  |   |                      |      |                      |    |\n  |   |        ipvl0         |      |         ipvl1        |    |\n  |   +----------#-----------+      +-----------#----------+    |\n  |              #                              #               |\n  |              ################################               |\n  |                              # eth0                         |\n  +==============================#==============================+\n（a） 创建两个网络命名空间 - ns0、ns1\n\t\tIP 网络添加 NS0\n\t\tIP 网络添加 NS1\n\n（b） 在 eth0（主设备）上创建两个 ipvlan 从站。\n\t\tIP 链路添加链路 eth0 IPvl0 类型 IPvlan 模式 L2\n\t\tIP 链路添加链路 eth0 IPvl1 类型 IPvlan 模式 L2\n\n（c） 将从属服务器分配到相应的网络命名空间\n\t\tIP link set dev ipvl0 netns ns0\n\t\tIP link set dev ipvl1 netns ns1\n\n（d） 现在切换到命名空间（ns0 或 ns1）以配置从属设备\n\t\t- 对于 ns0\n\t\t\t（1） IP netns exec ns0 bash\n\t\t\t（2） IP 链路设置开发 IPvl0 向上\n\t\t\t（3） IP 链路设置开发\n\t\t\t（4） IP -4 地址添加 127.0.0.1 开发 LO\n\t\t\t（5） IP -4 地址添加 $IPADDR 开发 IPvl0\n\t\t\t（6） IP -4 路由通过$ROUTER开发 IPvl0 添加默认值\n\t\t- 对于 ns1\n\t\t\t（1） IP Netns exec NS1 Bash\n\t\t\t（2） IP 链路设置开发 IPvl1 向上\n\t\t\t（3） IP 链路设置开发\n\t\t\t（4） IP -4 地址添加 127.0.0.1 开发 LO\n\t\t\t（5） IP -4 地址添加 $IPADDR 开发 IPvl1\n\t\t\t（6） IP -4 路由通过$ROUTER开发 IPvl1 添加默认值\n```\n\n\n\n- [`ptp`](https://www.cni.dev/plugins/current/main/ptp/) : Creates a veth pair\n- [`host-device`](https://www.cni.dev/plugins/current/main/host-device/) : Moves an already-existing device into a container\n- [`vlan`](https://www.cni.dev/plugins/current/main/vlan/) : Creates a vlan interface off a master\n\n#### Windows: windows specific \n\n- [`win-bridge`](https://www.cni.dev/plugins/current/main/win-bridge/) : Creates a bridge, adds the host and the container to it\n- [`win-overlay`](https://www.cni.dev/plugins/current/main/win-overlay/) : Creates an overlay interface to the container","source":"_posts/EdgeMesh/cilium与edgemesh性能测试/2023-ospp-fighting/Kubernetes 容器网络 CNI — 现有 CNI 方案的调研 .md","raw":"---\ntitle: 2023 ospp fighting\ncatalog: true\ndate: 2023-04-19 05:02:23\nsubtitle:\nheader-img:\ntags: ospp, edgemesh\ncategories: CNI Plugins\n---\n\n# CNI Plugins 调研\n\n## 1. 通用 CNI 插件\n\n> 主要基于 [containernetworking/plugins: Some reference and example networking plugins, maintained by the CNI team. (github.com)](https://github.com/containernetworking/plugins) ，[CNI](https://www.cni.dev/plugins/current/)\n\n由CNI 官方社区维护的 CNI plugins 主要分为三类：\n\n* `Main: interface-creating`: 主进程 CNI ,直接与 Linux 交流，创建接口、网络空间、对象等\n* `IPAM: IP address allocation`:  地址管理插件，主要负责 IP 地址管理和分配\n* `Meta: other plugins`: 其他的功能插件\n\n\n\n### Main: interface-creating  主进程 CNI \n\n### [`bridge`](https://www.cni.dev/plugins/current/main/bridge/) \n\n​\t创建虚拟网桥，并把本机（host）和容器（更准确说是network namespace）添加到其中\n\n### [`macvlan`](https://www.cni.dev/plugins/current/main/macvlan/)\n\n​\t创建一个新的 MAC 地址，将相关容器的所有流量都转发到该地址\n\n### [`ipvlan`](https://www.cni.dev/plugins/current/main/ipvlan/) \n\n​\t类似于 `macvlan`创建虚拟局域网连接，给容器增加 [ipvlan ](https://www.kernel.org/doc/Documentation/networking/ipvlan.txt)接口，他主要有两种模式：\n\n- L2 模式： 这个模式创建的容器网络与本机共享同一个 L2 设备，也就是说本机的广播数据包能够到达容器网络\n- L3 模式：\n\n这个模式创建对象的例子\n\n``` c\n  +=============================================================+\n  |  Host: host1                                                |\n  |                                                             |\n  |   +----------------------+      +----------------------+    |\n  |   |   NS:ns0             |      |  NS:ns1              |    |\n  |   |                      |      |                      |    |\n  |   |                      |      |                      |    |\n  |   |        ipvl0         |      |         ipvl1        |    |\n  |   +----------#-----------+      +-----------#----------+    |\n  |              #                              #               |\n  |              ################################               |\n  |                              # eth0                         |\n  +==============================#==============================+\n（a） 创建两个网络命名空间 - ns0、ns1\n\t\tIP 网络添加 NS0\n\t\tIP 网络添加 NS1\n\n（b） 在 eth0（主设备）上创建两个 ipvlan 从站。\n\t\tIP 链路添加链路 eth0 IPvl0 类型 IPvlan 模式 L2\n\t\tIP 链路添加链路 eth0 IPvl1 类型 IPvlan 模式 L2\n\n（c） 将从属服务器分配到相应的网络命名空间\n\t\tIP link set dev ipvl0 netns ns0\n\t\tIP link set dev ipvl1 netns ns1\n\n（d） 现在切换到命名空间（ns0 或 ns1）以配置从属设备\n\t\t- 对于 ns0\n\t\t\t（1） IP netns exec ns0 bash\n\t\t\t（2） IP 链路设置开发 IPvl0 向上\n\t\t\t（3） IP 链路设置开发\n\t\t\t（4） IP -4 地址添加 127.0.0.1 开发 LO\n\t\t\t（5） IP -4 地址添加 $IPADDR 开发 IPvl0\n\t\t\t（6） IP -4 路由通过$ROUTER开发 IPvl0 添加默认值\n\t\t- 对于 ns1\n\t\t\t（1） IP Netns exec NS1 Bash\n\t\t\t（2） IP 链路设置开发 IPvl1 向上\n\t\t\t（3） IP 链路设置开发\n\t\t\t（4） IP -4 地址添加 127.0.0.1 开发 LO\n\t\t\t（5） IP -4 地址添加 $IPADDR 开发 IPvl1\n\t\t\t（6） IP -4 路由通过$ROUTER开发 IPvl1 添加默认值\n```\n\n\n\n- [`ptp`](https://www.cni.dev/plugins/current/main/ptp/) : Creates a veth pair\n- [`host-device`](https://www.cni.dev/plugins/current/main/host-device/) : Moves an already-existing device into a container\n- [`vlan`](https://www.cni.dev/plugins/current/main/vlan/) : Creates a vlan interface off a master\n\n#### Windows: windows specific \n\n- [`win-bridge`](https://www.cni.dev/plugins/current/main/win-bridge/) : Creates a bridge, adds the host and the container to it\n- [`win-overlay`](https://www.cni.dev/plugins/current/main/win-overlay/) : Creates an overlay interface to the container","slug":"EdgeMesh/cilium与edgemesh性能测试/2023-ospp-fighting/Kubernetes 容器网络 CNI — 现有 CNI 方案的调研 ","published":1,"updated":"2023-04-23T12:57:05.973Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgtm6jqz002blyjx82qs7cot","content":"<h1 id=\"CNI-Plugins-调研\"><a href=\"#CNI-Plugins-调研\" class=\"headerlink\" title=\"CNI Plugins 调研\"></a>CNI Plugins 调研</h1><h2 id=\"1-通用-CNI-插件\"><a href=\"#1-通用-CNI-插件\" class=\"headerlink\" title=\"1. 通用 CNI 插件\"></a>1. 通用 CNI 插件</h2><blockquote>\n<p>主要基于 <a href=\"https://github.com/containernetworking/plugins\">containernetworking/plugins: Some reference and example networking plugins, maintained by the CNI team. (github.com)</a> ，<a href=\"https://www.cni.dev/plugins/current/\">CNI</a></p>\n</blockquote>\n<p>由CNI 官方社区维护的 CNI plugins 主要分为三类：</p>\n<ul>\n<li><code>Main: interface-creating</code>: 主进程 CNI ,直接与 Linux 交流，创建接口、网络空间、对象等</li>\n<li><code>IPAM: IP address allocation</code>:  地址管理插件，主要负责 IP 地址管理和分配</li>\n<li><code>Meta: other plugins</code>: 其他的功能插件</li>\n</ul>\n<h3 id=\"Main-interface-creating-主进程-CNI\"><a href=\"#Main-interface-creating-主进程-CNI\" class=\"headerlink\" title=\"Main: interface-creating  主进程 CNI\"></a>Main: interface-creating  主进程 CNI</h3><h3 id=\"bridge\"><a href=\"#bridge\" class=\"headerlink\" title=\"bridge\"></a><a href=\"https://www.cni.dev/plugins/current/main/bridge/\"><code>bridge</code></a></h3><p>​    创建虚拟网桥，并把本机（host）和容器（更准确说是network namespace）添加到其中</p>\n<h3 id=\"macvlan\"><a href=\"#macvlan\" class=\"headerlink\" title=\"macvlan\"></a><a href=\"https://www.cni.dev/plugins/current/main/macvlan/\"><code>macvlan</code></a></h3><p>​    创建一个新的 MAC 地址，将相关容器的所有流量都转发到该地址</p>\n<h3 id=\"ipvlan\"><a href=\"#ipvlan\" class=\"headerlink\" title=\"ipvlan\"></a><a href=\"https://www.cni.dev/plugins/current/main/ipvlan/\"><code>ipvlan</code></a></h3><p>​    类似于 <code>macvlan</code>创建虚拟局域网连接，给容器增加 <a href=\"https://www.kernel.org/doc/Documentation/networking/ipvlan.txt\">ipvlan </a>接口，他主要有两种模式：</p>\n<ul>\n<li>L2 模式： 这个模式创建的容器网络与本机共享同一个 L2 设备，也就是说本机的广播数据包能够到达容器网络</li>\n<li>L3 模式：</li>\n</ul>\n<p>这个模式创建对象的例子</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  +=============================================================+</span><br><span class=\"line\">  |  Host: host1                                                |</span><br><span class=\"line\">  |                                                             |</span><br><span class=\"line\">  |   +----------------------+      +----------------------+    |</span><br><span class=\"line\">  |   |   NS:ns0             |      |  NS:ns1              |    |</span><br><span class=\"line\">  |   |                      |      |                      |    |</span><br><span class=\"line\">  |   |                      |      |                      |    |</span><br><span class=\"line\">  |   |        ipvl0         |      |         ipvl1        |    |</span><br><span class=\"line\">  |   +----------#-----------+      +-----------#----------+    |</span><br><span class=\"line\">  |              #                              #               |</span><br><span class=\"line\">  |              ################################               |</span><br><span class=\"line\">  |                              # eth0                         |</span><br><span class=\"line\">  +==============================#==============================+</span><br><span class=\"line\">（a） 创建两个网络命名空间 - ns0、ns1</span><br><span class=\"line\">\t\tIP 网络添加 NS0</span><br><span class=\"line\">\t\tIP 网络添加 NS1</span><br><span class=\"line\"></span><br><span class=\"line\">（b） 在 eth0（主设备）上创建两个 ipvlan 从站。</span><br><span class=\"line\">\t\tIP 链路添加链路 eth0 IPvl0 类型 IPvlan 模式 L2</span><br><span class=\"line\">\t\tIP 链路添加链路 eth0 IPvl1 类型 IPvlan 模式 L2</span><br><span class=\"line\"></span><br><span class=\"line\">（c） 将从属服务器分配到相应的网络命名空间</span><br><span class=\"line\">\t\tIP link <span class=\"built_in\">set</span> dev ipvl0 netns ns0</span><br><span class=\"line\">\t\tIP link <span class=\"built_in\">set</span> dev ipvl1 netns ns1</span><br><span class=\"line\"></span><br><span class=\"line\">（d） 现在切换到命名空间（ns0 或 ns1）以配置从属设备</span><br><span class=\"line\">\t\t- 对于 ns0</span><br><span class=\"line\">\t\t\t（<span class=\"number\">1</span>） IP netns exec ns0 bash</span><br><span class=\"line\">\t\t\t（<span class=\"number\">2</span>） IP 链路设置开发 IPvl0 向上</span><br><span class=\"line\">\t\t\t（<span class=\"number\">3</span>） IP 链路设置开发</span><br><span class=\"line\">\t\t\t（<span class=\"number\">4</span>） IP <span class=\"number\">-4</span> 地址添加 <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span> 开发 LO</span><br><span class=\"line\">\t\t\t（<span class=\"number\">5</span>） IP <span class=\"number\">-4</span> 地址添加 $IPADDR 开发 IPvl0</span><br><span class=\"line\">\t\t\t（<span class=\"number\">6</span>） IP <span class=\"number\">-4</span> 路由通过$ROUTER开发 IPvl0 添加默认值</span><br><span class=\"line\">\t\t- 对于 ns1</span><br><span class=\"line\">\t\t\t（<span class=\"number\">1</span>） IP Netns exec NS1 Bash</span><br><span class=\"line\">\t\t\t（<span class=\"number\">2</span>） IP 链路设置开发 IPvl1 向上</span><br><span class=\"line\">\t\t\t（<span class=\"number\">3</span>） IP 链路设置开发</span><br><span class=\"line\">\t\t\t（<span class=\"number\">4</span>） IP <span class=\"number\">-4</span> 地址添加 <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span> 开发 LO</span><br><span class=\"line\">\t\t\t（<span class=\"number\">5</span>） IP <span class=\"number\">-4</span> 地址添加 $IPADDR 开发 IPvl1</span><br><span class=\"line\">\t\t\t（<span class=\"number\">6</span>） IP <span class=\"number\">-4</span> 路由通过$ROUTER开发 IPvl1 添加默认值</span><br></pre></td></tr></table></figure>\n\n\n\n<ul>\n<li><a href=\"https://www.cni.dev/plugins/current/main/ptp/\"><code>ptp</code></a> : Creates a veth pair</li>\n<li><a href=\"https://www.cni.dev/plugins/current/main/host-device/\"><code>host-device</code></a> : Moves an already-existing device into a container</li>\n<li><a href=\"https://www.cni.dev/plugins/current/main/vlan/\"><code>vlan</code></a> : Creates a vlan interface off a master</li>\n</ul>\n<h4 id=\"Windows-windows-specific\"><a href=\"#Windows-windows-specific\" class=\"headerlink\" title=\"Windows: windows specific\"></a>Windows: windows specific</h4><ul>\n<li><a href=\"https://www.cni.dev/plugins/current/main/win-bridge/\"><code>win-bridge</code></a> : Creates a bridge, adds the host and the container to it</li>\n<li><a href=\"https://www.cni.dev/plugins/current/main/win-overlay/\"><code>win-overlay</code></a> : Creates an overlay interface to the container</li>\n</ul>\n","site":{"data":{}},"cover":"/img/cover/2077_city.png","cover_type":"img","excerpt":"","more":"<h1 id=\"CNI-Plugins-调研\"><a href=\"#CNI-Plugins-调研\" class=\"headerlink\" title=\"CNI Plugins 调研\"></a>CNI Plugins 调研</h1><h2 id=\"1-通用-CNI-插件\"><a href=\"#1-通用-CNI-插件\" class=\"headerlink\" title=\"1. 通用 CNI 插件\"></a>1. 通用 CNI 插件</h2><blockquote>\n<p>主要基于 <a href=\"https://github.com/containernetworking/plugins\">containernetworking/plugins: Some reference and example networking plugins, maintained by the CNI team. (github.com)</a> ，<a href=\"https://www.cni.dev/plugins/current/\">CNI</a></p>\n</blockquote>\n<p>由CNI 官方社区维护的 CNI plugins 主要分为三类：</p>\n<ul>\n<li><code>Main: interface-creating</code>: 主进程 CNI ,直接与 Linux 交流，创建接口、网络空间、对象等</li>\n<li><code>IPAM: IP address allocation</code>:  地址管理插件，主要负责 IP 地址管理和分配</li>\n<li><code>Meta: other plugins</code>: 其他的功能插件</li>\n</ul>\n<h3 id=\"Main-interface-creating-主进程-CNI\"><a href=\"#Main-interface-creating-主进程-CNI\" class=\"headerlink\" title=\"Main: interface-creating  主进程 CNI\"></a>Main: interface-creating  主进程 CNI</h3><h3 id=\"bridge\"><a href=\"#bridge\" class=\"headerlink\" title=\"bridge\"></a><a href=\"https://www.cni.dev/plugins/current/main/bridge/\"><code>bridge</code></a></h3><p>​    创建虚拟网桥，并把本机（host）和容器（更准确说是network namespace）添加到其中</p>\n<h3 id=\"macvlan\"><a href=\"#macvlan\" class=\"headerlink\" title=\"macvlan\"></a><a href=\"https://www.cni.dev/plugins/current/main/macvlan/\"><code>macvlan</code></a></h3><p>​    创建一个新的 MAC 地址，将相关容器的所有流量都转发到该地址</p>\n<h3 id=\"ipvlan\"><a href=\"#ipvlan\" class=\"headerlink\" title=\"ipvlan\"></a><a href=\"https://www.cni.dev/plugins/current/main/ipvlan/\"><code>ipvlan</code></a></h3><p>​    类似于 <code>macvlan</code>创建虚拟局域网连接，给容器增加 <a href=\"https://www.kernel.org/doc/Documentation/networking/ipvlan.txt\">ipvlan </a>接口，他主要有两种模式：</p>\n<ul>\n<li>L2 模式： 这个模式创建的容器网络与本机共享同一个 L2 设备，也就是说本机的广播数据包能够到达容器网络</li>\n<li>L3 模式：</li>\n</ul>\n<p>这个模式创建对象的例子</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  +=============================================================+</span><br><span class=\"line\">  |  Host: host1                                                |</span><br><span class=\"line\">  |                                                             |</span><br><span class=\"line\">  |   +----------------------+      +----------------------+    |</span><br><span class=\"line\">  |   |   NS:ns0             |      |  NS:ns1              |    |</span><br><span class=\"line\">  |   |                      |      |                      |    |</span><br><span class=\"line\">  |   |                      |      |                      |    |</span><br><span class=\"line\">  |   |        ipvl0         |      |         ipvl1        |    |</span><br><span class=\"line\">  |   +----------#-----------+      +-----------#----------+    |</span><br><span class=\"line\">  |              #                              #               |</span><br><span class=\"line\">  |              ################################               |</span><br><span class=\"line\">  |                              # eth0                         |</span><br><span class=\"line\">  +==============================#==============================+</span><br><span class=\"line\">（a） 创建两个网络命名空间 - ns0、ns1</span><br><span class=\"line\">\t\tIP 网络添加 NS0</span><br><span class=\"line\">\t\tIP 网络添加 NS1</span><br><span class=\"line\"></span><br><span class=\"line\">（b） 在 eth0（主设备）上创建两个 ipvlan 从站。</span><br><span class=\"line\">\t\tIP 链路添加链路 eth0 IPvl0 类型 IPvlan 模式 L2</span><br><span class=\"line\">\t\tIP 链路添加链路 eth0 IPvl1 类型 IPvlan 模式 L2</span><br><span class=\"line\"></span><br><span class=\"line\">（c） 将从属服务器分配到相应的网络命名空间</span><br><span class=\"line\">\t\tIP link <span class=\"built_in\">set</span> dev ipvl0 netns ns0</span><br><span class=\"line\">\t\tIP link <span class=\"built_in\">set</span> dev ipvl1 netns ns1</span><br><span class=\"line\"></span><br><span class=\"line\">（d） 现在切换到命名空间（ns0 或 ns1）以配置从属设备</span><br><span class=\"line\">\t\t- 对于 ns0</span><br><span class=\"line\">\t\t\t（<span class=\"number\">1</span>） IP netns exec ns0 bash</span><br><span class=\"line\">\t\t\t（<span class=\"number\">2</span>） IP 链路设置开发 IPvl0 向上</span><br><span class=\"line\">\t\t\t（<span class=\"number\">3</span>） IP 链路设置开发</span><br><span class=\"line\">\t\t\t（<span class=\"number\">4</span>） IP <span class=\"number\">-4</span> 地址添加 <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span> 开发 LO</span><br><span class=\"line\">\t\t\t（<span class=\"number\">5</span>） IP <span class=\"number\">-4</span> 地址添加 $IPADDR 开发 IPvl0</span><br><span class=\"line\">\t\t\t（<span class=\"number\">6</span>） IP <span class=\"number\">-4</span> 路由通过$ROUTER开发 IPvl0 添加默认值</span><br><span class=\"line\">\t\t- 对于 ns1</span><br><span class=\"line\">\t\t\t（<span class=\"number\">1</span>） IP Netns exec NS1 Bash</span><br><span class=\"line\">\t\t\t（<span class=\"number\">2</span>） IP 链路设置开发 IPvl1 向上</span><br><span class=\"line\">\t\t\t（<span class=\"number\">3</span>） IP 链路设置开发</span><br><span class=\"line\">\t\t\t（<span class=\"number\">4</span>） IP <span class=\"number\">-4</span> 地址添加 <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span> 开发 LO</span><br><span class=\"line\">\t\t\t（<span class=\"number\">5</span>） IP <span class=\"number\">-4</span> 地址添加 $IPADDR 开发 IPvl1</span><br><span class=\"line\">\t\t\t（<span class=\"number\">6</span>） IP <span class=\"number\">-4</span> 路由通过$ROUTER开发 IPvl1 添加默认值</span><br></pre></td></tr></table></figure>\n\n\n\n<ul>\n<li><a href=\"https://www.cni.dev/plugins/current/main/ptp/\"><code>ptp</code></a> : Creates a veth pair</li>\n<li><a href=\"https://www.cni.dev/plugins/current/main/host-device/\"><code>host-device</code></a> : Moves an already-existing device into a container</li>\n<li><a href=\"https://www.cni.dev/plugins/current/main/vlan/\"><code>vlan</code></a> : Creates a vlan interface off a master</li>\n</ul>\n<h4 id=\"Windows-windows-specific\"><a href=\"#Windows-windows-specific\" class=\"headerlink\" title=\"Windows: windows specific\"></a>Windows: windows specific</h4><ul>\n<li><a href=\"https://www.cni.dev/plugins/current/main/win-bridge/\"><code>win-bridge</code></a> : Creates a bridge, adds the host and the container to it</li>\n<li><a href=\"https://www.cni.dev/plugins/current/main/win-overlay/\"><code>win-overlay</code></a> : Creates an overlay interface to the container</li>\n</ul>\n"},{"title":"2023 ospp fighting","catalog":true,"date":"2023-04-18T21:02:23.000Z","subtitle":null,"header-img":null,"published":0,"_content":"\n\n\n# 实现一个简单的 CNI\n\n","source":"_posts/EdgeMesh/cilium与edgemesh性能测试/2023-ospp-fighting/实现一个简单的 CNI.md","raw":"---\ntitle: 2023 ospp fighting\ncatalog: true\ndate: 2023-04-19 05:02:23\nsubtitle:\nheader-img:\ntags: ospp, edgemesh\ncategories: CNI\npublished: false\n---\n\n\n\n# 实现一个简单的 CNI\n\n","slug":"EdgeMesh/cilium与edgemesh性能测试/2023-ospp-fighting/实现一个简单的 CNI","updated":"2023-04-22T14:58:05.395Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgtm6jr4002wlyjxc6zbe6kl","content":"<h1 id=\"实现一个简单的-CNI\"><a href=\"#实现一个简单的-CNI\" class=\"headerlink\" title=\"实现一个简单的 CNI\"></a>实现一个简单的 CNI</h1>","site":{"data":{}},"cover":"/img/cover/2077_city.png","cover_type":"img","excerpt":"","more":"<h1 id=\"实现一个简单的-CNI\"><a href=\"#实现一个简单的-CNI\" class=\"headerlink\" title=\"实现一个简单的 CNI\"></a>实现一个简单的 CNI</h1>"}],"PostAsset":[],"PostCategory":[{"post_id":"clgtm6jq40007lyjxeb2t6kdw","category_id":"clgtm6jq7000blyjxdki832wu","_id":"clgtm6jqd000mlyjxcb357bat"},{"post_id":"clgtm6jq6000alyjx4nccd2gv","category_id":"clgtm6jqb000ilyjx0eqs5db2","_id":"clgtm6jqi000tlyjxag89flrd"},{"post_id":"clgtm6jq8000dlyjx30d637uz","category_id":"clgtm6jqb000ilyjx0eqs5db2","_id":"clgtm6jqk000ylyjx3kn2gdj0"},{"post_id":"clgtm6jqb000hlyjxeojzhsj5","category_id":"clgtm6jqh000slyjx5nt64ove","_id":"clgtm6jqm0015lyjxhm2l3y3v"},{"post_id":"clgtm6jqb000jlyjxh2kb3amy","category_id":"clgtm6jqh000slyjx5nt64ove","_id":"clgtm6jqn001alyjx5hvjfnj1"},{"post_id":"clgtm6jqd000llyjx3m5aauvq","category_id":"clgtm6jqm0014lyjxa5c51rr5","_id":"clgtm6jqp001glyjx8wijfmlf"},{"post_id":"clgtm6jqi000vlyjxhnnw598r","category_id":"clgtm6jqn001blyjxedt9beza","_id":"clgtm6jqr001mlyjx447nck1b"},{"post_id":"clgtm6jqk0011lyjx4bv1gfx7","category_id":"clgtm6jqq001ilyjx7npw5u1k","_id":"clgtm6jqt001slyjx1xmx329w"},{"post_id":"clgtm6jqo001dlyjx2e1h15jx","category_id":"clgtm6jqr001nlyjxan5cdbtk","_id":"clgtm6jqv001ylyjx9fgf8bo0"},{"post_id":"clgtm6jqo001elyjxekujfw8p","category_id":"clgtm6jqt001tlyjx2tivdak6","_id":"clgtm6jqx0025lyjx9z4k8wzt"},{"post_id":"clgtm6jqv001xlyjx8fmt1oag","category_id":"clgtm6jqb000ilyjx0eqs5db2","_id":"clgtm6jqy0027lyjx4frd8y2u"},{"post_id":"clgtm6jqp001hlyjx0dlc1u5r","category_id":"clgtm6jqt001tlyjx2tivdak6","_id":"clgtm6jqz002alyjxhlfshwe8"},{"post_id":"clgtm6jqt001rlyjxbrxeehqm","category_id":"clgtm6jqx0024lyjxdwqk3a2h","_id":"clgtm6jr1002glyjxb64jejwl"},{"post_id":"clgtm6jqv0020lyjx3b7wdi1a","category_id":"clgtm6jr0002dlyjxf9pg9hh6","_id":"clgtm6jr1002klyjxemdz1pyv"},{"post_id":"clgtm6jqw0021lyjx4r8q61jd","category_id":"clgtm6jr1002hlyjx3npyh59g","_id":"clgtm6jr2002olyjxfp1u17gb"},{"post_id":"clgtm6jqx0026lyjxdcb236ve","category_id":"clgtm6jr1002mlyjx1onv3aha","_id":"clgtm6jr2002rlyjx9qjq6t9v"},{"post_id":"clgtm6jqy0028lyjxc7f76lhe","category_id":"clgtm6jr2002qlyjxdjc7hpkz","_id":"clgtm6jr3002ulyjx2lyyf6dq"},{"post_id":"clgtm6jqz002blyjx82qs7cot","category_id":"clgtm6jr2002tlyjxgg9h4s0a","_id":"clgtm6jr3002vlyjxgqklg2j1"},{"post_id":"clgtm6jr4002wlyjxc6zbe6kl","category_id":"clgtm6jr1002hlyjx3npyh59g","_id":"clgtm6jr4002ylyjx5swb576p"}],"PostTag":[{"post_id":"clgtm6jq30005lyjxe1mb1y4o","tag_id":"clgtm6jq50008lyjxcffi440a","_id":"clgtm6jqa000glyjxchkp8577"},{"post_id":"clgtm6jq40007lyjxeb2t6kdw","tag_id":"clgtm6jqa000flyjxgrlx2bwx","_id":"clgtm6jqd000nlyjx2g5n4k23"},{"post_id":"clgtm6jq6000alyjx4nccd2gv","tag_id":"clgtm6jqc000klyjx4ngfhy33","_id":"clgtm6jqi000ulyjxavsvh2m2"},{"post_id":"clgtm6jq8000dlyjx30d637uz","tag_id":"clgtm6jqc000klyjx4ngfhy33","_id":"clgtm6jqk000zlyjxfs2s5a3r"},{"post_id":"clgtm6jqb000hlyjxeojzhsj5","tag_id":"clgtm6jqi000wlyjxaaw9enre","_id":"clgtm6jqm0016lyjxdw8m0zt4"},{"post_id":"clgtm6jqb000jlyjxh2kb3amy","tag_id":"clgtm6jql0012lyjx922r0d69","_id":"clgtm6jqo001clyjxe6s03b6s"},{"post_id":"clgtm6jqd000llyjx3m5aauvq","tag_id":"clgtm6jqn0019lyjxc2m5a011","_id":"clgtm6jqq001jlyjx8rqy3od0"},{"post_id":"clgtm6jqi000vlyjxhnnw598r","tag_id":"clgtm6jqp001flyjx72yfawia","_id":"clgtm6jqs001olyjx1qnb5h1e"},{"post_id":"clgtm6jqq001klyjxbxycfvbo","tag_id":"clgtm6jqs001plyjx9vei5ogv","_id":"clgtm6jqv001wlyjx8ufcg2qk"},{"post_id":"clgtm6jqt001rlyjxbrxeehqm","tag_id":"clgtm6jqu001vlyjx6r421jn6","_id":"clgtm6jqx0023lyjx389ecpov"},{"post_id":"clgtm6jqv001xlyjx8fmt1oag","tag_id":"clgtm6jqx0022lyjxh95x182u","_id":"clgtm6jr0002clyjx4d1s3btt"},{"post_id":"clgtm6jqz002blyjx82qs7cot","tag_id":"clgtm6jqz0029lyjx7nqpc1vn","_id":"clgtm6jr0002flyjx395876b0"},{"post_id":"clgtm6jqv0020lyjx3b7wdi1a","tag_id":"clgtm6jqz0029lyjx7nqpc1vn","_id":"clgtm6jr1002ilyjx98xzcdtn"},{"post_id":"clgtm6jqw0021lyjx4r8q61jd","tag_id":"clgtm6jr0002elyjx56ic0ey7","_id":"clgtm6jr1002llyjx6jbzaxas"},{"post_id":"clgtm6jqx0026lyjxdcb236ve","tag_id":"clgtm6jr1002jlyjxhxlk6cas","_id":"clgtm6jr2002plyjx3ei6g8kq"},{"post_id":"clgtm6jqy0028lyjxc7f76lhe","tag_id":"clgtm6jr2002nlyjxeshcb75d","_id":"clgtm6jr2002slyjxhho63juz"},{"post_id":"clgtm6jr4002wlyjxc6zbe6kl","tag_id":"clgtm6jqz0029lyjx7nqpc1vn","_id":"clgtm6jr4002xlyjxeodfc892"}],"Tag":[{"name":"Golang","_id":"clgtm6jq50008lyjxcffi440a"},{"name":"链表, 算法","_id":"clgtm6jqa000flyjxgrlx2bwx"},{"name":"working, 算法","_id":"clgtm6jqc000klyjx4ngfhy33"},{"name":"Dynamic Programming","_id":"clgtm6jqi000wlyjxaaw9enre"},{"name":"Working","_id":"clgtm6jql0012lyjx922r0d69"},{"name":"算法， 南开大学，Golang, working","_id":"clgtm6jqn0019lyjxc2m5a011"},{"name":"测试， edgeMesh","_id":"clgtm6jqp001flyjx72yfawia"},{"name":"Golang, List","_id":"clgtm6jqs001plyjx9vei5ogv"},{"name":"p2p,cpolar","_id":"clgtm6jqu001vlyjx6r421jn6"},{"name":"双指针, 算法","_id":"clgtm6jqx0022lyjxh95x182u"},{"name":"ospp, edgemesh","_id":"clgtm6jqz0029lyjx7nqpc1vn"},{"name":"ospp, CNI, Linux, Spec","_id":"clgtm6jr0002elyjx56ic0ey7"},{"name":"ospp, Linux, Network","_id":"clgtm6jr1002jlyjxhxlk6cas"},{"name":"ospp, edgemesh，Pod","_id":"clgtm6jr2002nlyjxeshcb75d"}]}}