<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ideamesh</title>
  
  <subtitle>learn and code</subtitle>
  <link href="http://ideameshdyx.github.io/atom.xml" rel="self"/>
  
  <link href="http://ideameshdyx.github.io/"/>
  <updated>2023-07-25T07:55:48.259Z</updated>
  <id>http://ideameshdyx.github.io/</id>
  
  <author>
    <name>IdeaMeshDYX</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ipip vs vxlan 汇总各自优劣</title>
    <link href="http://ideameshdyx.github.io/2023/07/11/EdgeMesh/cnidev/ipipVxlan/ipip-and-vxlan/"/>
    <id>http://ideameshdyx.github.io/2023/07/11/EdgeMesh/cnidev/ipipVxlan/ipip-and-vxlan/</id>
    <published>2023-07-11T19:37:09.000Z</published>
    <updated>2023-07-25T07:55:48.259Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IPIP-and-vxlan-Simple-Comparison"><a href="#IPIP-and-vxlan-Simple-Comparison" class="headerlink" title="IPIP and vxlan  Simple Comparison"></a>IPIP and vxlan  Simple Comparison</h1><blockquote><p>本文档的功能在于调研和对比容器网络隧道技术，针对于 EdgeMesh CNI 应该使用怎样的技术做出资料规整</p></blockquote><h2 id="why-cni-need-IPIP-or-Vxlan"><a href="#why-cni-need-IPIP-or-Vxlan" class="headerlink" title="why cni need IPIP or Vxlan"></a>why cni need IPIP or Vxlan</h2><p><strong>实现 CNI 时，为了给容器提供虚拟网络的隔离性和跨主机通信能力，就需要考虑 IPIP 以及 Vxlan 等技术</strong></p><p>在单节点上，通过创建虚拟网桥，然后将另一端插入到容器的 Veth 放入到网桥，这样链接在网桥上的容器之间就是二层可通的，但如果想让这些容器能够访问到网桥外的网络，包括本机的其他网桥以及节点之外的网络，就需要有合适的路由转发组件来完成。本机上的网络转发可以通过在路由规则中制定写死的网关，让容器之间和网桥之间可以访问，但如果涉及到节点之外的网络，尤其是二层不可通的网络当中，单节点往往难以知道数据包传输整个流程中的地址变化，而网络设备也不知道这些来自于容器的数据包地址该对应哪些链路和端口。</p><p>如果我们想要让容器的数据包可以传输到外界，就需要能够让节点外的网络设备或者是其他节点可以知道数据包转发的方向，而容器网络的地址和信息与底层网络设备并不一一对应，这就需要有借助于隧道技术，即IPIP， Vxlan 。当然为何就只讨论这两类技术呢？目前的答案是因为现有的 CNI 插件几乎都只关注于这两种技术的实现。</p><p>明白了 CNI 对隧道技术需求的原因，接下来深入分析 EdgeMesh  CNI 对这方面的需求。</p><p>EdgeMesh 针对的场景是对云边以及边边等复杂的边缘网络。相较于数据中心网络，边缘网络以及多集群网络最大的特征就是跨网段，物理设备二层不可通；其次就是资源受限，也就是说对于发包效率和存储管理并不能够像是数据中心那样更加随意和自由。与此同时，在 ServiceMesh 中，网络区段的界限并非与实际的物理网段一致，通过服务类型/部署形式等等，进行区分和流量控制也是需求之一。</p><p>到此我们可以大致绘制出 EdgeMesh CNI 的功能需求图谱了：</p><ul><li>首先是场景中存在着子网内网络流量和子网间网络流量，CNI 需要对不同的网络流量提供联通服务，也就是说针对于p2p流量和集群流量要做区分不同服务；</li><li>其次是要兼容边缘节点资源受限的问题，尽量维持组件的轻量化，通讯成本低。</li></ul><p>那么接下来我们继续深入来看看这两项技术各自的特征和好坏之处。</p><hr><h2 id="what-is-IPIP"><a href="#what-is-IPIP" class="headerlink" title="what is IPIP"></a>what is IPIP</h2><blockquote><p>IP in IP，一种IP隧道协议（IP Tunnel），将一个IP数据包，封装进另一个IP数据包中。为了封装IP数据包，在来源IP上要再加上一个外部的标头，隧道的进入点，目的位置，以及隧道离开的位置。<br><a href="https://zh.wikipedia.org/wiki/IP_in_IP">wiki IP in IP</a></p></blockquote><p>其实从定义中已经非常明确说明这项技术的核心：在原本的数据包基础上增加一段IP字段</p><p>引用文章<a href="https://www.zentao.pm/blog/kubernetes-network-model-1379.html">Kubernetes Network Model</a> 的示意图</p><p>从路由过程来看，当数据包离开了容器网段需要传输到外网的时候，会由本机的 IPIP 设备（是内核创建的转发设备 tunl,先暂时理解为一个内核进程将这些流量都拦截并对数据包做修改）<br>如下两图所示，我们可以清晰看到整个路由过程当中，IPIP隧道的创建和使用。</p><p><img src="ipip_data.png" alt="routing"></p><p>结构上来说，IPIP数据包只是在原有数据包的基础上增加了一段新的IP Header，总共20个字节。这段新的IP header 包含的是容器的地址，而外层的IP地址是本机的地址。数据包的路由就这样被自然分成了两个阶段，以下图为例，我们来梳理这个阶段的数据包传输。</p><p>当流量从节点外传输进入，首先使用的是外层IP地址进行路由转发，其目标地址和端口对应的是本机的IPIP设备的话，就会发往IPIP设备，之后外层的IP地址就被废弃去掉了，可以理解为经过这个IPIP设备外层地址就被扒去，数据包使用内层的地址进行路由，这个时候使用的IP地址就是容器网络的IP地址了</p><p><img src="IPIP.png" alt="routing"></p><p>不过这里还有几处疑问需要接下来继续去探索解决：</p><ol><li>该怎样创建IPIP设备，其工作原理到底是什么样的呢？</li><li>拦截了所有流量的这个内核IPIP设备是否会会成为系统性能的瓶颈？</li><li> 如何接入IPIP设备，使其灵活变化地址封装</li></ol><p>此外还有一点可以明确的是，IPIP是纯工作在三层及以上的技术，因为这样的隔离使得数据包以IPIP设备作为分界线，划分出了物理网络和容器网络的边界，但是二层以下的设备却都还是共用的。</p><h2 id="what-is-vxlan"><a href="#what-is-vxlan" class="headerlink" title="what is vxlan"></a>what is vxlan</h2><blockquote><p>虚拟局域网扩展（Virtual Extensible LAN, VXLAN）是一种网络虚拟化技术。它采用类似 VLAN 封装技术封装基于MAC含括第 4 层的UDP数据包的 OSI 第2层 以太网帧，使用 4789 作为默认分配的 IANA 目的地 UDP 端口号。</p></blockquote><p>与 IPIP 对应，Vxlan 也是在原本的数据包基础上增加了额外的字段，总共50 Bytes(包括8个vxlan协议相关字节，8个UDP头部字节，20个IP头部和14个MAC头部字节)，<br>如下图所示：</p><p><img src="vxlan_data.png" alt="vxlan_data"></p><p>相较于IPIP直接添加了一段IP Header， Vxlan还多增加了一些字段，如果说添加的IP Header 和IPIP一样，那么其他的字段又充当了什么样的角色呢？</p><ul><li><p>UDP Header:</p><p>  有不少的资料表述为 Vxlan 是基于UDP实现的Tunnel,所以数据包都是UDP数据包；这个表述是对的，但是在理解上却容易误导，因为 Vxlan 不是在已有的UDP数据包基础上建立隧道，而是在自己的协议中加入了 UDP Header 来保障传输数据的正确性</p><p>  这里有一个疑问是为何 UDP 工作在传输层(L4)协议却要比后面 Vxlan 工作在L2/L3层的MAC和IP要更早处理呢？这并不符合网络结构的逻辑。 <br>  我们仔细观察数据包的结构，实际上不管内部的 VXlan，外层到 UDP 的字段都符合网络协议栈的处理，那我们完全可以这样去假设：数据包经过 UDP 协议会被传输给内核当中的 Vxlan 设备，然后这个内核设备会依据 Vxlan 标识重新将数据包导入到本机的 L2 协议栈，再使用容器网络的IP进行路由。</p><p>  也就是说 Vxlan 的数据包会多一次经过本机的L2网络协议栈。</p></li><li><p>Vxlan Header: </p><p>  关于 VIN 的作用和实现较为繁多，尤其是他涉及的 NetworkPolicy 以及 子网划分方面的内容，需要单独再出一片文章来做解释和实验。<br>  对于本篇文章来说，重点只需要知道这个部分的字段可以用于区别不同网段和服务类型就可以</p></li><li><p>MAC Header:<br>  伪造的 MAC 字段，一般来说这个 MAC字段就是对应所创建的虚拟网桥（L2设备），当然这个部分的可填充型有待继续研究。</p></li></ul><h2 id="pros-and-cons"><a href="#pros-and-cons" class="headerlink" title="pros and cons"></a>pros and cons</h2><p>基本了解了二者的特征和实现原理之后，我们来继续深入研究对比一下两个方案。</p><ol><li><p>运行机制上均是在内核创建虚拟设备来做封包和解包</p><p> 二者都需要通过代码调用内核接口并创建对应的虚拟设备:</p><ul><li>IPIP 创建 Tunl</li><li>Vxlan 创建 VTEP</li></ul><p> 且都会作为容器网络的网关，修改封装所有的数据包，本身可能会随着容器数量的急剧增长而变成单节点网络性能的瓶颈，待之后研究。</p></li><li><p>添加的字段大小和数量不同</p><p> 这一点也有不少的文章和资料指出，尤其是 Vxlan 报文相较 IPIP 更大，所以网络线路传输的有效数据占比较小，尤其是对于小包或者是信令数据之类的，因为无论是什么样功能的数据包，经过容器网络的封装，底层网络都会将他们当作同等重要的数据来进行服务和传输。<br> 但是对于网络的划分和更长远的服务发展来说，Vxlan 有更加完整的网络字段，能够将容器网络对流量的控制和划分深入到L2，同时Vxlan在冗余和其他高可用性解决方案方面具有很大的潜力；而IPIP限制于其简单添加的头部字段就无法脱离于网络三层来提供服务。</p></li><li><p>适用场景并不相同<br> IPIP 是一种相对简化的隧道机制。将IP封装在IP中实际上是为充当路由器的设备而设计的，因为在IP报头之后的唯一内容就是——下一个IP报头。接着通过使用IP协议字段来指示下一个报头，这样端点就可以知道是否再次循环内部数据包以进行路由决策，这个过程是独立于二层的，换句话说内部的 IP 地址不仅和外部的地址毫无关联影响，他们自己之间也没有相关关联，所有的解包和封包都是对单独一个包而言的，即便可能前前后后不断重复封装的都是同一个地址。<br> 总之，<strong>IP-in-IP最终是点对点</strong>的。</p><p> VXLAN 最大 的特征就是一个VLAN标签，但它也不是像GRE和IPIP那样设计成点对点的。通过深入到二层的网络信息，使得它可以通过底层传输网络中的组播支持以太网BUM流量（广播、未知和组播）。换句话说，<strong>VXLAN是完全多点的，可以完全模拟以太网段</strong>，而不仅仅是其中的一个链路。</p></li><li><p>性能和消耗不相同</p><p> 基于 arm 此前的一项<a href="https://static.linaro.org/connect/lvc20/presentations/LVC20-115-0.pdf">研究</a></p><p> 研究对比出来的数据较多，我这里只拿出本题关注的几点：</p><ul><li>单集群同网段间 IPIP 的性能体现要比 Vxlan 较好一点</li><li>IPIP 和 Vxlan 内核代理可能会成为性能瓶颈</li></ul></li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] <a href="https://www.quora.com/Is-IPIP-better-than-VXLAN/answer/Jean-Yves-Landry-1?__filter__=all&amp;__nsrc__=notif_page&amp;__sncid__=41563303444&amp;__snid3__=55626021146">https://www.quora.com/Is-IPIP-better-than-VXLAN/answer/Jean-Yves-Landry-1?__filter__=all&amp;__nsrc__=notif_page&amp;__sncid__=41563303444&amp;__snid3__=55626021146</a>  <br>[2] <a href="https://vpnreviewopendiscussion.quora.com/Is-IPIP-better-than-VXLAN-1?comment_id=345922545&amp;comment_type=2&amp;__filter__=all&amp;__nsrc__=notif_page&amp;__sncid__=41580756912&amp;__snid3__=55649647167">https://vpnreviewopendiscussion.quora.com/Is-IPIP-better-than-VXLAN-1?comment_id=345922545&amp;comment_type=2&amp;__filter__=all&amp;__nsrc__=notif_page&amp;__sncid__=41580756912&amp;__snid3__=55649647167</a>   <br>[3] <a href="https://ranchermanager.docs.rancher.com/v2.6/faq/container-network-interface-providers">https://ranchermanager.docs.rancher.com/v2.6/faq/container-network-interface-providers</a>  <br>[4] <a href="https://www.manageengine.com/network-monitoring/tech-topics/vxlan-vs-vlan.html">https://www.manageengine.com/network-monitoring/tech-topics/vxlan-vs-vlan.html</a>   <br>[5] <a href="https://www.cnblogs.com/janeysj/p/14291537.html">https://www.cnblogs.com/janeysj/p/14291537.html</a>   <br>[6] <a href="https://forum.mikrotik.com/viewtopic.php?t=184769">https://forum.mikrotik.com/viewtopic.php?t=184769</a>   <br>[7] <a href="https://blog.crazytaxii.com/posts/k8s_cni/">https://blog.crazytaxii.com/posts/k8s_cni/</a>   <br>[8] <a href="https://docs.tigera.io/calico/latest/networking/configuring/vxlan-ipip?ref=qdnqn.com">https://docs.tigera.io/calico/latest/networking/configuring/vxlan-ipip?ref=qdnqn.com</a>   <br>[9] <a href="https://www.zentao.pm/blog/kubernetes-network-model-1379.html">https://www.zentao.pm/blog/kubernetes-network-model-1379.html</a>   \</p><h1 id="相关技术和架构调研汇总"><a href="#相关技术和架构调研汇总" class="headerlink" title="相关技术和架构调研汇总"></a><font size ='4'>相关技术和架构调研汇总</font></h1><table><thead><tr><th>组件名称</th><th>提供的网络隧道技术</th><th>连接服务情况</th></tr></thead><tbody><tr><td>cilium</td><td>Native-Routing，Geneve，Vxlan</td><td>支持 Kubernetes 和 Mesos</td></tr><tr><td>calico</td><td>IPIP, Vxlan</td><td>支持 Kubernetes, OpenShift 和 Mesos</td></tr><tr><td>flannel</td><td>Vxlan, Host-GW, IPIP</td><td>支持 Kubernetes, Mesos 和 Docker Swarm</td></tr><tr><td>Kilo</td><td>IPIP, Vxlan</td><td>支持 Kubernetes</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;IPIP-and-vxlan-Simple-Comparison&quot;&gt;&lt;a href=&quot;#IPIP-and-vxlan-Simple-Comparison&quot; class=&quot;headerlink&quot; title=&quot;IPIP and vxlan  Simple Compa</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>创建简单的 CNI 插件</title>
    <link href="http://ideameshdyx.github.io/2023/05/25/EdgeMesh/cnidev/cnibasic/CNI-CreateCNI/"/>
    <id>http://ideameshdyx.github.io/2023/05/25/EdgeMesh/cnidev/cnibasic/CNI-CreateCNI/</id>
    <published>2023-05-25T23:37:48.000Z</published>
    <updated>2023-07-25T07:57:07.494Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>使用 Golang 实现一个简易的 CNI<br>对于 CNI 的功能实现将按照循序渐进的方式来进行<br>实现目标</p><ul><li>依据 config 文件创建 bridge 对象并分配 ns 对应的 ip 地址</li><li>提供容器网络通信服务</li></ul><p>实验的代码和脚本可以在 <a href="https://github.com/IdeaMeshDyx/knetwork">IdeaMeshDyx/knetwork</a> 中找到</p></blockquote><h2 id="设计简易的-CNI-工作逻辑"><a href="#设计简易的-CNI-工作逻辑" class="headerlink" title="设计简易的 CNI 工作逻辑"></a>设计简易的 CNI 工作逻辑</h2><p>由于 cni 提供的服务集中于节点的 L2/L3 层通信，所以基础的 cni 大致功能就是通过读取 config 文件配置在本地 Linux 环境当中给容器分配地址并通过 bridge 等设备建立通信能力。</p><p>依据上一篇<a href="https://ideameshdyx.github.io/2023/04/18/EdgeMesh/2023-ospp-fighting/CNI-Basic/">博客</a>所学习到的 cni 规范，我们可以将 cni 的基础工作逻辑梳理如下：</p><ol><li>kubelet 先创建 pause 容器创建对应的网络命名空间；</li><li>cri 或者是 cni 主程序根据配置调用具体的 CNI 插件，可以配置成 CNI 插件链来进行链式调用；</li><li>当 CNI 插件被调用时，通过传入配置以及命令行参数来获得网络命名空间、容器的网络设备等必要信息，然后执行 ADD 、 DELETE 或者其他操作；</li><li>CNI 插件给 pause 容器配置正确的网络，pod 中其他的容器都是复用 pause 容器的网络；</li></ol><ul><li>当容器准备创建或被终止时，cni 插件被 cri 或者是其他的 cni 插件调用执行功能。<ul><li>当创建容器的时候，为容器分配网络资源，包括 IP 地址和网络连接</li><li>当销毁容器的时候，删除为容器分配的所有网络资源</li></ul></li><li>cni 插件所获取的信息格式如下: (cri 调用或者是其他 cni 插件)<ul><li>cni 执行的命令和操作(cni必须要实现的核心可调用功能)<ul><li>ADD</li><li>DELETE</li><li>VERSION</li><li>CHECK</li></ul></li><li>容器ID(服务的容器对象ID)</li><li>节点容器所连接网络空间的路径</li><li>容器中需要创建的接口名称</li><li>目前节点内 cni 可执行程序所在路径，一般其他的 cni 插件也在这个路径(一般是<code>/opt/cni/bin</code>)</li><li>cni 配置文件的路径</li></ul></li></ul><p>而对于节点运行的 cri 调用 cni 服务，需要在路径中设置 cni 可调用的地址。如果是在 Kubernetes 集群当中， cni 以容器的形式来提供服务就需要在其创建了对应的网桥提供服务之后，设置 cni 当中获取服务的地址为该网桥所在网段。<br>比如 Docker 当中设置 <code>vim /usr/lib/systemd/system/docker.service</code> 中 <code>--bip=10.244.12.1/24 </code> 如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[Service]</span><br><span class="line">Type=notify</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">the default is not to use systemd <span class="keyword">for</span> cgroups because the delegate issues still</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">exists and systemd currently does not support the cgroup feature <span class="built_in">set</span> required</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="keyword">for</span> containers run by docker</span></span><br><span class="line">ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock --bip=10.244.12.1/24 --mtu=1450</span><br><span class="line">ExecReload=/bin/kill -s HUP $MAINPID</span><br><span class="line">TimeoutStartSec=0</span><br><span class="line">RestartSec=2</span><br><span class="line">Restart=always</span><br></pre></td></tr></table></figure><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="Step1-创建-cni-主流程"><a href="#Step1-创建-cni-主流程" class="headerlink" title="Step1 : 创建 cni 主流程"></a><strong>Step1 : 创建 cni 主流程</strong></h3><p>首先，一个基本的 cni 需要完成在容器创建时候，依据传入参数为其分配网络资源；同时需要在容器终止时候，删除所有分配的资源。<br>所以可以先得到一个最基本的 cni 主程序框架如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;github.com/containernetworking/cni/pkg/skel&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/containernetworking/cni/pkg/version&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cmdAdd</span><span class="params">(args *skel.CmdArgs)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    <span class="doctag">TODO:</span> add code about cmdAdd</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 测试是否 cni 接收到了传入的容器网络配置参数</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;interfance Name: %s\n&quot;</span>, args.IfName)</span><br><span class="line">  fmt.Printf(<span class="string">&quot;Netns path: %s\n&quot;</span>, args.Netns)</span><br><span class="line">  fmt.Printf(<span class="string">&quot;The config data: %s\n&quot;</span>, args.StdinData)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cmdDel</span><span class="params">(args *skel.CmdArgs)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    <span class="doctag">TODO:</span> add code about cmdDel</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    skel.PluginMain(cmdAdd, cmdDel, cmdVersion, cmdCheck)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>按照所归纳的 cni 逻辑，我们已经实现了一个基础的框架，并且可以接受传入的网络配置参数，但目前还没有执行任何的动作。</p><p>传入的参数具体内容定义在 <code>pkg/skel/skel.go</code>:</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CmdArgs captures all the arguments passed in to the plugin</span></span><br><span class="line"><span class="comment">// via both env vars and stdin</span></span><br><span class="line"><span class="keyword">type</span> CmdArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">ContainerID   <span class="type">string</span></span><br><span class="line">Netns         <span class="type">string</span></span><br><span class="line">IfName        <span class="type">string</span></span><br><span class="line">Args          <span class="type">string</span></span><br><span class="line">Path          <span class="type">string</span></span><br><span class="line">NetnsOverride <span class="type">string</span></span><br><span class="line">StdinData     []<span class="type">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然 cni 接受参数的目的是去了解该创建怎样的容器网络。但是如何将这些参数传给 cni 呢？ 依据 cni 规范，我们需要从配置文件或者是 cri 传入参数中获取到对应的容器网络需求。顺带一提，在 Kubernetes 网络集群中，kubelet 也并不是直接与 cni 沟通的，所以 cni 本身可以在单节点上创建容器网络以及提供功能，只是说在集群当中可以结合 kubelet 提供 list/watch apiserver 的功能来做局域网内的地址管理和网络连通性，包括 ip capsulating， cidr 等等。</p><p>接下来为检验以上的功能逻辑通畅，创建以下 config 文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;name&quot;:</span> <span class="string">&quot;mynet&quot;</span>,</span><br><span class="line"><span class="attr">&quot;BridgeName&quot;:</span> <span class="string">&quot;test&quot;</span>,</span><br><span class="line"><span class="attr">&quot;IP&quot;:</span> <span class="string">&quot;192.0.2.1/24&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么接下来就可以，模拟 cri 调用 cni 通过 config 文件指定所创建的容器网络配置创建资源，所使用的指令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">go build -o example .</span><br><span class="line">echo &quot;Ready to call the cni program and create resources&quot;</span><br><span class="line">sudo CNI_COMMAND=ADD CNI_CONTAINERID=ns1 CNI_NETNS=/var/run/netns/ns1 CNI_IFNAME=eth10 CNI_PATH=`pwd` ./example &lt; config</span><br><span class="line">echo &quot;The CNI has been called, see the following results&quot;</span><br></pre></td></tr></table></figure><p>得到以下输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@master knet]# ./run.sh</span><br><span class="line">Ready to call the cni program and create resources</span><br><span class="line">interfance Name: eth10</span><br><span class="line">netns path: /var/run/netns/ns1</span><br><span class="line">the config data: &#123;</span><br><span class="line">        &quot;name&quot;: &quot;mynet&quot;,</span><br><span class="line">        &quot;BridgeName&quot;: &quot;test&quot;,</span><br><span class="line">        &quot;IP&quot;: &quot;192.0.2.1/24&quot;</span><br><span class="line">&#125;</span><br><span class="line">The CNI has been called, see the following results</span><br></pre></td></tr></table></figure><p>通过这个测试可以明确以上代码可以从命令行当中读取出对应的配置参数，不过仅只是将结果输出而已并没有做更多的操作，当然这并不可能是完整的 cni ，那接下来进一步实现当 cni 获取了这些参数之后该做些什么。</p><h3 id="step2-实现-cmdAdd-功能"><a href="#step2-实现-cmdAdd-功能" class="headerlink" title="step2: 实现 cmdAdd 功能"></a><strong>step2: 实现 cmdAdd 功能</strong></h3><p>本文的目的还是在于理清楚 cni 执行的底层逻辑，所以就不深入探究 cni 的多样功能实现，所以以创建一个 Linux 网桥为目标，具体代码逻辑如下：</p><ol><li>从配置中读取网桥信息。</li><li>获取我们想要使用的网桥名称。</li><li>如果系统中不存在该网桥，则创建它。</li></ol><p>由于 cni 的框架里面将配置内容以字节数组的形式存储在 CmdArgs 对象中，所以我们也应该创建一个结构来解码这些字节数组的数据，数据格式需要兼容规范的各类对象。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单的网桥结构</span></span><br><span class="line"><span class="keyword">type</span> SimpleBridge <span class="keyword">struct</span> &#123;</span><br><span class="line">BridgeName <span class="type">string</span> <span class="string">`json:&quot;bridgeName&quot;`</span></span><br><span class="line">IP         <span class="type">string</span> <span class="string">`json:&quot;ip&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在cmdAdd中解析传入的参数内容</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cmdAdd</span><span class="params">(args *skel.CmdArgs)</span></span> <span class="type">error</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当把配置文件中的数据转化为代码当中的数据结构，接下来我们就需要使用这些数据调用内核接口创建对应的内核资源。就但从目前的实现目标创建 Linux 网桥来说，可以通过原始的 os.Exec 创建，不过这样就需要去深入到不同操作系统和内核的功能实现上，为覆盖这部分的复杂性，我们就直接借用开源的调用来实现这部分的功能</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">1. 准备好我们想要的 netlink.Bridge 对象。</span></span><br><span class="line"><span class="comment">2. 创建网桥对象</span></span><br><span class="line"><span class="comment">3. 设置Linux网桥参数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">br := &amp;netlink.Bridge&#123;</span><br><span class="line">LinkAttrs: netlink.LinkAttrs&#123;</span><br><span class="line">Name: sb.BridgeName,</span><br><span class="line">MTU:  <span class="number">1500</span>,</span><br><span class="line"><span class="comment">// Let kernel use default txqueuelen; leaving it unset</span></span><br><span class="line"><span class="comment">// means 0, and a zero-length TX queue messes up FIFO</span></span><br><span class="line"><span class="comment">// traffic shapers which use TX queue length as the</span></span><br><span class="line"><span class="comment">// default packet limit</span></span><br><span class="line">TxQLen: <span class="number">-1</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err := netlink.LinkAdd(br)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; err != syscall.EEXIST &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := netlink.LinkSetUp(br); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>当然， cni 的实质原理就是接入 Linux 内核的调用并创建内核资源，所以需要调用借助一些相关的调用，上述代码使用的是 cni 官方整理 <code>github.com/containernetworking/cni/pkg/skel</code> 。除此之外，本文还收集了相关的一些 Go 仓库来帮助接下来的项目推进。<br><a href="https://github.com/vishvananda/netlink">netlink</a><br><a href="https://github.com/containerd/go-cni/tree/main">go-cni</a><br><a href="https://github.com/containerd/go-cni/tree/main">intel-cni</a><br><a href="https://github.com/containerd/go-cni/tree/main">sr-cni</a></p></blockquote><p>到这一步，代码就完成了对内核资源的创建和修改，接下来就是将这些将这些资源分配到需求的容器网络上。通过对于 Linux 网络的学习，我们可以想到一个非常简单的方法就是创建 veth 设备并将一端放入容器中，另一端插入到创建的网桥当中，这样网桥所连接的容器就都相当于共享同一个二层设备，划分到同一个子网当中。实际上大部分的 cni 也是同样的操作，不过仅仅设置一个单网桥对于高速网络或者是多功能多层次网络的服务可能稍显不足，这部分的功能会使用 eBPF 来作为补足。</p><p>说干就干，我们整理出一下需要继续添加到代码工程当中的逻辑：</p><ol><li>从我们之前创建的Bridge中获取Bridge对象</li><li>获取容器的命名空间</li><li>在容器上创建一个 veth，并将主机端 veth 移至主机 ns。</li><li>将主机端 veth 附加到 linux bridge 上</li></ol><p>在这个过程当中有一些地方需要注意：</p><ul><li>需要检验已创建的网络资源，避免冲突</li><li>获取并处理容器的网络空间</li></ul><p>这些问题如果是单独实现一个独立的 cni 插件，那么就不可避免需要考虑环境问题。(1) 怎样与其他的 cni 功能兼容或者是当检验到节点上有使用其他的 cni 插件，需要提醒用户卸载其他的 cni 插件再来安装配置. (2) 清除先前的程序遗留的网络配置参数和内容，保证不出现集群网络的资源冲突。(3) 分配资源的对象参数获取，这里其实指的就是容器网络。</p><p>这些麻烦都可以在对内核交互的调用中查询，此外还有其他的需求，也考虑在将来使用 eBPF 来做进一步的开发和补充。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取本地的网络设备情况</span></span><br><span class="line">l, err := netlink.LinkByName(sb.BridgeName)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;could not lookup %q: %v&quot;</span>, sb.BridgeName, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较是否有冲突的问题</span></span><br><span class="line">newBr, ok := l.(*netlink.Bridge)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;%q already exists but is not a bridge&quot;</span>, sb.BridgeName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而对于容器网络信息的获取，在之前的指令中也涉及到<code>CNI_CONTAINERID=ns1 CNI_NETNS=/var/run/netns/ns1</code>,这部分信息可以通过传入的参数获取。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">netns, err := ns.GetNS(args.Netns)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来对于每一个 <code>NetNs</code>对象（也就是容器对象），我们需要为它创建一个 veth 设备，并将它附加到创建的网桥上。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置 Handler ,为调用 handler 的容器创建 veth [此时 veth 的一端在容器内，另一端在 hostNS]</span></span><br><span class="line">hostIface := &amp;current.Interface&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> handler = <span class="function"><span class="keyword">func</span><span class="params">(hostNS ns.NetNS)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">hostVeth, _, err := ip.SetupVeth(args.IfName, <span class="number">1500</span>, hostNS)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">hostIface.Name = hostVeth.Name</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为每一个容器调用 handler</span></span><br><span class="line"><span class="keyword">if</span> err := netns.Do(handler); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取所创建的 Bridge </span></span><br><span class="line">hostVeth, err := netlink.LinkByName(hostIface.Name)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 veth 附加到创建的网桥上</span></span><br><span class="line"><span class="keyword">if</span> err := netlink.LinkSetMaster(hostVeth, newBr); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述过程当中，我们通过 <code>hostIface.Name</code> 获得主机端 veth 对的接口名称，然后将该链接附加到之前创建的 Linux 网桥上； 接着通过调用 <code>netlink.LinkByName</code> 函数从接口名称中获取链接对象, 然后调用 <code>netlink.LinkSetMaster</code> 函数将链接连接到网桥上。</p><blockquote><p>在操作过程中有一个非常重要的关注点： <strong>确保操作系统不会在命名空间的操作中切换线程</strong><br>可以参考 <a href="https://stackoverflow.com/questions/7439608/steps-in-context-switching">steps-in-context-switching</a> </p><p>命名空间操作需要独占访问某些资源，如进程ID（PID）和网络接口。当一个命名空间被创建或销毁时，内核必须确保该命名空间所拥有的资源被正确分配或释放，并且对这些资源的任何操作都是同步的。</p><p>如果操作系统在命名空间操作进行时切换线程，可能会导致资源冲突或竞赛条件，这可能导致不可预测的行为或系统不稳定。例如，如果一个线程正在设置一个新的网络命名空间，而另一个线程同时试图使用同一个网络接口，这可能会导致资源争夺和数据损坏。</p><p>因此，为了确保命名空间操作的完整性和一致性，操作系统必须以原子方式和互斥方式执行命名空间操作。</p></blockquote><p>所以我们使用以下方式限制,具体的使用手册是：<br><a href="https://stackoverflow.com/questions/25361831/benefits-of-runtime-lockosthread-in-golang">benefits-of-runtime-lockosthread-in-golang</a><br><a href="https://pkg.go.dev/runtime">go-pkg-runtime</a></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// this ensures that main runs only on main thread (thread group leader).</span></span><br><span class="line">        <span class="comment">// since namespace ops (unshare, setns) are done for a single thread, we</span></span><br><span class="line">        <span class="comment">// must ensure that the goroutine does not jump from OS thread to thread</span></span><br><span class="line">        runtime.LockOSThread()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过添加上述的代码，我们可以成功给多个 ns 容器提供自己的 veth 设备并接入网桥获取了连通性。然而每个容器依旧是在 L3 不通的，他们并没有唯一可以表示彼此的 IP 地址。 接下来，我们进一步来实验看看如何将 IP 地址分配给各自的容器。</p><p>IP 地址管理在集群中往往是结合 IPAM 插件实现相关的功能，通过接入 k8s apiserver 来同步和获取当前集群内的 IP 地址划分情况以及这些 IP 地址所分配到的节点地址。<br>这里的节点地址是提供给 k8s 建立集群的内网地址，也就是说如果是跨集群的情况，通过这样的方式 ip capsulated 使用的是节点地址，此时如果节点之间二层不可通的话，那么容器之间通过 PodIP 就无法找到彼此。</p><p>不过就本文实现的简易 cni 功能，我们仅通过配置文件来获取容器网络的配置信息，而实现对地址的分配依旧需要借助内核的调用，在此不再重复。但要强调的是，为简单实现，这部分的 IP 支持就仅涉及 IPV4，之后对于 IPV6可能借助 eBPF 实现能够兼容 SRV6 相关特性的 cni， 敬请期待。 </p><p>依据上述的逻辑，我们可以得到接下来的代码实现流程：</p><ol><li>依据配置中生成一个IP对象。</li><li>在目标网络命名空间中调用netlink.AddrAdd。</li></ol><p>那么接着看看 <code>netlink</code>  当中是如何实现他对于地址分配的呢？</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 位于 addr.go</span></span><br><span class="line"><span class="comment">// Addr represents an IP address from netlink. Netlink ip addresses</span></span><br><span class="line"><span class="comment">// include a mask, so it stores the address as a net.IPNet.</span></span><br><span class="line"><span class="keyword">type</span> Addr <span class="keyword">struct</span> &#123;</span><br><span class="line">*net.IPNet</span><br><span class="line">Label       <span class="type">string</span></span><br><span class="line">Flags       <span class="type">int</span></span><br><span class="line">Scope       <span class="type">int</span></span><br><span class="line">Peer        *net.IPNet</span><br><span class="line">Broadcast   net.IP</span><br><span class="line">PreferedLft <span class="type">int</span></span><br><span class="line">ValidLft    <span class="type">int</span></span><br><span class="line">LinkIndex   <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 位于 addr_linux.go</span></span><br><span class="line"><span class="comment">// AddrAdd will add an IP address to a link device.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Equivalent to: `ip addr add $addr dev $link`</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If `addr` is an IPv4 address and the broadcast address is not given, it</span></span><br><span class="line"><span class="comment">// will be automatically computed based on the IP mask if /30 or larger.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddrAdd</span><span class="params">(link Link, addr *Addr)</span></span> <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">return</span> pkgHandle.AddrAdd(link, addr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AddrAdd will add an IP address to a link device.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Equivalent to: `ip addr add $addr dev $link`</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If `addr` is an IPv4 address and the broadcast address is not given, it</span></span><br><span class="line"><span class="comment">// will be automatically computed based on the IP mask if /30 or larger.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Handle)</span></span> AddrAdd(link Link, addr *Addr) <span class="type">error</span> &#123;</span><br><span class="line">req := h.newNetlinkRequest(unix.RTM_NEWADDR, unix.NLM_F_CREATE|unix.NLM_F_EXCL|unix.NLM_F_ACK)</span><br><span class="line"><span class="keyword">return</span> h.addrHandle(link, addr, req)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们使用 golang 提供的 <code>net</code> 包来生成 <code>net.IPNet</code> 类型和它的CIDR形式（IP地址和Mask），然后通过 <code>net.ParseCIDR</code> 来解析配置文件中获取的IP字符串并返回一个 <code>net.IPNet</code> 的指针。而这几步都需要在创建对应网络资源的时候完成绑定，所以我们需要修改前面的处理程序，在创建 veth 时分配 IP 地址。由于从 <code>net.ParseCIDR</code> 得到的 <code>net.IPNet</code> 对象是子网而不是真正的 IP 地址，接下来需要依据此子网生成合适的 IP 地址重新分配。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = <span class="function"><span class="keyword">func</span><span class="params">(hostNS ns.NetNS)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    hostVeth, containerVeth, err := ip.SetupVeth(args.IfName, <span class="number">1500</span>, hostNS)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    hostIface.Name = hostVeth.Name</span><br><span class="line">    <span class="comment">// 在这里创建 IP  地址对象</span></span><br><span class="line">    ipv4Addr, ipv4Net, err := net.ParseCIDR(sb.IP)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    link, err := netlink.LinkByName(containerVeth.Name)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建 IP 地址</span></span><br><span class="line">    ipv4Net.IP = ipv4Addr</span><br><span class="line"></span><br><span class="line">    addr := &amp;netlink.Addr&#123;IPNet: ipv4Net, Label: <span class="string">&quot;&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">if</span> err = netlink.AddrAdd(link, addr); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，一个基础且完整的 <code>cmdAdd</code> 就完成了，我们接着来测试他的功能，通过过以下指令来测试功能</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除先前创建的资源</span></span><br><span class="line">sudo ip netns del ns1</span><br><span class="line">sudo ifconfig test down</span><br><span class="line">sudo brctl delbr test</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重新创建 ns1 来模拟容器</span></span><br><span class="line">sudo ip netns add ns1</span><br><span class="line">go build -o example .</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行 cni 来生成地址</span></span><br><span class="line">echo &quot;Ready to call the cni to create ip for ns1&quot;</span><br><span class="line">sudo CNI_COMMAND=ADD CNI_CONTAINERID=ns1 CNI_NETNS=/var/run/netns/ns1 CNI_IFNAME=eth10 CNI_PATH=`pwd` ./example &lt; config</span><br><span class="line">echo &quot;The CNI has been called, see the following results&quot;</span><br><span class="line">echo &quot;The bridge and the veth has been attatch to&quot;</span><br><span class="line">sudo brctl show test</span><br><span class="line">echo &quot;The interface in the netns&quot;</span><br><span class="line">sudo ip netns exec ns1 ifconfig -a</span><br></pre></td></tr></table></figure><p>执行的结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[root@master knet]# ./run.sh </span><br><span class="line">Cannot remove namespace file &quot;/var/run/netns/ns1&quot;: No such file or directory</span><br><span class="line">test: ERROR while getting interface flags: No such device</span><br><span class="line">bridge test doesn&#x27;t exist; can&#x27;t delete it</span><br><span class="line">Ready to call the cni to create ip for ns1</span><br><span class="line">&#123;test 192.0.2.15/24&#125;</span><br><span class="line">The CNI has been called, see the following results</span><br><span class="line">The bridge and the veth has been attatch to</span><br><span class="line">bridge name     bridge id               STP enabled     interfaces</span><br><span class="line">test            8000.b6e6090625de       no              veth2a9d8a3d</span><br><span class="line">The interface in the netns</span><br><span class="line">eth10: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.0.2.15  netmask 255.255.255.0  broadcast 192.0.2.255</span><br><span class="line">        inet6 fe80::477:7aff:fee3:a9b8  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 06:77:7a:e3:a9:b8  txqueuelen 0  (Ethernet)</span><br><span class="line">        RX packets 1  bytes 90 (90.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 1  bytes 90 (90.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=8&lt;LOOPBACK&gt;  mtu 65536</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure><p>可以看到IP地址已经设置到了接口eth10上，接着我们使用下面的命令将IP地址设置到linux网桥上，并使用ping命令来检查主机和目标网络命名空间之间的网络连接情况。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@master knet]# sudo ifconfig test 192.0.2.1</span><br><span class="line">[root@master knet]# sudo ip netns exec ns1 ping 192.0.2.1</span><br><span class="line">PING 192.0.2.1 (192.0.2.1) 56(84) bytes of data.</span><br><span class="line">64 bytes from 192.0.2.1: icmp_seq=1 ttl=64 time=0.077 ms</span><br><span class="line">64 bytes from 192.0.2.1: icmp_seq=2 ttl=64 time=0.044 ms</span><br><span class="line">64 bytes from 192.0.2.1: icmp_seq=3 ttl=64 time=0.053 ms</span><br><span class="line">64 bytes from 192.0.2.1: icmp_seq=4 ttl=64 time=0.045 ms</span><br><span class="line">^C</span><br><span class="line">--- 192.0.2.1 ping statistics ---</span><br><span class="line">4 packets transmitted, 4 received, 0% packet loss, ti</span><br></pre></td></tr></table></figure><blockquote><p>主要参考文章：<br><a href="https://www.hwchiu.com/introduce-cni-iii.html">Container Network Interface</a><br><a href="https://morven.life/posts/create-your-own-cni-with-golang/">Create your CNI </a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;使用 Golang 实现一个简易的 CNI&lt;br&gt;对于 CNI 的功能实现将按照循序渐进的方式来进行&lt;br&gt;实现目标&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;依据 config 文件创建 bridge 对象并分配 ns 对应的 ip 地址&lt;/li&gt;
&lt;li&gt;提供</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>完美主义的根源</title>
    <link href="http://ideameshdyx.github.io/2023/05/15/Book/%E5%A6%82%E4%BD%95%E6%88%90%E4%B8%BA%E4%B8%8D%E5%AE%8C%E7%BE%8E%E4%B8%BB%E4%B9%89%E8%80%85/%E5%AE%8C%E7%BE%8E%E4%B8%BB%E4%B9%89%E7%9A%84%E6%A0%B9%E6%BA%90/"/>
    <id>http://ideameshdyx.github.io/2023/05/15/Book/%E5%A6%82%E4%BD%95%E6%88%90%E4%B8%BA%E4%B8%8D%E5%AE%8C%E7%BE%8E%E4%B8%BB%E4%B9%89%E8%80%85/%E5%AE%8C%E7%BE%8E%E4%B8%BB%E4%B9%89%E7%9A%84%E6%A0%B9%E6%BA%90/</id>
    <published>2023-05-15T15:40:37.000Z</published>
    <updated>2023-07-12T07:24:11.034Z</updated>
    
    <content type="html"><![CDATA[<h2 id="完美主义的根源"><a href="#完美主义的根源" class="headerlink" title="完美主义的根源"></a>完美主义的根源</h2><p>缺乏安全感</p><p>自卑情结（inferiority complex）</p><blockquote><p>自卑心理和缺乏安全感一样，会令你对自己的缺陷高度敏感。你会一直小心翼翼，认为这样就会避免犯错。这或许能够给你一些虚假的安全感，但是，要想获得真正地获得安全感，你需要了解并接受真正的自己。</p><p>如果你能够接受自己，包括自己的缺点，即使遭遇最为严厉的批评，你也有力量捍卫自己。</p></blockquote><p>书中虽然详述了自卑情结的祸害，却没有更多地分析产生自卑情结的原因。</p><p>导致自卑情结和缺乏安全感的原因有很多，依照我的看法，外界因素占比较多。不稳定的家庭环境，不充足的教育背景，不契合的生活族群，诸多种种都会导致个人的自卑。</p><p>从家庭环境来说，最主要的原因并不是物质条件的匮乏或者充裕，而是父母价值观的熏陶，这部分的自卑来源于自我定位和认知上的<strong>焦虑</strong>。作为评价自我最重要的一环，价值观的塑造时时刻刻都在影响着个人的发展。从中国近代直至现今的家庭环境来说，往往总是物质条件充裕的家庭更愿意指导孩子去追求实现自我和精神发展上的条件，衡量成功与否在于是否做出了什么；相较之下贫苦的家庭则更可能面临着教育经历较差的父母，受限于物理条件的制约，他们更加追捧于财富和权力。如此这些自认为失败的人生经历和教训，以一种代代相传的方式侵染着其子孙，成功与否就看是否出名了，是否有钱了，是否能把其他人踩在脚下了。当然，也并非所有的家庭都是这样，物质条件充裕但仍旧贪婪追求垄断的氏族，物质条件匮乏却见识长远的中低产家庭，以上的情况就存在换位。</p><p>但不论如何，有着较强自卑心理的孩子，其父母所灌输的价值观和自我衡量的方式必定是更加偏向于物质层面和外界条件的。诚然，这样的价值观更加符合资本发展积累和自然优胜劣汰的逻辑，可能会在一定程度上有着较高的竞争力，但在我看来，这样的追求并没有把人作为人来对待。父母是否想过，为什么想要一个孩子，为什么要抚养他长大，为什么期望着他成长之后的人生呢？</p><p>从教育背景来说，核心在于所遇到的导师教育的态度和方式之上。首先要明确的是，教育背景不论好坏学校，只看主导老师的能力强弱。985、211、双一流但是老师却不知道如何教人，也不明白自己所处位置的重要性；职高甚至是周边的朋友，如师如父，指点迷津；换句话说，教育背景的高低在于老师，选择好的学校和学历更多地是增加遇到好老师的概率，当然社会用工环境和舆论将这个概念泛化，认为好的高校就必定有好的教育，这个想法是错误的。</p><p>师者，我认为需因材施教，需适时施教，需以德为教。自卑心理的产生很大程度上来源自老师的批评和否定，当然这并不是说批评和否定是错误的，但老师不做任何的理解和认知，不去了解学生的努力和困惑，只以结果的好坏和成果的多少来说，这样包工头子似的培育方式就是将错误的完美主义强加于学生身上，久而久之，学生自然产生厌恶，自然害怕失误，自然讨厌学习，因为自己有困惑但无法解决，寻求老师换来的只是一顿批判。学生不是工人，不是下属，不是劳力，师生之间本不该存在雇佣关系和支配关系；犯错是被允许的、疑惑是被允许的、无知也应该是被允许的。如果从小学到高中，再到大学，这样的否定不绝于耳，那这个学生的教育背景就是极其糟糕的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;完美主义的根源&quot;&gt;&lt;a href=&quot;#完美主义的根源&quot; class=&quot;headerlink&quot; title=&quot;完美主义的根源&quot;&gt;&lt;/a&gt;完美主义的根源&lt;/h2&gt;&lt;p&gt;缺乏安全感&lt;/p&gt;
&lt;p&gt;自卑情结（inferiority complex）&lt;/p&gt;
&lt;blockq</summary>
      
    
    
    
    <category term="book" scheme="http://ideameshdyx.github.io/categories/book/"/>
    
    
    <category term="book" scheme="http://ideameshdyx.github.io/tags/book/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 容器网络 — CNI</title>
    <link href="http://ideameshdyx.github.io/2023/04/18/EdgeMesh/cnidev/cnibasic/CNI-Basic/"/>
    <id>http://ideameshdyx.github.io/2023/04/18/EdgeMesh/cnidev/cnibasic/CNI-Basic/</id>
    <published>2023-04-18T21:02:23.000Z</published>
    <updated>2023-07-25T07:56:39.689Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CNI-概述"><a href="#CNI-概述" class="headerlink" title="CNI 概述"></a>CNI 概述</h1><h2 id="什么是-CNI"><a href="#什么是-CNI" class="headerlink" title="什么是 CNI"></a>什么是 CNI</h2><blockquote><p>CNI的全称是 Container Network Interface，它为<strong>容器提供了一种基于插件结构的标准化网络解决方案</strong>。以往，容器的网络层是和具体的底层网络环境高度相关的，不同的网络服务提供商有不同的实现。<strong>CNI从网络服务里抽象出了一套标准接口</strong>，从而屏蔽了上层网络和底层网络提供商的网络实现之间的差异。并且，通过插件结构，它让容器在网络层的具体实现变得可插拔了，所以非常灵活。</p></blockquote><p>首先 CNI 是一套标准接口，它隶属于<a href="https://cncf.io/">CNCF(Cloud Native Computing Foundation)</a>，依照这个标准所实现的为 CNI Plugins, 他们彼此独立，也可以组合起来一起使用，由一组用于配置 Linux 容器的网络接口的规范和库组成，同时还包含了一些插件，CNI 仅关心容器创建时的网络分配，和当容器被删除时释放网络资源。</p><p>其次 依据 CNI 的<a href="https://github.com/containernetworking/cni/blob/master/SPEC.md">规范</a>，CNI 具有以下几点特征：</p><ul><li>CNI 需提供网络管理员<strong>定义网络配置的文件格式</strong></li><li>CNI 需提供 Container Runtime（CRI） 调用功能的<strong>协议/API</strong>。</li><li>当 CNI 被 CRI 调用时，需依据配置文件执行网络配置功能</li><li>CNI 需预留可调用其他插件的能力</li><li>CNI 需规范统一返回给CRI 的数据格式</li></ul><p>依据这样的特征和要求，可以明确实现一个CNI插件需要包含以下部分：</p><ul><li>可执行文件<ul><li>CNI 主进程</li><li>IPAM 等</li></ul></li><li>网络配置文件</li></ul><hr><h2 id="CNI-的功能"><a href="#CNI-的功能" class="headerlink" title="CNI 的功能"></a>CNI 的功能</h2><p>CNI 插件首先得实现一个可以被容器管理系统（CRI），比如rkt、Kubernetes 所调用的可执行文件——cni plugins，这个插件首先需要提供<strong>基础的 Linux 网络联通服务</strong>，比如创建 veth 或者 bridge 并将 veth 对的一端插入容器的 network namespace，一端插入 bridge，使得容器之间可以相互通信。然后<strong>将IP 分配给接口</strong>，并通过调用 **IPAM **插件来设置和管理IP地址，使得集群内的容器IP地址相互不重复，或者是结合其他的插件来实现更加复杂的网络路由管理功能等等。</p><p>那么接下来，依据对于这几项功能的要求，来具体看看 CNI 的标准</p><hr><h2 id="CNI-统一的网络配置文件"><a href="#CNI-统一的网络配置文件" class="headerlink" title="CNI 统一的网络配置文件"></a>CNI 统一的网络配置文件</h2><p>CNI 为容器网络管理员(操作人员、网络插件、网络编排系统)定义了一种网络配置格式。它包含了供 CRI 和 CNI 插件使用的指令。在插件执行时，这种配置格式由 CRI 解释，并转化为代码数据结构，传递给 CNI 插件。</p><p>一般来说配置文件主要是以 JSON 文件为主，且包含以下几个键值：</p><ul><li><code>cniVersion</code>: 指定CNI规范的版本，这样 CRI 和 CNI 才能读懂彼此</li><li><code>Name</code>: 网络名字，这在一个主机（或其他管理域）的所有网络配置中应该是唯一的。必须以一个字母数字字符开始，后面可以选择由一个或多个字母数字字符、下划线、点（.）或连字符（-）的任何组合。</li><li><code>disableCheck</code>: 是否禁用检查网络，如果为true,则 <code>container runtime</code> 不会调用 Check 方法进行网络检查。</li><li><code>plugin</code>: cni插件及其配置列表，可以配置多个插件。</li></ul><p>接着展开说明一下 plugin 当中的参数，这也与实现 CNI 的功能息息相关，CRI 解析出配置文件当中的这个字段，是必须要一个字不漏地完整交给 CNI 插件来做网络管理</p><ol><li><p>必须配置的键值</p><p><code>type</code> :  指定目前系统目录当中所使用的 CNI 插件，一般是 cni 可执行文件的目录索引</p><p>至少得有一个基础的 cni 插件来完成最基础的 Linux 网络配置的功能</p></li><li><p>可选键值，由 CRI 依据协议发送的 request 指定</p><p><code>capabilities</code>:  如果 CNI_ARGS 中没有指定此项功能时候来补充的</p></li><li><p>预留键值，由 CRI 在执行时产生的</p><ul><li><code>runtimeConfig</code> :  比如 CNI 自己设置的 isGateway == true 就表明告诉插件，作为网关，给bridge指定一个IP地址。这样，连接到bridge的容器就可以拿它当网关来用了。</li><li><code>args</code></li><li>或者是任何以 <code>cni.dev/</code>开头的</li></ul></li><li><p>可选键值,由容器网络管理员添加</p><p><code>ipMasq</code>: 为目标网络配上Outbound Masquerade(地址伪装)，即：由容器内部通过网关向外发送数据包时，对数据包的源IP地址进行修改。</p><p>当我们的容器以宿主机作为网关时，这个参数是必须要设置的。否则，从容器内部发出的数据包就没有办法通过网关路由到其他网段。因为容器内部的IP地址无法被目标网段识别，所以这些数据包最终会被丢弃掉。</p><p><code>ipam</code>: PAM(IP Adderss Management)即IP地址管理，提供了一系列方法用于对IP和路由进行管理。实际上，它对应的是由CNI提供的一组标准IPAM插件，比如像host-local，dhcp，static等。如果要对整个集群的地址做管理，让pod具有单独的ip地址，就需要在这里添加额外的插件</p><blockquote><p>例子1当中：</p><ul><li>type：指定所用IPAM插件的名称，在例子里，用的是host-local。</li><li>subnet：为目标网络分配网段，包括网络ID和子网掩码，以CIDR形式标记。在例子里为<code>10.15.10.0/24</code>，也就是目标网段为<code>10.15.10.0</code>，子网掩码为<code>255.255.255.0</code>。</li><li>routes：用于指定路由规则，插件会在容器的路由表里生成相应的规则。其中，dst表示希望到达的目标网段，以CIDR形式标记。gw对应网关的IP地址，也就是要到达目标网段所要经过的“next hop(下一跳)”。如果省略gw的话，那么插件会自动帮容器选择默认网关。在例子里，gw选择的是默认网关，而dst为<code>0.0.0.0/0</code>则代表“任何网络”，表示数据包将通过默认网关发往任何网络。实际上，这对应的是一条默认路由规则，即：当所有其他路由规则都不匹配时，将选择该路由。</li><li>rangeStart：允许分配的IP地址范围的起始值</li><li>rangeEnd：允许分配的IP地址范围的结束值</li><li>gateway：为网关（也就是将要在宿主机上创建的bridge）指定的IP地址。如果省略的话，那么插件会自动从允许分配的IP地址范围内选择起始值作为网关的IP地址。</li></ul></blockquote></li></ol><p>配置文件例子如下：</p><p>例子1：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;cniVersion&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.4.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lab-br0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bridge&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;bridge&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lab-br0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;isGateway&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;ipMasq&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;ipam&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;host-local&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;subnet&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.15.10.0/24&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;routes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">&#123;</span> <span class="attr">&quot;dst&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.0.0.0/0&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;rangeStart&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.15.10.100&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;rangeEnd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.15.10.200&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;gateway&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.15.10.99&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>例子2：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;cniVersion&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;dbnet&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;plugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bridge&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="comment">// plugin specific parameters</span></span><br><span class="line">      <span class="attr">&quot;bridge&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cni0&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;keyA&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;some more&quot;</span><span class="punctuation">,</span> <span class="string">&quot;plugin specific&quot;</span><span class="punctuation">,</span> <span class="string">&quot;configuration&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      </span><br><span class="line">      <span class="attr">&quot;ipam&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;host-local&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="comment">// ipam specific</span></span><br><span class="line">        <span class="attr">&quot;subnet&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.1.0.0/16&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;gateway&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.1.0.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;routes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">&#123;</span><span class="attr">&quot;dst&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.0.0.0/0&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;dns&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;nameservers&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="string">&quot;10.1.0.1&quot;</span> <span class="punctuation">]</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;tuning&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;capabilities&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;mac&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;sysctl&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;net.core.somaxconn&quot;</span><span class="punctuation">:</span> <span class="string">&quot;500&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;portmap&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;capabilities&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;portMappings&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><hr><h2 id="CNI-运行时协议"><a href="#CNI-运行时协议" class="headerlink" title="CNI 运行时协议"></a>CNI 运行时协议</h2><p>CNI协议是基于由 CRI 的调用请求来告诉 CNI 该做些什么。</p><p>主要的协议参数定义如下：</p><ul><li>CNI_COMMAND：表示所需的操作；ADD、DEL、CHECK、或VERSION。</li><li>CNI_CONTAINERID：容器ID。告诉CNI插件，将要加入目标网络的容器所对应的network namespace的ID,容器的唯一的标识符，由 CRI 分配。不能是空的。必须以一个字母数字字符开始，后面可以选择一个或多个字母数字字符、下划线（）、点（.）或连字符（-）的任何组合。</li><li>CNI_NETNS：容器对应的network namespace在宿主机上的文件路径。（例如：/run/netns/[nsname]）。</li><li>CNI_IFNAME：作为veth pair在容器一端的网络接口,一般是在容器内创建的接口的名称；如果 CNI 插件无法使用这个接口名称，那么就必须返回一个错误。</li><li>CNI_ARGS：用户在调用时传入的额外参数。用分号分隔的字母数字键值对；例如，”FOO=BAR;ABC=123”</li><li>CNI_PATH: 表示 CNI 插件可执行文件的路径列表。路径由操作系统特定的列表分隔符分隔；例如Linux上的’:’和Windows上的’；’。</li></ul><p>告诉CNI插件要执行的命令，允许的命令有ADD，DEL，CHECK，VERSION。</p><p>对于支持CNI规范的容器系统而言，当容器启动的时候，系统就会自动调用相应的CNI插件，并设置CNI_COMMAND为ADD。相应地，DEL是在容器被销毁时调用的，用于清除在执行ADD阶段分配的网络资源。CHECK用于检查容器网络是否正常。VERSION则用来显示插件的版本。具体的操作如下：</p><ul><li><p>ADD</p><ul><li><p>将容器添加到网络中，或将新的配置修改应用到已有的集群当中。</p></li><li><p>一个CNI插件在收到ADD命令后，应该选择</p><ul><li><p>在 CNI_NETNS 的容器内创建由 CNI_IFNAME 定义的接口，</p></li><li><p>调整容器内 CNI_NETNS 处由CNI_IFNAME定义的接口的配置</p><p>如果CNI插件成功，必须要返回一个处理结果，要么打印出来，要么修改传入的参数。</p></li></ul></li></ul></li><li><p>DELETE</p><ul><li><p>将容器删除出网络，或将新的配置修改应用到已有的集群当中。</p><p>功能与ADD 相对</p></li></ul></li><li><p>CHECK</p><ul><li>查找类型字段中指定的可执行文件，如果没找到返回错误</li><li>当 Plugins （CNI调用的其他的Plugins）返回错误时，将其返回给调用者</li></ul></li></ul><hr><h2 id="CNI-与插件"><a href="#CNI-与插件" class="headerlink" title="CNI 与插件"></a>CNI 与插件</h2><p>为了解决容器网络的各项需求和问题，将所有的功能单独集中在 CNI 单个程序中是不现实的，而且难以兼容不同的上层系统和底层的网络管理，于是一个显然的想法就是将这些功能独立出来，使用插件（Plugins）的形式来执行。</p><p>一个常见的例子就是 IP 地址管理，这就是IP地址管理插件（IPAM插件），它必须设置容器和虚拟网络设备的接口 ，IP / 子网，网关和路由，然后将此信息返回给“主”插件（CNI本体）来执行，换句话说 IPAM 做逻辑上的网络地址管理然后告诉本体 CNI 去执行 <code>ADD</code>,<code>DELETE</code>。 </p><p>CNI 本体调用这些插件的形式也是通过路径找到这些插件的可执行文件来实现的，一般这些插件的位置也都一起放置在 <code>CNI_PATH</code>之下。同时插件和 CNI 本体都是通过 stdin 接收网络配置，也通过 stdout 输出结果。</p><p>如此看来 CNI 的工作流程就是一条链状的调用过程，但调用链中的每一个可执行程序所接收的配置文件信息都是完整的。</p><hr><h1 id="CNI-配置文件样例"><a href="#CNI-配置文件样例" class="headerlink" title="CNI 配置文件样例"></a>CNI 配置文件样例</h1><blockquote><p>参考<a href="https://github.com/containernetworking/cni/blob/spec-v1.0.0/SPEC.md">cni/SPEC.md at spec-v1.0.0 · containernetworking/cni (github.com)</a> 的 Appendix: Examples</p></blockquote><p>借助 Github 所给的 SPEC 例子，假设目前 CRI 接收到的 json 文件如下，</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;cniVersion&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;dbnet&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;plugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bridge&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="comment">// plugin specific parameters</span></span><br><span class="line">      <span class="attr">&quot;bridge&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cni0&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;keyA&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;some more&quot;</span><span class="punctuation">,</span> <span class="string">&quot;plugin specific&quot;</span><span class="punctuation">,</span> <span class="string">&quot;configuration&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      </span><br><span class="line">      <span class="attr">&quot;ipam&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;host-local&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="comment">// ipam specific</span></span><br><span class="line">        <span class="attr">&quot;subnet&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.1.0.0/16&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;gateway&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.1.0.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;routes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">&#123;</span><span class="attr">&quot;dst&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.0.0.0/0&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;dns&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;nameservers&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="string">&quot;10.1.0.1&quot;</span> <span class="punctuation">]</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;tuning&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;capabilities&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;mac&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;sysctl&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;net.core.somaxconn&quot;</span><span class="punctuation">:</span> <span class="string">&quot;500&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;portmap&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;capabilities&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;portMappings&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="Add-example"><a href="#Add-example" class="headerlink" title="Add example"></a>Add example</h3><p>The container runtime would perform the following steps for the <code>add</code> operation.</p><ol><li>Call the <code>bridge</code> plugin with the following JSON, <code>CNI_COMMAND=ADD</code>:</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;cniVersion&quot;: &quot;1.0.0&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;dbnet&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;bridge&quot;,</span><br><span class="line">    &quot;bridge&quot;: &quot;cni0&quot;,</span><br><span class="line">    &quot;keyA&quot;: [&quot;some more&quot;, &quot;plugin specific&quot;, &quot;configuration&quot;],</span><br><span class="line">    &quot;ipam&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;host-local&quot;,</span><br><span class="line">        &quot;subnet&quot;: &quot;10.1.0.0/16&quot;,</span><br><span class="line">        &quot;gateway&quot;: &quot;10.1.0.1&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;dns&quot;: &#123;</span><br><span class="line">        &quot;nameservers&quot;: [ &quot;10.1.0.1&quot; ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The bridge plugin, as it delegates IPAM to the <code>host-local</code> plugin, would execute the <code>host-local</code> binary with the exact same input, <code>CNI_COMMAND=ADD</code>.</p><p>The <code>host-local</code> plugin returns the following result:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;ips&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;address&quot;: &quot;10.1.0.5/16&quot;,</span><br><span class="line">          &quot;gateway&quot;: &quot;10.1.0.1&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;routes&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;dst&quot;: &quot;0.0.0.0/0&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;dns&quot;: &#123;</span><br><span class="line">      &quot;nameservers&quot;: [ &quot;10.1.0.1&quot; ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The bridge plugin returns the following result, configuring the interface according to the delegated IPAM configuration:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;ips&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;address&quot;: &quot;10.1.0.5/16&quot;,</span><br><span class="line">          &quot;gateway&quot;: &quot;10.1.0.1&quot;,</span><br><span class="line">          &quot;interface&quot;: 2</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;routes&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;dst&quot;: &quot;0.0.0.0/0&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;interfaces&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;cni0&quot;,</span><br><span class="line">            &quot;mac&quot;: &quot;00:11:22:33:44:55&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;veth3243&quot;,</span><br><span class="line">            &quot;mac&quot;: &quot;55:44:33:22:11:11&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;eth0&quot;,</span><br><span class="line">            &quot;mac&quot;: &quot;99:88:77:66:55:44&quot;,</span><br><span class="line">            &quot;sandbox&quot;: &quot;/var/run/netns/blue&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;dns&quot;: &#123;</span><br><span class="line">      &quot;nameservers&quot;: [ &quot;10.1.0.1&quot; ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>Next, call the <code>tuning</code> plugin, with <code>CNI_COMMAND=ADD</code>. Note that <code>prevResult</code> is supplied, along with the <code>mac</code> capability argument. The request configuration passed is:</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;cniVersion&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;name&quot;: &quot;dbnet&quot;,</span><br><span class="line">  &quot;type&quot;: &quot;tuning&quot;,</span><br><span class="line">  &quot;sysctl&quot;: &#123;</span><br><span class="line">    &quot;net.core.somaxconn&quot;: &quot;500&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;runtimeConfig&quot;: &#123;</span><br><span class="line">    &quot;mac&quot;: &quot;00:11:22:33:44:66&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;prevResult&quot;: &#123;</span><br><span class="line">    &quot;ips&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;address&quot;: &quot;10.1.0.5/16&quot;,</span><br><span class="line">          &quot;gateway&quot;: &quot;10.1.0.1&quot;,</span><br><span class="line">          &quot;interface&quot;: 2</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;routes&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;dst&quot;: &quot;0.0.0.0/0&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;interfaces&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;cni0&quot;,</span><br><span class="line">            &quot;mac&quot;: &quot;00:11:22:33:44:55&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;veth3243&quot;,</span><br><span class="line">            &quot;mac&quot;: &quot;55:44:33:22:11:11&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;eth0&quot;,</span><br><span class="line">            &quot;mac&quot;: &quot;99:88:77:66:55:44&quot;,</span><br><span class="line">            &quot;sandbox&quot;: &quot;/var/run/netns/blue&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;dns&quot;: &#123;</span><br><span class="line">      &quot;nameservers&quot;: [ &quot;10.1.0.1&quot; ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The plugin returns the following result. Note that the <strong>mac</strong> has changed.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;ips&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;address&quot;: &quot;10.1.0.5/16&quot;,</span><br><span class="line">          &quot;gateway&quot;: &quot;10.1.0.1&quot;,</span><br><span class="line">          &quot;interface&quot;: 2</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;routes&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;dst&quot;: &quot;0.0.0.0/0&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;interfaces&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;cni0&quot;,</span><br><span class="line">            &quot;mac&quot;: &quot;00:11:22:33:44:55&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;veth3243&quot;,</span><br><span class="line">            &quot;mac&quot;: &quot;55:44:33:22:11:11&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;eth0&quot;,</span><br><span class="line">            &quot;mac&quot;: &quot;00:11:22:33:44:66&quot;,</span><br><span class="line">            &quot;sandbox&quot;: &quot;/var/run/netns/blue&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;dns&quot;: &#123;</span><br><span class="line">      &quot;nameservers&quot;: [ &quot;10.1.0.1&quot; ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>Finally, call the <code>portmap</code> plugin, with <code>CNI_COMMAND=ADD</code>. Note that <code>prevResult</code> matches that returned by <code>tuning</code>:</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;cniVersion&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;name&quot;: &quot;dbnet&quot;,</span><br><span class="line">  &quot;type&quot;: &quot;portmap&quot;,</span><br><span class="line">  &quot;runtimeConfig&quot;: &#123;</span><br><span class="line">    &quot;portMappings&quot; : [</span><br><span class="line">      &#123; &quot;hostPort&quot;: 8080, &quot;containerPort&quot;: 80, &quot;protocol&quot;: &quot;tcp&quot; &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;prevResult&quot;: &#123;</span><br><span class="line">    &quot;ips&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;address&quot;: &quot;10.1.0.5/16&quot;,</span><br><span class="line">          &quot;gateway&quot;: &quot;10.1.0.1&quot;,</span><br><span class="line">          &quot;interface&quot;: 2</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;routes&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;dst&quot;: &quot;0.0.0.0/0&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;interfaces&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;cni0&quot;,</span><br><span class="line">            &quot;mac&quot;: &quot;00:11:22:33:44:55&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;veth3243&quot;,</span><br><span class="line">            &quot;mac&quot;: &quot;55:44:33:22:11:11&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;eth0&quot;,</span><br><span class="line">            &quot;mac&quot;: &quot;00:11:22:33:44:66&quot;,</span><br><span class="line">            &quot;sandbox&quot;: &quot;/var/run/netns/blue&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;dns&quot;: &#123;</span><br><span class="line">      &quot;nameservers&quot;: [ &quot;10.1.0.1&quot; ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The <code>portmap</code> plugin outputs the exact same result as that returned by <code>bridge</code>, as the plugin has not modified anything that would change the result (i.e. it only created iptables rules).</p><h3 id="Check-example"><a href="#Check-example" class="headerlink" title="Check example"></a>Check example</h3><p>Given the previous <em>Add</em>, the container runtime would perform the following steps for the <em>Check</em> action:</p><ol><li>First call the <code>bridge</code> plugin with the following request configuration, including the <code>prevResult</code> field containing the final JSON response from the <em>Add</em> operation, <strong>including the changed mac</strong>. <code>CNI_COMMAND=CHECK</code></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;cniVersion&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;name&quot;: &quot;dbnet&quot;,</span><br><span class="line">  &quot;type&quot;: &quot;bridge&quot;,</span><br><span class="line">  &quot;bridge&quot;: &quot;cni0&quot;,</span><br><span class="line">  &quot;keyA&quot;: [&quot;some more&quot;, &quot;plugin specific&quot;, &quot;configuration&quot;],</span><br><span class="line">  &quot;ipam&quot;: &#123;</span><br><span class="line">    &quot;type&quot;: &quot;host-local&quot;,</span><br><span class="line">    &quot;subnet&quot;: &quot;10.1.0.0/16&quot;,</span><br><span class="line">    &quot;gateway&quot;: &quot;10.1.0.1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dns&quot;: &#123;</span><br><span class="line">    &quot;nameservers&quot;: [ &quot;10.1.0.1&quot; ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;prevResult&quot;: &#123;</span><br><span class="line">    &quot;ips&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;address&quot;: &quot;10.1.0.5/16&quot;,</span><br><span class="line">          &quot;gateway&quot;: &quot;10.1.0.1&quot;,</span><br><span class="line">          &quot;interface&quot;: 2</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;routes&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;dst&quot;: &quot;0.0.0.0/0&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;interfaces&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;cni0&quot;,</span><br><span class="line">            &quot;mac&quot;: &quot;00:11:22:33:44:55&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;veth3243&quot;,</span><br><span class="line">            &quot;mac&quot;: &quot;55:44:33:22:11:11&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;eth0&quot;,</span><br><span class="line">            &quot;mac&quot;: &quot;00:11:22:33:44:66&quot;,</span><br><span class="line">            &quot;sandbox&quot;: &quot;/var/run/netns/blue&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;dns&quot;: &#123;</span><br><span class="line">      &quot;nameservers&quot;: [ &quot;10.1.0.1&quot; ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The <code>bridge</code> plugin, as it delegates IPAM, calls <code>host-local</code>, <code>CNI_COMMAND=CHECK</code>. It returns no error.</p><p>Assuming the <code>bridge</code> plugin is satisfied, it produces no output on standard out and exits with a 0 return code.</p><ol><li>Next call the <code>tuning</code> plugin with the following request configuration:</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;cniVersion&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;name&quot;: &quot;dbnet&quot;,</span><br><span class="line">  &quot;type&quot;: &quot;tuning&quot;,</span><br><span class="line">  &quot;sysctl&quot;: &#123;</span><br><span class="line">    &quot;net.core.somaxconn&quot;: &quot;500&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;runtimeConfig&quot;: &#123;</span><br><span class="line">    &quot;mac&quot;: &quot;00:11:22:33:44:66&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;prevResult&quot;: &#123;</span><br><span class="line">    &quot;ips&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;address&quot;: &quot;10.1.0.5/16&quot;,</span><br><span class="line">          &quot;gateway&quot;: &quot;10.1.0.1&quot;,</span><br><span class="line">          &quot;interface&quot;: 2</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;routes&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;dst&quot;: &quot;0.0.0.0/0&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;interfaces&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;cni0&quot;,</span><br><span class="line">            &quot;mac&quot;: &quot;00:11:22:33:44:55&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;veth3243&quot;,</span><br><span class="line">            &quot;mac&quot;: &quot;55:44:33:22:11:11&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;eth0&quot;,</span><br><span class="line">            &quot;mac&quot;: &quot;00:11:22:33:44:66&quot;,</span><br><span class="line">            &quot;sandbox&quot;: &quot;/var/run/netns/blue&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;dns&quot;: &#123;</span><br><span class="line">      &quot;nameservers&quot;: [ &quot;10.1.0.1&quot; ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Likewise, the <code>tuning</code> plugin exits indicating success.</p><ol><li>Finally, call <code>portmap</code> with the following request configuration:</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;cniVersion&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;name&quot;: &quot;dbnet&quot;,</span><br><span class="line">  &quot;type&quot;: &quot;portmap&quot;,</span><br><span class="line">  &quot;runtimeConfig&quot;: &#123;</span><br><span class="line">    &quot;portMappings&quot; : [</span><br><span class="line">      &#123; &quot;hostPort&quot;: 8080, &quot;containerPort&quot;: 80, &quot;protocol&quot;: &quot;tcp&quot; &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;prevResult&quot;: &#123;</span><br><span class="line">    &quot;ips&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;address&quot;: &quot;10.1.0.5/16&quot;,</span><br><span class="line">          &quot;gateway&quot;: &quot;10.1.0.1&quot;,</span><br><span class="line">          &quot;interface&quot;: 2</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;routes&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;dst&quot;: &quot;0.0.0.0/0&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;interfaces&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;cni0&quot;,</span><br><span class="line">            &quot;mac&quot;: &quot;00:11:22:33:44:55&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;veth3243&quot;,</span><br><span class="line">            &quot;mac&quot;: &quot;55:44:33:22:11:11&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;eth0&quot;,</span><br><span class="line">            &quot;mac&quot;: &quot;00:11:22:33:44:66&quot;,</span><br><span class="line">            &quot;sandbox&quot;: &quot;/var/run/netns/blue&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;dns&quot;: &#123;</span><br><span class="line">      &quot;nameservers&quot;: [ &quot;10.1.0.1&quot; ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Delete-example"><a href="#Delete-example" class="headerlink" title="Delete example"></a>Delete example</h3><p>Given the same network configuration JSON list, the container runtime would perform the following steps for the <em>Delete</em> action. Note that plugins are executed in reverse order from the <em>Add</em> and <em>Check</em> actions.</p><ol><li>First, call <code>portmap</code> with the following request configuration, <code>CNI_COMMAND=DEL</code>:</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;cniVersion&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;name&quot;: &quot;dbnet&quot;,</span><br><span class="line">  &quot;type&quot;: &quot;portmap&quot;,</span><br><span class="line">  &quot;runtimeConfig&quot;: &#123;</span><br><span class="line">    &quot;portMappings&quot; : [</span><br><span class="line">      &#123; &quot;hostPort&quot;: 8080, &quot;containerPort&quot;: 80, &quot;protocol&quot;: &quot;tcp&quot; &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;prevResult&quot;: &#123;</span><br><span class="line">    &quot;ips&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;address&quot;: &quot;10.1.0.5/16&quot;,</span><br><span class="line">          &quot;gateway&quot;: &quot;10.1.0.1&quot;,</span><br><span class="line">          &quot;interface&quot;: 2</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;routes&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;dst&quot;: &quot;0.0.0.0/0&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;interfaces&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;cni0&quot;,</span><br><span class="line">            &quot;mac&quot;: &quot;00:11:22:33:44:55&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;veth3243&quot;,</span><br><span class="line">            &quot;mac&quot;: &quot;55:44:33:22:11:11&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;eth0&quot;,</span><br><span class="line">            &quot;mac&quot;: &quot;00:11:22:33:44:66&quot;,</span><br><span class="line">            &quot;sandbox&quot;: &quot;/var/run/netns/blue&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;dns&quot;: &#123;</span><br><span class="line">      &quot;nameservers&quot;: [ &quot;10.1.0.1&quot; ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>Next, call the <code>tuning</code> plugin with the following request configuration, <code>CNI_COMMAND=DEL</code>:</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;cniVersion&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;name&quot;: &quot;dbnet&quot;,</span><br><span class="line">  &quot;type&quot;: &quot;tuning&quot;,</span><br><span class="line">  &quot;sysctl&quot;: &#123;</span><br><span class="line">    &quot;net.core.somaxconn&quot;: &quot;500&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;runtimeConfig&quot;: &#123;</span><br><span class="line">    &quot;mac&quot;: &quot;00:11:22:33:44:66&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;prevResult&quot;: &#123;</span><br><span class="line">    &quot;ips&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;address&quot;: &quot;10.1.0.5/16&quot;,</span><br><span class="line">          &quot;gateway&quot;: &quot;10.1.0.1&quot;,</span><br><span class="line">          &quot;interface&quot;: 2</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;routes&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;dst&quot;: &quot;0.0.0.0/0&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;interfaces&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;cni0&quot;,</span><br><span class="line">            &quot;mac&quot;: &quot;00:11:22:33:44:55&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;veth3243&quot;,</span><br><span class="line">            &quot;mac&quot;: &quot;55:44:33:22:11:11&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;eth0&quot;,</span><br><span class="line">            &quot;mac&quot;: &quot;00:11:22:33:44:66&quot;,</span><br><span class="line">            &quot;sandbox&quot;: &quot;/var/run/netns/blue&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;dns&quot;: &#123;</span><br><span class="line">      &quot;nameservers&quot;: [ &quot;10.1.0.1&quot; ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>Finally, call <code>bridge</code>:</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;cniVersion&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;name&quot;: &quot;dbnet&quot;,</span><br><span class="line">  &quot;type&quot;: &quot;bridge&quot;,</span><br><span class="line">  &quot;bridge&quot;: &quot;cni0&quot;,</span><br><span class="line">  &quot;keyA&quot;: [&quot;some more&quot;, &quot;plugin specific&quot;, &quot;configuration&quot;],</span><br><span class="line">  &quot;ipam&quot;: &#123;</span><br><span class="line">    &quot;type&quot;: &quot;host-local&quot;,</span><br><span class="line">    &quot;subnet&quot;: &quot;10.1.0.0/16&quot;,</span><br><span class="line">    &quot;gateway&quot;: &quot;10.1.0.1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dns&quot;: &#123;</span><br><span class="line">    &quot;nameservers&quot;: [ &quot;10.1.0.1&quot; ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;prevResult&quot;: &#123;</span><br><span class="line">    &quot;ips&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;address&quot;: &quot;10.1.0.5/16&quot;,</span><br><span class="line">          &quot;gateway&quot;: &quot;10.1.0.1&quot;,</span><br><span class="line">          &quot;interface&quot;: 2</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;routes&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;dst&quot;: &quot;0.0.0.0/0&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;interfaces&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;cni0&quot;,</span><br><span class="line">            &quot;mac&quot;: &quot;00:11:22:33:44:55&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;veth3243&quot;,</span><br><span class="line">            &quot;mac&quot;: &quot;55:44:33:22:11:11&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;eth0&quot;,</span><br><span class="line">            &quot;mac&quot;: &quot;00:11:22:33:44:66&quot;,</span><br><span class="line">            &quot;sandbox&quot;: &quot;/var/run/netns/blue&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;dns&quot;: &#123;</span><br><span class="line">      &quot;nameservers&quot;: [ &quot;10.1.0.1&quot; ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The bridge plugin executes the <code>host-local</code> delegated plugin with <code>CNI_COMMAND=DEL</code> before returning.</p><hr><h2 id="相关仓库及文献"><a href="#相关仓库及文献" class="headerlink" title="相关仓库及文献"></a>相关仓库及文献</h2><p><a href="https://github.com/containernetworking/cni/blob/spec-v1.0.0/SPEC.md">cni/SPEC.md at spec-v1.0.0 · containernetworking/cni (github.com)</a></p><p><a href="https://lengrongfu.github.io/2022-05-11-k8s%E4%B9%8BCNI%E8%A7%84%E8%8C%83%E8%A7%A3%E8%AF%BB/">Kubernetes网络之CNI规范解读 | LRF (lengrongfu.github.io)</a></p><p><a href="https://www.redhat.com/sysadmin/cni-kubernetes">A brief overview of the Container Network Interface (CNI) in Kubernetes | Enable Sysadmin (redhat.com)</a></p><p><a href="https://learn.microsoft.com/en-us/azure/aks/use-byo-cni?tabs=azure-cli">Bring your own Container Network Interface (CNI) plugin - Azure Kubernetes Service | Microsoft Learn</a></p><p><a href="https://kubernetes.io/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/">Network Plugins | Kubernetes</a></p><p><a href="https://www.tigera.io/learn/guides/kubernetes-networking/kubernetes-cni/">Kubernetes CNI Explained (tigera.io)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CNI-概述&quot;&gt;&lt;a href=&quot;#CNI-概述&quot; class=&quot;headerlink&quot; title=&quot;CNI 概述&quot;&gt;&lt;/a&gt;CNI 概述&lt;/h1&gt;&lt;h2 id=&quot;什么是-CNI&quot;&gt;&lt;a href=&quot;#什么是-CNI&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="CNI" scheme="http://ideameshdyx.github.io/categories/CNI/"/>
    
    
    <category term="ospp, CNI, Linux, Spec" scheme="http://ideameshdyx.github.io/tags/ospp-CNI-Linux-Spec/"/>
    
  </entry>
  
  <entry>
    <title>CNI 与  Pod 容器网络—— Linux 网络</title>
    <link href="http://ideameshdyx.github.io/2023/04/18/EdgeMesh/cnidev/cnibasic/CNI-LinuxNetwork/"/>
    <id>http://ideameshdyx.github.io/2023/04/18/EdgeMesh/cnidev/cnibasic/CNI-LinuxNetwork/</id>
    <published>2023-04-18T21:02:23.000Z</published>
    <updated>2023-07-25T07:57:16.292Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CNI-与-Pod-容器网络——-Linux-网络"><a href="#CNI-与-Pod-容器网络——-Linux-网络" class="headerlink" title="CNI 与  Pod 容器网络—— Linux 网络"></a>CNI 与  Pod 容器网络—— Linux 网络</h1><blockquote><p>Pod 容器在 kubernetes 网络中是怎样获取他的地址的呢? </p><p>如何保障 Pod IP 在整个集群当中的唯一性？</p><p>容器流量如何在所给的IP之间相互转发？</p></blockquote><hr><h2 id="从-namespace-开始"><a href="#从-namespace-开始" class="headerlink" title="从 namespace 开始"></a>从 namespace 开始</h2><p>namespace 技术是 Linux 内核提供的一项非常重要的功能，也是容器虚拟化的基础技术，通过构建系统资源的边界，形成一个相对封闭的资源区域，也就是大家认识的容器。Linux 提供的 namespace 包括以下几个方面：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Linux provides the following namespaces:</span><br><span class="line"></span><br><span class="line">Namespace   Constant          Isolates</span><br><span class="line">Cgroup      CLONE_NEWCGROUP   Cgroup root directory</span><br><span class="line">IPC         CLONE_NEWIPC      System V IPC, POSIX message queues</span><br><span class="line">Network     CLONE_NEWNET      Network devices, stacks, ports, etc.</span><br><span class="line">Mount       CLONE_NEWNS       Mount points</span><br><span class="line">PID         CLONE_NEWPID      Process IDs</span><br><span class="line">User        CLONE_NEWUSER     User and group IDs</span><br><span class="line">UTS         CLONE_NEWUTS      Hostname and NIS domain name</span><br></pre></td></tr></table></figure><p>其中网络名字空间(network namespace)是网络虚拟化技术的基础，也是本文最为关注的部分；现有的各项容器技术在实现他们各自的网络连接时所依赖的核心，所以要探究 Pod 网络和 CNI 就必须先从 network namespace 入手。</p><p>在 Linux 系统当中，每一个 network  namespace  都有他自己的网络设置，包括（routing table）路由表、（network interface）网络设备、（IP address）IP 地址等等，这样隔离的一个典型好处就是在不同的network namespace 之下程序可以绑定到同一个端口并保持各自的网络约束不变。与其他的 namespace 一样, network namspace 也可以调用 clone() API创建一个通用的 namespace, 然后传入 CLONE_NEWNET 参数来创建 network namespace。不过就简单配置来说， 可以使用 <strong>netns</strong> 执行对 networkname space  的各项增删改查。</p><p>依据 network namspace 划分出网络区域就像是创建网络通信的对端，但光有隔离出来的对象并不能构成网络；容器还要和外界进行网络联通才能提供服务。与实际网络场景不相同的是，没有物理实体的交换机和路由器，甚至可用的物理网卡也是受限的，那么如何能够在划分隔离出的区域之间提供通信呢？同时如何能够定位这些区域并让数据包能够正确地从一个 netns 中传输到另一个 netns呢？</p><hr><h2 id="veth-的创建和连接"><a href="#veth-的创建和连接" class="headerlink" title="veth 的创建和连接"></a>veth 的创建和连接</h2><p>首先要清楚 veth-pairs， veth 是虚拟以太网卡（virtual Ethernet）的缩写，veth 设备总是成对出现的，也因此称之为 veth-pair。可以通过<code> ip link add veth0 type veth peer name veth1</code> 等指令来创建管理这些虚拟网卡，eg ：<a href="https://morningspace.github.io/tech/k8s-net-docker0/">从docker0开始</a> ，<a href="https://medium.com/techlog/diving-into-linux-networking-and-docker-bridge-veth-and-iptables-a05eb27b1e72">Deep dive into Linux Networking and Docker | Medium</a> 等文章就有讲到其作用和类似操作，不再复述。</p><p>但关键在于对于系统来说，veth到底是什么呢？是一个文件，进程还是描述符,他是否直接和物理网卡相关？它的工作原理是什么，是怎样来让容器之间相互通信的呢？接着来深入研究其内核当中的实现，具体参考：<a href="https://man7.org/linux/man-pages/man4/veth.4.html">veth(4) - Linux manual page (man7.org)</a>，<a href="https://github.com/torvalds/linux/blob/master/drivers/net/veth.c">linux/veth.c at master · torvalds/linux (github.com)</a></p><p>veth的相关源码位于 <code>drivers/net/veth.c</code>中，其中的初始化入口是<code>veth_init</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __init <span class="type">int</span> <span class="title function_">veth_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> rtnl_link_register(&amp;veth_link_ops);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化函数注册了<code>veth_link_ops</code>(veth 设备的操作方法)，它包含了 veth 设备的创建启动和删除等回调函数，具体结构如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtnl_link_ops</span> <span class="title">veth_link_ops</span> =</span> &#123;</span><br><span class="line">.kind= DRV_NAME,</span><br><span class="line">.priv_size= <span class="keyword">sizeof</span>(<span class="keyword">struct</span> veth_priv),</span><br><span class="line">.setup= veth_setup,</span><br><span class="line">.validate= veth_validate,</span><br><span class="line">.newlink= veth_newlink,</span><br><span class="line">.dellink= veth_dellink,</span><br><span class="line">.policy= veth_policy,</span><br><span class="line">.maxtype= VETH_INFO_MAX,</span><br><span class="line">.get_link_net= veth_get_link_net,</span><br><span class="line">.get_num_tx_queues= veth_get_num_queues,</span><br><span class="line">.get_num_rx_queues= veth_get_num_queues,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从 <code>kind</code> 到 <code>setup</code> 都是创建对应的数据结构并写入常量参数,所以创建的关键还是在 <code>veth_newlink</code>,<code>veth_dellink</code>，但二者的执行逻辑相关，所以只看其中一个。 </p><p>首先是 <code>veth_newlink</code>, 不过他的实现较长，只能抓取一部分关键拆分开来看：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">veth_newlink</span><span class="params">(<span class="keyword">struct</span> net *src_net, <span class="keyword">struct</span> net_device *dev,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> nlattr *tb[], <span class="keyword">struct</span> nlattr *data[],</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> netlink_ext_ack *extack)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 由于虚拟网络设备对是由两个网络设备组成,</span></span><br><span class="line">    <span class="comment">// dev 是虚拟网络设备对的其中一个网络设备，不可能创建单独的设备，那就需要创建一个临时的对端 peer</span></span><br><span class="line">    <span class="comment">// 因而调用 rtnl_create_link 函数创建对端网络设备的逻辑对象 peer </span></span><br><span class="line">peer = rtnl_create_link(net, ifname, name_assign_type,</span><br><span class="line">&amp;veth_link_ops, tbp, extack);</span><br><span class="line">err = register_netdevice(peer);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 注册 dev 对象，本质上就在内存里面建立一个 struct 并将信息从文件映射过去</span></span><br><span class="line">err = register_netdevice(dev);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 把 peer 和 dev 关联到一起</span></span><br><span class="line">priv = netdev_priv(dev);               <span class="comment">// 获取 dev 的私有数据部分</span></span><br><span class="line">rcu_assign_pointer(priv-&gt;peer, peer);  <span class="comment">// 将其 peer 字段指向 dev</span></span><br><span class="line">err = veth_init_queues(dev, tb);</span><br><span class="line">priv = netdev_priv(peer);              <span class="comment">// 获取 peer 的私有数据部分</span></span><br><span class="line">rcu_assign_pointer(priv-&gt;peer, dev);   <span class="comment">// 将其 peer 字段指向 dev</span></span><br><span class="line">    ...</span><br><span class="line">err = veth_init_queues(peer, tb);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加 XDP 访问支持 --&gt; veth 在内核运行流程中接近网卡</span></span><br><span class="line">    ...</span><br><span class="line"><span class="comment">/* update XDP supported features */</span></span><br><span class="line">veth_set_xdp_features(dev);</span><br><span class="line">veth_set_xdp_features(peer);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>veth_newlink</code>当中通过**<code>register_netdevice</code>** 注册了两个网络虚拟设备： <code>peer</code> 和 <code>dev</code>，并通过让 <code>dev</code> 的 peer 指针指向创建的 peer，让<code>peer</code> 的 peer  指针指向 dev，来完成了 veth 设备的结对。这个过程是符合 veth 的工作逻辑的，由于  veth 总是成对出现，所以在生成新的 veth 时候就需要指定它所连接对端  peer，当然这个过程发生在内核运行当中，并不是有物理上的连接关系，直白来说就是依据文件信息写入到内存，开辟一个空间来存储对应的信息，然后修改指针指向来表示连接关系。</p><p>创建完成之后，veth 又是怎么来传输数据的呢？回到之前的 <code>veth_setup</code>,启动 veth 的流程，也是将各类函数注册指定到 veth 对象当中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">veth_setup</span><span class="params">(<span class="keyword">struct</span> net_device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">ether_setup(dev);</span><br><span class="line">    ...</span><br><span class="line">dev-&gt;netdev_ops = &amp;veth_netdev_ops;</span><br><span class="line">dev-&gt;xdp_metadata_ops = &amp;veth_xdp_metadata_ops;</span><br><span class="line">dev-&gt;ethtool_ops = &amp;veth_ethtool_ops;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到是 veth 对象的操作列表包含三类：<code>veth_netdev_ops</code>,<code>veth_xdp_metadata_ops</code>,<code>veth_ethtool_ops</code>, 具体的列表如下：</p><p>net_device_ops 结构是网络设备的操作函数集结构, 包含了 Linux 网络设备对象的各项操作行为列表，也是  veth 对象调用实现功能的具体行为。</p><p>从以下列表其实可以知道，Linux 设备是通用一个网卡的代码数据操作流程及对象的，以下的操作函数对于 ebpf xdp 程序直接操作有一定参考，是EdgeMesh 为来优化的对象，故进一步深入探究。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_device_ops</span> <span class="title">veth_netdev_ops</span> =</span> &#123;</span><br><span class="line">.ndo_init            = veth_dev_init,</span><br><span class="line">.ndo_open            = veth_open,</span><br><span class="line">.ndo_stop            = veth_close,</span><br><span class="line">.ndo_start_xmit      = veth_xmit,</span><br><span class="line">.ndo_get_stats64     = veth_get_stats64,</span><br><span class="line">.ndo_set_rx_mode     = veth_set_multicast_list,</span><br><span class="line">.ndo_set_mac_address = eth_mac_addr,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NET_POLL_CONTROLLER</span></span><br><span class="line">.ndo_poll_controller= veth_poll_controller,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">.ndo_get_iflink= veth_get_iflink,</span><br><span class="line">.ndo_fix_features= veth_fix_features,</span><br><span class="line">.ndo_set_features= veth_set_features,</span><br><span class="line">.ndo_features_check= passthru_features_check,</span><br><span class="line">.ndo_set_rx_headroom= veth_set_rx_headroom,</span><br><span class="line">.ndo_bpf= veth_xdp,</span><br><span class="line">.ndo_xdp_xmit= veth_ndo_xdp_xmit,</span><br><span class="line">.ndo_get_peer_dev= veth_peer_dev,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这些函数的具体作用如下整理：</p><ul><li><p><code>ndo_init</code>: 该函数指向 <code>veth_dev_init</code>，网络设备初始化函数，由驱动程序实现，在网卡设备分配之后调用。</p></li><li><p><code>ndo_open</code>: 该函数指向 <code>veth_open</code>，被调用以打开虚拟网络设备并将其加入网络协议栈，由驱动程序实现，用于开启网络设备并为进程提供网络访问。</p></li><li><p><code>ndo_stop</code>：该函数指向 <code>veth_close</code>，由驱动程序实现，被调用以停止虚拟网络设备并将其从网络协议栈中移除。</p></li><li><p>==<code>ndo_start_xmit</code>：该函数指向 <code>veth_xmit</code>，由驱动程序实现，用于将给定的网络数据帧发送到指定的网络设备上。==</p></li><li><p><code>ndo_get_stats64</code>：该函数指向 <code>veth_get_stats64</code>，由驱动程序实现，用于获取虚拟网络设备当前的统计信息。</p></li><li><p><code>ndo_set_rx_mode</code>：该函数指向 <code>veth_set_multicast_list</code>，由驱动程序实现，用于设置网络设备接收模式。</p></li><li><p><code>ndo_set_mac_address</code>：该函数指向 <code>eth_mac_addr</code>，用于设置虚拟网络设备的MAC地址。</p></li><li><p><code>ndo_poll_controller</code>：该函数指向 <code>veth_poll_controller</code>，由驱动程序实现，veth调用之后触发软中断从 Ringbuffer 当中 poll 数据包</p></li><li><p><code>ndo_get_iflink</code>：该函数指向 <code>veth_get_iflink</code>，用于获取虚拟网络设备的网络接口索引号。</p></li><li><p><code>ndo_fix_features</code>：该函数指向 <code>veth_fix_features</code>，用于设置虚拟网络设备的特性参数；</p></li><li><p><code>ndo_set_features</code>：该函数指向 <code>veth_set_features</code>，用于修改或更新虚拟网络设备已经打开的特性参数。</p></li><li><p><code>ndo_features_check</code>：该函数指向 <code>passthru_features_check</code>，检查虚拟网络设备是否包含由 ETS（Enhanced Traffic Service）要求的特征。</p></li><li><p><code>ndo_set_rx_headroom</code>: 该函数指向 <code>veth_set_rx_headroom</code>，用于设置虚拟网络设备中下行数据帧包头部的大小。</p></li><li><p><code>ndo_bpf</code>：该函数指向 <code>veth_xdp</code>，用于添加eBPF扩展程序入口并进行初始化。</p></li><li><p><code>ndo_xdp_xmit</code>: 该函数指向 <code>veth_ndo_xdp_xmit</code>，驱动程序的XDP传输方法入口，将网络数据帧发送到用户提供的XDP扩展程序。</p></li><li><p><code>ndo_get_peer_dev</code>: 该函数指向 <code>veth_peer_dev</code>，用于获取与虚拟网络设备配对的网络设备。 </p></li></ul><p><code>ethtool_ops</code>结构则代表了与<code>ethtool</code>工具相关的网络设备操作函数集合。<code>ethtool</code>用于获取和设置与<code>ethtool</code>兼容设备的驱动程序和硬件信息，同时实现均衡网速，流量控制等功能。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">ethtool_ops</span> <span class="title">veth_ethtool_ops</span> =</span> &#123;</span><br><span class="line">.get_drvinfo= veth_get_drvinfo,</span><br><span class="line">.get_link= ethtool_op_get_link,</span><br><span class="line">.get_strings= veth_get_strings,</span><br><span class="line">.get_sset_count= veth_get_sset_count,</span><br><span class="line">.get_ethtool_stats= veth_get_ethtool_stats,</span><br><span class="line">.get_link_ksettings= veth_get_link_ksettings,</span><br><span class="line">.get_ts_info= ethtool_op_get_ts_info,</span><br><span class="line">.get_channels= veth_get_channels,</span><br><span class="line">.set_channels= veth_set_channels,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>xdp_metadata_ops</code>结构体定义了XDP（eBPF based packet processing）元数据的操作集合，在实现高性能网络数据包处理、过滤和转发的过程中起到重要作用。该操作集与XDP引擎密切相关，包括xsk_frame_parse（对接收的数据包的元数据进行解析）和xsk_frame_init（初始化元数据）等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">xdp_metadata_ops</span> <span class="title">veth_xdp_metadata_ops</span> =</span> &#123;</span><br><span class="line">.xmo_rx_timestamp= veth_xdp_rx_timestamp,</span><br><span class="line">.xmo_rx_hash= veth_xdp_rx_hash,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p><code>xmo_rx_timestamp</code> ： 该函数指针指向 <code>veth_xdp_rx_timestamp</code> 函数，用于获取 XDP 包的接收时间戳，即处理 XDP 包的内核进程把包抓取的时间。该时间可以在 eBPF 程序中使用，例如可用于实现延迟测量(metric)，排除处理器竞争以及路由表测量等。</p></li><li><p><code>xmo_rx_hash</code>：该函数指针指向 <code>veth_xdp_rx_hash</code>，用于获取 XDP 数据包的接收哈希值。通过接收哈希值，可以在 eBPF 中就各个数据包的接收位置和网络环境进行更好的控制和调节，以优化网络性能。例如在基于哈希的负载均衡中，可以使用哈希值来决定要将数据包路由到哪个接收 CPU 或内核上。</p></li></ul><p>在 Linux 中，这些函数指针被定义为可选项，也就是说并非每个驱动程序都会实现这两个函数指针。<code>xdp_metadata_ops</code> 使驱动程序与 eBPF程序 在处理特定的数据包和流量时更加灵活；但反过来说也需要配备一定的环境才能够实现这些调用的功能。</p><p>到这里，veth 的创建和各项功能在 Linux 视角的样子就全部呈现了，总的来说 veth 本身是 Linux 中创建的 <code>net_device</code> 结构，通过注册所需的初始化和操作行为等特定函数以及对其进行相应的参数配置，最终实例化为 veth 对象，用于虚拟网络的构建。同时更明确了 veth 是工作在二层的数据结构，他传输数据会调用驱动程序实现的 <code>ndo_start_xmit</code>函数，在指定了对端之后，数据包发送会存入 skb 并插入 <code>softnet_data-&gt;input_pkt_queue</code>中，出发软中断，接下来就是对称一般的内核接收过程。</p><hr><h2 id="网桥的连接和传输"><a href="#网桥的连接和传输" class="headerlink" title="网桥的连接和传输"></a>网桥的连接和传输</h2><p>veth 可以感性地认知为网卡，它给予了所划分出的 network namspace 一个出入的门，此前的结构如果将 veth 分别指向两个网络空间，就能够实现这二者的通信，但是当所划分的网络空间区域增加的时候，这样子点对点的连接方式显然就很难支撑了。</p><p>这样就需要解决单节点大量容器之间的网络互连问题。</p><p>参考实际物理网络的结构，Linux 实现并提供了一个完全由软件虚拟出来的交换机，它可以提供很多的虚拟端口，把许多的 veth 连接在一个平面的网络，通过自己的转发功能让虚拟机网卡之间可以通信，这个技术就叫做 bridge。</p><p>如何使用 bridge 连接不同的网络空间呢？<a href="https://developers.redhat.com/blog/2018/10/22/introduction-to-linux-interfaces-for-virtual-networking#team_device">Introduction to Linux interfaces for virtual networking | Red Hat Developer</a>，<a href="https://dev.to/arriqaaq/diving-into-linux-networking-and-docker-bridge-veth-and-iptables-419a">Deep dive into Linux Networking and Docker - Bridge, vETH and IPTables - DEV Community</a>  等文章也有详尽阐述，不再复述。</p><p>其中要关注的点是： bridge 的工作源码都是在 /net/core/dev.c 或者是 /net/bridge 目录下面，也就是说他是工作在二层上的设备（这一点与物理交换相同），但所给的实验来验证连通性是依靠 ping 指令从IP来看的，但这并不意味着 bridge 是依靠 IP  来做转发的。</p><p>为了验证这一点，深入来看 bridge 的内核实现</p><p>从外部网络到达节点时候，数据包会被网卡先送到 RingBuffer 中，然后依次经过硬中断、软中断处理，在软中断中再以此把包送到设备层（连接bridge）、协议栈，最后唤醒应用程序。</p><p>从节点内的应用程序到达外部的时候，会从应用程序调用系统调用，在进入协议栈（传输层、网络层），再进入邻居子系统到网络设备子系统（bridge），之后调用驱动程序触发硬中断到网卡。</p><p>在这个过程中，bridge 输入数据包处理工作流程在 <code>/net/bridge/br_input.c</code> 中 <code>br_handle_frame_finish</code>函数里</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">br_handle_frame_finish</span><span class="params">(<span class="keyword">struct</span> net *net, <span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取 veth 所连接的网桥端口以及 bridge 设备</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_port</span> *<span class="title">p</span> =</span> br_port_get_rcu(skb-&gt;dev);</span><br><span class="line">    <span class="comment">// 创建转发表对象</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_fdb_entry</span> *<span class="title">dst</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_mcast_port</span> *<span class="title">pmctx</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_mdb_entry</span> *<span class="title">mdst</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_vlan</span> *<span class="title">vlan</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_bridge</span> *<span class="title">br</span>;</span></span><br><span class="line">br = p-&gt;br;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找并更新转发表，这个转发表使用的地址是eth_hdr(skb)-&gt;h_source</span></span><br><span class="line">br_fdb_update(br, p, eth_hdr(skb)-&gt;h_source,vid, BIT(BR_FDB_LOCKED));</span><br><span class="line">dst = br_fdb_find_rcu(br, eth_hdr(skb)-&gt;h_dest, vid);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 转发</span></span><br><span class="line"><span class="keyword">if</span> (dst) &#123;</span><br><span class="line">br_forward(dst-&gt;dst, skb, local_rcv, <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 本机访问</span></span><br><span class="line"><span class="keyword">if</span> (local_rcv)</span><br><span class="line"><span class="keyword">return</span> br_pass_frame_up(skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中查找和转发使用的地址是eth_hdr(skb)-&gt;h_dest，和物理环境当中的交换机会自动学习端口所对应的节点mac地址一样，软件模拟的 bridge 也会自学习 veth 与 eth_hdr 的对应关系。</p><p>总的来说，当创建了 bridge 并把 veth 设备放入其中，网桥就能够为连接的网络空间提供一个平面的网络连接服务。</p><p>其实到目前为止，所涉及的网络设备都工作在二层，对应到物理环境就是都使用的 MAC 地址进行寻址和交换信息，这样的网络服务就是 Linux  基本网络服务，能够实现单节点上的网络空间连通性。</p><p>可只是这样是无法满足Kubernetes 集群的网络寻址和路由需求的，现有的网络追求平面式的连接服务但是底层依旧还是得通过IP进行寻址；回到容器网络当中，这也意味着希望在容器网络当中的实体能够拥有各自独立、唯一的IP地址，可以是容器、物理机或者是其他的网络设备（比如虚拟路由器）等，容器可以被添加到一个或多个网络中或从一个或多个网络中删除。这就是接下来 CNI 需要满足的功能之一。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CNI-与-Pod-容器网络——-Linux-网络&quot;&gt;&lt;a href=&quot;#CNI-与-Pod-容器网络——-Linux-网络&quot; class=&quot;headerlink&quot; title=&quot;CNI 与  Pod 容器网络—— Linux 网络&quot;&gt;&lt;/a&gt;CNI 与  Pod</summary>
      
    
    
    
    <category term="Linux, Container" scheme="http://ideameshdyx.github.io/categories/Linux-Container/"/>
    
    
    <category term="ospp, Linux, Network" scheme="http://ideameshdyx.github.io/tags/ospp-Linux-Network/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 容器网络 CNI — 现有 CNI 方案的调研</title>
    <link href="http://ideameshdyx.github.io/2023/04/18/EdgeMesh/cnidev/cnibasic/CNI-ReaseachofCni/"/>
    <id>http://ideameshdyx.github.io/2023/04/18/EdgeMesh/cnidev/cnibasic/CNI-ReaseachofCni/</id>
    <published>2023-04-18T21:02:23.000Z</published>
    <updated>2023-07-25T07:57:26.908Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CNI-Plugins-调研"><a href="#CNI-Plugins-调研" class="headerlink" title="CNI Plugins 调研"></a>CNI Plugins 调研</h1><h2 id="1-通用-CNI-插件"><a href="#1-通用-CNI-插件" class="headerlink" title="1. 通用 CNI 插件"></a>1. 通用 CNI 插件</h2><blockquote><p>主要基于 <a href="https://github.com/containernetworking/plugins">containernetworking/plugins: Some reference and example networking plugins, maintained by the CNI team. (github.com)</a> ，<a href="https://www.cni.dev/plugins/current/">CNI</a></p></blockquote><p>由CNI 官方社区维护的 CNI plugins 主要分为三类：</p><ul><li><code>Main: interface-creating</code>: 主进程 CNI ,直接与 Linux 交流，创建接口、网络空间、对象等</li><li><code>IPAM: IP address allocation</code>:  地址管理插件，主要负责 IP 地址管理和分配</li><li><code>Meta: other plugins</code>: 其他的功能插件</li></ul><h3 id="Main-interface-creating-主进程-CNI"><a href="#Main-interface-creating-主进程-CNI" class="headerlink" title="Main: interface-creating  主进程 CNI"></a>Main: interface-creating  主进程 CNI</h3><h3 id="bridge"><a href="#bridge" class="headerlink" title="bridge"></a><a href="https://www.cni.dev/plugins/current/main/bridge/"><code>bridge</code></a></h3><p>​    创建虚拟网桥，并把本机（host）和容器（更准确说是network namespace）添加到其中</p><h3 id="macvlan"><a href="#macvlan" class="headerlink" title="macvlan"></a><a href="https://www.cni.dev/plugins/current/main/macvlan/"><code>macvlan</code></a></h3><p>​    创建一个新的 MAC 地址，将相关容器的所有流量都转发到该地址</p><h3 id="ipvlan"><a href="#ipvlan" class="headerlink" title="ipvlan"></a><a href="https://www.cni.dev/plugins/current/main/ipvlan/"><code>ipvlan</code></a></h3><p>​    类似于 <code>macvlan</code>创建虚拟局域网连接，给容器增加 <a href="https://www.kernel.org/doc/Documentation/networking/ipvlan.txt">ipvlan </a>接口，他主要有两种模式：</p><ul><li>L2 模式：  TX 流程完成在容器内的网络堆栈，之后数据包就会传输到本机队列等待发送，这个模式下容器网络可以进行RX/TX多播和广播（如本机启用的话）。</li><li>L3 模式：容器网络仅能够处理 L3 网络流程，数据包先在容器内处理到 L3，然后再由主设备进行 L2 的处理和路由，再发送出去。这个模式创建的容器网络与本机共享同一个 L2 设备，所以容器网络将不会接收多播/广播流量，也无法发送多播/广播流量</li></ul><p>这个模式创建对象的例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">  +=============================================================+</span><br><span class="line">  |  Host: host1                                                |</span><br><span class="line">  |                                                             |</span><br><span class="line">  |                                                             |</span><br><span class="line">  |   +----------------------+      +----------------------+    |</span><br><span class="line">  |   |   NS:ns0             |      |  NS:ns1              |    |</span><br><span class="line">  |   |                      |      |                      |    |</span><br><span class="line">  |   |                      |      |                      |    |</span><br><span class="line">  |   |        ipvl0         |      |         ipvl1        |    |</span><br><span class="line">  |   +----------#-----------+      +-----------#----------+    |</span><br><span class="line">  |              #                              #               |</span><br><span class="line">  |              ################################               |</span><br><span class="line">  |                              # eth0                         |</span><br><span class="line">  +==============================#==============================+</span><br><span class="line">（a） 创建两个网络命名空间 - ns0、ns1</span><br><span class="line">IP 网络添加 NS0</span><br><span class="line">IP 网络添加 NS1</span><br><span class="line"></span><br><span class="line">（b） 在 eth0（主设备）上创建两个 ipvlan 从站。</span><br><span class="line">IP 链路添加链路 eth0 IPvl0 类型 IPvlan 模式 L2</span><br><span class="line">IP 链路添加链路 eth0 IPvl1 类型 IPvlan 模式 L2</span><br><span class="line"></span><br><span class="line">（c） 将从属服务器分配到相应的网络命名空间</span><br><span class="line">IP link <span class="built_in">set</span> dev ipvl0 netns ns0</span><br><span class="line">IP link <span class="built_in">set</span> dev ipvl1 netns ns1</span><br><span class="line"></span><br><span class="line">（d） 现在切换到命名空间（ns0 或 ns1）以配置从属设备</span><br><span class="line">- 对于 ns0</span><br><span class="line">（<span class="number">1</span>） IP netns exec ns0 bash</span><br><span class="line">（<span class="number">2</span>） IP 链路设置开发 IPvl0 向上</span><br><span class="line">（<span class="number">3</span>） IP 链路设置开发</span><br><span class="line">（<span class="number">4</span>） IP <span class="number">-4</span> 地址添加 <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> 开发 LO</span><br><span class="line">（<span class="number">5</span>） IP <span class="number">-4</span> 地址添加 $IPADDR 开发 IPvl0</span><br><span class="line">（<span class="number">6</span>） IP <span class="number">-4</span> 路由通过$ROUTER开发 IPvl0 添加默认值</span><br><span class="line">- 对于 ns1</span><br><span class="line">（<span class="number">1</span>） IP Netns exec NS1 Bash</span><br><span class="line">（<span class="number">2</span>） IP 链路设置开发 IPvl1 向上</span><br><span class="line">（<span class="number">3</span>） IP 链路设置开发</span><br><span class="line">（<span class="number">4</span>） IP <span class="number">-4</span> 地址添加 <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> 开发 LO</span><br><span class="line">（<span class="number">5</span>） IP <span class="number">-4</span> 地址添加 $IPADDR 开发 IPvl1</span><br><span class="line">（<span class="number">6</span>） IP <span class="number">-4</span> 路由通过$ROUTER开发 IPvl1 添加默认值</span><br></pre></td></tr></table></figure><h3 id="ptp"><a href="#ptp" class="headerlink" title="ptp"></a><a href="https://www.cni.dev/plugins/current/main/ptp/"><code>ptp</code></a></h3><p>​    该插件只会创建 veth 对</p><h3 id="host-device"><a href="#host-device" class="headerlink" title="host-device"></a><a href="https://www.cni.dev/plugins/current/main/host-device/"><code>host-device</code></a></h3><p>​    将现有的网络设备移动到容器中</p><h3 id="vlan"><a href="#vlan" class="headerlink" title="vlan"></a><a href="https://www.cni.dev/plugins/current/main/vlan/"><code>vlan</code></a></h3><p>​    将会创建一个独立于宿主机的 vxlan 网络接口</p><h3 id="Windows-windows-specific"><a href="#Windows-windows-specific" class="headerlink" title="Windows: windows specific"></a>Windows: windows specific</h3><h4 id="win-bridge"><a href="#win-bridge" class="headerlink" title="win-bridge"></a><a href="https://www.cni.dev/plugins/current/main/win-bridge/"><code>win-bridge</code></a></h4><pre><code> 创建虚拟网桥并把本机和（单个）容器连接到这个网桥上</code></pre><h4 id="win-overlay"><a href="#win-overlay" class="headerlink" title="win-overlay"></a><a href="https://www.cni.dev/plugins/current/main/win-overlay/"><code>win-overlay</code></a></h4><p>​    创建 overlay 接口给 容器</p><hr><h2 id="2-IPAM-插件"><a href="#2-IPAM-插件" class="headerlink" title="2. IPAM 插件"></a>2. IPAM 插件</h2><h3 id="dhcp"><a href="#dhcp" class="headerlink" title="dhcp"></a><a href="https://www.cni.dev/plugins/current/ipam/dhcp/"><code>dhcp</code></a></h3><p>​    给对应容器创建守护进程，这个进程用于发送DHCP请求给网关</p><h3 id="host-local"><a href="#host-local" class="headerlink" title="host-local"></a><a href="https://www.cni.dev/plugins/current/ipam/host-local/"><code>host-local</code></a></h3><p>​    依据宿主机的网络信息来分配IP地址，会维护一个描述本机配置的数据文件</p><h3 id="static"><a href="#static" class="headerlink" title="static"></a><a href="https://www.cni.dev/plugins/current/ipam/static/"><code>static</code></a></h3><p>​    分配指定条件的IPv4 和IPv6地址给容器</p><hr><h2 id="3-Meta-多功能插件"><a href="#3-Meta-多功能插件" class="headerlink" title="3. Meta 多功能插件"></a>3. Meta 多功能插件</h2><h3 id="tuning"><a href="#tuning" class="headerlink" title="tuning"></a><a href="https://www.cni.dev/plugins/current/meta/tuning/"><code>tuning</code></a></h3><p>​    改变现有网络接口的 <code>sysctl</code> 参数</p><h3 id="portmap"><a href="#portmap" class="headerlink" title="portmap"></a><a href="https://www.cni.dev/plugins/current/meta/portmap/"><code>portmap</code></a></h3><p>​    使用 iptables 的端口映射插件，建立从宿主机到容器的端口映射</p><h3 id="bandwidth"><a href="#bandwidth" class="headerlink" title="bandwidth"></a><a href="https://www.cni.dev/plugins/current/meta/bandwidth/"><code>bandwidth</code></a></h3><p>​    使用流量控制tbf（token-bucket filter），通过限制入口和出口流量从而控制带宽</p><h3 id="sbr"><a href="#sbr" class="headerlink" title="sbr"></a><a href="https://www.cni.dev/plugins/current/meta/sbr/"><code>sbr</code></a></h3><pre><code> 为网络设备提供源路由的配置功能</code></pre><h3 id="firewall"><a href="#firewall" class="headerlink" title="firewall"></a><a href="https://www.cni.dev/plugins/current/meta/firewall/"><code>firewall</code></a></h3><p>通过 <code>iptables</code> 增添路由规则来控制允许出入容器的流量</p><p>以上这些基础插件的代码位置位于：<a href="https://github.com/containernetworking/plugins/tree/main/plugins">plugins/plugins at main · containernetworking/plugins (github.com)</a></p><h2 id="第三方-CNI-插件"><a href="#第三方-CNI-插件" class="headerlink" title="第三方 CNI 插件"></a>第三方 CNI 插件</h2><p>第三方插件的实现方式较多，尤其是在上述的这些基础 CNI 仅仅能够满足单节点容器地址管理划分创建需求的情况下，依据不同操作系统、不同需求的网络规模和网络规则创建，CNI 的功能和使用也就多种多样了。</p><p>为了能够明确插件的实际功能，本文将主要依据功能的不同给 CNI 做一个标签，并整理他们使用时的规范和方法。</p><h3 id="Project-Calico-a-layer-3-virtual-network"><a href="#Project-Calico-a-layer-3-virtual-network" class="headerlink" title="Project Calico - a layer 3 virtual network"></a><a href="https://github.com/projectcalico/calico">Project Calico - a layer 3 virtual network</a></h3><blockquote></blockquote><p>仓库位置是：<a href="https://github.com/projectcalico/calico/tree/master/cni-plugin">calico/cni-plugin at master · projectcalico/calico (github.com)</a></p><p>相关文档是：<a href="https://docs.tigera.io/calico/latest/reference/configure-cni-plugins">Configure the Calico CNI plugins | Calico Documentation (tigera.io)</a></p><h3 id="Weave-a-multi-host-Docker-network"><a href="#Weave-a-multi-host-Docker-network" class="headerlink" title="Weave - a multi-host Docker network"></a><a href="https://github.com/weaveworks/weave">Weave - a multi-host Docker network</a></h3><p>仓库位置是：<a href="https://github.com/weaveworks/weave/tree/master/plugin">weave/plugin at master · weaveworks/weave (github.com)</a></p><p>相关文档是：<a href="https://www.weave.works/docs/net/latest/kubernetes/">Integrating Kubernetes and Mesos via the CNI Plugin (weave.works)</a></p><h3 id="Cilium-BPF-amp-XDP-for-containers"><a href="#Cilium-BPF-amp-XDP-for-containers" class="headerlink" title="Cilium - BPF &amp; XDP for containers"></a><a href="https://github.com/cilium/cilium">Cilium - BPF &amp; XDP for containers</a></h3><p>仓库位置是：<a href="https://github.com/cilium/cilium/tree/main/plugins/cilium-cni">cilium/plugins/cilium-cni at main · cilium/cilium (github.com)</a></p><p>相关文档是：<a href="https://docs.cilium.io/en/stable/installation/cni-chaining/#id1">CNI Chaining — Cilium 1.13.2 documentation</a></p><h3 id="Contiv-Networking-policy-networking-for-various-use-cases"><a href="#Contiv-Networking-policy-networking-for-various-use-cases" class="headerlink" title="Contiv Networking - policy networking for various use cases"></a><a href="https://github.com/contiv/netplugin">Contiv Networking - policy networking for various use cases</a></h3><p>仓库位置是：<a href="https://github.com/contiv/netplugin">contiv/netplugin: Container networking for various use cases (github.com)</a></p><p>相关文档是：无</p><h3 id="SR-IOV"><a href="#SR-IOV" class="headerlink" title="SR-IOV"></a><a href="https://github.com/hustcat/sriov-cni">SR-IOV</a></h3><p>仓库位置是：<a href="https://github.com/hustcat/sriov-cni">hustcat/sriov-cni: SR-IOV CNI plugin (github.com)</a></p><p>相关文档是：<a href="https://blog.scottlowe.org/2009/12/02/what-is-sr-iov/">What is SR-IOV? - Scott’s Weblog - The weblog of an IT pro focusing on cloud computing, Kubernetes, Linux, containers, and networking (scottlowe.org)</a></p><h3 id="Infoblox-enterprise-IP-address-management-for-containers"><a href="#Infoblox-enterprise-IP-address-management-for-containers" class="headerlink" title="Infoblox - enterprise IP address management for containers"></a><a href="https://github.com/infobloxopen/cni-infoblox">Infoblox - enterprise IP address management for containers</a></h3><p>仓库位置是：<a href="https://github.com/infobloxopen/cni-infoblox">infobloxopen/cni-infoblox: CNI Infoblox Code (github.com)</a></p><p>相关文档是：<a href="https://blogs.infoblox.com/community/cni-networking-and-ipam/">CNI Networking and IPAM (infoblox.com)</a></p><h3 id="Multus-a-Multi-plugin"><a href="#Multus-a-Multi-plugin" class="headerlink" title="Multus - a Multi plugin"></a><a href="https://github.com/k8snetworkplumbingwg/multus-cni">Multus - a Multi plugin</a></h3><p>仓库位置是：<a href="https://github.com/k8snetworkplumbingwg/multus-cni">k8snetworkplumbingwg/multus-cni: A CNI meta-plugin for multi-homed pods in Kubernetes (github.com)</a></p><p>相关文档是：<a href="https://github.com/k8snetworkplumbingwg/multus-cni/blob/master/docs/how-to-use.md">multus-cni/how-to-use.md at master · k8snetworkplumbingwg/multus-cni (github.com)</a></p><h3 id="Romana-Layer-3-CNI-plugin-supporting-network-policy-for-Kubernetes"><a href="#Romana-Layer-3-CNI-plugin-supporting-network-policy-for-Kubernetes" class="headerlink" title="Romana - Layer 3 CNI plugin supporting network policy for Kubernetes"></a><a href="https://github.com/romana/kube">Romana - Layer 3 CNI plugin supporting network policy for Kubernetes</a></h3><p>仓库位置是：<a href="https://github.com/romana/kube">romana/kube: Kubernetes specific components for Romana (github.com)</a></p><p>相关文档是：<a href="https://github.com/romana/romana">romana/romana: The Romana Project - Installation scripts, documentation, issue tracker and wiki. Start here. (github.com)</a></p><h3 id="CNI-Genie-generic-CNI-network-plugin"><a href="#CNI-Genie-generic-CNI-network-plugin" class="headerlink" title="CNI-Genie - generic CNI network plugin"></a><a href="https://github.com/Huawei-PaaS/CNI-Genie">CNI-Genie - generic CNI network plugin</a></h3><p>仓库位置是：<a href="https://github.com/huawei-cloudnative/CNI-Genie">huawei-cloudnative/CNI-Genie: CNI-Genie for choosing pod network of your choice during deployment time. Supported pod networks - Calico, Flannel, Romana, Weave (github.com)</a></p><p>相关文档是：同一仓库</p><h3 id="Nuage-CNI-Nuage-Networks-SDN-plugin-for-network-policy-kubernetes-support"><a href="#Nuage-CNI-Nuage-Networks-SDN-plugin-for-network-policy-kubernetes-support" class="headerlink" title="Nuage CNI - Nuage Networks SDN plugin for network policy kubernetes support"></a><a href="https://github.com/nuagenetworks/nuage-cni">Nuage CNI - Nuage Networks SDN plugin for network policy kubernetes support</a></h3><p>仓库位置是：<a href="https://github.com/nuagenetworks/nuage-cni">nuagenetworks/nuage-cni: Nuage VSP plugin for the CNI project (github.com)</a></p><p>相关文档是：同一仓库</p><h3 id="Silk-a-CNI-plugin-designed-for-Cloud-Foundry"><a href="#Silk-a-CNI-plugin-designed-for-Cloud-Foundry" class="headerlink" title="Silk - a CNI plugin designed for Cloud Foundry"></a><a href="https://github.com/cloudfoundry-incubator/silk">Silk - a CNI plugin designed for Cloud Foundry</a></h3><p>仓库位置是：<a href="https://github.com/cloudfoundry/silk">cloudfoundry/silk: a network fabric for containers. inspired by flannel, designed for Cloud Foundry. (github.com)</a></p><p>相关文档是：同一位置</p><h3 id="Linen-a-CNI-plugin-designed-for-overlay-networks-with-Open-vSwitch-and-fit-in-SDN-OpenFlow-network-environment"><a href="#Linen-a-CNI-plugin-designed-for-overlay-networks-with-Open-vSwitch-and-fit-in-SDN-OpenFlow-network-environment" class="headerlink" title="Linen - a CNI plugin designed for overlay networks with Open vSwitch and fit in SDN/OpenFlow network environment"></a><a href="https://github.com/John-Lin/linen-cni">Linen - a CNI plugin designed for overlay networks with Open vSwitch and fit in SDN/OpenFlow network environment</a></h3><p>仓库位置是：<a href="https://github.com/John-Lin/linen-cni">John-Lin/linen-cni: A CNI plugin designed for overlay networks with Open vSwitch (github.com)</a></p><p>相关文档是：同一仓库</p><h3 id="Vhostuser-a-Dataplane-network-plugin-Supports-OVS-DPDK-amp-VPP"><a href="#Vhostuser-a-Dataplane-network-plugin-Supports-OVS-DPDK-amp-VPP" class="headerlink" title="Vhostuser - a Dataplane network plugin - Supports OVS-DPDK &amp; VPP"></a><a href="https://github.com/intel/vhost-user-net-plugin">Vhostuser - a Dataplane network plugin - Supports OVS-DPDK &amp; VPP</a></h3><p>仓库位置是：<a href="https://github.com/intel/userspace-cni-network-plugin">intel/userspace-cni-network-plugin (github.com)</a></p><p>相关文档是：<a href="https://docs.google.com/document/d/1jAFDNWhf6flTlPHmbWavlyLrkFJtAdQlcOnG3qhRYtU/edit#heading=h.jj69b7nmami">Userspace CNI Design document - Google 文档</a></p><h3 id="Amazon-ECS-CNI-Plugins-a-collection-of-CNI-Plugins-to-configure-containers-with-Amazon-EC2-elastic-network-interfaces-ENIs"><a href="#Amazon-ECS-CNI-Plugins-a-collection-of-CNI-Plugins-to-configure-containers-with-Amazon-EC2-elastic-network-interfaces-ENIs" class="headerlink" title="Amazon ECS CNI Plugins - a collection of CNI Plugins to configure containers with Amazon EC2 elastic network interfaces (ENIs)"></a><a href="https://github.com/aws/amazon-ecs-cni-plugins">Amazon ECS CNI Plugins - a collection of CNI Plugins to configure containers with Amazon EC2 elastic network interfaces (ENIs)</a></h3><p>仓库位置是：<a href="https://github.com/aws/amazon-ecs-cni-plugins">aws/amazon-ecs-cni-plugins: Networking Plugins repository for ECS Task Networking (github.com)</a></p><p>相关文档是：<a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/Welcome.html">What is Amazon Elastic Container Service? - Amazon Elastic Container Service</a></p><h3 id="Bonding-CNI-a-Link-aggregating-plugin-to-address-failover-and-high-availability-network"><a href="#Bonding-CNI-a-Link-aggregating-plugin-to-address-failover-and-high-availability-network" class="headerlink" title="Bonding CNI - a Link aggregating plugin to address failover and high availability network"></a><a href="https://github.com/Intel-Corp/bond-cni">Bonding CNI - a Link aggregating plugin to address failover and high availability network</a></h3><p>仓库位置是：<a href="https://github.com/k8snetworkplumbingwg/bond-cni">k8snetworkplumbingwg/bond-cni: Bond-cni is for fail-over and high availability of networking in cloudnative orchestration (github.com)</a></p><p>相关文档是：同一位置</p><h3 id="ovn-kubernetes-an-container-network-plugin-built-on-Open-vSwitch-OVS-and-Open-Virtual-Networking-OVN-with-support-for-both-Linux-and-Windows"><a href="#ovn-kubernetes-an-container-network-plugin-built-on-Open-vSwitch-OVS-and-Open-Virtual-Networking-OVN-with-support-for-both-Linux-and-Windows" class="headerlink" title="ovn-kubernetes - an container network plugin built on Open vSwitch (OVS) and Open Virtual Networking (OVN) with support for both Linux and Windows"></a><a href="https://github.com/openvswitch/ovn-kubernetes">ovn-kubernetes - an container network plugin built on Open vSwitch (OVS) and Open Virtual Networking (OVN) with support for both Linux and Windows</a></h3><p>仓库位置是：<a href="https://github.com/ovn-org/ovn-kubernetes">ovn-org/ovn-kubernetes: Kubernetes integration for OVN (github.com)</a></p><p>相关文档是：<a href="https://docs.openvswitch.org/en/latest/intro/install/">Installing Open vSwitch — Open vSwitch 3.1.90 documentation</a></p><h3 id="Juniper-Contrail-TungstenFabric-Provides-overlay-SDN-solution-delivering-multicloud-networking-hybrid-cloud-networking-simultaneous-overlay-underlay-support-network-policy-enforcement-network-isolation-service-chaining-and-flexible-load-balancing"><a href="#Juniper-Contrail-TungstenFabric-Provides-overlay-SDN-solution-delivering-multicloud-networking-hybrid-cloud-networking-simultaneous-overlay-underlay-support-network-policy-enforcement-network-isolation-service-chaining-and-flexible-load-balancing" class="headerlink" title="Juniper Contrail / TungstenFabric - Provides overlay SDN solution, delivering multicloud networking, hybrid cloud networking, simultaneous overlay-underlay support, network policy enforcement, network isolation, service chaining and flexible load balancing"></a><a href="https://www.juniper.net/cloud">Juniper Contrail</a> / <a href="https://tungstenfabric.io/">TungstenFabric</a> - Provides overlay SDN solution, delivering multicloud networking, hybrid cloud networking, simultaneous overlay-underlay support, network policy enforcement, network isolation, service chaining and flexible load balancing</h3><p>仓库位置是：<a href="https://www.juniper.net/us/en/it-networking.html">Enterprise IT Networking Products &amp; Solutions | Juniper Networks US</a></p><p>相关文档是：<a href="https://newsroom.juniper.net/news/news-details/2023/Juniper-Networks-Brings-More-Simplicity-Scale-and-Security-to-Enterprise-Networking-with-Three-Step-Campus-Fabric-Workflow-and-New-EX-Distribution-Switch/default.aspx">Juniper Networks Brings More Simplicity, Scale and Security to Enterprise Networking with Three-Step Campus Fabric Workflow and New EX Distribution Switch | Juniper Networks Inc.</a></p><blockquote><p>无法参考，为保证资料完整性留存</p></blockquote><h3 id="Knitter-a-CNI-plugin-supporting-multiple-networking-for-Kubernetes"><a href="#Knitter-a-CNI-plugin-supporting-multiple-networking-for-Kubernetes" class="headerlink" title="Knitter - a CNI plugin supporting multiple networking for Kubernetes"></a><a href="https://github.com/ZTE/Knitter">Knitter - a CNI plugin supporting multiple networking for Kubernetes</a></h3><p>仓库位置是：<a href="https://github.com/ZTE/Knitter">ZTE/Knitter: Kubernetes network solution (github.com)</a></p><p>相关文档是：<a href="https://github.com/ZTE/Knitter/tree/master/docs">Knitter/docs at master · ZTE/Knitter (github.com)</a></p><h3 id="DANM-a-CNI-compliant-networking-solution-for-TelCo-workloads-running-on-Kubernetes"><a href="#DANM-a-CNI-compliant-networking-solution-for-TelCo-workloads-running-on-Kubernetes" class="headerlink" title="DANM - a CNI-compliant networking solution for TelCo workloads running on Kubernetes"></a><a href="https://github.com/nokia/danm">DANM - a CNI-compliant networking solution for TelCo workloads running on Kubernetes</a></h3><p>仓库位置是：<a href="https://github.com/nokia/danm">nokia/danm: TelCo grade network management in a Kubernetes cluster (github.com)</a></p><p>相关文档是：<a href="https://github.com/nokia/danm/blob/master/deployment-guide.md">danm/deployment-guide.md at master · nokia/danm (github.com)</a></p><h3 id="VMware-NSX-–-a-CNI-plugin-that-enables-automated-NSX-L2-L3-networking-and-L4-L7-Load-Balancing-network-isolation-at-the-pod-node-and-cluster-level-and-zero-trust-security-policy-for-your-Kubernetes-cluster"><a href="#VMware-NSX-–-a-CNI-plugin-that-enables-automated-NSX-L2-L3-networking-and-L4-L7-Load-Balancing-network-isolation-at-the-pod-node-and-cluster-level-and-zero-trust-security-policy-for-your-Kubernetes-cluster" class="headerlink" title="VMware NSX – a CNI plugin that enables automated NSX L2/L3 networking and L4/L7 Load Balancing; network isolation at the pod, node, and cluster level; and zero-trust security policy for your Kubernetes cluster."></a><a href="https://docs.vmware.com/en/VMware-NSX-T/2.2/com.vmware.nsxt.ncp_kubernetes.doc/GUID-6AFA724E-BB62-4693-B95C-321E8DDEA7E1.html">VMware NSX – a CNI plugin that enables automated NSX L2/L3 networking and L4/L7 Load Balancing; network isolation at the pod, node, and cluster level; and zero-trust security policy for your Kubernetes cluster.</a></h3><p>仓库位置是：<a href="https://github.com/weaveworks/weave/tree/master/plugin">weave/plugin at master · weaveworks/weave (github.com)</a></p><p>相关文档是：[Integrating Kubernetes and Mesos via the CNI Plugin (weave.works)]</p><h3 id="cni-route-override-a-meta-CNI-plugin-that-override-route-information"><a href="#cni-route-override-a-meta-CNI-plugin-that-override-route-information" class="headerlink" title="cni-route-override - a meta CNI plugin that override route information"></a><a href="https://github.com/redhat-nfvpe/cni-route-override">cni-route-override - a meta CNI plugin that override route information</a></h3><p>仓库位置是：<a href="https://github.com/redhat-nfvpe/cni-route-override">redhat-nfvpe/cni-route-override: CNI plugin to override routes for a container interface (github.com)</a></p><p>相关文档是：同一位置</p><h3 id="Terway-a-collection-of-CNI-Plugins-based-on-alibaba-cloud-VPC-ECS-network-product"><a href="#Terway-a-collection-of-CNI-Plugins-based-on-alibaba-cloud-VPC-ECS-network-product" class="headerlink" title="Terway - a collection of CNI Plugins based on alibaba cloud VPC/ECS network product"></a><a href="https://github.com/AliyunContainerService/terway">Terway - a collection of CNI Plugins based on alibaba cloud VPC/ECS network product</a></h3><p>仓库位置是：<a href="https://github.com/AliyunContainerService/terway">AliyunContainerService/terway: CNI plugin for Alibaba Cloud VPC/ENI (github.com)</a></p><p>相关文档是：同一位置</p><h3 id="Cisco-ACI-CNI-for-on-prem-and-cloud-container-networking-with-consistent-policy-and-security-model"><a href="#Cisco-ACI-CNI-for-on-prem-and-cloud-container-networking-with-consistent-policy-and-security-model" class="headerlink" title="Cisco ACI CNI - for on-prem and cloud container networking with consistent policy and security model."></a><a href="https://github.com/noironetworks/aci-containers">Cisco ACI CNI - for on-prem and cloud container networking with consistent policy and security model.</a></h3><p>仓库位置是：<a href="https://github.com/noironetworks/aci-containers">noironetworks/aci-containers: Plugins for integrating ACI with container orchestration systems (github.com)</a></p><p>相关文档是：同一位置</p><h3 id="Kube-OVN-a-CNI-plugin-that-bases-on-OVN-OVS-and-provides-advanced-features-like-subnet-static-ip-ACL-QoS-etc"><a href="#Kube-OVN-a-CNI-plugin-that-bases-on-OVN-OVS-and-provides-advanced-features-like-subnet-static-ip-ACL-QoS-etc" class="headerlink" title="Kube-OVN - a CNI plugin that bases on OVN/OVS and provides advanced features like subnet, static ip, ACL, QoS, etc."></a><a href="https://github.com/kubeovn/kube-ovn">Kube-OVN - a CNI plugin that bases on OVN/OVS and provides advanced features like subnet, static ip, ACL, QoS, etc.</a></h3><p>仓库位置是：<a href="https://github.com/kubeovn/kube-ovn">kubeovn/kube-ovn: A Bridge between SDN and Cloud Native (Project under CNCF) (github.com)</a></p><p>相关文档是：<a href="https://github.com/kubeovn/kube-ovn/blob/master/docs/install.md">kube-ovn/install.md at master · kubeovn/kube-ovn (github.com)</a></p><h3 id="Project-Antrea-an-Open-vSwitch-k8s-CNI"><a href="#Project-Antrea-an-Open-vSwitch-k8s-CNI" class="headerlink" title="Project Antrea - an Open vSwitch k8s CNI"></a><a href="https://github.com/vmware-tanzu/antrea">Project Antrea - an Open vSwitch k8s CNI</a></h3><p>仓库位置是：<a href="https://github.com/antrea-io/antrea">antrea-io/antrea: Kubernetes networking based on Open vSwitch (github.com)</a></p><p>相关文档是：<a href="https://github.com/antrea-io/antrea/blob/main/docs/getting-started.md">antrea/getting-started.md at main · antrea-io/antrea (github.com)</a></p><h3 id="OVN4NFV-K8S-Plugin-a-OVN-based-CNI-controller-plugin-to-provide-cloud-native-based-Service-function-chaining-SFC-Multiple-OVN-overlay-networking"><a href="#OVN4NFV-K8S-Plugin-a-OVN-based-CNI-controller-plugin-to-provide-cloud-native-based-Service-function-chaining-SFC-Multiple-OVN-overlay-networking" class="headerlink" title="OVN4NFV-K8S-Plugin - a OVN based CNI controller plugin to provide cloud native based Service function chaining (SFC), Multiple OVN overlay networking"></a><a href="https://github.com/opnfv/ovn4nfv-k8s-plugin">OVN4NFV-K8S-Plugin - a OVN based CNI controller plugin to provide cloud native based Service function chaining (SFC), Multiple OVN overlay networking</a></h3><p>仓库位置是：<a href="https://github.com/opnfv/ovn4nfv-k8s-plugin">opnfv/ovn4nfv-k8s-plugin: This repository is archived. Please see https://github.com/akraino-edge-stack/icn-nodus for the latest code.</a></p><p>相关文档是：同一位置</p><blockquote><p>已经关闭</p></blockquote><h3 id="Azure-CNI-a-CNI-plugin-that-natively-extends-Azure-Virtual-Networks-to-containers"><a href="#Azure-CNI-a-CNI-plugin-that-natively-extends-Azure-Virtual-Networks-to-containers" class="headerlink" title="Azure CNI - a CNI plugin that natively extends Azure Virtual Networks to containers"></a><a href="https://github.com/Azure/azure-container-networking">Azure CNI - a CNI plugin that natively extends Azure Virtual Networks to containers</a></h3><p>仓库位置是：<a href="https://github.com/Azure/azure-container-networking">Azure/azure-container-networking: Azure Container Networking Solutions for Linux and Windows Containers (github.com)</a></p><p>相关文档是：<a href="https://github.com/Azure/azure-container-networking/tree/master/docs">azure-container-networking/docs at master · Azure/azure-container-networking (github.com)</a></p><h3 id="Hybridnet-a-CNI-plugin-designed-for-hybrid-clouds-which-provides-both-overlay-and-underlay-networking-for-containers-in-one-or-more-clusters-Overlay-and-underlay-containers-can-run-on-the-same-node-and-have-cluster-wide-bidirectional-network-connectivity"><a href="#Hybridnet-a-CNI-plugin-designed-for-hybrid-clouds-which-provides-both-overlay-and-underlay-networking-for-containers-in-one-or-more-clusters-Overlay-and-underlay-containers-can-run-on-the-same-node-and-have-cluster-wide-bidirectional-network-connectivity" class="headerlink" title="Hybridnet - a CNI plugin designed for hybrid clouds which provides both overlay and underlay networking for containers in one or more clusters. Overlay and underlay containers can run on the same node and have cluster-wide bidirectional network connectivity."></a><a href="https://github.com/alibaba/hybridnet">Hybridnet - a CNI plugin designed for hybrid clouds which provides both overlay and underlay networking for containers in one or more clusters. Overlay and underlay containers can run on the same node and have cluster-wide bidirectional network connectivity.</a></h3><p>仓库位置是：<a href="https://github.com/alibaba/hybridnet">alibaba/hybridnet: A CNI plugin, provides networking environment where overlay and underlay containers can run on the same node and have cluster-wide bidirectional network connectivity. (github.com)</a></p><p>相关文档是：<a href="https://github.com/alibaba/hybridnet/wiki">Home · alibaba/hybridnet Wiki (github.com)</a></p><h3 id="Spiderpool-An-IP-Address-Management-IPAM-CNI-plugin-of-Kubernetes-for-managing-static-ip-for-underlay-network"><a href="#Spiderpool-An-IP-Address-Management-IPAM-CNI-plugin-of-Kubernetes-for-managing-static-ip-for-underlay-network" class="headerlink" title="Spiderpool - An IP Address Management (IPAM) CNI plugin of Kubernetes for managing static ip for underlay network"></a><a href="https://github.com/spidernet-io/spiderpool">Spiderpool - An IP Address Management (IPAM) CNI plugin of Kubernetes for managing static ip for underlay network</a></h3><p>仓库位置是：<a href="https://github.com/spidernet-io/spiderpool">spidernet-io/spiderpool: spiderpool: Kubernetes IPAM for underlay network (github.com)</a></p><p>相关文档是：<a href="https://github.com/spidernet-io/spiderpool/blob/main/docs/usage/install.md">spiderpool/install.md at main · spidernet-io/spiderpool (github.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CNI-Plugins-调研&quot;&gt;&lt;a href=&quot;#CNI-Plugins-调研&quot; class=&quot;headerlink&quot; title=&quot;CNI Plugins 调研&quot;&gt;&lt;/a&gt;CNI Plugins 调研&lt;/h1&gt;&lt;h2 id=&quot;1-通用-CNI-插件&quot;&gt;&lt;a h</summary>
      
    
    
    
    <category term="Linux" scheme="http://ideameshdyx.github.io/categories/Linux/"/>
    
    
    <category term="ospp, edgemesh" scheme="http://ideameshdyx.github.io/tags/ospp-edgemesh/"/>
    
  </entry>
  
  <entry>
    <title>从微习惯到不完美主义</title>
    <link href="http://ideameshdyx.github.io/2023/04/01/Book/%E5%A6%82%E4%BD%95%E6%88%90%E4%B8%BA%E4%B8%8D%E5%AE%8C%E7%BE%8E%E4%B8%BB%E4%B9%89%E8%80%85/%E4%BB%8E%E5%BE%AE%E4%B9%A0%E6%83%AF%E5%88%B0%E4%B8%8D%E5%AE%8C%E7%BE%8E%E4%B8%BB%E4%B9%89/"/>
    <id>http://ideameshdyx.github.io/2023/04/01/Book/%E5%A6%82%E4%BD%95%E6%88%90%E4%B8%BA%E4%B8%8D%E5%AE%8C%E7%BE%8E%E4%B8%BB%E4%B9%89%E8%80%85/%E4%BB%8E%E5%BE%AE%E4%B9%A0%E6%83%AF%E5%88%B0%E4%B8%8D%E5%AE%8C%E7%BE%8E%E4%B8%BB%E4%B9%89/</id>
    <published>2023-04-01T16:46:21.000Z</published>
    <updated>2023-07-12T07:24:11.033Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>近期反省结论 –&gt; 过于追求过程和结果的完美程度，成效并不符合预期，因此针对这个问题进行修正。</p><p>本系列主要摘录书中语句加自己的感悟，贯彻“不完美主义”</p></blockquote><h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><blockquote><p>当购买花束时路过健身房，想要去健身提升自己，但却考虑到自己的装束并不适合运动，也不适合一整套的锻炼，于是放弃。</p></blockquote><p>心里的完美主义看到的是去做一件事不充分的条件，没有满足条件于是不做；但不完美主义看到的是一个健身的机会，不必完全做到到可以就做一部分。</p><p>阻力是不一样的，过程也是不一样的，尽管这样零散的不完美无法达到最优和最高效，但是从0到1，排除阻力，往往是面对拖延和困难最重要的一步。</p><blockquote><p>采纳建议、付诸实践是个人成长中最困难的部分，我们许下的愿望很多的，但真正实现的却很少。</p></blockquote><p>贬低和责备，是必要的，它适用于抑制过高过盛的气焰，能够摆脱浮躁不稳的心态；但却不适合在关键时候和细碎时候使用，开始与尝试，需要的是勇气和信心，越是等待条件越是怀疑自己，越是容易昏头、容易退缩。</p><h2 id="什么是完美主义"><a href="#什么是完美主义" class="headerlink" title="什么是完美主义"></a>什么是完美主义</h2><p>​    追求完美并没有错，完美主义的贯彻，严于律己，推动和逼迫自己，才能够不松懈，所以完美主义作为主旋律是没有错的；可是并不是所有的事情都必须彻底贯彻完美主义，我们是否可以做到整体上的完美主义，局部的不完美主义呢？</p><p>​    就像是我在写这篇博客一样，总想着需要将所读到的数据中好的句子、深入的感悟、句子所在位置、相关引用、句子语法甚至是表述语气，逐字逐句层层琢磨，非得让他毫无遗漏；但这样，光是读一页纸就耗费了许多的精力，如果书籍内容涉及专业领域，代码实验和环境问题又是一笔账，忙来忙去，总感觉做了非常多的事情，但收效并不高。</p><p>​    以往我总想着是不是读书不重要呢，总应该先做重要且紧急的事情。但即便是换了重要的事情，也容易推动缓慢，到头来一些不紧急的事情也变得紧急起来，相对不重要的事情也变得重要起来。</p><p>​    允许完成一件事的不完美，允许改进和成长的空间，允许犯错和失误的自己。现在即便没有设想的那般毫无缺漏，但只要下一步、下一秒有所成长，有所进步就足够了。</p><p>​    计算成长的方式不该是满10进1，而应该是大于即是满足。</p><blockquote><p>如果想要批判完美主义，可以从以下五方面入手：</p><ul><li>过高期待</li><li>纠结不放</li><li>行动顾虑</li></ul></blockquote><blockquote><p>如果你追求完美，将永远无法感到满足</p><p>​                                                            —— 列夫.托尔斯泰</p></blockquote><h3 id="三种完美主义标准"><a href="#三种完美主义标准" class="headerlink" title="三种完美主义标准"></a>三种完美主义标准</h3><blockquote><p>完美主义标准一般有三种：情景、品质与数量</p></blockquote><blockquote><p>完美情景：如果过于追求情景的完美，当事人就会丧失很多情境下行动的机会。</p></blockquote><p>​    设想当中的环境，理想当中的条件，预想之内的行动，去无法获得计划之下的结果，高估了自己？还是小看了任务，事情并不是那么单纯。</p><blockquote><p>资源，时段： 有些人也会应为缺少某些东西而拒绝行动。你是否只愿意身着运动服饰在健身房运动？事实上，你并不需要追求条件上的完美，唯一需要的健身器械就是你自己的身体。</p></blockquote><p>​    工具、条件、准备，或者用我的理解：就是寻找解决一道题目最优的工具和方式；这种对于暴力解法或者是朴实思路的歧视，同时也是对于巧妙方法的高看。</p><p>​    或许有着更加高效的方式和条件方法，但这些方法并不是必要的条件，一味的执着最优，往往连保底都没有。尤其是对于初次、陌生、不熟悉的事物，放下身段，沉下心态，用最不完美的方式开始，也不至于空手而归。</p><blockquote><p>对数量追求完美，指的是那种只要数量达不到预期就无法心满意足的状态。</p></blockquote><blockquote><p>一些目标并非无法完成，而他们之所以会导致完美主义的弊端，是因为这种目标似乎暗示了不如预期的进步就是不够好的。</p></blockquote><blockquote><p>这样的目标就像是撑杆跳：只要不跳过就算失败，只要跳过了就是成功。你跳到多高并不重要，你能不能跳过成了唯一的标准。这种将目标做两极化处理的观点本应鼓励我们朝着目标的方向努力，甚至超越目标，事实上却成了非常低级的策略。</p></blockquote><blockquote><p>完美主义者无法接受微小的价值或进步；他们只看重宏大、顺利、完美的成功。</p></blockquote><p>成败分明的宏大目标比比皆是，但值得肯定的微小进步却不被记录，如果说高楼大厦着实耀眼，但他又何尝不是一砖一瓦累积起来的呢？</p><p>​    虽说书中这里将不完美主义和完美主义对立了起来（或者说译文的表述如此），但完美主义的成败标准也是不可缺少的。人总有松懈的时候，心态膨胀、心性浮躁、情感飘忽，如果没有一个标准或者是结果来导向的话，终难成大事。所以我想，时常的鞭策和逼迫，离开自己的舒适区，以完美主义要求并没有问题；但是自我衡量、决策思考时候，不该是两极化的完美主义，而应该柔软下来，认知到每一个细小的进步，或许这一次还不行，但只要还有机会，我就会努力迈进。</p><p><em>耗时45分钟</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;近期反省结论 –&amp;gt; 过于追求过程和结果的完美程度，成效并不符合预期，因此针对这个问题进行修正。&lt;/p&gt;
&lt;p&gt;本系列主要摘录书中语句加自己的感悟，贯彻“不完美主义”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;序&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="book" scheme="http://ideameshdyx.github.io/categories/book/"/>
    
    
    <category term="book" scheme="http://ideameshdyx.github.io/tags/book/"/>
    
  </entry>
  
</feed>
