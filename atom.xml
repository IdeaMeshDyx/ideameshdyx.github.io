<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ideamesh</title>
  
  <subtitle>learn and code</subtitle>
  <link href="http://ideameshdyx.github.io/atom.xml" rel="self"/>
  
  <link href="http://ideameshdyx.github.io/"/>
  <updated>2023-04-23T07:33:39.431Z</updated>
  <id>http://ideameshdyx.github.io/</id>
  
  <author>
    <name>IdeaMeshDYX</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>post</title>
    <link href="http://ideameshdyx.github.io/2023/04/22/Common/zjx/test/"/>
    <id>http://ideameshdyx.github.io/2023/04/22/Common/zjx/test/</id>
    <published>2023-04-22T16:28:20.000Z</published>
    <updated>2023-04-23T07:33:39.431Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>2023 ospp fighting</title>
    <link href="http://ideameshdyx.github.io/2023/04/18/EdgeMesh/cilium%E4%B8%8Eedgemesh%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/2023-ospp-fighting/2023-ospp-fighting/"/>
    <id>http://ideameshdyx.github.io/2023/04/18/EdgeMesh/cilium%E4%B8%8Eedgemesh%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/2023-ospp-fighting/2023-ospp-fighting/</id>
    <published>2023-04-18T21:02:23.000Z</published>
    <updated>2023-04-23T14:16:47.027Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文档用于整理申请 2023ospp edgeMesh CNI 项目的准备和奋战过程</p></blockquote><h1 id="时间线记录"><a href="#时间线记录" class="headerlink" title="时间线记录"></a>时间线记录</h1><h2 id="1-项目申请准备阶段"><a href="#1-项目申请准备阶段" class="headerlink" title="1. 项目申请准备阶段"></a>1. 项目申请准备阶段</h2><blockquote><p>4/19 </p></blockquote><p>​    调研并整理 CNI 相关内容</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文档用于整理申请 2023ospp edgeMesh CNI 项目的准备和奋战过程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;时间线记录&quot;&gt;&lt;a href=&quot;#时间线记录&quot; class=&quot;headerlink&quot; title=&quot;时间线记录</summary>
      
    
    
    
    <category term="ospp" scheme="http://ideameshdyx.github.io/categories/ospp/"/>
    
    
    <category term="ospp, edgemesh" scheme="http://ideameshdyx.github.io/tags/ospp-edgemesh/"/>
    
  </entry>
  
  <entry>
    <title>CNI 概述</title>
    <link href="http://ideameshdyx.github.io/2023/04/18/EdgeMesh/cilium%E4%B8%8Eedgemesh%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/2023-ospp-fighting/Kubernetes%20%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%20CNI%20%E2%80%94%20CNI%20/"/>
    <id>http://ideameshdyx.github.io/2023/04/18/EdgeMesh/cilium%E4%B8%8Eedgemesh%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/2023-ospp-fighting/Kubernetes%20%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%20CNI%20%E2%80%94%20CNI%20/</id>
    <published>2023-04-18T21:02:23.000Z</published>
    <updated>2023-04-23T13:00:04.100Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CNI-概述"><a href="#CNI-概述" class="headerlink" title="CNI 概述"></a>CNI 概述</h1><h2 id="什么是-CNI"><a href="#什么是-CNI" class="headerlink" title="什么是 CNI"></a>什么是 CNI</h2><blockquote><p>CNI的全称是 Container Network Interface，它为<strong>容器提供了一种基于插件结构的标准化网络解决方案</strong>。以往，容器的网络层是和具体的底层网络环境高度相关的，不同的网络服务提供商有不同的实现。<strong>CNI从网络服务里抽象出了一套标准接口</strong>，从而屏蔽了上层网络和底层网络提供商的网络实现之间的差异。并且，通过插件结构，它让容器在网络层的具体实现变得可插拔了，所以非常灵活。</p></blockquote><p>首先 CNI 是一套标准接口，它隶属于<a href="https://cncf.io/">CNCF(Cloud Native Computing Foundation)</a>，依照这个标准所实现的为 CNI Plugins, 他们彼此独立，也可以组合起来一起使用，由一组用于配置 Linux 容器的网络接口的规范和库组成，同时还包含了一些插件，CNI 仅关心容器创建时的网络分配，和当容器被删除时释放网络资源。</p><p>其次 依据 CNI 的<a href="https://github.com/containernetworking/cni/blob/master/SPEC.md">规范</a>，CNI 具有以下几点特征：</p><ul><li>CNI 需提供网络管理员<strong>定义网络配置的文件格式</strong></li><li>CNI 需提供 Container Runtime（CRI） 调用功能的<strong>协议/API</strong>。</li><li>当 CNI 被 CRI 调用时，需依据配置文件执行网络配置功能</li><li>CNI 需预留可调用其他插件的能力</li><li>CNI 需规范统一返回给CRI 的数据格式</li></ul><p>依据这样的特征和要求，可以明确实现一个CNI插件需要包含以下部分：</p><ul><li>可执行文件<ul><li>cni plugins</li><li>IPAM</li></ul></li><li>网络配置文件</li></ul><h2 id="CNI-的功能"><a href="#CNI-的功能" class="headerlink" title="CNI 的功能"></a>CNI 的功能</h2><p>CNI 插件首先得实现一个可以被容器管理系统（CRI），比如rkt、Kubernetes 所调用的可执行文件——cni plugins，这个插件首先需要提供<strong>基础的 Linux 网络联通服务</strong>，比如创建 veth 或者 bridge 并将 veth 对的一端插入容器的 network namespace，一端插入 bridge，使得容器之间可以相互通信。然后<strong>将IP 分配给接口</strong>，并通过调用 **IPAM **插件来设置和管理IP地址，使得集群内的容器IP地址相互不重复，或者是结合其他的插件来实现更加复杂的网络路由管理功能等等。</p><p>那么接下来，依据对于这几项功能的要求，来具体看看 CNI 的标准</p><h2 id="CNI-统一的网络配置文件"><a href="#CNI-统一的网络配置文件" class="headerlink" title="CNI 统一的网络配置文件"></a>CNI 统一的网络配置文件</h2><p>CNI 为容器网络管理员(操作人员、网络插件、网络编排系统)定义了一种网络配置格式。它包含了供 CRI 和 CNI 插件使用的指令。在插件执行时，这种配置格式由 CRI 解释，并转化为代码数据结构，传递给 CNI 插件。</p><p>一般来说配置文件主要是以 JSON 文件为主，且包含以下几个键值：</p><ul><li><code>cniVersion</code>: 指定CNI规范的版本，这样 CRI 和 CNI 才能读懂彼此</li><li><code>Name</code>: 网络名字，这在一个主机（或其他管理域）的所有网络配置中应该是唯一的。必须以一个字母数字字符开始，后面可以选择由一个或多个字母数字字符、下划线、点（.）或连字符（-）的任何组合。</li><li><code>disableCheck</code>: 是否禁用检查网络，如果为true,则 <code>container runtime</code> 不会调用 Check 方法进行网络检查。</li><li><code>plugin</code>: cni插件及其配置列表，可以配置多个插件。</li></ul><p>接着展开说明一下 plugin 当中的参数，这也与实现 CNI 的功能息息相关，CRI 解析出配置文件当中的这个字段，是必须要一个字不漏地完整交给 CNI 插件来做网络管理</p><ol><li><p>必须配置的键值</p><p><code>type</code> :  指定目前系统目录当中所使用的 CNI 插件，一般是 cni 可执行文件的目录索引</p><p>至少得有一个基础的 cni 插件来完成最基础的 Linux 网络配置的功能</p></li><li><p>可选键值，由 CRI 依据协议发送的 request 指定</p><p><code>capabilities</code>:  如果 CNI_ARGS 中没有指定此项功能时候来补充的</p></li><li><p>预留键值，由 CRI 在执行时产生的</p><ul><li><code>runtimeConfig</code> :  比如 CNI 自己设置的 isGateway == true 就表明告诉插件，作为网关，给bridge指定一个IP地址。这样，连接到bridge的容器就可以拿它当网关来用了。</li><li><code>args</code></li><li>或者是任何以 <code>cni.dev/</code>开头的</li></ul></li><li><p>可选键值,由容器网络管理员添加</p><p><code>ipMasq</code>: 为目标网络配上Outbound Masquerade(地址伪装)，即：由容器内部通过网关向外发送数据包时，对数据包的源IP地址进行修改。</p><p>当我们的容器以宿主机作为网关时，这个参数是必须要设置的。否则，从容器内部发出的数据包就没有办法通过网关路由到其他网段。因为容器内部的IP地址无法被目标网段识别，所以这些数据包最终会被丢弃掉。</p><p><code>ipam</code>: PAM(IP Adderss Management)即IP地址管理，提供了一系列方法用于对IP和路由进行管理。实际上，它对应的是由CNI提供的一组标准IPAM插件，比如像host-local，dhcp，static等。如果要对整个集群的地址做管理，让pod具有单独的ip地址，就需要在这里添加额外的插件</p><blockquote><p>例子1当中：</p><ul><li>type：指定所用IPAM插件的名称，在例子里，用的是host-local。</li><li>subnet：为目标网络分配网段，包括网络ID和子网掩码，以CIDR形式标记。在例子里为<code>10.15.10.0/24</code>，也就是目标网段为<code>10.15.10.0</code>，子网掩码为<code>255.255.255.0</code>。</li><li>routes：用于指定路由规则，插件会在容器的路由表里生成相应的规则。其中，dst表示希望到达的目标网段，以CIDR形式标记。gw对应网关的IP地址，也就是要到达目标网段所要经过的“next hop(下一跳)”。如果省略gw的话，那么插件会自动帮容器选择默认网关。在例子里，gw选择的是默认网关，而dst为<code>0.0.0.0/0</code>则代表“任何网络”，表示数据包将通过默认网关发往任何网络。实际上，这对应的是一条默认路由规则，即：当所有其他路由规则都不匹配时，将选择该路由。</li><li>rangeStart：允许分配的IP地址范围的起始值</li><li>rangeEnd：允许分配的IP地址范围的结束值</li><li>gateway：为网关（也就是将要在宿主机上创建的bridge）指定的IP地址。如果省略的话，那么插件会自动从允许分配的IP地址范围内选择起始值作为网关的IP地址。</li></ul></blockquote></li></ol><p>配置文件例子如下：</p><p>例子1：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;cniVersion&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.4.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lab-br0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bridge&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;bridge&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lab-br0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;isGateway&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;ipMasq&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;ipam&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;host-local&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;subnet&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.15.10.0/24&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;routes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">&#123;</span> <span class="attr">&quot;dst&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.0.0.0/0&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;rangeStart&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.15.10.100&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;rangeEnd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.15.10.200&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;gateway&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.15.10.99&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>例子2：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;cniVersion&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;dbnet&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;plugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bridge&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="comment">// plugin specific parameters</span></span><br><span class="line">      <span class="attr">&quot;bridge&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cni0&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;keyA&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;some more&quot;</span><span class="punctuation">,</span> <span class="string">&quot;plugin specific&quot;</span><span class="punctuation">,</span> <span class="string">&quot;configuration&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      </span><br><span class="line">      <span class="attr">&quot;ipam&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;host-local&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="comment">// ipam specific</span></span><br><span class="line">        <span class="attr">&quot;subnet&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.1.0.0/16&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;gateway&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.1.0.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;routes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">&#123;</span><span class="attr">&quot;dst&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.0.0.0/0&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;dns&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;nameservers&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="string">&quot;10.1.0.1&quot;</span> <span class="punctuation">]</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;tuning&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;capabilities&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;mac&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;sysctl&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;net.core.somaxconn&quot;</span><span class="punctuation">:</span> <span class="string">&quot;500&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;portmap&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;capabilities&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;portMappings&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="CNI-运行时协议"><a href="#CNI-运行时协议" class="headerlink" title="CNI 运行时协议"></a>CNI 运行时协议</h3><p>CNI协议是基于由 CRI 的调用请求来告诉 CNI 该做些什么。</p><p>主要的协议参数定义如下：</p><ul><li>CNI_COMMAND：表示所需的操作；ADD、DEL、CHECK、或VERSION。</li><li>CNI_CONTAINERID：容器ID。告诉CNI插件，将要加入目标网络的容器所对应的network namespace的ID,容器的唯一的标识符，由 CRI 分配。不能是空的。必须以一个字母数字字符开始，后面可以选择一个或多个字母数字字符、下划线（）、点（.）或连字符（-）的任何组合。</li><li>CNI_NETNS：容器对应的network namespace在宿主机上的文件路径。（例如：/run/netns/[nsname]）。</li><li>CNI_IFNAME：作为veth pair在容器一端的网络接口,一般是在容器内创建的接口的名称；如果 CNI 插件无法使用这个接口名称，那么就必须返回一个错误。</li><li>CNI_ARGS：用户在调用时传入的额外参数。用分号分隔的字母数字键值对；例如，”FOO=BAR;ABC=123”</li><li>CNI_PATH: 表示 CNI 插件可执行文件的路径列表。路径由操作系统特定的列表分隔符分隔；例如Linux上的’:’和Windows上的’；’。</li></ul><p>告诉CNI插件要执行的命令，允许的命令有ADD，DEL，CHECK，VERSION。</p><p>对于支持CNI规范的容器系统而言，当容器启动的时候，系统就会自动调用相应的CNI插件，并设置CNI_COMMAND为ADD。相应地，DEL是在容器被销毁时调用的，用于清除在执行ADD阶段分配的网络资源。CHECK用于检查容器网络是否正常。VERSION则用来显示插件的版本。具体的操作如下：</p><ul><li><p>ADD</p><ul><li><p>将容器添加到网络中，或将新的配置修改应用到已有的集群当中。</p></li><li><p>一个CNI插件在收到ADD命令后，应该选择</p><ul><li><p>在 CNI_NETNS 的容器内创建由 CNI_IFNAME 定义的接口，</p></li><li><p>调整容器内 CNI_NETNS 处由CNI_IFNAME定义的接口的配置</p><p>如果CNI插件成功，必须要返回一个处理结果，要么打印出来，要么修改传入的参数。</p></li></ul></li></ul></li><li><p>DELETE</p><ul><li><p>将容器删除出网络，或将新的配置修改应用到已有的集群当中。</p><p>功能与ADD 相对</p></li></ul></li><li><p>CHECK</p><ul><li>查找类型字段中指定的可执行文件，如果没找到返回错误</li><li>当 Plugins （CNI调用的其他的Plugins）返回错误时，将其返回给调用者</li></ul></li></ul><hr><h2 id="CNI-与插件"><a href="#CNI-与插件" class="headerlink" title="CNI 与插件"></a>CNI 与插件</h2><p>为了解决容器网络的各项需求和问题，将所有的功能单独集中在 CNI 单个程序中是不现实的，而且难以兼容不同的上层系统和底层的网络管理，于是一个显然的想法就是将这些功能独立出来，使用插件（Plugins）的形式来执行。</p><p>一个常见的例子就是 IP 地址管理，这就是IP地址管理插件（IPAM插件），它必须设置容器和虚拟网络设备的接口 ，IP / 子网，网关和路由，然后将此信息返回给“主”插件（CNI本体）来执行，换句话说 IPAM 做逻辑上的网络地址管理然后告诉本体 CNI 去执行 <code>ADD</code>,<code>DELETE</code>。 </p><p>CNI 本体调用这些插件的形式也是通过路径找到这些插件的可执行文件来实现的，一般这些插件的位置也都一起放置在 <code>CNI_PATH</code>之下。同时插件和 CNI 本体都是通过 stdin 接收网络配置，也通过 stdout 输出结果。</p><p>如此看来 CNI 的工作流程就是一条链状的调用过程，但调用链中的每一个可执行程序所接收的配置文件信息并不相同。</p><hr><h1 id="CNI-配置文件样例分析"><a href="#CNI-配置文件样例分析" class="headerlink" title="CNI 配置文件样例分析"></a>CNI 配置文件样例分析</h1><blockquote><p>参考<a href="https://github.com/containernetworking/cni/blob/spec-v1.0.0/SPEC.md">cni/SPEC.md at spec-v1.0.0 · containernetworking/cni (github.com)</a> 的 Appendix: Examples</p></blockquote><p>借助 Github 所给的 SPEC 例子，要求 CRI 生成 portmap 和mac 相关的参数，同时使用CNI_IFNAME=eth0。假设目前 CRI 接收到的 json 文件如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;cniVersion&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;dbnet&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;plugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bridge&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="comment">// plugin specific parameters</span></span><br><span class="line">      <span class="attr">&quot;bridge&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cni0&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;keyA&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;some more&quot;</span><span class="punctuation">,</span> <span class="string">&quot;plugin specific&quot;</span><span class="punctuation">,</span> <span class="string">&quot;configuration&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      </span><br><span class="line">      <span class="attr">&quot;ipam&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;host-local&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="comment">// ipam specific</span></span><br><span class="line">        <span class="attr">&quot;subnet&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.1.0.0/16&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;gateway&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.1.0.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;routes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">&#123;</span><span class="attr">&quot;dst&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.0.0.0/0&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;dns&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;nameservers&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="string">&quot;10.1.0.1&quot;</span> <span class="punctuation">]</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;tuning&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;capabilities&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;mac&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;sysctl&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;net.core.somaxconn&quot;</span><span class="punctuation">:</span> <span class="string">&quot;500&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;portmap&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;capabilities&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;portMappings&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>我把它简化一下，提取出重要的配置参数，按照插件的调用链来作解释。</p><p>对于 <code>ADD</code> 操作，配置文件所看到的主体为如下所示，提供信息表明 cni 标准为： “1.0.0”, 并创建一个名为dbnet的网络空间，这个网络空间并不是指 network namespace,应该把它理解为一个局域网络的名字，比如插件使用的是 <code>bridge</code>创建，那么这个名字就是创建的网桥名字，也就是<code>ifconfig</code> 看到的网络设备名字；同时配置文件规定了整个 CNI plugins 的调用链，包括从 <code>bridge</code>到<code>tuning</code>再到<code>portmap</code>，然后完成这个网络空间的创建即 <code>ADD</code> 操作</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;cniVersion&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;dbnet&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;plugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bridge&quot;</span><span class="punctuation">,</span><span class="attr">&quot;bridge&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cni0&quot;</span><span class="punctuation">,</span><span class="attr">&quot;ipam&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="attr">&quot;dns&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;tuning&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;portmap&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>首先 CRI 会调用 <code>bridge</code> 插件( CNI ) ,传入 <code>CNI_COMMAND=ADD</code>参数，并传入以下 json 信息:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;cniVersion&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;dbnet&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bridge&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;bridge&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cni0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;keyA&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;some more&quot;</span><span class="punctuation">,</span> <span class="string">&quot;plugin specific&quot;</span><span class="punctuation">,</span> <span class="string">&quot;configuration&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;ipam&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;host-local&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;subnet&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.1.0.0/16&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;gateway&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.1.0.1&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;dns&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;nameservers&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="string">&quot;10.1.0.1&quot;</span> <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>被调用的 CNI 插件 bridge ，首先会去调用他所管的 IPAM 插件 <code>host-local</code>，并传入与它收到的配置信息和 ADD指令参数，也就是下面两行,创建一个 <code>10.1.0.0/16</code>的子网，同时设置 <code>10.1.0.1 为</code>网关（<code>gateway</code>表示对应网关的IP地址，也就是要到达目标网段所要经过的“next hop(下一跳)），地址为<code>10.1.0.1</code>。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;subnet&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.1.0.0/16&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;gateway&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.1.0.1&quot;</span></span><br></pre></td></tr></table></figure><p>设置成功，IPAM 插件应该返回以下的结果给 bridge，但这个设置的概念与不同的 CNI 实现有关，一般来说单独的 IPAM 设置指的是数据层面的管理，这个 IPAM 会为容器端的网络接口分配IP地址，比如通过调用<code>net.ParseCIDR</code>函数，对传入的<code>ipAddress</code>进行解析，依据节点环境并生成<code>ipv4Addr</code>和<code>ipv4Net</code>对象，并返回数据，但是并没有调用 Linux 的接口生成对象。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;ips&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.1.0.5/16&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;gateway&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.1.0.1&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;routes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;dst&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.0.0.0/0&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;dns&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;nameservers&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="string">&quot;10.1.0.1&quot;</span> <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>新增加的两条信息：</p><ol><li><p><code>routes</code> 表示路由规则，如果在配置日志文件当中设置好，IPAM 插件会为 CNI 在容器的路由表里生成相应的规则。其中，<code>dst</code>表示希望到达的目标网段，以CIDR形式标记，在例子里 dst 为<code>0.0.0.0/0</code>，代表“任何网络”，表示数据包将通过默认网关发往任何网络，实际上，这对应的是一条默认路由规则，即：当所有其他路由规则都不匹配时，将选择该路由。</p></li><li><p><code>dns</code> 表示设置的 dns 服务由网关提供</p></li></ol><p>bridge 插件得到配置地址的结果和参数之后，就会依据 IPAM 所给的信息来设置节点的网络情况，一般是这个时候来来调用 <code>setupVeth</code> 以及 <code>netlink</code> 的函数方法，创建并写入对象信息，就像是指令来执行 <code>ip link add</code>,<code>ip link set ... up</code>等等。</p><p>当创建过程结束之后，bridge 插件就会返回以下结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;ips&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.1.0.5/16&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;gateway&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.1.0.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;interface&quot;</span><span class="punctuation">:</span> <span class="number">2</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;routes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;dst&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.0.0.0/0&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;interfaces&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cni0&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;mac&quot;</span><span class="punctuation">:</span> <span class="string">&quot;00:11:22:33:44:55&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;veth3243&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;mac&quot;</span><span class="punctuation">:</span> <span class="string">&quot;55:44:33:22:11:11&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;eth0&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;mac&quot;</span><span class="punctuation">:</span> <span class="string">&quot;99:88:77:66:55:44&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;sandbox&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/var/run/netns/blue&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;dns&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;nameservers&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="string">&quot;10.1.0.1&quot;</span> <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>其实上面已经是相对完整的调用过程了，但是例子当中的插件还继续调用了<code>tuning</code>,<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`tuning` 接收的参数包括 `CNI_COMMAND=ADD`,原本的配置文件加上 **bridge 插件返回的结果**，结合下来 `tuning`接收到的配置文件为：</span><br><span class="line"></span><br><span class="line">```json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;cniVersion&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;name&quot;: &quot;dbnet&quot;,</span><br><span class="line">  &quot;type&quot;: &quot;tuning&quot;,</span><br><span class="line">  &quot;sysctl&quot;: &#123;</span><br><span class="line">    &quot;net.core.somaxconn&quot;: &quot;500&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;runtimeConfig&quot;: &#123;</span><br><span class="line">    &quot;mac&quot;: &quot;00:11:22:33:44:66&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;prevResult&quot;: &#123;</span><br><span class="line">    &quot;ips&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;address&quot;: &quot;10.1.0.5/16&quot;,</span><br><span class="line">          &quot;gateway&quot;: &quot;10.1.0.1&quot;,</span><br><span class="line">          &quot;interface&quot;: 2</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;routes&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;dst&quot;: &quot;0.0.0.0/0&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;interfaces&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;cni0&quot;,</span><br><span class="line">            &quot;mac&quot;: &quot;00:11:22:33:44:55&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;veth3243&quot;,</span><br><span class="line">            &quot;mac&quot;: &quot;55:44:33:22:11:11&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;eth0&quot;,</span><br><span class="line">            &quot;mac&quot;: &quot;99:88:77:66:55:44&quot;,</span><br><span class="line">            &quot;sandbox&quot;: &quot;/var/run/netns/blue&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;dns&quot;: &#123;</span><br><span class="line">      &quot;nameservers&quot;: [ &quot;10.1.0.1&quot; ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到它所接收的文件内容当中，新增了之前一个插件产生的结果 <code>prevResult</code>。</p><p>标准的部分就到这里了结束了，但可以看到标准更多地还是定义了 CRI ，网络管理者 和 CNI 之间的通信形式，但是这并非完全满足了 Pod 网络管理的需求，尤其是作为 IPAM 的 <code>host-local</code> 插件仅能够确保同一台宿主机上运行的所有容器，IP地址一定都是彼此唯一的；无法做到让这个 IP 地址在集群当中唯一。更多的功能需要进一步去研究各个 CNI 插件具体提供的功能。</p><h2 id="CNI-配置文件语法"><a href="#CNI-配置文件语法" class="headerlink" title="CNI 配置文件语法"></a>CNI 配置文件语法</h2><p>做填空题目就可以：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;cniVersion&quot;</span><span class="punctuation">:</span> <span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;disableCheck&quot;</span><span class="punctuation">:</span></span><br><span class="line">  <span class="attr">&quot;plugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;bridge&quot;</span><span class="punctuation">:</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;ipMasq&quot;</span><span class="punctuation">:</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;ipam&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;dns&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;nameservers&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;domain&quot;</span><span class="punctuation">:</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;search&quot;</span><span class="punctuation">:</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;options&quot;</span><span class="punctuation">:</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><hr><h1 id="相关仓库及文献"><a href="#相关仓库及文献" class="headerlink" title="相关仓库及文献"></a>相关仓库及文献</h1><p><a href="https://github.com/containernetworking/cni/blob/spec-v1.0.0/SPEC.md">cni/SPEC.md at spec-v1.0.0 · containernetworking/cni (github.com)</a></p><p><a href="https://lengrongfu.github.io/2022-05-11-k8s%E4%B9%8BCNI%E8%A7%84%E8%8C%83%E8%A7%A3%E8%AF%BB/">Kubernetes网络之CNI规范解读 | LRF (lengrongfu.github.io)</a></p><p><a href="https://www.redhat.com/sysadmin/cni-kubernetes">A brief overview of the Container Network Interface (CNI) in Kubernetes | Enable Sysadmin (redhat.com)</a></p><p><a href="https://learn.microsoft.com/en-us/azure/aks/use-byo-cni?tabs=azure-cli">Bring your own Container Network Interface (CNI) plugin - Azure Kubernetes Service | Microsoft Learn</a></p><p><a href="https://kubernetes.io/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/">Network Plugins | Kubernetes</a></p><p><a href="https://www.tigera.io/learn/guides/kubernetes-networking/kubernetes-cni/">Kubernetes CNI Explained (tigera.io)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CNI-概述&quot;&gt;&lt;a href=&quot;#CNI-概述&quot; class=&quot;headerlink&quot; title=&quot;CNI 概述&quot;&gt;&lt;/a&gt;CNI 概述&lt;/h1&gt;&lt;h2 id=&quot;什么是-CNI&quot;&gt;&lt;a href=&quot;#什么是-CNI&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="CNI" scheme="http://ideameshdyx.github.io/categories/CNI/"/>
    
    
    <category term="ospp, CNI, Linux, Spec" scheme="http://ideameshdyx.github.io/tags/ospp-CNI-Linux-Spec/"/>
    
  </entry>
  
  <entry>
    <title>CNI 与  Pod 容器网络—— Linux 网络</title>
    <link href="http://ideameshdyx.github.io/2023/04/18/EdgeMesh/cilium%E4%B8%8Eedgemesh%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/2023-ospp-fighting/Kubernetes%20%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%20CNI%20%E2%80%94%20Linux%20%E7%BD%91%E7%BB%9C%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    <id>http://ideameshdyx.github.io/2023/04/18/EdgeMesh/cilium%E4%B8%8Eedgemesh%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/2023-ospp-fighting/Kubernetes%20%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%20CNI%20%E2%80%94%20Linux%20%E7%BD%91%E7%BB%9C%E8%99%9A%E6%8B%9F%E5%8C%96/</id>
    <published>2023-04-18T21:02:23.000Z</published>
    <updated>2023-04-23T10:06:29.042Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CNI-与-Pod-容器网络——-Linux-网络"><a href="#CNI-与-Pod-容器网络——-Linux-网络" class="headerlink" title="CNI 与  Pod 容器网络—— Linux 网络"></a>CNI 与  Pod 容器网络—— Linux 网络</h1><blockquote><p>Pod 容器在 kubernetes 网络中是怎样获取他的地址的呢? </p><p>如何保障 Pod IP 在整个集群当中的唯一性？</p><p>容器流量如何在所给的IP之间相互转发？</p></blockquote><hr><h2 id="从-namespace-开始"><a href="#从-namespace-开始" class="headerlink" title="从 namespace 开始"></a>从 namespace 开始</h2><p>namespace 技术是 Linux 内核提供的一项非常重要的功能，也是容器虚拟化的基础技术，通过构建系统资源的边界，形成一个相对封闭的资源区域，也就是大家认识的容器。Linux 提供的 namespace 包括以下几个方面：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Linux provides the following namespaces:</span><br><span class="line"></span><br><span class="line">Namespace   Constant          Isolates</span><br><span class="line">Cgroup      CLONE_NEWCGROUP   Cgroup root directory</span><br><span class="line">IPC         CLONE_NEWIPC      System V IPC, POSIX message queues</span><br><span class="line">Network     CLONE_NEWNET      Network devices, stacks, ports, etc.</span><br><span class="line">Mount       CLONE_NEWNS       Mount points</span><br><span class="line">PID         CLONE_NEWPID      Process IDs</span><br><span class="line">User        CLONE_NEWUSER     User and group IDs</span><br><span class="line">UTS         CLONE_NEWUTS      Hostname and NIS domain name</span><br></pre></td></tr></table></figure><p>其中网络名字空间(network namespace)是网络虚拟化技术的基础，也是本文最为关注的部分；现有的各项容器技术在实现他们各自的网络连接时所依赖的核心，所以要探究 Pod 网络和 CNI 就必须先从 network namespace 入手。</p><p>在 Linux 系统当中，每一个 network  namespace  都有他自己的网络设置，包括（routing table）路由表、（network interface）网络设备、（IP address）IP 地址等等，这样隔离的一个典型好处就是在不同的network namespace 之下程序可以绑定到同一个端口并保持各自的网络约束不变。与其他的 namespace 一样, network namspace 也可以调用 clone() API创建一个通用的 namespace, 然后传入 CLONE_NEWNET 参数来创建 network namespace。不过就简单配置来说， 可以使用 <strong>netns</strong> 执行对 networkname space  的各项增删改查。</p><p>依据 network namspace 划分出网络区域就像是创建网络通信的对端，但光有隔离出来的对象并不能构成网络；容器还要和外界进行网络联通才能提供服务。与实际网络场景不相同的是，没有物理实体的交换机和路由器，甚至可用的物理网卡也是受限的，那么如何能够在划分隔离出的区域之间提供通信呢？同时如何能够定位这些区域并让数据包能够正确地从一个 netns 中传输到另一个 netns呢？</p><hr><h2 id="veth-的创建和连接"><a href="#veth-的创建和连接" class="headerlink" title="veth 的创建和连接"></a>veth 的创建和连接</h2><p>首先要清楚 veth-pairs， veth 是虚拟以太网卡（virtual Ethernet）的缩写，veth 设备总是成对出现的，也因此称之为 veth-pair。可以通过<code> ip link add veth0 type veth peer name veth1</code> 等指令来创建管理这些虚拟网卡，eg ：<a href="https://morningspace.github.io/tech/k8s-net-docker0/">从docker0开始</a> ，<a href="https://medium.com/techlog/diving-into-linux-networking-and-docker-bridge-veth-and-iptables-a05eb27b1e72">Deep dive into Linux Networking and Docker | Medium</a> 等文章就有讲到其作用和类似操作，不再复述。</p><p>但关键在于对于系统来说，veth到底是什么呢？是一个文件，进程还是描述符,他是否直接和物理网卡相关？它的工作原理是什么，是怎样来让容器之间相互通信的呢？接着来深入研究其内核当中的实现，具体参考：<a href="https://man7.org/linux/man-pages/man4/veth.4.html">veth(4) - Linux manual page (man7.org)</a>，<a href="https://github.com/torvalds/linux/blob/master/drivers/net/veth.c">linux/veth.c at master · torvalds/linux (github.com)</a></p><p>veth的相关源码位于 <code>drivers/net/veth.c</code>中，其中的初始化入口是<code>veth_init</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __init <span class="type">int</span> <span class="title function_">veth_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> rtnl_link_register(&amp;veth_link_ops);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化函数注册了<code>veth_link_ops</code>(veth 设备的操作方法)，它包含了 veth 设备的创建启动和删除等回调函数，具体结构如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtnl_link_ops</span> <span class="title">veth_link_ops</span> =</span> &#123;</span><br><span class="line">.kind= DRV_NAME,</span><br><span class="line">.priv_size= <span class="keyword">sizeof</span>(<span class="keyword">struct</span> veth_priv),</span><br><span class="line">.setup= veth_setup,</span><br><span class="line">.validate= veth_validate,</span><br><span class="line">.newlink= veth_newlink,</span><br><span class="line">.dellink= veth_dellink,</span><br><span class="line">.policy= veth_policy,</span><br><span class="line">.maxtype= VETH_INFO_MAX,</span><br><span class="line">.get_link_net= veth_get_link_net,</span><br><span class="line">.get_num_tx_queues= veth_get_num_queues,</span><br><span class="line">.get_num_rx_queues= veth_get_num_queues,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从 <code>kind</code> 到 <code>setup</code> 都是创建对应的数据结构并写入常量参数,所以创建的关键还是在 <code>veth_newlink</code>,<code>veth_dellink</code>，但二者的执行逻辑相关，所以只看其中一个。 </p><p>首先是 <code>veth_newlink</code>, 不过他的实现较长，只能抓取一部分关键拆分开来看：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">veth_newlink</span><span class="params">(<span class="keyword">struct</span> net *src_net, <span class="keyword">struct</span> net_device *dev,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> nlattr *tb[], <span class="keyword">struct</span> nlattr *data[],</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> netlink_ext_ack *extack)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 由于虚拟网络设备对是由两个网络设备组成,</span></span><br><span class="line">    <span class="comment">// dev 是虚拟网络设备对的其中一个网络设备，不可能创建单独的设备，那就需要创建一个临时的对端 peer</span></span><br><span class="line">    <span class="comment">// 因而调用 rtnl_create_link 函数创建对端网络设备的逻辑对象 peer </span></span><br><span class="line">peer = rtnl_create_link(net, ifname, name_assign_type,</span><br><span class="line">&amp;veth_link_ops, tbp, extack);</span><br><span class="line">err = register_netdevice(peer);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 注册 dev 对象，本质上就在内存里面建立一个 struct 并将信息从文件映射过去</span></span><br><span class="line">err = register_netdevice(dev);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 把 peer 和 dev 关联到一起</span></span><br><span class="line">priv = netdev_priv(dev);               <span class="comment">// 获取 dev 的私有数据部分</span></span><br><span class="line">rcu_assign_pointer(priv-&gt;peer, peer);  <span class="comment">// 将其 peer 字段指向 dev</span></span><br><span class="line">err = veth_init_queues(dev, tb);</span><br><span class="line">priv = netdev_priv(peer);              <span class="comment">// 获取 peer 的私有数据部分</span></span><br><span class="line">rcu_assign_pointer(priv-&gt;peer, dev);   <span class="comment">// 将其 peer 字段指向 dev</span></span><br><span class="line">    ...</span><br><span class="line">err = veth_init_queues(peer, tb);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加 XDP 访问支持 --&gt; veth 在内核运行流程中接近网卡</span></span><br><span class="line">    ...</span><br><span class="line"><span class="comment">/* update XDP supported features */</span></span><br><span class="line">veth_set_xdp_features(dev);</span><br><span class="line">veth_set_xdp_features(peer);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>veth_newlink</code>当中通过**<code>register_netdevice</code>** 注册了两个网络虚拟设备： <code>peer</code> 和 <code>dev</code>，并通过让 <code>dev</code> 的 peer 指针指向创建的 peer，让<code>peer</code> 的 peer  指针指向 dev，来完成了 veth 设备的结对。这个过程是符合 veth 的工作逻辑的，由于  veth 总是成对出现，所以在生成新的 veth 时候就需要指定它所连接对端  peer，当然这个过程发生在内核运行当中，并不是有物理上的连接关系，直白来说就是依据文件信息写入到内存，开辟一个空间来存储对应的信息，然后修改指针指向来表示连接关系。</p><p>创建完成之后，veth 又是怎么来传输数据的呢？回到之前的 <code>veth_setup</code>,启动 veth 的流程，也是将各类函数注册指定到 veth 对象当中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">veth_setup</span><span class="params">(<span class="keyword">struct</span> net_device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">ether_setup(dev);</span><br><span class="line">    ...</span><br><span class="line">dev-&gt;netdev_ops = &amp;veth_netdev_ops;</span><br><span class="line">dev-&gt;xdp_metadata_ops = &amp;veth_xdp_metadata_ops;</span><br><span class="line">dev-&gt;ethtool_ops = &amp;veth_ethtool_ops;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到是 veth 对象的操作列表包含三类：<code>veth_netdev_ops</code>,<code>veth_xdp_metadata_ops</code>,<code>veth_ethtool_ops</code>, 具体的列表如下：</p><p>net_device_ops 结构是网络设备的操作函数集结构, 包含了 Linux 网络设备对象的各项操作行为列表，也是  veth 对象调用实现功能的具体行为。</p><p>从以下列表其实可以知道，Linux 设备是通用一个网卡的代码数据操作流程及对象的，以下的操作函数对于 ebpf xdp 程序直接操作有一定参考，是EdgeMesh 为来优化的对象，故进一步深入探究。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_device_ops</span> <span class="title">veth_netdev_ops</span> =</span> &#123;</span><br><span class="line">.ndo_init            = veth_dev_init,</span><br><span class="line">.ndo_open            = veth_open,</span><br><span class="line">.ndo_stop            = veth_close,</span><br><span class="line">.ndo_start_xmit      = veth_xmit,</span><br><span class="line">.ndo_get_stats64     = veth_get_stats64,</span><br><span class="line">.ndo_set_rx_mode     = veth_set_multicast_list,</span><br><span class="line">.ndo_set_mac_address = eth_mac_addr,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NET_POLL_CONTROLLER</span></span><br><span class="line">.ndo_poll_controller= veth_poll_controller,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">.ndo_get_iflink= veth_get_iflink,</span><br><span class="line">.ndo_fix_features= veth_fix_features,</span><br><span class="line">.ndo_set_features= veth_set_features,</span><br><span class="line">.ndo_features_check= passthru_features_check,</span><br><span class="line">.ndo_set_rx_headroom= veth_set_rx_headroom,</span><br><span class="line">.ndo_bpf= veth_xdp,</span><br><span class="line">.ndo_xdp_xmit= veth_ndo_xdp_xmit,</span><br><span class="line">.ndo_get_peer_dev= veth_peer_dev,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这些函数的具体作用如下整理：</p><ul><li><p><code>ndo_init</code>: 该函数指向 <code>veth_dev_init</code>，网络设备初始化函数，由驱动程序实现，在网卡设备分配之后调用。</p></li><li><p><code>ndo_open</code>: 该函数指向 <code>veth_open</code>，被调用以打开虚拟网络设备并将其加入网络协议栈，由驱动程序实现，用于开启网络设备并为进程提供网络访问。</p></li><li><p><code>ndo_stop</code>：该函数指向 <code>veth_close</code>，由驱动程序实现，被调用以停止虚拟网络设备并将其从网络协议栈中移除。</p></li><li><p>==<code>ndo_start_xmit</code>：该函数指向 <code>veth_xmit</code>，由驱动程序实现，用于将给定的网络数据帧发送到指定的网络设备上。==</p></li><li><p><code>ndo_get_stats64</code>：该函数指向 <code>veth_get_stats64</code>，由驱动程序实现，用于获取虚拟网络设备当前的统计信息。</p></li><li><p><code>ndo_set_rx_mode</code>：该函数指向 <code>veth_set_multicast_list</code>，由驱动程序实现，用于设置网络设备接收模式。</p></li><li><p><code>ndo_set_mac_address</code>：该函数指向 <code>eth_mac_addr</code>，用于设置虚拟网络设备的MAC地址。</p></li><li><p><code>ndo_poll_controller</code>：该函数指向 <code>veth_poll_controller</code>，由驱动程序实现，veth调用之后触发软中断从 Ringbuffer 当中 poll 数据包</p></li><li><p><code>ndo_get_iflink</code>：该函数指向 <code>veth_get_iflink</code>，用于获取虚拟网络设备的网络接口索引号。</p></li><li><p><code>ndo_fix_features</code>：该函数指向 <code>veth_fix_features</code>，用于设置虚拟网络设备的特性参数；</p></li><li><p><code>ndo_set_features</code>：该函数指向 <code>veth_set_features</code>，用于修改或更新虚拟网络设备已经打开的特性参数。</p></li><li><p><code>ndo_features_check</code>：该函数指向 <code>passthru_features_check</code>，检查虚拟网络设备是否包含由 ETS（Enhanced Traffic Service）要求的特征。</p></li><li><p><code>ndo_set_rx_headroom</code>: 该函数指向 <code>veth_set_rx_headroom</code>，用于设置虚拟网络设备中下行数据帧包头部的大小。</p></li><li><p><code>ndo_bpf</code>：该函数指向 <code>veth_xdp</code>，用于添加eBPF扩展程序入口并进行初始化。</p></li><li><p><code>ndo_xdp_xmit</code>: 该函数指向 <code>veth_ndo_xdp_xmit</code>，驱动程序的XDP传输方法入口，将网络数据帧发送到用户提供的XDP扩展程序。</p></li><li><p><code>ndo_get_peer_dev</code>: 该函数指向 <code>veth_peer_dev</code>，用于获取与虚拟网络设备配对的网络设备。 </p></li></ul><p><code>ethtool_ops</code>结构则代表了与<code>ethtool</code>工具相关的网络设备操作函数集合。<code>ethtool</code>用于获取和设置与<code>ethtool</code>兼容设备的驱动程序和硬件信息，同时实现均衡网速，流量控制等功能。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">ethtool_ops</span> <span class="title">veth_ethtool_ops</span> =</span> &#123;</span><br><span class="line">.get_drvinfo= veth_get_drvinfo,</span><br><span class="line">.get_link= ethtool_op_get_link,</span><br><span class="line">.get_strings= veth_get_strings,</span><br><span class="line">.get_sset_count= veth_get_sset_count,</span><br><span class="line">.get_ethtool_stats= veth_get_ethtool_stats,</span><br><span class="line">.get_link_ksettings= veth_get_link_ksettings,</span><br><span class="line">.get_ts_info= ethtool_op_get_ts_info,</span><br><span class="line">.get_channels= veth_get_channels,</span><br><span class="line">.set_channels= veth_set_channels,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>xdp_metadata_ops</code>结构体定义了XDP（eBPF based packet processing）元数据的操作集合，在实现高性能网络数据包处理、过滤和转发的过程中起到重要作用。该操作集与XDP引擎密切相关，包括xsk_frame_parse（对接收的数据包的元数据进行解析）和xsk_frame_init（初始化元数据）等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">xdp_metadata_ops</span> <span class="title">veth_xdp_metadata_ops</span> =</span> &#123;</span><br><span class="line">.xmo_rx_timestamp= veth_xdp_rx_timestamp,</span><br><span class="line">.xmo_rx_hash= veth_xdp_rx_hash,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p><code>xmo_rx_timestamp</code> ： 该函数指针指向 <code>veth_xdp_rx_timestamp</code> 函数，用于获取 XDP 包的接收时间戳，即处理 XDP 包的内核进程把包抓取的时间。该时间可以在 eBPF 程序中使用，例如可用于实现延迟测量(metric)，排除处理器竞争以及路由表测量等。</p></li><li><p><code>xmo_rx_hash</code>：该函数指针指向 <code>veth_xdp_rx_hash</code>，用于获取 XDP 数据包的接收哈希值。通过接收哈希值，可以在 eBPF 中就各个数据包的接收位置和网络环境进行更好的控制和调节，以优化网络性能。例如在基于哈希的负载均衡中，可以使用哈希值来决定要将数据包路由到哪个接收 CPU 或内核上。</p></li></ul><p>在 Linux 中，这些函数指针被定义为可选项，也就是说并非每个驱动程序都会实现这两个函数指针。<code>xdp_metadata_ops</code> 使驱动程序与 eBPF程序 在处理特定的数据包和流量时更加灵活；但反过来说也需要配备一定的环境才能够实现这些调用的功能。</p><p>到这里，veth 的创建和各项功能在 Linux 视角的样子就全部呈现了，总的来说 veth 本身是 Linux 中创建的 <code>net_device</code> 结构，通过注册所需的初始化和操作行为等特定函数以及对其进行相应的参数配置，最终实例化为 veth 对象，用于虚拟网络的构建。同时更明确了 veth 是工作在二层的数据结构，他传输数据会调用驱动程序实现的 <code>ndo_start_xmit</code>函数，在指定了对端之后，数据包发送会存入 skb 并插入 <code>softnet_data-&gt;input_pkt_queue</code>中，出发软中断，接下来就是对称一般的内核接收过程。</p><hr><h2 id="网桥的连接和传输"><a href="#网桥的连接和传输" class="headerlink" title="网桥的连接和传输"></a>网桥的连接和传输</h2><p>veth 可以感性地认知为网卡，它给予了所划分出的 network namspace 一个出入的门，此前的结构如果将 veth 分别指向两个网络空间，就能够实现这二者的通信，但是当所划分的网络空间区域增加的时候，这样子点对点的连接方式显然就很难支撑了。</p><p>这样就需要解决单节点大量容器之间的网络互连问题。</p><p>参考实际物理网络的结构，Linux 实现并提供了一个完全由软件虚拟出来的交换机，它可以提供很多的虚拟端口，把许多的 veth 连接在一个平面的网络，通过自己的转发功能让虚拟机网卡之间可以通信，这个技术就叫做 bridge。</p><p>如何使用 bridge 连接不同的网络空间呢？<a href="https://developers.redhat.com/blog/2018/10/22/introduction-to-linux-interfaces-for-virtual-networking#team_device">Introduction to Linux interfaces for virtual networking | Red Hat Developer</a>，<a href="https://dev.to/arriqaaq/diving-into-linux-networking-and-docker-bridge-veth-and-iptables-419a">Deep dive into Linux Networking and Docker - Bridge, vETH and IPTables - DEV Community</a>  等文章也有详尽阐述，不再复述。</p><p>其中要关注的点是： bridge 的工作源码都是在 /net/core/dev.c 或者是 /net/bridge 目录下面，也就是说他是工作在二层上的设备（这一点与物理交换相同），但所给的实验来验证连通性是依靠 ping 指令从IP来看的，但这并不意味着 bridge 是依靠 IP  来做转发的。</p><p>为了验证这一点，深入来看 bridge 的内核实现</p><p>从外部网络到达节点时候，数据包会被网卡先送到 RingBuffer 中，然后依次经过硬中断、软中断处理，在软中断中再以此把包送到设备层（连接bridge）、协议栈，最后唤醒应用程序。</p><p>从节点内的应用程序到达外部的时候，会从应用程序调用系统调用，在进入协议栈（传输层、网络层），再进入邻居子系统到网络设备子系统（bridge），之后调用驱动程序触发硬中断到网卡。</p><p>在这个过程中，bridge 输入数据包处理工作流程在 <code>/net/bridge/br_input.c</code> 中 <code>br_handle_frame_finish</code>函数里</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">br_handle_frame_finish</span><span class="params">(<span class="keyword">struct</span> net *net, <span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取 veth 所连接的网桥端口以及 bridge 设备</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_port</span> *<span class="title">p</span> =</span> br_port_get_rcu(skb-&gt;dev);</span><br><span class="line">    <span class="comment">// 创建转发表对象</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_fdb_entry</span> *<span class="title">dst</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_mcast_port</span> *<span class="title">pmctx</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_mdb_entry</span> *<span class="title">mdst</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_vlan</span> *<span class="title">vlan</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_bridge</span> *<span class="title">br</span>;</span></span><br><span class="line">br = p-&gt;br;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找并更新转发表，这个转发表使用的地址是eth_hdr(skb)-&gt;h_source</span></span><br><span class="line">br_fdb_update(br, p, eth_hdr(skb)-&gt;h_source,vid, BIT(BR_FDB_LOCKED));</span><br><span class="line">dst = br_fdb_find_rcu(br, eth_hdr(skb)-&gt;h_dest, vid);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 转发</span></span><br><span class="line"><span class="keyword">if</span> (dst) &#123;</span><br><span class="line">br_forward(dst-&gt;dst, skb, local_rcv, <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 本机访问</span></span><br><span class="line"><span class="keyword">if</span> (local_rcv)</span><br><span class="line"><span class="keyword">return</span> br_pass_frame_up(skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中查找和转发使用的地址是eth_hdr(skb)-&gt;h_dest，和物理环境当中的交换机会自动学习端口所对应的节点mac地址一样，软件模拟的 bridge 也会自学习 veth 与 eth_hdr 的对应关系。</p><p>总的来说，当创建了 bridge 并把 veth 设备放入其中，网桥就能够为连接的网络空间提供一个平面的网络连接服务。</p><p>其实到目前为止，所涉及的网络设备都工作在二层，对应到物理环境就是都使用的 MAC 地址进行寻址和交换信息，这样的网络服务就是 Linux  基本网络服务，能够实现单节点上的网络空间连通性。</p><p>可只是这样是无法满足Kubernetes 集群的网络寻址和路由需求的，现有的网络追求平面式的连接服务但是底层依旧还是得通过IP进行寻址；回到容器网络当中，这也意味着希望在容器网络当中的实体能够拥有各自独立、唯一的IP地址，可以是容器、物理机或者是其他的网络设备（比如虚拟路由器）等，容器可以被添加到一个或多个网络中或从一个或多个网络中删除。这就是接下来 CNI 需要满足的功能之一。</p><hr><h2 id="再看-Namespace"><a href="#再看-Namespace" class="headerlink" title="再看 Namespace"></a>再看 Namespace</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CNI-与-Pod-容器网络——-Linux-网络&quot;&gt;&lt;a href=&quot;#CNI-与-Pod-容器网络——-Linux-网络&quot; class=&quot;headerlink&quot; title=&quot;CNI 与  Pod 容器网络—— Linux 网络&quot;&gt;&lt;/a&gt;CNI 与  Pod</summary>
      
    
    
    
    <category term="Linux, Container" scheme="http://ideameshdyx.github.io/categories/Linux-Container/"/>
    
    
    <category term="ospp, Linux, Network" scheme="http://ideameshdyx.github.io/tags/ospp-Linux-Network/"/>
    
  </entry>
  
  <entry>
    <title>2023 ospp fighting</title>
    <link href="http://ideameshdyx.github.io/2023/04/18/EdgeMesh/cilium%E4%B8%8Eedgemesh%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/2023-ospp-fighting/Kubernetes%20%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%20CNI%20%E2%80%94%20%E7%8E%B0%E6%9C%89%20CNI%20%E6%96%B9%E6%A1%88%E7%9A%84%E8%B0%83%E7%A0%94%20/"/>
    <id>http://ideameshdyx.github.io/2023/04/18/EdgeMesh/cilium%E4%B8%8Eedgemesh%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/2023-ospp-fighting/Kubernetes%20%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%20CNI%20%E2%80%94%20%E7%8E%B0%E6%9C%89%20CNI%20%E6%96%B9%E6%A1%88%E7%9A%84%E8%B0%83%E7%A0%94%20/</id>
    <published>2023-04-18T21:02:23.000Z</published>
    <updated>2023-04-23T12:57:05.973Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CNI-Plugins-调研"><a href="#CNI-Plugins-调研" class="headerlink" title="CNI Plugins 调研"></a>CNI Plugins 调研</h1><h2 id="1-通用-CNI-插件"><a href="#1-通用-CNI-插件" class="headerlink" title="1. 通用 CNI 插件"></a>1. 通用 CNI 插件</h2><blockquote><p>主要基于 <a href="https://github.com/containernetworking/plugins">containernetworking/plugins: Some reference and example networking plugins, maintained by the CNI team. (github.com)</a> ，<a href="https://www.cni.dev/plugins/current/">CNI</a></p></blockquote><p>由CNI 官方社区维护的 CNI plugins 主要分为三类：</p><ul><li><code>Main: interface-creating</code>: 主进程 CNI ,直接与 Linux 交流，创建接口、网络空间、对象等</li><li><code>IPAM: IP address allocation</code>:  地址管理插件，主要负责 IP 地址管理和分配</li><li><code>Meta: other plugins</code>: 其他的功能插件</li></ul><h3 id="Main-interface-creating-主进程-CNI"><a href="#Main-interface-creating-主进程-CNI" class="headerlink" title="Main: interface-creating  主进程 CNI"></a>Main: interface-creating  主进程 CNI</h3><h3 id="bridge"><a href="#bridge" class="headerlink" title="bridge"></a><a href="https://www.cni.dev/plugins/current/main/bridge/"><code>bridge</code></a></h3><p>​    创建虚拟网桥，并把本机（host）和容器（更准确说是network namespace）添加到其中</p><h3 id="macvlan"><a href="#macvlan" class="headerlink" title="macvlan"></a><a href="https://www.cni.dev/plugins/current/main/macvlan/"><code>macvlan</code></a></h3><p>​    创建一个新的 MAC 地址，将相关容器的所有流量都转发到该地址</p><h3 id="ipvlan"><a href="#ipvlan" class="headerlink" title="ipvlan"></a><a href="https://www.cni.dev/plugins/current/main/ipvlan/"><code>ipvlan</code></a></h3><p>​    类似于 <code>macvlan</code>创建虚拟局域网连接，给容器增加 <a href="https://www.kernel.org/doc/Documentation/networking/ipvlan.txt">ipvlan </a>接口，他主要有两种模式：</p><ul><li>L2 模式： 这个模式创建的容器网络与本机共享同一个 L2 设备，也就是说本机的广播数据包能够到达容器网络</li><li>L3 模式：</li></ul><p>这个模式创建对象的例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">  +=============================================================+</span><br><span class="line">  |  Host: host1                                                |</span><br><span class="line">  |                                                             |</span><br><span class="line">  |   +----------------------+      +----------------------+    |</span><br><span class="line">  |   |   NS:ns0             |      |  NS:ns1              |    |</span><br><span class="line">  |   |                      |      |                      |    |</span><br><span class="line">  |   |                      |      |                      |    |</span><br><span class="line">  |   |        ipvl0         |      |         ipvl1        |    |</span><br><span class="line">  |   +----------#-----------+      +-----------#----------+    |</span><br><span class="line">  |              #                              #               |</span><br><span class="line">  |              ################################               |</span><br><span class="line">  |                              # eth0                         |</span><br><span class="line">  +==============================#==============================+</span><br><span class="line">（a） 创建两个网络命名空间 - ns0、ns1</span><br><span class="line">IP 网络添加 NS0</span><br><span class="line">IP 网络添加 NS1</span><br><span class="line"></span><br><span class="line">（b） 在 eth0（主设备）上创建两个 ipvlan 从站。</span><br><span class="line">IP 链路添加链路 eth0 IPvl0 类型 IPvlan 模式 L2</span><br><span class="line">IP 链路添加链路 eth0 IPvl1 类型 IPvlan 模式 L2</span><br><span class="line"></span><br><span class="line">（c） 将从属服务器分配到相应的网络命名空间</span><br><span class="line">IP link <span class="built_in">set</span> dev ipvl0 netns ns0</span><br><span class="line">IP link <span class="built_in">set</span> dev ipvl1 netns ns1</span><br><span class="line"></span><br><span class="line">（d） 现在切换到命名空间（ns0 或 ns1）以配置从属设备</span><br><span class="line">- 对于 ns0</span><br><span class="line">（<span class="number">1</span>） IP netns exec ns0 bash</span><br><span class="line">（<span class="number">2</span>） IP 链路设置开发 IPvl0 向上</span><br><span class="line">（<span class="number">3</span>） IP 链路设置开发</span><br><span class="line">（<span class="number">4</span>） IP <span class="number">-4</span> 地址添加 <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> 开发 LO</span><br><span class="line">（<span class="number">5</span>） IP <span class="number">-4</span> 地址添加 $IPADDR 开发 IPvl0</span><br><span class="line">（<span class="number">6</span>） IP <span class="number">-4</span> 路由通过$ROUTER开发 IPvl0 添加默认值</span><br><span class="line">- 对于 ns1</span><br><span class="line">（<span class="number">1</span>） IP Netns exec NS1 Bash</span><br><span class="line">（<span class="number">2</span>） IP 链路设置开发 IPvl1 向上</span><br><span class="line">（<span class="number">3</span>） IP 链路设置开发</span><br><span class="line">（<span class="number">4</span>） IP <span class="number">-4</span> 地址添加 <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> 开发 LO</span><br><span class="line">（<span class="number">5</span>） IP <span class="number">-4</span> 地址添加 $IPADDR 开发 IPvl1</span><br><span class="line">（<span class="number">6</span>） IP <span class="number">-4</span> 路由通过$ROUTER开发 IPvl1 添加默认值</span><br></pre></td></tr></table></figure><ul><li><a href="https://www.cni.dev/plugins/current/main/ptp/"><code>ptp</code></a> : Creates a veth pair</li><li><a href="https://www.cni.dev/plugins/current/main/host-device/"><code>host-device</code></a> : Moves an already-existing device into a container</li><li><a href="https://www.cni.dev/plugins/current/main/vlan/"><code>vlan</code></a> : Creates a vlan interface off a master</li></ul><h4 id="Windows-windows-specific"><a href="#Windows-windows-specific" class="headerlink" title="Windows: windows specific"></a>Windows: windows specific</h4><ul><li><a href="https://www.cni.dev/plugins/current/main/win-bridge/"><code>win-bridge</code></a> : Creates a bridge, adds the host and the container to it</li><li><a href="https://www.cni.dev/plugins/current/main/win-overlay/"><code>win-overlay</code></a> : Creates an overlay interface to the container</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CNI-Plugins-调研&quot;&gt;&lt;a href=&quot;#CNI-Plugins-调研&quot; class=&quot;headerlink&quot; title=&quot;CNI Plugins 调研&quot;&gt;&lt;/a&gt;CNI Plugins 调研&lt;/h1&gt;&lt;h2 id=&quot;1-通用-CNI-插件&quot;&gt;&lt;a h</summary>
      
    
    
    
    <category term="CNI Plugins" scheme="http://ideameshdyx.github.io/categories/CNI-Plugins/"/>
    
    
    <category term="ospp, edgemesh" scheme="http://ideameshdyx.github.io/tags/ospp-edgemesh/"/>
    
  </entry>
  
  <entry>
    <title>Go basic knowledge</title>
    <link href="http://ideameshdyx.github.io/2023/04/09/Go/Go-basic-knowledge/Go-basic-knowledge/"/>
    <id>http://ideameshdyx.github.io/2023/04/09/Go/Go-basic-knowledge/Go-basic-knowledge/</id>
    <published>2023-04-09T17:16:19.000Z</published>
    <updated>2023-04-22T13:24:02.204Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Go-入门知识"><a href="#Go-入门知识" class="headerlink" title="Go 入门知识"></a>Go 入门知识</h1><blockquote><p>本章节内容基于 <a href="https://tour.go-zh.org/">https://tour.go-zh.org/</a>  <a href="https://tour.go-zh.org/list">Go语言测试平台</a> 索引整理完成</p><p>答案训练参考：</p><p><a href="https://gist.github.com/zyxar/2317744">https://gist.github.com/zyxar/2317744</a></p><p><a href="https://gist.github.com/CarlosLanderas/11b4f6727deec051883ddc02edf5cd0b">https://gist.github.com/CarlosLanderas/11b4f6727deec051883ddc02edf5cd0b</a></p><p>一些有用书籍索引：</p><p><a href="https://books.studygolang.com/gopl-zh/">Go语言圣经（中文版）</a></p><p><a href="http://c.biancheng.net/golang/">Go语言入门教程，Golang入门教程</a></p><p><a href="https://books.studygolang.com/The-Golang-Standard-Library-by-Example/">《Go语言标准库》</a></p></blockquote><h1 id="1-Go-包相关"><a href="#1-Go-包相关" class="headerlink" title="1. Go 包相关"></a>1. Go 包相关</h1><h2 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h2><p>每个 Go 程序都是由包构成的。</p><p>程序从 <code>main</code> 包开始运行。</p><p>比如通过导入路径 <code>&quot;fmt&quot;</code> 和 <code>&quot;math/rand&quot;</code> 来使用这两个包。</p><p>按照约定，包名与导入路径的最后一个元素一致。例如，<code>&quot;math/rand&quot;</code> 包中的源码均以 <code>package rand</code> 语句开始。</p><h2 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h2><p>圆括号组合了导入，这是“分组”形式的导入语</p><h1 id="2-变量"><a href="#2-变量" class="headerlink" title="2. 变量"></a>2. 变量</h1><p>注意类型在变量名之后 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y <span class="type">int</span></span><br></pre></td></tr></table></figure><p><code>var</code> 语句用于声明一个变量列表，跟函数的参数列表一样，类型在最后</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a ,b c, d <span class="type">int</span></span><br></pre></td></tr></table></figure><p>变量声明可以包含初始值，每个变量对应一个， 逗号隔开，如果初始化值已存在，则可以省略类型；变量会从初始值中获得类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i, j <span class="type">int</span> = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"><span class="keyword">var</span> c, python, java = <span class="literal">true</span>, <span class="literal">false</span>, <span class="string">&quot;no!&quot;</span></span><br></pre></td></tr></table></figure><p>简洁赋值语句 <code>:=</code> 可在类型明确的地方代替 <code>var</code> 声明。</p><p>函数外的每个语句都必须以关键字开始（<code>var</code>, <code>func</code> 等等），因此 ​<code>:=</code>​ 结构不能在函数外使用[相较之下 var 可以写到函数外面，在包层级]</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">k := <span class="number">3</span></span><br><span class="line">c, python, java := <span class="literal">true</span>, <span class="literal">false</span>, <span class="string">&quot;no!&quot;</span></span><br></pre></td></tr></table></figure><p><strong>Go 的基本类型有</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">bool</span><br><span class="line"></span><br><span class="line">string</span><br><span class="line"></span><br><span class="line">int  int8  int16  int32  int64</span><br><span class="line">uint uint8 uint16 uint32 uint64 uintptr</span><br><span class="line"></span><br><span class="line">byte // uint8 的别名</span><br><span class="line"></span><br><span class="line">rune // int32 的别名</span><br><span class="line">    // 表示一个 Unicode 码点</span><br><span class="line"></span><br><span class="line">float32 float64</span><br><span class="line"></span><br><span class="line">complex64 complex128</span><br></pre></td></tr></table></figure><p>本例展示了几种类型的变量。 同导入语句一样，变量声明也可以“分组”成一个语法块。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">ToBe   <span class="type">bool</span>       = <span class="literal">false</span></span><br><span class="line">MaxInt <span class="type">uint64</span>     = <span class="number">1</span>&lt;&lt;<span class="number">64</span> - <span class="number">1</span></span><br><span class="line">z      <span class="type">complex128</span> = cmplx.Sqrt(<span class="number">-5</span> + <span class="number">12i</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>int</code>, <code>uint</code> 和 <code>uintptr</code> 在 32 位系统上通常为 32 位宽，在 64 位系统上则为 64 位宽。 当你需要一个整数值时应使用 <code>int</code> 类型，除非你有特殊的理由使用固定大小或无符号的整数类型。</p><p>没有明确初始值的变量声明会被赋予它们的 <strong>零值</strong>。</p><p>零值是：</p><ul><li>数值类型为 <code>0</code>，</li><li>布尔类型为 <code>false</code>，</li><li>字符串为 <code>&quot;&quot;</code>（空字符串）。</li></ul><p>表达式 <code>T(v)</code> 将值 <code>v</code> 转换为类型 <code>T</code>。</p><p>一些关于数值的转换：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var i int = 42</span><br><span class="line">var f float64 = float64(i)</span><br><span class="line">var u uint = uint(f)</span><br></pre></td></tr></table></figure><p>或者，更加简单的形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i := 42</span><br><span class="line">f := float64(i)</span><br><span class="line">u := uint(f)</span><br></pre></td></tr></table></figure><p>与 C 不同的是，Go 在不同类型的项之间赋值时需要显式转换,，等号右边的数值必须是类型明确的</p><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>常量的声明与变量类似，只不过是使用 <code>const</code> 关键字。</p><p>常量可以是字符、字符串、布尔值或数值。</p><p>常量不能用 <code>:=</code> 语法声明。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> World = <span class="string">&quot;世界&quot;</span></span><br><span class="line"><span class="comment">//相较之下，这个申明的world是一个变量，也就是可以改变其类型的</span></span><br><span class="line">world := <span class="string">&quot;世界&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> World = <span class="string">&quot;世界&quot;</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Hello&quot;</span>, World)</span><br><span class="line"></span><br><span class="line">world := <span class="string">&quot;世界&quot;</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Go rules?&quot;</span>, world)</span><br><span class="line">world = <span class="string">&quot;是吗&quot;</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Go rules?&quot;</span>, world)</span><br><span class="line">结果是：</span><br><span class="line">Hello 世界</span><br><span class="line">Go rules? 世界</span><br><span class="line">Go rules? 是吗</span><br></pre></td></tr></table></figure><h2 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h2><p>在声明一个变量而不指定其类型时（即使用不带类型的 <code>:=</code> 语法或 <code>var =</code> 表达式语法），变量的类型由右值推导得出。</p><p>当右值声明了类型时，新变量的类型与其相同：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var i int</span><br><span class="line">j := i // j 也是一个 int</span><br></pre></td></tr></table></figure><p>不过当右边包含未指明类型的数值常量时，新变量的类型就可能是 <code>int</code>, <code>float64</code> 或 <code>complex128</code> 了，这取决于常量的精度：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i := 42           // int</span><br><span class="line">f := 3.142        // float64</span><br><span class="line">g := 0.867 + 0.5i // complex128</span><br></pre></td></tr></table></figure><h2 id="数值常量"><a href="#数值常量" class="headerlink" title="数值常量"></a>数值常量</h2><p>数值常量是高精度的 <strong>值</strong>。</p><p>一个未指定类型的常量由上下文来决定其类型。</p><p>再尝试一下输出 <code>needInt(Big)</code> 吧。</p><p>（<code>int</code> 类型最大可以存储一个 64 位的整数，有时会更小。）</p><p>（<code>int</code> 可以存放最大64位的整数，根据平台不同有时会更少。）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line"><span class="comment">// 将 1 左移 100 位来创建一个非常大的数字</span></span><br><span class="line"><span class="comment">// 即这个数的二进制是 1 后面跟着 100 个 0</span></span><br><span class="line">Big = <span class="number">1</span> &lt;&lt; <span class="number">100</span></span><br><span class="line"><span class="comment">// 再往右移 99 位，即 Small = 1 &lt;&lt; 1，或者说 Small = 2</span></span><br><span class="line">Small = Big &gt;&gt; <span class="number">99</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="3-语句"><a href="#3-语句" class="headerlink" title="3. 语句"></a>3. 语句</h1><h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><p>Go 的 <code>if</code> 语句与 <code>for</code> 循环类似，表达式外无需小括号 <code>( )</code> ，而大括号 <code>&#123; &#125;</code> 则是必须的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> sqrt(-x) + <span class="string">&quot;i&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><p>Go 只有一种循环结构：<code>for</code> 循环。</p><p>基本的 <code>for</code> 循环由三部分组成，它们用分号隔开：</p><ul><li>初始化语句：在第一次迭代前执行</li><li>条件表达式：在每次迭代前求值</li><li>后置语句：在每次迭代的结尾执行</li></ul><p>初始化语句通常为一句短变量声明，该变量声明仅在 <code>for</code> 语句的作用域中可见。</p><p>一旦条件表达式的布尔值为 <code>false</code>，循环迭代就会终止。</p><p>初始化语句和后置语句是可选的，也就是说完全可以只有一个条件，其含义也变成了wihle语句，但是go里面没有while只有for</p><p><strong>注意</strong>：和 C、Java、JavaScript 之类的语言不同，<strong>Go 的 for 语句后面的三个构成部分外没有小括号</strong>， 而包围函数主体的大括号 <code>&#123; &#125;</code> 则是必须的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">sum += i</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(sum)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">sum := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> sum &lt; <span class="number">1000</span>&#123;</span><br><span class="line">sum += sum</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(sum)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="if-的简短语句"><a href="#if-的简短语句" class="headerlink" title="if 的简短语句"></a>if 的简短语句</h2><p>同 <code>for</code> 一样， <code>if</code> 语句可以在条件表达式前执行一个简单的语句。</p><p><strong>该语句声明的变量作用域仅在 ​</strong>**<code>if</code>**<strong>​ 之内。</strong>也就是说出了if语句，这个变量就没有了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pow</span><span class="params">(x, n, lim <span class="type">float64</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">if</span> v := math.Pow(x, n); v &lt; lim &#123;</span><br><span class="line"><span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> lim</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="if-和-else"><a href="#if-和-else" class="headerlink" title="if 和 else"></a>if 和 else</h2><p>在 <code>if</code> 的简短语句中声明的变量同样可以在任何对应的 <code>else</code> 块中使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> v := math.Pow(x, n); v &lt; lim &#123;</span><br><span class="line"><span class="keyword">return</span> v</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%g &gt;= %g\n&quot;</span>, v, lim)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//一般格式是：</span></span><br><span class="line"><span class="keyword">if</span> &#123;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> &#123;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><p><code>switch</code> 是编写一连串 <code>if - else</code> 语句的简便方法。它运行第一个值等于条件表达式的 case 语句。</p><p>Go 的 switch 语句类似于 C、C++、Java、JavaScript 和 PHP 中的，不过 Go 只运行选定的 case，而非之后所有的 case。 实际上，Go 自动提供了在这些语言中每个 case 后面所需的 <code>break</code> 语句。 除非以 <code>fallthrough</code> 语句结束，否则分支会自动终止。 Go 的另一点重要的不同在于 switch 的 case 无需为常量，且取值不必为整数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> os := runtime.GOOS; os &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;darwin&quot;</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;OS X.&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;linux&quot;</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;Linux.&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">// freebsd, openbsd,</span></span><br><span class="line"><span class="comment">// plan9, windows...</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%s.\n&quot;</span>, os)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="switch-的求值顺序"><a href="#switch-的求值顺序" class="headerlink" title="switch 的求值顺序"></a>switch 的求值顺序</h2><p>switch 的 case 语句从上到下顺次执行，直到匹配成功时停止。</p><p>（例如，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">switch i &#123;</span><br><span class="line">case 0:</span><br><span class="line">case f():</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>i==0</code> 时 <code>f</code> 不会被调用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">today := time.Now().Weekday()</span><br><span class="line"><span class="keyword">switch</span> time.Saturday &#123;</span><br><span class="line"><span class="keyword">case</span> today + <span class="number">0</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;Today.&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> today + <span class="number">1</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;Tomorrow.&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> today + <span class="number">2</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;In two days.&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;Too far away.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="没有条件的-switch"><a href="#没有条件的-switch" class="headerlink" title="没有条件的 switch"></a>没有条件的 switch</h2><p>没有条件的 switch 同 <code>switch true</code> 一样。</p><p>这种形式能将一长串 if-then-else 写得更加清晰。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">t := time.Now()</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> t.Hour() &lt; <span class="number">12</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;Good morning!&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> t.Hour() &lt; <span class="number">17</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;Good afternoon.&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;Good evening.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h2><p>defer 语句会将函数推迟到外层函数返回之后执行。</p><p>推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;world&quot;</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">结果是：</span><br><span class="line">hello</span><br><span class="line">world</span><br></pre></td></tr></table></figure><h2 id="defer-栈"><a href="#defer-栈" class="headerlink" title="defer 栈"></a>defer 栈</h2><p>推迟的函数调用会被压入一个栈中。当外层函数返回时，被推迟的函数会按照后进先出的顺序调用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;counting&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;done&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">由于是按照栈的形式来存的</span><br><span class="line">counting</span><br><span class="line">done</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><p><a href="https://blog.go-zh.org/defer-panic-and-recover">Defer，Panic,Recover</a></p><h2 id="函数返回"><a href="#函数返回" class="headerlink" title="函数返回"></a>函数返回</h2><p>函数可以返回任意数量的返回值, 但是结构上需要结合函数形式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="type">string</span>)</span></span> (<span class="type">string</span>, <span class="type">string</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> y, x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go 的返回值可被命名，它们会被视作定义在函数顶部的变量。</p><p>返回值的名称应当具有一定的意义，它可以作为文档使用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Go-入门知识&quot;&gt;&lt;a href=&quot;#Go-入门知识&quot; class=&quot;headerlink&quot; title=&quot;Go 入门知识&quot;&gt;&lt;/a&gt;Go 入门知识&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本章节内容基于 &lt;a href=&quot;https://tour.go-zh.o</summary>
      
    
    
    
    <category term="Golang, Basic" scheme="http://ideameshdyx.github.io/categories/Golang-Basic/"/>
    
    
  </entry>
  
  <entry>
    <title>读书笔记--深入理解Linux网络</title>
    <link href="http://ideameshdyx.github.io/2023/04/02/Book/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%E7%BD%91%E7%BB%9C/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%E7%BD%91%E7%BB%9C/"/>
    <id>http://ideameshdyx.github.io/2023/04/02/Book/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%E7%BD%91%E7%BB%9C/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%E7%BD%91%E7%BB%9C/</id>
    <published>2023-04-02T17:47:41.000Z</published>
    <updated>2023-04-22T13:24:02.204Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Golang-数据结构-链表</title>
    <link href="http://ideameshdyx.github.io/2023/04/01/Algorithm/Golang-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Golang-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/"/>
    <id>http://ideameshdyx.github.io/2023/04/01/Algorithm/Golang-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Golang-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/</id>
    <published>2023-04-01T16:46:21.000Z</published>
    <updated>2023-04-23T10:12:49.569Z</updated>
    
    
    
    
    <category term="算法，Golang, 链表" scheme="http://ideameshdyx.github.io/categories/%E7%AE%97%E6%B3%95%EF%BC%8CGolang-%E9%93%BE%E8%A1%A8/"/>
    
    
    <category term="链表, 算法" scheme="http://ideameshdyx.github.io/tags/%E9%93%BE%E8%A1%A8-%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Golang 算法课程--数据结构</title>
    <link href="http://ideameshdyx.github.io/2023/04/01/Algorithm/Golang-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Golang-%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B--%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://ideameshdyx.github.io/2023/04/01/Algorithm/Golang-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Golang-%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B--%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2023-04-01T16:46:21.000Z</published>
    <updated>2023-04-22T13:24:02.164Z</updated>
    
    <content type="html"><![CDATA[<h1 id="告别盲目刷题，击破算法面试"><a href="#告别盲目刷题，击破算法面试" class="headerlink" title="告别盲目刷题，击破算法面试"></a>告别盲目刷题，击破算法面试</h1><blockquote><p>学习拉钩教育算法课程记录加个人感悟记录<br>如果有版权问题，请联系 <a href="mailto:&#50;&#x33;&#55;&#x34;&#48;&#56;&#55;&#51;&#50;&#x32;&#64;&#x71;&#113;&#x2e;&#x63;&#111;&#x6d;">&#50;&#x33;&#55;&#x34;&#48;&#56;&#55;&#51;&#50;&#x32;&#64;&#x71;&#113;&#x2e;&#x63;&#111;&#x6d;</a> 删除课程部分的内容</p><p>算法能力的高度，决定了个人能够解决的实战问题复杂度的上限</p><p>数学基础决定了算法能力的高低</p></blockquote><h2 id="解题流程-："><a href="#解题流程-：" class="headerlink" title="==解题流程==："></a>==解题流程==：</h2><h3 id="四部分析法"><a href="#四部分析法" class="headerlink" title="==四部分析法=="></a>==四部分析法==</h3><ul><li><p><strong>==模拟==</strong> ： 模拟题目的运行<br>使用简单且有一定量的小例子，将自己当作计算机来执行这个流程<br><em>一般使用题目给的较长的那个例子就可以</em><br><br>这部分也是读题和理解输入输出内容的部分，理解题意的部分<br><br>这个时候一定不能够着急，不要害怕或者是觉得麻烦，一定要耐下性子，把简单的一个逻辑过程给跑清楚，理解这段程序或者是业务需要咱们处理什么样的问题。<br><br>跑的过程，不要完全先入为主，应当以题目的要求来推进演示。<br><br>不要想着在这一步就把所有的问题都给解决，一步步推进就可以. </p><br /></li><li><p><strong>==规律==</strong> ： 尝试总结出题目的一般规律和特点</p><p>数学规律和特性一般来说很难直接从零归纳出来，但我们可以依赖所学习的高数、线性代数、离散数学、测度论等高等数学理论当中所见到的数学计算模型来匹配，这也是这部分最重要的基础</p><p>先总结一些考题可能会用到的观察特点：</p><ul><li>形式相关：比如 括号匹配、从1加到100，</li><li>数量变化：数量变化与取模相关，数量变化呈现递推公式</li><li></li></ul></li></ul><ul><li><p><strong>==匹配==</strong> ： 找到符合这些特点的数据结构和算法</p><ul><li><p>关注数据的输入类型：对输入数据进行分类，哪一些数据进行怎样的操作</p></li><li><p>**==怎样匹配呢？==**：</p><ul><li>题目模拟的时候（这部分一般使用栈、队列、二叉树）来理解题目要求的数字变化</li><li>观察结果集合，或者是原本中间的变化集合，当期符合某种数据结构的变化特征的时候，就可以选用这个数据结构</li></ul></li></ul></li></ul><ul><li>**==考虑边界条件==**： 考虑特殊情况<br>特殊情况：<ul><li>字符串为空，字符串只有一个，两个、</li><li>数组为空，数字为0或者是其他不符合规律的特殊情况</li></ul></li></ul><ul><li><strong>==深度思考==</strong> ： 平时练习当中的流程，用于提高算法模型的积累<ul><li>深度： 这种解法还可以怎么优化</li><li>广度： 这种解法的具有普适性吗？可以推广吗？问题的限定条件变多的话，这个模型是否还可以适合。</li><li>数学模式扩散： 这样特点的问题是否有对应的数学模型或者是理论描述过</li></ul></li></ul><h1 id="栈：-从简单栈到单调栈，让栈问题不再困难"><a href="#栈：-从简单栈到单调栈，让栈问题不再困难" class="headerlink" title="栈： 从简单栈到单调栈，让栈问题不再困难"></a>栈： 从简单栈到单调栈，让栈问题不再困难</h1><h2 id="结构特征"><a href="#结构特征" class="headerlink" title="结构特征"></a>结构特征</h2><p>先进后出</p><p>对栈的操作：</p><ul><li><strong>==pop==</strong> 弹出栈顶元素，一般来说栈中可操作的元素就是栈顶元素，其他元素也都是先pop出其上面的元素，变成栈顶元素之后再进行操作。</li><li> <strong>==peek==</strong> 获取栈顶元素，只是读取操作，但并没有弹出栈顶元素</li><li> <strong>==push==</strong> 将元素压入栈中</li></ul><h3 id="Golang-栈的使用"><a href="#Golang-栈的使用" class="headerlink" title="Golang 栈的使用"></a>Golang 栈的使用</h3><p>在 Go 中并没有直接提供Stack的方法结构，但可以使用切片非常简单地表示和使用栈、队列结构。</p><p> 先进后出的数据结构，使用**==切片==**表示，压入栈的操作就是往切片中添加元素，弹出栈的操作就是输出末尾元素，并将切片缩小为：<code>[:len(stack)-1]</code></p><p>以下为栈的代码模板实现：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stack <span class="keyword">struct</span>&#123;</span><br><span class="line">    Stack []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stack)</span></span>push(x <span class="keyword">interface</span>&#123;&#125;)&#123;</span><br><span class="line">    s = <span class="built_in">append</span>(s,x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stack)</span></span>pop()&#123;</span><br><span class="line">    s = s[:<span class="built_in">len</span>(s)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stack)</span></span>peek()(x <span class="keyword">interface</span>&#123;&#125;)&#123;</span><br><span class="line">    <span class="keyword">return</span> s[<span class="built_in">len</span>(s)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键在于记住：</p><ul><li>栈顶元素 —&gt; 切片末尾元素</li><li>切片是左闭右开，所以pop操作是 s = s[:len(s)-1], 但如果是队列pop出第一个元素就需要往后再移动一位 s = s[1:] 而不是 s = s[0:]</li></ul><h2 id="典型题目"><a href="#典型题目" class="headerlink" title="典型题目"></a>典型题目</h2><h3 id="判断字符串是否合法"><a href="#判断字符串是否合法" class="headerlink" title="判断字符串是否合法"></a>判断字符串是否合法</h3><p>题目：<a href="https://leetcode.cn/problems/valid-parentheses/">https://leetcode.cn/problems/valid-parentheses/</a></p><h4 id="正确解法和流程"><a href="#正确解法和流程" class="headerlink" title="正确解法和流程"></a>正确解法和流程</h4><p><a href="https://leetcode.cn/link/?target=https://www.bilibili.com/video/BV1AF411w78g">https://leetcode.cn/link/?target=https://www.bilibili.com/video/BV1AF411w78g</a></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValid</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    pairs := <span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">byte</span>&#123;</span><br><span class="line">        <span class="string">&#x27;)&#x27;</span>: <span class="string">&#x27;(&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;]&#x27;</span>: <span class="string">&#x27;[&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;&#125;&#x27;</span>: <span class="string">&#x27;&#123;&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    stack := []<span class="type">byte</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> pairs[s[i]] &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(stack) == <span class="number">0</span> || stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>] != pairs[s[i]] &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stack = <span class="built_in">append</span>(stack, s[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(stack) == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="个人解法和流程"><a href="#个人解法和流程" class="headerlink" title="个人解法和流程"></a>个人解法和流程</h4><blockquote><p>问题集中体现在数据特性处理判断太过分散，属实是缝缝补补有一年<br>对输入数据进行分类，哪一些数据进行怎样的操作</p><ul><li>输入的是左括号应该入栈</li><li>输入的是右括号应该做判断<br /></li></ul></blockquote><p>我的代码是：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">isValid</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    </span><br><span class="line">    l := <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">if</span> l%<span class="number">2</span> != <span class="number">0</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    stack := <span class="built_in">make</span>([]<span class="type">rune</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    m := <span class="keyword">map</span>[<span class="type">rune</span>]<span class="type">rune</span>&#123;</span><br><span class="line">        <span class="string">&#x27;]&#x27;</span>:<span class="string">&#x27;[&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;)&#x27;</span>:<span class="string">&#x27;(&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;&#125;&#x27;</span>:<span class="string">&#x27;&#123;&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> s&#123;</span><br><span class="line">        <span class="keyword">if</span> v == <span class="string">&#x27;[&#x27;</span> ||v == <span class="string">&#x27;&#123;&#x27;</span> ||v == <span class="string">&#x27;(&#x27;</span>&#123;</span><br><span class="line">            stack = <span class="built_in">append</span>(stack,v)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(stack) == <span class="number">0</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>] == m[v]&#123;</span><br><span class="line">            stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> m[v] != <span class="number">0</span> &#123;<span class="keyword">return</span> <span class="literal">false</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(stack) == <span class="number">0</span>&#123;<span class="keyword">return</span> <span class="literal">true</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述在判断栈顶元素的时候逻辑不够清晰，所以加了很多的if来补足条件，我们看例子当中所给的逻辑顺序：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    pairs := <span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">byte</span>&#123;</span><br><span class="line">    <span class="string">&#x27;)&#x27;</span>: <span class="string">&#x27;(&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;]&#x27;</span>: <span class="string">&#x27;[&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;&#125;&#x27;</span>: <span class="string">&#x27;&#123;&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line">stack := []<span class="type">byte</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">    <span class="keyword">if</span> pairs[s[i]] &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(stack) == <span class="number">0</span> || stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>] != pairs[s[i]] &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        stack = <span class="built_in">append</span>(stack, s[i])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(stack) == <span class="number">0</span></span><br></pre></td></tr></table></figure><p>关键差距就在于这一句话：<code>pairs[s[i]] &gt; 0 </code>, 这个判断对输入的数据做了一次分类，依据上面的map结构可知，这句话 &lt; 0 时候标识map当中没有存储对应的对象，而map中存储的是所有的左括号，所以这个判断的作用是<strong>当输入是右括号的时候进入函数</strong>，然后逻辑体依据输入是右括号判断，如果当前栈里面没有元素或者是栈顶元素与右括号不匹配那么就返回false<br><br>实际上我写的函数最后夜市做了类似的判断，但显然没有考虑数据分类的情况。</p><h3 id="判断大鱼吃小鱼最后留下的鱼"><a href="#判断大鱼吃小鱼最后留下的鱼" class="headerlink" title="判断大鱼吃小鱼最后留下的鱼"></a>判断大鱼吃小鱼最后留下的鱼</h3><p>题目：</p><p>近似题目：<a href="https://www.nowcoder.com/questionTerminal/3fdfc63015df42c6a78fdae46709fa69?f=discussion">https://www.nowcoder.com/questionTerminal/3fdfc63015df42c6a78fdae46709fa69?f=discussion</a></p><br /><h4 id="正确解法和流程-1"><a href="#正确解法和流程-1" class="headerlink" title="正确解法和流程"></a>正确解法和流程</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param N int整型 N条鱼</span></span><br><span class="line"><span class="comment">     * @param A int整型vector 每条鱼的体积为Ai</span></span><br><span class="line"><span class="comment">     * @return int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">P</span>&#123;</span><br><span class="line">        <span class="type">int</span> x, t;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> N, vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        stack&lt;P&gt; S;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=N<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(!S.<span class="built_in">empty</span>() &amp;&amp; A[i]&gt;S.<span class="built_in">top</span>().x)&#123;</span><br><span class="line">                t = <span class="built_in">max</span>(S.<span class="built_in">top</span>().t, t+<span class="number">1</span>);</span><br><span class="line">                S.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            S.<span class="built_in">push</span>(&#123;A[i], t&#125;);</span><br><span class="line">            cnt = <span class="built_in">max</span>(cnt, t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="个人解法和流程-1"><a href="#个人解法和流程-1" class="headerlink" title="个人解法和流程"></a>个人解法和流程</h4><p>由于找不到相同的题目，就找了类似的题目，但是解题的思路不太一样<br>图片上的大鱼吃小鱼，只需要每次比较栈顶元素和新进来的元素大小即可，当大于的时候，就不做操作，当栈顶元素小于输入元素的时候，pop出栈顶元素并push进入这个最大值，最后栈中元素就是结果。这个过程当中几处需要重视的地方是：</p><ul><li>当鱼的方向一致时候，大鱼并不会把同方向的小鱼给吃了【可能不论大小鱼的速度相同（bushi）】，而如果小鱼在左，大鱼在右，方向不同，则也不会吃</li></ul><p>牛客网的题目则加了非常多的条件和限制，是对栈问题的一个较大的变化</p><blockquote><p>对比上述两个题目可以观察到：<br><font color ='blue'> 1. 消除的行为不同</font><br>  括号匹配中，消除行为是配对的两者都会消除，也就是栈顶元素和输入元素一起被消除<br>  大鱼吃小鱼中，消除行为是配对的两者中会有一个被消除<br>–&gt; 是否入栈和出栈的判断<br><font color ='blue'> 2. 栈中的内容不同</font><br>  括号匹配当中，栈中存放的就是内容本身<br>  大鱼吃小鱼当中，栈里存放的是内容的索引，可以通过索引找到内容<br><font color ='blue'> 3. 弹栈的方式也不相同</font><br>  括号匹配只需要每次弹出一个元素就可以<br>  大鱼则需要用while语句一直弹出到满足某个条件才停止</p></blockquote><h2 id="栈问题的特征和解决流程"><a href="#栈问题的特征和解决流程" class="headerlink" title="栈问题的特征和解决流程"></a>栈问题的特征和解决流程</h2><h3 id="pop-行为不同"><a href="#pop-行为不同" class="headerlink" title="pop 行为不同"></a>pop 行为不同</h3><p>pop【弹栈的操作不一样】<br>常见的就是每次循环都判断栈顶元素的特点而pop或者push或者不操作，但这样必须得是连续性的元素才有这样的特征</p><p><strong>==在弹栈的时候，是否一定要满足某个条件才停止弹栈==</strong><br>也就是说当输入元素之后需要将其和站内其他的元素进行比较，在使用的时候尤其要注意迭代过程</p><h3 id="栈中存储内容不相同"><a href="#栈中存储内容不相同" class="headerlink" title="栈中存储内容不相同"></a>栈中存储内容不相同</h3><p>是否栈中存储数据、还是存储索引、还是存储一个自建的新的结构</p><h3 id="栈顶元素的含义不相同"><a href="#栈顶元素的含义不相同" class="headerlink" title="栈顶元素的含义不相同"></a>栈顶元素的含义不相同</h3><h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><p>单调栈是指栈中元素必须按照升序排列的栈或者是降序排列的栈</p><p>单调栈分为：</p><ul><li><p>递增栈：<br>  栈中元素从左到右遵守从小到大的顺序<br>  入栈时候，当<strong>入栈元素小于栈顶元素</strong>就会pop出栈顶元素，直到入栈元素大于栈顶元素<br>  特点是：<br>  入栈小数会消除栈内大数</p></li><li><p>递减栈<br>  栈中元素从左到右遵守从大到小的顺序<br>  入栈时候，当<strong>入栈元素大于栈顶元素</strong>就会pop出栈顶元素，直到入栈元素小于栈顶元素<br>  特点是：<br>  入栈大数会消除栈内小数</p></li></ul><h3 id="典型代码："><a href="#典型代码：" class="headerlink" title="典型代码："></a>典型代码：</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">stack := <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">0</span>)</span><br><span class="line"><span class="comment">/**递增栈的入栈</span></span><br><span class="line"><span class="comment">* 用for 循环出栈，直到栈顶元素满足递增栈的要求</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(stack)&gt; <span class="number">0</span> &amp;&amp; A[i] &gt; stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]&#123;</span><br><span class="line">    <span class="comment">// pop出栈内比 A[i]小但却在前面的元素</span></span><br><span class="line">    stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line">stack = <span class="built_in">append</span>(stack,A[i])</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="找到当前数字右边最小的对应数字"><a href="#找到当前数字右边最小的对应数字" class="headerlink" title="找到当前数字右边最小的对应数字"></a>找到当前数字右边最小的对应数字</h3><h3 id="取k个字符，求字典序最小的组合"><a href="#取k个字符，求字典序最小的组合" class="headerlink" title="取k个字符，求字典序最小的组合"></a>取k个字符，求字典序最小的组合</h3><blockquote><p>字典序：</p><ul><li>对单个元素按照ascii 表中大小顺序排列</li><li>多个元素时，按照从左到右顺序，先从高位字典排序，然后在相同高位中按照地位再字典排序</li></ul></blockquote><h3 id="给定一个数组，数组中元素代表模板的高度，请你求出相邻木板能剪出的最大矩形面积"><a href="#给定一个数组，数组中元素代表模板的高度，请你求出相邻木板能剪出的最大矩形面积" class="headerlink" title="给定一个数组，数组中元素代表模板的高度，请你求出相邻木板能剪出的最大矩形面积"></a>给定一个数组，数组中元素代表模板的高度，请你求出相邻木板能剪出的最大矩形面积</h3><blockquote><p>和求最大容积是一个题目</p></blockquote><br /><h2 id="leetcode-题目汇总"><a href="#leetcode-题目汇总" class="headerlink" title="leetcode 题目汇总"></a>leetcode 题目汇总</h2><blockquote><p>以leetcode 题目为例子</p></blockquote><p>相关栈的题目汇总：<br>[1][<a href="https://leetcode.cn/problem-list/xb9nqhhg/?topicSlugs=stack&amp;page=1%5D">https://leetcode.cn/problem-list/xb9nqhhg/?topicSlugs=stack&amp;page=1]</a><br>[2][<a href="https://leetcode.cn/problem-list/e8X3pBZi/?page=1&amp;topicSlugs=heap-priority-queue%5D">https://leetcode.cn/problem-list/e8X3pBZi/?page=1&amp;topicSlugs=heap-priority-queue]</a><br>[3][<a href="https://leetcode.cn/problem-list/2cktkvj/?page=1&amp;topicSlugs=stack%5D">https://leetcode.cn/problem-list/2cktkvj/?page=1&amp;topicSlugs=stack]</a></p><h1 id="队列：FIFO-队列与单调队列的深挖与扩展"><a href="#队列：FIFO-队列与单调队列的深挖与扩展" class="headerlink" title="队列：FIFO 队列与单调队列的深挖与扩展"></a>队列：FIFO 队列与单调队列的深挖与扩展</h1><p>先进先出，是共同特征</p><p>类别上可以分出：</p><ul><li>FIFO队列</li><li>单调队列</li></ul><h2 id="FIFO队列"><a href="#FIFO队列" class="headerlink" title="FIFO队列"></a>FIFO队列</h2><p><strong>==Push 元素时候， 总是将放在元素放在队列尾部，也就是操作 fifo[len(fifo)-1]==</strong><br><strong>==Pop 元素时候，总是将队列首部的元素扔掉 ，也就是操作 fifo = fifo[1:]==</strong></p><h3 id="二叉树的层次遍历（两种方法）"><a href="#二叉树的层次遍历（两种方法）" class="headerlink" title="二叉树的层次遍历（两种方法）"></a>二叉树的层次遍历（两种方法）</h3><ul><li><p>规律：<br>广度遍历（层次遍历）：由于二叉树的特点，当拿到第N层的结点A之后，可以通过 A 的left，right指针拿到下一层的节点</p></li><li><p><em>但是与A在同一层的节点还有其他吗，这个时候就需要按层来存储节点，不能直接使用递归</em>*</p>   <br />   顺序输出：每层输出时，排在左边的节点，它的子节点同样排在下一层的最左边</li></ul><p>–&gt; <strong>==题目具备广度遍历（分层遍历）的特点 和 顺序输出的特点 ，应该想到应用FIFO队列==</strong></p><ul><li>边界<br>特殊判断： 如果发现是一棵空二叉树，就直接返回空结果<br>==制定一个规则==： 不要让空指针进入到FIFO队列（一些编程的亮点）</li></ul><p><font color = 'red'> 非常重要的概念： QSize 表示当前层数 </font></p><h4 id="层次遍历二叉树"><a href="#层次遍历二叉树" class="headerlink" title="层次遍历二叉树"></a>层次遍历二叉树</h4><p>题目链接：<a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/submissions/">https://leetcode.cn/problems/binary-tree-level-order-traversal/submissions/</a></p><h5 id="解题思路1"><a href="#解题思路1" class="headerlink" title="解题思路1"></a>解题思路1</h5><p>关键思路在于将每一层的节点都存在FIFO队列里面，在每次遍历的时候从左到右pop出该层的节点，同时在队尾加入他的左右孩子</p><p>队首pop出当层节点，队尾append下一层的孩子节点<br>QSize 记录当层的节点数量</p><p>时间复杂度是O(n), 空间复杂度由QSize决定O(K),K表示QSize最大，也就是存储的一层节点数量最多的时候</p><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">levelOrder</span><span class="params">(root *TreeNode)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 创建FIFO 队列来存储遍历的过程</span></span><br><span class="line">    fifo := <span class="built_in">make</span>([]*TreeNode,<span class="number">0</span>)</span><br><span class="line">    <span class="comment">// QSize 表示当前遍历的层</span></span><br><span class="line">    QSize := <span class="number">1</span></span><br><span class="line">    <span class="comment">// 初始化最终结果</span></span><br><span class="line">    result := <span class="built_in">make</span>([][]<span class="type">int</span>,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将根节点入栈</span></span><br><span class="line">    fifo = <span class="built_in">append</span>(fifo,root)</span><br><span class="line">    <span class="comment">// 开始层序遍历，只要当前队列不为空</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(fifo) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 创建结果数组用于存储当层pop出的元素值</span></span><br><span class="line">        tmp := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 当层元素QSize全部遍历以此，这里不能用len(fifo)，因为fifo的长度是在变化的</span></span><br><span class="line">        <span class="keyword">for</span> i := QSize;i &gt; <span class="number">0</span>;i--&#123;</span><br><span class="line">            <span class="comment">// 拿出队列头元素</span></span><br><span class="line">            node := fifo[<span class="number">0</span>]</span><br><span class="line">            <span class="comment">// 判断他的左孩子是否为空</span></span><br><span class="line">            <span class="keyword">if</span> node.Left!= <span class="literal">nil</span>&#123;</span><br><span class="line">                fifo = <span class="built_in">append</span>(fifo,node.Left)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断他的右孩子是否为空</span></span><br><span class="line">            <span class="keyword">if</span> node.Right != <span class="literal">nil</span>&#123;</span><br><span class="line">                fifo = <span class="built_in">append</span>(fifo,node.Right)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将该节点的值存入结果</span></span><br><span class="line">            tmp = <span class="built_in">append</span>(tmp,node.Val)</span><br><span class="line">            <span class="comment">// 推出队首元素</span></span><br><span class="line">            fifo = fifo[<span class="number">1</span>:]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将结果 tmp 存入到结果数组当中</span></span><br><span class="line">        result = <span class="built_in">append</span>(result,tmp)</span><br><span class="line">        <span class="comment">// 重新计算当前层的节点数量</span></span><br><span class="line">        QSize = <span class="built_in">len</span>(fifo)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a>官方题解</h5><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">levelOrder</span><span class="params">(root *TreeNode)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    ret := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    &#125;</span><br><span class="line">    q := []*TreeNode&#123;root&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; <span class="built_in">len</span>(q) &gt; <span class="number">0</span>; i++ &#123;</span><br><span class="line">        ret = <span class="built_in">append</span>(ret, []<span class="type">int</span>&#123;&#125;)</span><br><span class="line">        p := []*TreeNode&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(q); j++ &#123;</span><br><span class="line">            node := q[j]</span><br><span class="line">            ret[i] = <span class="built_in">append</span>(ret[i], node.Val)</span><br><span class="line">            <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                p = <span class="built_in">append</span>(p, node.Left)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                p = <span class="built_in">append</span>(p, node.Right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        q = p</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="解题思路2"><a href="#解题思路2" class="headerlink" title="解题思路2"></a>解题思路2</h5><p>使用链表来解决问题</p><h4 id="锯齿状层次遍历"><a href="#锯齿状层次遍历" class="headerlink" title="锯齿状层次遍历"></a>锯齿状层次遍历</h4><p>题目链接：<a href="https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/">https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/</a></p><h5 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h5><p>层次遍历的基础上加一个qs，表示当前层是从左到右还是从右到左</p><p>**==本题当中所犯的错误：==**：</p><ul><li>每一轮都需要重新计算qsize,一定不要忘了这一点</li><li>tmp 接收的时候还是按照栈的pop逻辑，所以顺序上还需要再反一次</li><li>题目样例当中root是按照从左到右遍历过一次来计算的</li></ul><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zigzagLevelOrder</span><span class="params">(root *TreeNode)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">//结果数组</span></span><br><span class="line">    result := <span class="built_in">make</span>([][]<span class="type">int</span>,<span class="number">0</span>)</span><br><span class="line">    <span class="comment">//全局的fifo队列</span></span><br><span class="line">    fifo := <span class="built_in">make</span>([]*TreeNode,<span class="number">0</span>)</span><br><span class="line">    <span class="comment">// Qsize 表示当前层的节点数，qs 表示该层的遍历顺序，0表示从左到右，1表示从右到左</span></span><br><span class="line">    Qsize ,qs := <span class="number">1</span> , <span class="number">1</span></span><br><span class="line">    <span class="comment">// 如果树中没有节点则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将 root 放入队列</span></span><br><span class="line">    fifo = <span class="built_in">append</span>(fifo,root)</span><br><span class="line">    <span class="comment">//遍历整棵树</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(fifo) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        tmp := <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> i:= <span class="number">1</span>; Qsize &gt;= i &amp;&amp; qs == <span class="number">0</span> ;i++&#123;</span><br><span class="line">            node := fifo[Qsize-i]</span><br><span class="line">            <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                fifo = <span class="built_in">append</span>(fifo,node.Right)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> node.Left != <span class="literal">nil</span>&#123;</span><br><span class="line">                fifo = <span class="built_in">append</span>(fifo,node.Left)</span><br><span class="line">            &#125;</span><br><span class="line">            tmp = <span class="built_in">append</span>(tmp,node.Val)                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i:= <span class="number">1</span>; Qsize &gt;= i &amp;&amp; qs == <span class="number">1</span> ;i++&#123;</span><br><span class="line">            node := fifo[Qsize-i]</span><br><span class="line">            <span class="keyword">if</span> node.Left != <span class="literal">nil</span>&#123;</span><br><span class="line">                fifo = <span class="built_in">append</span>(fifo,node.Left)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> node.Right != <span class="literal">nil</span>&#123;</span><br><span class="line">                fifo = <span class="built_in">append</span>(fifo,node.Right)</span><br><span class="line">            &#125;</span><br><span class="line">            tmp = <span class="built_in">append</span>(tmp,node.Val)                </span><br><span class="line">        &#125;</span><br><span class="line">        fifo = fifo[Qsize:]</span><br><span class="line">        Qsize = <span class="built_in">len</span>(fifo)</span><br><span class="line">        result = <span class="built_in">append</span>(result,tmp)</span><br><span class="line">        <span class="keyword">if</span> qs == <span class="number">1</span>&#123;</span><br><span class="line">            qs = <span class="number">0</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            qs = <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="倒序层次遍历"><a href="#倒序层次遍历" class="headerlink" title="倒序层次遍历"></a>倒序层次遍历</h4><p>题目链接：<a href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/">https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/</a></p><h5 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h5><p>从题目要求当中可以读出，是在之前的层序遍历基础上把结果倒过来输出，那么会比较自然想到可以在使用一个栈用来存储中间结果</p><h5 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h5><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">levelOrderBottom</span><span class="params">(root *TreeNode)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 构造全局fifo队列</span></span><br><span class="line">    fifo := <span class="built_in">make</span>([]*TreeNode,<span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 构造结果栈</span></span><br><span class="line">    stack := <span class="built_in">make</span>([][]<span class="type">int</span>,<span class="number">0</span>)</span><br><span class="line">    result := <span class="built_in">make</span>([][]<span class="type">int</span>,<span class="number">0</span>)</span><br><span class="line">    <span class="comment">//表示当前层的节点数量</span></span><br><span class="line">    Qsize := <span class="number">1</span></span><br><span class="line">    fifo = <span class="built_in">append</span>(fifo,root)</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(fifo) &gt; <span class="number">0</span>&#123;</span><br><span class="line">        tmp := <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> Qsize &gt; <span class="number">0</span>&#123;</span><br><span class="line">            node:= fifo[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">if</span> node.Left != <span class="literal">nil</span>&#123;</span><br><span class="line">                fifo =<span class="built_in">append</span>(fifo,node.Left)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> node.Right != <span class="literal">nil</span>&#123;</span><br><span class="line">                fifo = <span class="built_in">append</span>(fifo,node.Right)</span><br><span class="line">            &#125;</span><br><span class="line">            Qsize--</span><br><span class="line">            fifo = fifo[<span class="number">1</span>:]</span><br><span class="line">            tmp = <span class="built_in">append</span>(tmp,node.Val)</span><br><span class="line">        &#125;</span><br><span class="line">        stack = <span class="built_in">append</span>(stack,tmp)</span><br><span class="line">        Qsize = <span class="built_in">len</span>(fifo)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将栈中元素pop 到结果当中</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span>&#123;</span><br><span class="line">        result = <span class="built_in">append</span>(result,stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>])</span><br><span class="line">        stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h2><p>设计一个可以容纳 k 个元素的循环队列，需要实现以下接口：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ringQueue <span class="keyword">interface</span>&#123;</span><br><span class="line">    <span class="comment">//构造函数，参数k表示这个循环队列最多容纳k个元素</span></span><br><span class="line">    CircularQueue(<span class="type">int</span>)</span><br><span class="line">    <span class="comment">//将value放到队列中，成功返回true</span></span><br><span class="line">    EnQueue(<span class="type">int</span>) <span class="type">bool</span></span><br><span class="line">    <span class="comment">// 删除队首元素，成功返回true</span></span><br><span class="line">    DeQueue() <span class="type">bool</span></span><br><span class="line">    <span class="comment">// 得到队首元素，如果队列为空，返回-1</span></span><br><span class="line">    Front() <span class="type">int</span></span><br><span class="line">    <span class="comment">// 得到队尾元素，如果队列为空，返回-1</span></span><br><span class="line">    Rear() <span class="type">int</span></span><br><span class="line">    <span class="comment">// 查看循环队列是否为空</span></span><br><span class="line">    isEmpty() <span class="type">bool</span></span><br><span class="line">    <span class="comment">// 查看队列是否已经放满k个元素</span></span><br><span class="line">    isFull() <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>==循环队列的重点在于==: <font color = 'red'>循环使用固定空间</font></strong></li><li><strong>==难点在于==： <font color='red'>控制好 Front/Rear两个首位指示器</font></strong></li></ul><h3 id="表示方法1"><a href="#表示方法1" class="headerlink" title="表示方法1"></a>表示方法1</h3><p>使用 <code>used</code>、<code>front</code>、<code>rear</code> 三个变量来控制，其中<code>used, front</code>都代表的是数组的下标</p><p>注意以下几点：</p><ul><li>index = i 的后一个是i+1，前一个是i+1</li><li>index = k-1 的后一个就是index=0</li><li>index = 0 的前一个是 index = k-1</li><li><em>==可以使用取模的方式统一处理==:</em>*<br><font color='red'> index = i 的后一个元素下标是（i+1）% k</font><br><font color='red'> index = i 的前一个元素下标是（i-1+k）% k</font><br><font color='blue'>所有的循环数组下标的处理都需要按照这个取模的方式</font></li></ul><p>参考的实例代码如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyCircularQueue <span class="keyword">struct</span> &#123;</span><br><span class="line">    queue  []<span class="type">int</span></span><br><span class="line">    rear   <span class="type">int</span></span><br><span class="line">    front  <span class="type">int</span></span><br><span class="line">    used   <span class="type">int</span></span><br><span class="line">    length <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CircularQueue</span><span class="params">(k <span class="type">int</span>)</span></span> ringQueue &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;MyCircularQueue&#123;</span><br><span class="line">        queue:  <span class="built_in">make</span>([]<span class="type">int</span>, k),</span><br><span class="line">        rear:   <span class="number">0</span>,</span><br><span class="line">        front:  <span class="number">0</span>,</span><br><span class="line">        used:   <span class="number">0</span>,</span><br><span class="line">        length: k,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *MyCircularQueue)</span></span> EnQueue(value <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> q.isFull() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span> </span><br><span class="line">    &#125;</span><br><span class="line">    q.queue[q.rear] = value</span><br><span class="line">    q.rear = (q.rear + <span class="number">1</span>) % q.length</span><br><span class="line">    q.used++</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *MyCircularQueue)</span></span> DeQueue() <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> q.isEmpty() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    q.front = (q.front + <span class="number">1</span>) % q.length</span><br><span class="line">    q.used--</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *MyCircularQueue)</span></span> Front() <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> q.used == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> q.queue[q.front]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *MyCircularQueue)</span></span> Rear() <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> q.used == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> q.queue[(q.rear<span class="number">-1</span>+q.length)%q.length]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *MyCircularQueue)</span></span> isEmpty() <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> q.used == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *MyCircularQueue)</span></span> isFull() <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> q.used == q.length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>备注：<br>在 <code>DeQueue()</code> 方法中，删除队首元素时并不会真的删除该元素，而是通过移动 <code>front</code> 指针来达到删除的效果。</p><p>循环队列是一个环状的数据结构，可以想象成沿着环形路径移动指针。在实现循环队列时，每当删除队首元素时，我们需要将 <code>front</code> 指针向前移一位，指向队列中的下一个元素，这样队列中原来的第二个元素就成为了新的头部元素。这里使用 “指向队列中的下一个元素” 实际上是模运算的作用，如 <code>(i+1) % n</code> 将会得到指向 <code>i</code> 在循环数组中下一个元素的索引值。</p><p>而在这个移动指针的过程中，由于队列的前面已经没有元素，所以我们不需要将队首元素真正地删除。相反，仅需要更新 <code>front</code> 指针，让它指向目前第一个元素，后面再添加新的元素，也会覆盖掉先前的元素，实现对队列的循环利用。</p><h3 id="表示方法2"><a href="#表示方法2" class="headerlink" title="表示方法2"></a>表示方法2</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyCircularQueue <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 k + 1 ，也就是多余一个空格的循环队列来设计</span></span><br><span class="line">    queue []<span class="type">int</span></span><br><span class="line">    front <span class="type">int</span></span><br><span class="line">    rear <span class="type">int</span></span><br><span class="line">    capacity <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(k <span class="type">int</span>)</span></span> MyCircularQueue &#123;</span><br><span class="line">    <span class="keyword">return</span> MyCircularQueue&#123;</span><br><span class="line">        queue: <span class="built_in">make</span>([]<span class="type">int</span>,k+<span class="number">1</span>),</span><br><span class="line">        front: <span class="number">0</span>,</span><br><span class="line">        rear: <span class="number">0</span>,</span><br><span class="line">        capacity: k+<span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyCircularQueue)</span></span> EnQueue(value <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> this.IsFull()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    this.queue[this.rear] = value</span><br><span class="line">    this.rear = (this.rear + <span class="number">1</span>)%this.capacity</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyCircularQueue)</span></span> DeQueue() <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> this.IsEmpty()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    this.front = (this.front+<span class="number">1</span>)%this.capacity</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyCircularQueue)</span></span> Front() <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> this.IsEmpty() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> this.queue[this.front]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyCircularQueue)</span></span> Rear() <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> this.IsEmpty()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    rearPosition := (this.rear<span class="number">-1</span>+this.capacity)%this.capacity</span><br><span class="line">    <span class="keyword">return</span> this.queue[rearPosition]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyCircularQueue)</span></span> IsEmpty() <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> this.rear ==this.front</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyCircularQueue)</span></span> IsFull() <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (this.rear+<span class="number">1</span>)%this.capacity == this.front</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyCircularQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor(k);</span></span><br><span class="line"><span class="comment"> * param_1 := obj.EnQueue(value);</span></span><br><span class="line"><span class="comment"> * param_2 := obj.DeQueue();</span></span><br><span class="line"><span class="comment"> * param_3 := obj.Front();</span></span><br><span class="line"><span class="comment"> * param_4 := obj.Rear();</span></span><br><span class="line"><span class="comment"> * param_5 := obj.IsEmpty();</span></span><br><span class="line"><span class="comment"> * param_6 := obj.IsFull();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="循环双向队列"><a href="#循环双向队列" class="headerlink" title="循环双向队列"></a>循环双向队列</h3><h4 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h4><p><strong>==犯错的地方：==</strong><br><font color='red'> InsertFront的时候，需要先移动front向前一位，然后再把值插进去</font><br>最开始想的，直接让front和rear都指向一个空白的空间，那么就需要在插入的时候先将front向前移动两位，但这样的话就会浪费一个数值的空间，因为多余一个位就完全可以满足要求</p><p>使用k+1的情况，如果是在LRU缓存或者是Ringbuffer当中还需要考虑，将队尾[或者是队中]的元素插入到队首，也就是将最近使用的元素放到前面</p><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyCircularDeque <span class="keyword">struct</span> &#123;</span><br><span class="line">    queue []<span class="type">int</span></span><br><span class="line">    front <span class="type">int</span></span><br><span class="line">    rear <span class="type">int</span> </span><br><span class="line">    capacity <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(k <span class="type">int</span>)</span></span> MyCircularDeque &#123;</span><br><span class="line">    <span class="keyword">return</span> MyCircularDeque&#123;</span><br><span class="line">        queue: <span class="built_in">make</span>([]<span class="type">int</span>,k+<span class="number">1</span>),</span><br><span class="line">        front: <span class="number">0</span>,</span><br><span class="line">        rear: <span class="number">0</span>,</span><br><span class="line">        capacity: k+<span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyCircularDeque)</span></span> InsertFront(value <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> this.IsFull()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    this.front = (this.front<span class="number">-1</span> + this.capacity)%this.capacity</span><br><span class="line">    this.queue[this.front] = value</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyCircularDeque)</span></span> InsertLast(value <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> this.IsFull()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    this.queue[this.rear] = value</span><br><span class="line">    this.rear = (this.rear+<span class="number">1</span>)%this.capacity</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyCircularDeque)</span></span> DeleteFront() <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> this.IsEmpty()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    this.front = (this.front+<span class="number">1</span>)%this.capacity</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyCircularDeque)</span></span> DeleteLast() <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> this.IsEmpty()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    this.rear = (this.rear<span class="number">-1</span>+this.capacity)%this.capacity</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyCircularDeque)</span></span> GetFront() <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> this.IsEmpty()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> this.queue[this.front]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyCircularDeque)</span></span> GetRear() <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> this.IsEmpty()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> this.queue[(this.rear<span class="number">-1</span>+this.capacity)%this.capacity]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyCircularDeque)</span></span> IsEmpty() <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> this.front == this.rear</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyCircularDeque)</span></span> IsFull() <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> this.front == (this.rear+<span class="number">1</span>)%this.capacity</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyCircularDeque object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor(k);</span></span><br><span class="line"><span class="comment"> * param_1 := obj.InsertFront(value);</span></span><br><span class="line"><span class="comment"> * param_2 := obj.InsertLast(value);</span></span><br><span class="line"><span class="comment"> * param_3 := obj.DeleteFront();</span></span><br><span class="line"><span class="comment"> * param_4 := obj.DeleteLast();</span></span><br><span class="line"><span class="comment"> * param_5 := obj.GetFront();</span></span><br><span class="line"><span class="comment"> * param_6 := obj.GetRear();</span></span><br><span class="line"><span class="comment"> * param_7 := obj.IsEmpty();</span></span><br><span class="line"><span class="comment"> * param_8 := obj.IsFull();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>相似点：</p><ul><li>都使用了取模的方式</li></ul><h2 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h2><p>单调队列属于双端队列的一种</p><p>要求队列中的元素必须满足单调性</p><p>单调队列如对时候的要求：入队前后，单调性完整</p><p><strong>==单调递减队列最重要的特性==:<font color='red'>入队和出队的组合，可以在O(1)时间得到某个区间上的最大值</font></strong></p><h3 id="情况讨论"><a href="#情况讨论" class="headerlink" title="情况讨论"></a>情况讨论</h3><blockquote><p>需要回答的问题：</p><ul><li>这个区间是什么</li><li>怎样定量地描述这个区间</li><li>与队列中的元素个数有什么关系<br>可以分以下两种情况来讨论：</li></ul></blockquote><ol><li>只有入队的情况<br>在没有出队的情况下，对原数组的比较范围就会逐步增加<br>队首元素表示是已比较范围内的最大值</li><li>出队和入队混合的情况<br>控制覆盖范围为 k –&gt; 滑动窗口<ul><li>入队： 扩展单调队列的覆盖范围</li><li>出队： 控制单调队列的覆盖范围</li><li>队首元素是覆盖范围的最大值</li><li>队列中的元素个数小于覆盖范围的元素个数</li></ul></li></ol><h3 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//入队的代码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *queue)</span></span>push(val <span class="type">int</span>)&#123;</span><br><span class="line">    <span class="comment">// 入队时候，要剔除掉尾部的元素，知道尾部元素大于或者是等于入队元素</span></span><br><span class="line">    while(!q.isEmpty() &amp;&amp; q.getLast()&lt;val)&#123;</span><br><span class="line">        q.removeLast()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将元素入队</span></span><br><span class="line">    q.addLast(val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出队的时候，需要给出一个value</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(q *queue)</span></span> pop(val <span class="type">int</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!q.isEmpty() &amp;&amp; q.getFirst()==val)&#123;</span><br><span class="line">        q.removeFirst()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的代码编写关键：</p><ul><li>队首元素q.getFirst() 所获取的值是队列中的最大值</li><li>出队时<ul><li>如果一个元素已经被其他元素剔除出去了，那么他就不会再入队</li><li>如果一个元素是当前队列的最大值，会再出队</li></ul></li></ul><h3 id="滑动窗口的最大值"><a href="#滑动窗口的最大值" class="headerlink" title="滑动窗口的最大值"></a>滑动窗口的最大值</h3><h3 id="捡金币游戏"><a href="#捡金币游戏" class="headerlink" title="捡金币游戏"></a>捡金币游戏</h3><blockquote><p>考点:</p><ul><li>找到get数组，并知道get数组是当前元素和滑动窗口中最大值的和计算而来</li><li>利用单调队列在get[]数组上操作，找到滑动窗口的最大值</li></ul></blockquote><p>拓展： 是否存在不同的出队方式</p><blockquote><p>整理一下代码模板：<br><font color = 'red'>分层遍历</font><br><font color = 'red'>循环队列</font><br><font color = 'red'>单调队列</font></p></blockquote><p>一些有意思的题目：</p><ul><li>利用栈实现一个队列</li><li>利用队列实现一个栈</li></ul><h1 id="优先级队列：堆与优先级队列，筛选最优元素"><a href="#优先级队列：堆与优先级队列，筛选最优元素" class="headerlink" title="优先级队列：堆与优先级队列，筛选最优元素"></a>优先级队列：堆与优先级队列，筛选最优元素</h1><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p> FIFO队列： 节点之间的优先级是由遍历时的顺序决定的<br> 优先级队列： 节点之间按照大小进行排序后，再决定优先级，底层依赖的数据结构一般是堆</p><h4 id="堆的分类"><a href="#堆的分类" class="headerlink" title="堆的分类"></a>堆的分类</h4><ol><li><p>大根堆<br>节点的值比他的孩子节点都大</p></li><li><p>小根堆<br>节点的值要比他的孩子节点都小<br>堆的特点–大堆的根是最大值，小堆的根是最小值</p></li></ol><h4 id="堆的实现"><a href="#堆的实现" class="headerlink" title="堆的实现"></a>堆的实现</h4><blockquote><p>以大堆为例子</p></blockquote><p>大多数时候都是使用数组来表示堆</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Heap <span class="keyword">struct</span> &#123;</span><br><span class="line">    data []<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建新的大根堆</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewHeap</span><span class="params">()</span></span> Heap &#123;</span><br><span class="line">    <span class="keyword">return</span> Heap&#123;</span><br><span class="line">        data: <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取大根堆的长度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Heap)</span></span> Len() <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(h.data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取指定位置元素的父节点位置</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parent</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (i - <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取指定位置元素的左子节点位置</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">leftChild</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> i*<span class="number">2</span> + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取指定位置元素的右子节点位置</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rightChild</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> i*<span class="number">2</span> + <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下沉操作，将指定位置的元素向下移动，直到它大于所有子节点为止</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Heap)</span></span> sink(i <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        left, right := leftChild(i), rightChild(i)</span><br><span class="line">        maxPos := i</span><br><span class="line">        <span class="keyword">if</span> left &lt; h.Len() &amp;&amp; h.data[left] &gt; h.data[maxPos] &#123;</span><br><span class="line">            maxPos = left</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> right &lt; h.Len() &amp;&amp; h.data[right] &gt; h.data[maxPos] &#123;</span><br><span class="line">            maxPos = right</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> maxPos == i &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        h.data[i], h.data[maxPos] = h.data[maxPos], h.data[i]</span><br><span class="line">        i = maxPos</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上浮操作，将指定位置的元素向上移动，直到它小于其父节点为止</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Heap)</span></span> swim(i <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> i &gt; <span class="number">0</span> &#123;</span><br><span class="line">        p := parent(i)</span><br><span class="line">        <span class="keyword">if</span> h.data[p] &gt;= h.data[i] &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        h.data[p], h.data[i] = h.data[i], h.data[p]</span><br><span class="line">        i = p</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出堆，弹出大根堆的堆顶元素，并重新调整堆结构</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Heap)</span></span> pop() <span class="type">int</span> &#123;</span><br><span class="line">    res := h.data[<span class="number">0</span>]</span><br><span class="line">    h.data[<span class="number">0</span>] = h.data[<span class="built_in">len</span>(h.data)<span class="number">-1</span>]</span><br><span class="line">    h.data = h.data[:<span class="built_in">len</span>(h.data)<span class="number">-1</span>]</span><br><span class="line">    h.sink(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入堆，将新元素插入到大根堆中，并重新调整堆结构</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Heap)</span></span> push(val <span class="type">int</span>) &#123;</span><br><span class="line">    h.data = <span class="built_in">append</span>(h.data, val)</span><br><span class="line">    h.swim(<span class="built_in">len</span>(h.data) - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="最小的k个数"><a href="#最小的k个数" class="headerlink" title="最小的k个数"></a>最小的k个数</h4><blockquote><p>N 的数量级非常大，或者其希望能够获得一个较小的区间内的数字<br>同时输出的操作是每时每刻的话，一直是用排序的代价就会很高<br>在上述大根堆的基础上来完成的话，就是以下代码：</p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getLeastNumbers</span><span class="params">(arr []<span class="type">int</span>, k <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 建立大根堆</span></span><br><span class="line">    minH := Heap&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i &lt; <span class="built_in">len</span>(arr); i++&#123;</span><br><span class="line">        minH.push(arr[i])</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(minH.data) &gt; k &#123;</span><br><span class="line">            minH.pop()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minH.data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h2><h4 id="google-面试题目：有一台机器会每隔一秒输出一个信号，请在每次输出信号的时候输出所有信号的中间值，如果信号数量位偶数则返回中间两数的平均值"><a href="#google-面试题目：有一台机器会每隔一秒输出一个信号，请在每次输出信号的时候输出所有信号的中间值，如果信号数量位偶数则返回中间两数的平均值" class="headerlink" title="google 面试题目：有一台机器会每隔一秒输出一个信号，请在每次输出信号的时候输出所有信号的中间值，如果信号数量位偶数则返回中间两数的平均值"></a>google 面试题目：有一台机器会每隔一秒输出一个信号，请在每次输出信号的时候输出所有信号的中间值，如果信号数量位偶数则返回中间两数的平均值</h4><p>题目连接：</p><blockquote><p>leetcode 这道题目还能够用排序是因为算的是所有一共的，如果是实时输出就每次都需要排序，所以直接维护一个结构更适合</p></blockquote><h1 id="链表：-如何利用”假头，新链表，双指针”解决链表类型题目"><a href="#链表：-如何利用”假头，新链表，双指针”解决链表类型题目" class="headerlink" title="链表： 如何利用”假头，新链表，双指针”解决链表类型题目"></a>链表： 如何利用”假头，新链表，双指针”解决链表类型题目</h1><blockquote><p>解决链表问题的三板斧：<br>假头<br>新链表<br>双指针<br>链表尤其需要考虑各种边界条件、链表结构简单，但是查找交换反转非常容易出错</p></blockquote><h3 id="三板斧"><a href="#三板斧" class="headerlink" title="三板斧"></a>三板斧</h3><h4 id="假头"><a href="#假头" class="headerlink" title="假头"></a>假头</h4><p>在链表前面增加额外的节点–&gt; 可以节省许多对于nil指针的操作，能够节省不少的精力</p><p>dummy 指针初始化之后就不会再发生改变了<br>tail  指针随着元素改变移动</p><ol><li>tail 插入节点</li><li>头部插入节点</li><li>查找结点（总是会查找目标节点的pre）</li><li>在指定位置插入节点–&gt; getPre</li><li>删除节点<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> linkList <span class="keyword">interface</span>&#123;</span><br><span class="line">    initDummyList()</span><br><span class="line">    appendNode(*<span class="keyword">interface</span>&#123;&#125;)<span class="type">bool</span></span><br><span class="line">    getPre(<span class="type">int</span>)*<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    findNode(<span class="type">int</span>) *<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    insertNode(*<span class="keyword">interface</span>&#123;&#125;)<span class="type">bool</span></span><br><span class="line">    deletNode(<span class="type">int</span>) <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="树：-如何深度运用树的遍历"><a href="#树：-如何深度运用树的遍历" class="headerlink" title="树： 如何深度运用树的遍历"></a>树： 如何深度运用树的遍历</h1><blockquote><p>大部分语言的map数据结构，基本上是基于树来实现的<br>b+树，红黑树，二叉树等等，在leetcode和考题当中常见二叉树，同时对于其他的树结构，可以通过二叉树的遍历来扩展出对应的遍历方式。</p></blockquote><h2 id="1-ensp-树节点的结构："><a href="#1-ensp-树节点的结构：" class="headerlink" title="1 &ensp; 树节点的结构："></a><strong>1</strong> &ensp; 树节点的结构：</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span>&#123;</span><br><span class="line">    val <span class="type">int</span></span><br><span class="line">    left *TreeNode</span><br><span class="line">    right *TreeNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-ensp-前序遍历"><a href="#2-ensp-前序遍历" class="headerlink" title="2 &ensp; 前序遍历"></a><strong>2</strong> &ensp; 前序遍历</h2><blockquote><p><font color='red'>遍历根节点、左子树、右子树</font></p></blockquote><h3 id="2-1-ensp-使用递归完成前序遍历"><a href="#2-1-ensp-使用递归完成前序遍历" class="headerlink" title="2.1 &ensp; 使用递归完成前序遍历"></a><strong>2.1</strong> &ensp; 使用递归完成前序遍历</h3><p>采用整体的思想：<br>首先遍历根节点，然后遍历左子树的时候，就把左子树放到相应的位置，遍历右子树的时候，就把右子树放到相应的位置。<br>然后展开左子树<br>然后展开右子树</p><blockquote><p>时间复杂度：O(N)<br>空间复杂度：O(K) K表示的树的高度<br><font color=CC6699>一定注意要问清楚:在访问每个节点的时候，是需要Print出来，还是放到一个链表/数组当中存储</font></p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用递归方式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">traverse</span><span class="params">(root *TreeNode)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    &#125;</span><br><span class="line">    traverse(root.Left)</span><br><span class="line">    traverse(root.Right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-ensp-使用栈完成前序遍历"><a href="#2-2-ensp-使用栈完成前序遍历" class="headerlink" title="2.2 &ensp; 使用栈完成前序遍历"></a><strong>2.2</strong> &ensp; 使用栈完成前序遍历</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val   <span class="type">int</span></span><br><span class="line">    Left  *TreeNode</span><br><span class="line">    Right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preorderTraversal</span><span class="params">(root *TreeNode)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> res []<span class="type">int</span></span><br><span class="line">    <span class="keyword">var</span> stack []*TreeNode</span><br><span class="line">    stack = <span class="built_in">append</span>(stack, root)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        node := stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">        stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">        res = <span class="built_in">append</span>(res, node.Val)</span><br><span class="line">        <span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">            stack = <span class="built_in">append</span>(stack, node.Right)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">            stack = <span class="built_in">append</span>(stack, node.Left)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-2-1-ensp-Morris-遍历-只需要O-1-的空间"><a href="#2-2-1-ensp-Morris-遍历-只需要O-1-的空间" class="headerlink" title="2.2-1 &ensp; Morris 遍历: 只需要O(1)的空间"></a><strong>2.2-1</strong> &ensp; Morris 遍历: 只需要O(1)的空间</h3><h3 id="2-3-ensp-题目"><a href="#2-3-ensp-题目" class="headerlink" title="2.3 &ensp; 题目"></a><strong>2.3</strong> &ensp; 题目</h3><p>下述为前序遍历常见题目</p><h4 id="2-3-1-验证二叉树"><a href="#2-3-1-验证二叉树" class="headerlink" title="2.3.1 验证二叉树"></a><strong>2.3.1</strong> 验证二叉树</h4><p>验证一颗二叉树是否满足二叉搜索树的性质</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> basic <span class="keyword">struct</span>&#123;</span><br><span class="line">    node *TreeNode</span><br><span class="line">    leftboard <span class="type">int</span></span><br><span class="line">    rightboard <span class="type">int</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stackBst</span><span class="params">(root *TreeNode)</span></span> <span class="type">bool</span>&#123;</span><br><span class="line">    <span class="comment">// 构造边界影子树栈</span></span><br><span class="line">    stack := <span class="built_in">make</span>([]basic,<span class="number">0</span>)</span><br><span class="line">    left, right := math.MinInt64,math.MaxInt64</span><br><span class="line">    <span class="keyword">for</span> root != <span class="literal">nil</span> || <span class="built_in">len</span>(stack) &gt; <span class="number">0</span>&#123;</span><br><span class="line">        <span class="comment">// 当还没有遍历完左子树</span></span><br><span class="line">        <span class="keyword">for</span> root != <span class="literal">nil</span>&#123;</span><br><span class="line">            <span class="comment">// 判断不满足搜索树的节点要求</span></span><br><span class="line">            <span class="keyword">if</span> root.Val &lt;= left || root.Val &gt;= right &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 满足范围要求，那就要往下继续找</span></span><br><span class="line">            <span class="comment">// 先记录当前影子树的边界</span></span><br><span class="line">            stack = <span class="built_in">append</span>(stack, basic&#123;</span><br><span class="line">                node: root,</span><br><span class="line">                leftboard: left,</span><br><span class="line">                rightboard: right,</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="comment">// 往下移动，同时缩小右边界</span></span><br><span class="line">            right = root.Val</span><br><span class="line">            root = root.Left</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左子树遍历完了，找右子树</span></span><br><span class="line">        top := stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">        stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关键就是这里需要重新赋值比较的left和right</span></span><br><span class="line">        root = top.node</span><br><span class="line">        left,right = top.leftboard,top.rightboard</span><br><span class="line">        left = root.Val</span><br><span class="line">        root = root.Right       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValidBST</span><span class="params">(root *TreeNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> stackBst(root)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者是使用递归的方式</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValidBST</span><span class="params">(root *TreeNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    ans := <span class="literal">true</span></span><br><span class="line">    ans = preOderBST(root,math.MinInt64,math.MaxInt64)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preOderBST</span><span class="params">(root *TreeNode, left <span class="type">int</span>, right <span class="type">int</span>)</span></span><span class="type">bool</span>&#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> root.Val &lt;= left || root.Val &gt;= right &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> preOderBST(root.Left,left,root.Val) &amp;&amp; preOderBST(root.Right,root.Val,right)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// // 特殊在于 golang 的特点： 传参如果要一直修改其中的值，就需要传入一个引用，或者是采用闭包的方式</span></span><br><span class="line"><span class="comment">// func preOderBST(root *TreeNode, left int, right int, ans *bool)&#123;</span></span><br><span class="line"><span class="comment">// // 递归是否达到条件，即到达叶节点，到达叶节点表示所有节点都满足情况，所以为true</span></span><br><span class="line"><span class="comment">// // 第二个条件是 是否有判断出不满足的树，有的话ans就会变成false,直接返回</span></span><br><span class="line"><span class="comment">// if root == nil || !(*ans) &#123;</span></span><br><span class="line"><span class="comment">// return</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// // 判断条件就是 当前的值要小于right同时大于left才满足</span></span><br><span class="line"><span class="comment">// if root.Val &lt;= left || root.Val &gt;= right &#123;</span></span><br><span class="line"><span class="comment">// *ans = false</span></span><br><span class="line"><span class="comment">// return</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// // 前序遍历</span></span><br><span class="line"><span class="comment">// preOderBST(root.Left, left, root.Val, ans)</span></span><br><span class="line"><span class="comment">// preOderBST(root.Right, root.Val, right, ans)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><h4 id="2-3-2-目标和的所有路径"><a href="#2-3-2-目标和的所有路径" class="headerlink" title="2.3.2 目标和的所有路径"></a><strong>2.3.2</strong> 目标和的所有路径</h4><p><a href="https://leetcode.cn/problems/path-sum/">https://leetcode.cn/problems/path-sum/</a></p><blockquote><p>二叉树进行回溯的代码模板</p><ul><li>遇到新的节点： 路径总是从尾部添加节点</li><li>遍历完节点，路径就把他从尾部扔掉</li></ul></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func hasPathSum(root *TreeNode, targetSum int) bool &#123;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//     var backTrace func(*TreeNode, int) bool</span></span><br><span class="line"><span class="comment">//     backTrace = func(root *TreeNode, Sum int)bool&#123;</span></span><br><span class="line"><span class="comment">//         left , right := false,false </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//         if root == nil &#123;</span></span><br><span class="line"><span class="comment">//             return false</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         Sum += root.Val</span></span><br><span class="line"><span class="comment">//         if root.Left == nil &amp;&amp; root.Right == nil &amp;&amp; Sum == targetSum &#123;</span></span><br><span class="line"><span class="comment">//             return true</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         if root.Left != nil&#123;</span></span><br><span class="line"><span class="comment">//             left = backTrace(root.Left,Sum)</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         if root.Right != nil&#123;</span></span><br><span class="line"><span class="comment">//             right = backTrace(root.Right,Sum)</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         return left || right</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     return backTrace(root,0)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// // 使用广度优先的遍历--层序遍历--队列</span></span><br><span class="line"><span class="comment">// func hasPathSum(root *TreeNode, targetSum int) bool &#123;</span></span><br><span class="line"><span class="comment">//     if root == nil&#123;</span></span><br><span class="line"><span class="comment">//         return false</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     fifo := make([]*TreeNode,0)</span></span><br><span class="line"><span class="comment">//     Qsize := 1</span></span><br><span class="line"><span class="comment">//     fifo = append(fifo,root)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     for len(fifo) &gt; 0 &#123;</span></span><br><span class="line"><span class="comment">//         for Qsize &gt; 0 &#123;</span></span><br><span class="line"><span class="comment">//             top := fifo[0]</span></span><br><span class="line"><span class="comment">//             if top.Left == nil &amp;&amp; top.Right == nil &amp;&amp; top.Val == targetSum&#123;</span></span><br><span class="line"><span class="comment">//                 return true</span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line"><span class="comment">//             if top.Left != nil&#123;</span></span><br><span class="line"><span class="comment">//                 top.Left.Val = top.Left.Val + top.Val</span></span><br><span class="line"><span class="comment">//                 fifo = append(fifo,top.Left)</span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line"><span class="comment">//             if top.Right != nil&#123;</span></span><br><span class="line"><span class="comment">//                 top.Right.Val = top.Right.Val + top.Val</span></span><br><span class="line"><span class="comment">//                 fifo = append(fifo,top.Right)</span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line"><span class="comment">//             fifo = fifo[1:]</span></span><br><span class="line"><span class="comment">//             Qsize -= 1</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         Qsize = len(fifo)</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     return false</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用栈来存储，栈中元素是当前树的路径</span></span><br><span class="line"><span class="keyword">type</span> path <span class="keyword">struct</span>&#123;</span><br><span class="line">    node *TreeNode</span><br><span class="line">    sum <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasPathSum</span><span class="params">(root *TreeNode, targetSum <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    paths := <span class="built_in">make</span>([]path,<span class="number">0</span>)</span><br><span class="line">    paths = <span class="built_in">append</span>(paths, path&#123;</span><br><span class="line">        node: root,</span><br><span class="line">        sum: root.Val,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(paths) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        node := paths[<span class="built_in">len</span>(paths)<span class="number">-1</span>]</span><br><span class="line">        paths = paths[:<span class="built_in">len</span>(paths)<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span> node.node.Left == <span class="literal">nil</span> &amp;&amp; node.node.Right == <span class="literal">nil</span> &amp;&amp; node.sum == targetSum &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> node.node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">            right := node.node.Right</span><br><span class="line">            paths = <span class="built_in">append</span>(paths,path&#123;</span><br><span class="line">                node: right,</span><br><span class="line">                sum: right.Val + node.sum,</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> node.node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">            left := node.node.Left</span><br><span class="line">            paths = <span class="built_in">append</span>(paths,path&#123;</span><br><span class="line">                node: left,</span><br><span class="line">                sum: left.Val + node.sum,</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-3-得到路径和为指定数字的路径集合"><a href="#2-3-3-得到路径和为指定数字的路径集合" class="headerlink" title="2.3.3 得到路径和为指定数字的路径集合"></a><strong>2.3.3</strong> 得到路径和为指定数字的路径集合</h4><p><a href="https://leetcode.cn/problems/path-sum-ii/solution/">https://leetcode.cn/problems/path-sum-ii/solution/</a><br><font color='red'> 这道题目非常重要：有两大问题都在这个地方表现出来了</font></p><p>==Golang的特性：Defer函数的使用==<br>这道题目在使用前序遍历的时候，由于在叶子节点以及从左子树转换为右子树的时候都需要将原本记录在path当中的路径节点删除pop出来，递归时候就需要考虑在什么时候执行出栈操作，没错即便是在递归当中也还是必须要考虑栈的操作，因为需要一个连续记录的路径信息</p><p>关键在于pop的时机：pop的时机是：1. 本身是叶子节点，直接return 结束dfs，2. 左右的子树都被递归判断过的树中结点，也就是dfs(Left),dfs(Right)正常结束，刚好发现二者均都是在dfs执行完之后执行，而且覆盖了dfs执行完之后所有的情况<br>同时 Golang 的 <strong>Defer(){}</strong> 会在函数执行完并在返回之前执行，完全满足这个场景的需求，所以可以在递归函数体当中使用defer来完成对应的操作</p><p>==Golang的特性：切片索引==<br>切片本身就是指针，且每次操作都会影响到底层数组<br>如果不在递归函数体当中使用切片之前重新对切片进行赋值，那么，之后对于底层数组的操作也会反映到之前的切片上，产生的效果就是明明原本计算好了结果但最后得到的并不是正确答案，关键就在于==后面切片的操作修改了底层数组，导致原本切片对应的结果被修改了==</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pathSum</span><span class="params">(root *TreeNode, targetSum <span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    result := <span class="built_in">make</span>([][]<span class="type">int</span>,<span class="number">0</span>)</span><br><span class="line">    path := <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(*TreeNode,<span class="type">int</span>)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode,left <span class="type">int</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">nil</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        &#125;</span><br><span class="line">        path = <span class="built_in">append</span>(path,root.Val)</span><br><span class="line">        left = left - root.Val</span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; </span><br><span class="line">            path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">        &#125;()</span><br><span class="line">        <span class="keyword">if</span> root.Left == <span class="literal">nil</span> &amp;&amp; root.Right == <span class="literal">nil</span> &amp;&amp; left == <span class="number">0</span>&#123;</span><br><span class="line">            <span class="comment">// new := make([]int,len(path))</span></span><br><span class="line">            <span class="comment">// copy(new,path)</span></span><br><span class="line">            <span class="comment">// result = append(result,new)</span></span><br><span class="line">            result = <span class="built_in">append</span>(result,<span class="built_in">append</span>([]<span class="type">int</span>(<span class="literal">nil</span>),path...))</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.Left,left)</span><br><span class="line">        dfs(root.Right,left)</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root,targetSum)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-3"><a href="#2-3-3" class="headerlink" title="2.3.3"></a><strong>2.3.3</strong></h4><blockquote><p>等待回溯来看<br><a href="https://leetcode.cn/problems/path-sum-iii/solution/437-lu-jing-zong-he-iii-dfshui-su-qian-zhui-he-yi-/">https://leetcode.cn/problems/path-sum-iii/solution/437-lu-jing-zong-he-iii-dfshui-su-qian-zhui-he-yi-/</a></p></blockquote><h2 id="3-中序遍历"><a href="#3-中序遍历" class="headerlink" title="3 中序遍历"></a><strong>3</strong> 中序遍历</h2><p><font color='red'>遍历左子树，然后是根节点，然后是右子树</font></p><h3 id="3-1-ensp-使用递归完成中序遍历"><a href="#3-1-ensp-使用递归完成中序遍历" class="headerlink" title="3.1 &ensp; 使用递归完成中序遍历"></a><strong>3.1</strong> &ensp; 使用递归完成中序遍历</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-2-ensp-使用栈完成中序遍历"><a href="#3-2-ensp-使用栈完成中序遍历" class="headerlink" title="3.2 &ensp; 使用栈完成中序遍历"></a><strong>3.2</strong> &ensp; 使用栈完成中序遍历</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inorderTraversal</span><span class="params">(root *TreeNode)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> res []<span class="type">int</span></span><br><span class="line">    <span class="keyword">var</span> stack []*TreeNode</span><br><span class="line">    <span class="keyword">var</span> pathStack []<span class="type">string</span></span><br><span class="line">    node := root</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> node != <span class="literal">nil</span> || <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> node != <span class="literal">nil</span> &#123;</span><br><span class="line">            stack = <span class="built_in">append</span>(stack, node)</span><br><span class="line">            pathStack = <span class="built_in">append</span>(pathStack, fmt.Sprintf(<span class="string">&quot;%d&quot;</span>, node.Val))</span><br><span class="line">            node = node.Left</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node = stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">            stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">            path := pathStack[<span class="built_in">len</span>(pathStack)<span class="number">-1</span>]</span><br><span class="line">            pathStack = pathStack[:<span class="built_in">len</span>(pathStack)<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> node.Left == <span class="literal">nil</span> &amp;&amp; node.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">                res = <span class="built_in">append</span>(res, node.Val)</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 输出到达叶子节点的路径</span></span><br><span class="line">                fmt.Println(path)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            node = node.Right</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-找出二叉搜索树里面出现次数最多的数"><a href="#3-3-找出二叉搜索树里面出现次数最多的数" class="headerlink" title="3.3 找出二叉搜索树里面出现次数最多的数"></a><strong>3.3</strong> 找出二叉搜索树里面出现次数最多的数</h3><p>找众数就需要遍历所有的节点，二叉搜索树中序遍历的结果会是一个递增的数组，其数据特性就在于使用中序遍历的时候，所有的元素都是连续的</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMode</span><span class="params">(root *TreeNode)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 结果数组</span></span><br><span class="line">    ans := <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">0</span>)</span><br><span class="line">    base,count,maxnum := math.MinInt64,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用递归的方式</span></span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(*TreeNode)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.Left)</span><br><span class="line">        <span class="keyword">if</span> root.Val == base &#123;</span><br><span class="line">            count++</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            base = root.Val</span><br><span class="line">            count = <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> count == maxnum &#123;</span><br><span class="line">            ans = <span class="built_in">append</span>(ans,base)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> count &gt; maxnum &#123;</span><br><span class="line">            ans = []<span class="type">int</span>&#123;&#125;</span><br><span class="line">            maxnum = count</span><br><span class="line">            ans = <span class="built_in">append</span>(ans,base)</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.Right)</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-找出二叉搜索树里面任意两个节点之间绝对值得最小值"><a href="#3-4-找出二叉搜索树里面任意两个节点之间绝对值得最小值" class="headerlink" title="3.4 找出二叉搜索树里面任意两个节点之间绝对值得最小值"></a><strong>3.4</strong> 找出二叉搜索树里面任意两个节点之间绝对值得最小值</h3><p><a href="https://leetcode.cn/problems/minimum-distance-between-bst-nodes/">https://leetcode.cn/problems/minimum-distance-between-bst-nodes/</a></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minDiffInBST</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 使用栈来中序遍历，栈顶元素就是上一遍历的节点元素</span></span><br><span class="line">    stack := <span class="built_in">make</span>([]*TreeNode,<span class="number">0</span>)</span><br><span class="line">    res := <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> root != <span class="literal">nil</span> || <span class="built_in">len</span>(stack) &gt; <span class="number">0</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">            stack = <span class="built_in">append</span>(stack,root)</span><br><span class="line">            root = root.Left</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node := stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">        stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">        res = <span class="built_in">append</span>(res,node.Val)</span><br><span class="line"></span><br><span class="line">        root = node</span><br><span class="line">        root = root.Right</span><br><span class="line">    &#125;</span><br><span class="line">    m := math.MaxInt64</span><br><span class="line">    <span class="keyword">for</span> i:= <span class="number">0</span>; i &lt; <span class="built_in">len</span>(res)<span class="number">-1</span>; i++&#123;</span><br><span class="line">        r := res[i+<span class="number">1</span>]-res[i]</span><br><span class="line">        m = min(m,r) </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> m</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(args ...<span class="type">int</span>)</span></span><span class="type">int</span>&#123;</span><br><span class="line">    min := args[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> _, val := <span class="keyword">range</span> args&#123;</span><br><span class="line">        <span class="keyword">if</span> val &lt; min &#123;</span><br><span class="line">            min = val</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-一棵二叉搜索树的两个节点被交换了，恢复这颗二叉搜索树"><a href="#3-5-一棵二叉搜索树的两个节点被交换了，恢复这颗二叉搜索树" class="headerlink" title="3.5 一棵二叉搜索树的两个节点被交换了，恢复这颗二叉搜索树"></a><strong>3.5</strong> 一棵二叉搜索树的两个节点被交换了，恢复这颗二叉搜索树</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recoverTree</span><span class="params">(root *TreeNode)</span></span>  &#123;</span><br><span class="line">    <span class="comment">// 使用递归解决这个问题</span></span><br><span class="line">    problem := <span class="built_in">make</span>([]*TreeNode,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">var</span> findP <span class="function"><span class="keyword">func</span><span class="params">(*TreeNode)</span></span></span><br><span class="line">    findP = <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">nil</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        &#125;</span><br><span class="line">        findP(root.Left)</span><br><span class="line">        <span class="comment">// if pre == math.MaxInt64&#123;</span></span><br><span class="line">        <span class="comment">//     pre = root.Val</span></span><br><span class="line">        <span class="comment">//     return</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// if root.Val - pre &lt; 0&#123;</span></span><br><span class="line">        <span class="comment">//     problem = append(problem,root)</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// pre = root.Val</span></span><br><span class="line">        problem = <span class="built_in">append</span>(problem, root)</span><br><span class="line">        findP(root.Right)</span><br><span class="line">    &#125;</span><br><span class="line">    findP(root)</span><br><span class="line">    pre,cur := <span class="number">-1</span>,<span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(problem)<span class="number">-1</span>; i++&#123;</span><br><span class="line">        <span class="keyword">if</span> problem[i].Val &gt; problem[i+<span class="number">1</span>].Val &#123;</span><br><span class="line">            cur = i + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> pre == <span class="number">-1</span> &#123;</span><br><span class="line">                pre = i</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    problem[pre].Val,problem[cur].Val = problem[cur].Val,problem[pre].Val</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除二叉搜索树的节点"><a href="#删除二叉搜索树的节点" class="headerlink" title="删除二叉搜索树的节点"></a>删除二叉搜索树的节点</h3><blockquote><p>题目最重要的考点就是分类，讨论各种情况下的处理方式</p></blockquote><p><font sizecolor ='red'>清晰地讲出每种情况的处理办法</font><br><font sizecolor ='red'>清晰简介地实现代码</font></p><h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><h3 id="使用栈完成后序遍历"><a href="#使用栈完成后序遍历" class="headerlink" title="使用栈完成后序遍历"></a>使用栈完成后序遍历</h3><h3 id="迭代写法的考点"><a href="#迭代写法的考点" class="headerlink" title="迭代写法的考点"></a>迭代写法的考点</h3><ol><li>是否有右子树</li><li>pre指针是不是指向当前结点的右子树</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;告别盲目刷题，击破算法面试&quot;&gt;&lt;a href=&quot;#告别盲目刷题，击破算法面试&quot; class=&quot;headerlink&quot; title=&quot;告别盲目刷题，击破算法面试&quot;&gt;&lt;/a&gt;告别盲目刷题，击破算法面试&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;学习拉钩教育算法课程记录加</summary>
      
    
    
    
    <category term="算法，Golang" scheme="http://ideameshdyx.github.io/categories/%E7%AE%97%E6%B3%95%EF%BC%8CGolang/"/>
    
    
    <category term="working, 算法" scheme="http://ideameshdyx.github.io/tags/working-%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Golang 双指针</title>
    <link href="http://ideameshdyx.github.io/2023/04/01/Algorithm/Golang-%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B/Golang-%E5%8F%8C%E6%8C%87%E9%92%88/Golang-%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    <id>http://ideameshdyx.github.io/2023/04/01/Algorithm/Golang-%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B/Golang-%E5%8F%8C%E6%8C%87%E9%92%88/Golang-%E5%8F%8C%E6%8C%87%E9%92%88/</id>
    <published>2023-04-01T16:46:21.000Z</published>
    <updated>2023-04-22T13:24:02.288Z</updated>
    
    <content type="html"><![CDATA[<h1 id="双指针：如何掌握最长、定长、最短区间问题的解题诀窍"><a href="#双指针：如何掌握最长、定长、最短区间问题的解题诀窍" class="headerlink" title="双指针：如何掌握最长、定长、最短区间问题的解题诀窍"></a>双指针：如何掌握最长、定长、最短区间问题的解题诀窍</h1><blockquote><p>通常是明明用两个指针在数组/链表上遍历，然后解决满足某种性质的问题<br>解决问题：<br><strong>最长区间</strong><br><strong>定长区间</strong><br><strong>最短区间</strong><br><font color = 'red'>1. 弄清楚题目要的是什么样的区间，是上述三种中的哪一类</font><br><font color = 'red'>2. 区间需要满足的条件是什么</font></p></blockquote><h2 id="1-ensp-区间特性"><a href="#1-ensp-区间特性" class="headerlink" title="1 &ensp; 区间特性"></a><strong>1</strong> &ensp; 区间特性</h2><h3 id="单调性-amp-最优"><a href="#单调性-amp-最优" class="headerlink" title="单调性 &amp; 最优"></a>单调性 &amp; 最优</h3><blockquote><p>使用双指针需要保证区间的单调性</p></blockquote><ol><li><p>单调性的定义：<br>区间的单调性： 固定了划分区间的条件之后，遍历区间内的元素，按照一定顺序的时候，区间内的元素应该是都满足某一个条件，且存在问题定义上的大小单调变化。<br>比如： 在一个完全都是正整数的区间里面，划分子集的标准是固定子集右端元素（最右端元素只能是A[i]），集合内元素的和从下标为-1到i-1,均大于某个数，且这个和逐步减少（$\because 元素都是正数，减少了就变小了$）</p></li><li><p>快速判断区间属性是否满足单调性的办法<br><font color = 'red'> 往区间里面添加元素的时候，区间的约束条件可以变化，但不能出现波折</font><br>理解为： 添加一个元素之后，要么依旧满足条件，符合单调性；要么出现一会不满足一会满足的情况，不符合单调性</p></li></ol><blockquote><p>遍历区间的所有子集可以使用这样的方式： 固定子集的最右边元素为固定元素：<br>固定右区间集合，把A[i]元素固定为区间的右端点，之变动区间的左边界形成的所有区间，并且按照区间长度需要从长到短排列</p></blockquote><ol start="3"><li>找到最优解<br><font color = 'red'> 从左向右遍历区间右端固定元素集合中的每个区间，找到一个满足条件的解就停止（因为单调性继续调整依旧满足条件）</font></li></ol><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><ol><li><p>寻找以A[i]为有边界的最优解，分为以下三步</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Step <span class="number">1</span> :</span><br><span class="line">将A[i] 加入到区间中，形成新的区间 （left,i]</span><br><span class="line">room = <span class="built_in">append</span>(room,A[i])</span><br><span class="line"></span><br><span class="line">Step <span class="number">2</span>：</span><br><span class="line">遍历A[i]的固定右区间集，直到找到以A[i]为右端点的最优解</span><br><span class="line"><span class="keyword">for</span> left &lt; i &amp;&amp; (left,i] 区间不满足要求 &#123;</span><br><span class="line">    left++</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">Step <span class="number">3</span>:</span><br><span class="line">此时要么得到一个满足要求的解，要么没有满足单调性的区间</span><br><span class="line">(left,i]区间满足要求</span><br></pre></td></tr></table></figure></li><li><p>题目须具备的条件</p><ul><li>给定一个条件</li><li>求最长区间/最长字串</li><li>题目给出的区间需要具备的单调性</li></ul></li><li><p>必杀技</p><ul><li>left，right 指针</li><li>只有在不满足条件的时候才向右移动left指针</li></ul></li><li><p>最长区间的代码模板</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxLength</span><span class="params">(A []<span class="type">int</span>)</span></span> <span class="type">int</span>&#123;</span><br><span class="line">    <span class="comment">// 创建左指针和结果</span></span><br><span class="line">    left, ans := <span class="number">-1</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从左向右遍历区间</span></span><br><span class="line">    <span class="keyword">for</span> i:= <span class="number">0</span>; i&lt; <span class="built_in">len</span>(A); i++&#123;</span><br><span class="line">        <span class="comment">// Assert 在加入 A[i] 之前，(left,i-1] 是一个合法有效的区间，在最开始的时候left = -1，i-1=-1，是空区间，满足条件</span></span><br><span class="line">        <span class="comment">// Step1 : 直接将A[i]加到区间中，形成(left,i]</span></span><br><span class="line">        <span class="comment">// step2 : 将A[I]加入之后，依据left的惰性yuanze</span></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> check检查区间状态是否满足条件</span></span><br><span class="line">        <span class="keyword">for</span> check(left,i) &#123;</span><br><span class="line">            left++<span class="comment">// 如果不满足条件，移动左指针</span></span><br><span class="line">            <span class="comment">// TODO： 修改区间的状态</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// assert 此时的(left,i] 必然满足条件</span></span><br><span class="line">        ans = max(ans,i-left)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回最优解</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>时间复杂度为 O(n)</p><h2 id="2-ensp-例题-区间长度类型"><a href="#2-ensp-例题-区间长度类型" class="headerlink" title="2 &ensp; 例题: 区间长度类型"></a><strong>2</strong> &ensp; 例题: 区间长度类型</h2><h3 id="不含重复字符的最长区间"><a href="#不含重复字符的最长区间" class="headerlink" title="不含重复字符的最长区间"></a>不含重复字符的最长区间</h3><blockquote><p>单调性： 当找到一个没有重复字符的区间时候，减少区间内元素，新的区间依旧满足没有重复元素<br><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">https://leetcode.cn/problems/longest-substring-without-repeating-characters/</a></p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 双指针解决</span></span><br><span class="line">    left, ans := <span class="number">-1</span>,<span class="number">0</span></span><br><span class="line">    <span class="comment">// 存储区间内元素的映射</span></span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">int</span>,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;<span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">        m[s[i]] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> m[s[i]] &gt; <span class="number">1</span> &#123;</span><br><span class="line">            left++</span><br><span class="line">            m[s[left]]--</span><br><span class="line">        &#125;</span><br><span class="line">        ans = max(ans, i-left)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(args ...<span class="type">int</span>)</span></span><span class="type">int</span>&#123;</span><br><span class="line">    m := args[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> _, val := <span class="keyword">range</span> args&#123;</span><br><span class="line">        <span class="keyword">if</span> val &gt; m &#123;</span><br><span class="line">            m = val</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="替换后的最长重复字符"><a href="#替换后的最长重复字符" class="headerlink" title="替换后的最长重复字符"></a>替换后的最长重复字符</h3><blockquote><p>给你一个字符串 s 和一个整数 k 。你可以选择字符串中的任一字符，并将其更改为任何其他大写英文字符。该操作最多可执行 k 次。<br><a href="https://leetcode.cn/problems/longest-repeating-character-replacement/">https://leetcode.cn/problems/longest-repeating-character-replacement/</a></p></blockquote><p>在执行上述操作后，返回包含相同字母的最长子字符串的长度。<br>示例 1：<br>输入：s = “ABAB”, k = 2<br>输出：4<br>解释：用两个’A’替换为两个’B’,反之亦然。<br>示例 2：<br>输入：s = “AABABBA”, k = 1<br>输出：4<br>解释：<br>将中间的一个’A’替换为’B’,字符串变为 “AABBBBA”。<br>子串 “BBBB” 有最长重复字母, 答案为 4。<br> 提示：<br>1 &lt;= s.length &lt;= 105<br>s 仅由大写英文字母组成<br>0 &lt;= k &lt;= s.length</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">characterReplacement</span><span class="params">(s <span class="type">string</span>, k <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    left, ans := <span class="number">-1</span>,<span class="number">0</span></span><br><span class="line">    max_repeat := <span class="number">0</span></span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">int</span>,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++&#123;</span><br><span class="line">        m[s[i]]++</span><br><span class="line"></span><br><span class="line">        max_repeat = max(m[s[i]],max_repeat)</span><br><span class="line">        <span class="keyword">for</span> i-left-max_repeat &gt; k&#123;</span><br><span class="line">            left++</span><br><span class="line">            m[s[left]]--</span><br><span class="line">        &#125; </span><br><span class="line">        ans = max(ans,i-left)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(args ...<span class="type">int</span>)</span></span><span class="type">int</span>&#123;</span><br><span class="line">    m := args[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> _, val := <span class="keyword">range</span> args&#123;</span><br><span class="line">        <span class="keyword">if</span> val &gt; m &#123;</span><br><span class="line">            m = val</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符流中第一个只出现一次的字符"><a href="#字符流中第一个只出现一次的字符" class="headerlink" title="字符流中第一个只出现一次的字符"></a>字符流中第一个只出现一次的字符</h3><blockquote><p>请实现一个函数用来找出字符流中第一个只出现一次的字符。<br><a href="https://www.acwing.com/problem/content/60/">https://www.acwing.com/problem/content/60/</a><br>例如，当从字符流中只读出前两个字符 go 时，第一个只出现一次的字符是 g。<br>当从该字符流中读出前六个字符 google 时，第一个只出现一次的字符是 l。<br>如果当前字符流没有存在出现一次的字符，返回 # 字符。<br>数据范围<br>字符流读入字符数量 [0,1000]</p></blockquote><p>样例<br>输入：”google”<br>输出：”ggg#ll”<br>解释：每当字符流读入一个字符，就进行一次判断并输出当前的第一个只出现一次的字符。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Solution <span class="keyword">struct</span> &#123;</span><br><span class="line">    left <span class="type">int</span> <span class="comment">// 最左侧字符位置</span></span><br><span class="line">    cnt  [<span class="number">256</span>]<span class="type">int</span> <span class="comment">// 字符个数计数器</span></span><br><span class="line">    s    <span class="type">string</span> <span class="comment">// 保存输入的字符串</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s Solution</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insert</span><span class="params">(ch <span class="type">byte</span>)</span></span> &#123;</span><br><span class="line">    s.cnt[ch]++ <span class="comment">// 将该字符出现次数加1</span></span><br><span class="line">    s.s += <span class="type">string</span>(ch) <span class="comment">// 将该字符加入到字符串s中</span></span><br><span class="line">    <span class="comment">// 如果最左侧的字符出现次数大于1，则将最左侧字符的位置向右移动，直到最左侧字符出现次数为1或者left &gt;= right</span></span><br><span class="line">    <span class="keyword">for</span> s.left &lt; <span class="built_in">len</span>(s.s) &amp;&amp; s.cnt[s.s[s.left]] &gt; <span class="number">1</span> &#123;</span><br><span class="line">        s.left++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">firstAppearingOnce</span><span class="params">()</span></span> <span class="type">byte</span> &#123;</span><br><span class="line">    <span class="comment">// 如果最左侧字符位置left大于等于字符串s的长度，则返回&#x27;#&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> s.left &gt;= <span class="built_in">len</span>(s.s) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;#&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回最左侧的字符</span></span><br><span class="line">    <span class="keyword">return</span> s.s[s.left]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最多有k个不同字符的最长子字符串"><a href="#最多有k个不同字符的最长子字符串" class="headerlink" title="最多有k个不同字符的最长子字符串"></a>最多有k个不同字符的最长子字符串</h3><blockquote><p>给定字符串S，找到最多有k个不同字符的最长子串T。<br><a href="https://www.lintcode.com/problem/386/">https://www.lintcode.com/problem/386/</a><br>样例<br>样例 1:</p></blockquote><p>输入: S = “eceba” 并且 k = 3<br>输出: 4<br>解释: T = “eceb”<br>样例 2:</p><p>输入: S = “WORLD” 并且 k = 4<br>输出: 4<br>解释: T = “WORL” 或 “ORLD”<br>挑战<br>O(n) 时间复杂度</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param s: A string</span></span><br><span class="line"><span class="comment"> * @param k: An integer</span></span><br><span class="line"><span class="comment"> * @return: An integer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LengthOfLongestSubstringKDistinct</span><span class="params">(s <span class="type">string</span>, k <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    left, count,l := <span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line"></span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">int</span>,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt; <span class="built_in">len</span>(s); i++&#123;</span><br><span class="line">        <span class="keyword">if</span> m[s[i]] == <span class="number">0</span> &#123;</span><br><span class="line">            count++</span><br><span class="line">        &#125;</span><br><span class="line">        m[s[i]]++</span><br><span class="line">        <span class="keyword">for</span> count &gt; k &#123;</span><br><span class="line">            left++</span><br><span class="line">            m[s[left]]--</span><br><span class="line">            <span class="keyword">if</span> m[s[left]] == <span class="number">0</span> &#123;</span><br><span class="line">                count--</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        l = max(l,i-left)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(args ...<span class="type">int</span>)</span></span> <span class="type">int</span>&#123;</span><br><span class="line">    m := args[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> _, val := <span class="keyword">range</span> args&#123;</span><br><span class="line">        <span class="keyword">if</span> val &gt; m &#123;</span><br><span class="line">            m = val</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组中的最长山脉"><a href="#数组中的最长山脉" class="headerlink" title="数组中的最长山脉"></a>数组中的最长山脉</h3><blockquote><p><a href="https://leetcode.cn/problems/longest-mountain-in-array/description/">https://leetcode.cn/problems/longest-mountain-in-array/description/</a></p></blockquote><p>把符合下列属性的数组 arr 称为 山脉数组 ：</p><p>arr.length &gt;= 3<br>存在下标 i（0 &lt; i &lt; arr.length - 1），满足<br>arr[0] &lt; arr[1] &lt; … &lt; arr[i - 1] &lt; arr[i]<br>arr[i] &gt; arr[i + 1] &gt; … &gt; arr[arr.length - 1]<br>给出一个整数数组 arr，返回最长山脉子数组的长度。如果不存在山脉子数组，返回 0 。<br>示例 1：<br>输入：arr = [2,1,4,7,3,2,5]<br>输出：5<br>解释：最长的山脉子数组是 [1,4,7,3,2]，长度为 5。<br>示例 2：</p><p>输入：arr = [2,2,2]<br>输出：0<br>解释：不存在山脉子数组。<br>提示：<br>1 &lt;= arr.length &lt;= 104<br>0 &lt;= arr[i] &lt;= 104<br> <br>进阶：<br>你可以仅用一趟扫描解决此问题吗？<br>你可以用 O(1) 空间解决此问题吗？</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestMountain</span><span class="params">(A []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    N := <span class="built_in">len</span>(A)</span><br><span class="line">    <span class="keyword">if</span> N &lt; <span class="number">3</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    left := <span class="number">-1</span></span><br><span class="line">    <span class="comment">// -1表示只有一个元素</span></span><br><span class="line">    <span class="comment">// 0表示正上升</span></span><br><span class="line">    <span class="comment">// 1表示正下降</span></span><br><span class="line">    status := <span class="number">-1</span></span><br><span class="line">    preValue := A[<span class="number">0</span>]</span><br><span class="line">    ans := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 题目要求必须至少有3个元素，所以不可能从0开始</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; N; i++ &#123;</span><br><span class="line">        x := A[i]</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果要把x加进来</span></span><br><span class="line">        <span class="comment">// 如果里面还只有一个元素</span></span><br><span class="line">        <span class="keyword">if</span> status == <span class="number">-1</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> x &gt; preValue &#123;</span><br><span class="line">                <span class="comment">// 那么状态改为上升</span></span><br><span class="line">                status = <span class="number">0</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果相等，或者变小，那么区间只能再变成只有一个元素的了</span></span><br><span class="line">                <span class="comment">// 状态依然更新为只有一个元素</span></span><br><span class="line">                status = <span class="number">-1</span></span><br><span class="line">                <span class="comment">// 区间更新为(left, i]</span></span><br><span class="line">                left = i - <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果正在上升</span></span><br><span class="line">        <span class="keyword">if</span> status == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> x &gt; preValue &#123;</span><br><span class="line">                <span class="comment">// nothing</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> x == preValue &#123;</span><br><span class="line">                <span class="comment">// 如果相等，那么区间只能再变成只有一个元素的状态了</span></span><br><span class="line">                status = <span class="number">-1</span></span><br><span class="line">                left = i - <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 下降了</span></span><br><span class="line">                status = <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果正在下降</span></span><br><span class="line">        <span class="keyword">if</span> status == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> x &lt; preValue &#123;</span><br><span class="line">                <span class="comment">// nothing</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> x == preValue &#123;</span><br><span class="line">                status = <span class="number">-1</span></span><br><span class="line">                left = i - <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果正在上升</span></span><br><span class="line">                status = <span class="number">0</span></span><br><span class="line">                <span class="comment">// 注意这里left要变成(i - 2, i]</span></span><br><span class="line">                <span class="comment">// 这里已经有两个元素了</span></span><br><span class="line">                left = i - <span class="number">2</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        preValue = x</span><br><span class="line">        <span class="keyword">if</span> status == <span class="number">1</span> &#123;</span><br><span class="line">            ans = max(ans, i-left)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ans &gt;= <span class="number">3</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(args ...<span class="type">int</span>)</span></span><span class="type">int</span>&#123;</span><br><span class="line">    m := args[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> _, val := <span class="keyword">range</span> args&#123;</span><br><span class="line">        <span class="keyword">if</span> val &gt; m &#123;</span><br><span class="line">             m = val</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="3-ensp-例题：区间计数"><a href="#3-ensp-例题：区间计数" class="headerlink" title="3  &ensp; 例题：区间计数"></a><strong>3</strong>  &ensp; 例题：区间计数</h2><h3 id="区间计数"><a href="#区间计数" class="headerlink" title="区间计数"></a>区间计数</h3><blockquote><p>区间最优原则表示：当按照区间最右边元素划分区间，并找到最优解之后，left继续向有移动形成的短区间都满足条件</p></blockquote><h4 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h4><blockquote><p>在求最长区间代码模板上变式</p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rangeCounter</span><span class="params">(A []<span class="type">int</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 区间的左指针</span></span><br><span class="line">    left,ans := <span class="number">-1</span>,<span class="number">0</span></span><br><span class="line">    <span class="comment">// 不变式0： 最开始的区间为(-1，-1] 是一个空区间</span></span><br><span class="line">    <span class="comment">//          我们认为空区间总是满足条件</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(A); i++&#123;</span><br><span class="line">        <span class="comment">// 不变式1： 在加入A[i]之前，(left,i-1]是一个合法的有效区间</span></span><br><span class="line">        <span class="comment">// 需要改变的部分为下：</span></span><br><span class="line">        <span class="comment">// Step1： 直接将A[i]加入到区间中，形成(left,i]</span></span><br><span class="line">        <span class="comment">// Step2:  将A[i] 加入之后，依据多性原则判断Left是否移动且移动多少</span></span><br><span class="line">        <span class="comment">/** <span class="doctag">TODO:</span> 设计check函数，检查区间是否满足条件</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">for</span> check(left,i] &#123;</span><br><span class="line">            <span class="comment">// 如果不满足条件，则移动左指针</span></span><br><span class="line">            left++</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">            <span class="doctag">TODO:</span> 修改区间的状态或者改变区间的性质</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不变式2： 此时(left,i]必然合法</span></span><br><span class="line">        <span class="comment">// 累计区间个数: 以A[i]为有边界的子区间总共有i-left个</span></span><br><span class="line">        ans = ans + i-left</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;双指针：如何掌握最长、定长、最短区间问题的解题诀窍&quot;&gt;&lt;a href=&quot;#双指针：如何掌握最长、定长、最短区间问题的解题诀窍&quot; class=&quot;headerlink&quot; title=&quot;双指针：如何掌握最长、定长、最短区间问题的解题诀窍&quot;&gt;&lt;/a&gt;双指针：如何掌握最长、</summary>
      
    
    
    
    <category term="算法，Golang" scheme="http://ideameshdyx.github.io/categories/%E7%AE%97%E6%B3%95%EF%BC%8CGolang/"/>
    
    
    <category term="双指针, 算法" scheme="http://ideameshdyx.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88-%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Go 系统知识汇总</title>
    <link href="http://ideameshdyx.github.io/2023/04/01/Go/Go-%E9%9D%A2%E8%AF%95%E9%97%AE%E7%AD%94%E5%9B%9E%E5%BF%86/Go%20%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/"/>
    <id>http://ideameshdyx.github.io/2023/04/01/Go/Go-%E9%9D%A2%E8%AF%95%E9%97%AE%E7%AD%94%E5%9B%9E%E5%BF%86/Go%20%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/</id>
    <published>2023-04-01T12:57:34.000Z</published>
    <updated>2023-04-22T13:24:02.216Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Golang-系统知识回答收集"><a href="#Golang-系统知识回答收集" class="headerlink" title="Golang 系统知识回答收集"></a>Golang 系统知识回答收集</h1><h2 id="Golang-语法方面"><a href="#Golang-语法方面" class="headerlink" title="Golang 语法方面"></a>Golang 语法方面</h2><h3 id="Golang关键字有哪些"><a href="#Golang关键字有哪些" class="headerlink" title="Golang关键字有哪些"></a>Golang关键字有哪些</h3><h3 id="Golang-当中"><a href="#Golang-当中" class="headerlink" title="Golang 当中"></a>Golang 当中</h3><p>关键字是指被编程语言用作特定目的的保留单词，这些关键字在代码当中具有特殊的含义，不能被用作标识符（例如变量名，函数名，类型名等）。以下是Golang中关键字的列表</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span></span> </span><br><span class="line"><span class="keyword">type</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> </span><br><span class="line"><span class="keyword">struct</span> </span><br><span class="line"><span class="keyword">var</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span> <span class="keyword">continue</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> </span><br><span class="line"><span class="keyword">select</span></span><br><span class="line"><span class="keyword">defer</span></span><br><span class="line"><span class="keyword">switch</span></span><br><span class="line"><span class="keyword">for</span> </span><br><span class="line"><span class="keyword">range</span> </span><br><span class="line"><span class="keyword">goto</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">if</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span></span><br><span class="line"><span class="keyword">chan</span> </span><br><span class="line"><span class="keyword">map</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span></span><br><span class="line"><span class="keyword">package</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span></span><br><span class="line"><span class="keyword">return</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">fallthrough</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="range-函数的具体使用"><a href="#range-函数的具体使用" class="headerlink" title="range 函数的具体使用"></a>range 函数的具体使用</h3><p>golang当中range 关键字可以用于迭代数组、切片、字符串、map和通道等数据类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代数组和切片时候，返回当前元素的索引和值</span></span><br><span class="line">arr := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">for</span> key,num := <span class="keyword">range</span> arr&#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;now arr[%d] is %d\n&quot;</span>, key,num)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// map 迭代字符串的时候，每次迭代返回当前字符的索引和Unicode码点</span></span><br><span class="line"></span><br><span class="line">s := <span class="string">&quot;hello world&quot;</span></span><br><span class="line"><span class="keyword">for</span> i, c := <span class="keyword">range</span> s&#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;index:%d, Unicode code ponit : %U\n&quot;</span>,i,c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代map结构</span></span><br><span class="line">m := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>&#123;</span><br><span class="line"><span class="number">1</span>: <span class="string">&quot;one&quot;</span>,</span><br><span class="line"><span class="number">2</span>: <span class="string">&quot;two&quot;</span>,</span><br><span class="line"><span class="number">3</span>: <span class="string">&quot;three&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> k,v := <span class="keyword">range</span> m&#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;key : %d, value : %s&quot;</span>,k,v)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代通道使用range 迭代通道的时候，会不断地从通道当中接受元素，直到通道关闭为止</span></span><br><span class="line"></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>;i&lt;<span class="number">5</span>,i++&#123;</span><br><span class="line">ch &lt;- i</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(ch)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> v := <span class="keyword">range</span> ch &#123;</span><br><span class="line">fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在迭代通道的时候，如果通道没有关闭，那么循环就会一直等待下去，知道程序死锁，因此必须要再写入完所有的数据之后关闭通道，或者使用’select’语句在接受通道数据的时候检查通道是否已经关闭</p><h3 id="Slice-扩容机制"><a href="#Slice-扩容机制" class="headerlink" title="Slice 扩容机制"></a>Slice 扩容机制</h3><p>Go 1.18 版本之后，当新切片需要的容量cap大于两倍扩容的容量时候，则直接按照新切片需要的容量进行扩容：</p><ul><li>当原 Slice 容量 &lt; threshold 的时候，新 slice 容量变成原来的2 倍</li><li>当原 Slice 容量 &gt; threshold 的时候，进入一个循环，每次容量增加 （旧容量 + 3*threshold）/4</li></ul><h3 id="Slice-为什么不是线程安全的"><a href="#Slice-为什么不是线程安全的" class="headerlink" title="Slice 为什么不是线程安全的"></a>Slice 为什么不是线程安全的</h3><p>因为 Slice 内部使用了底层数组，数组在内存当中是连续存储的并没有加锁的机制，本身并不支持并发的读写</p><p>当多个Goroutine并发访问同一个Slice的时候，可能存在某个Goroutine修改了Slice中的某个元素，其他Goroutine无法立即看到这个修改，也可能会造成竞争问题。可以通过使用((20230318150223-agvrll2 “互斥锁”))或者((20230318154221-miv3alf “原子操作”))来保证某个Goroutine访问的时候其他goroutine不能够同时访问，另外也可以使用通道来进行同步，通过将Slice的访问权限交给某个Goroutine，从而保障其他的Goroutine无法同时访问该Slice。</p><h3 id="map的底层原理"><a href="#map的底层原理" class="headerlink" title="map的底层原理"></a>map的底层原理</h3><p>map对象本身是一个指针，占用8个字节（64位计算机），指向<code>hmap</code>结构体，hmap包含多个bmap数组（桶）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span>&#123;</span><br><span class="line">count <span class="type">int</span> <span class="comment">// 元素个数，调用len(map)的时候直接返回</span></span><br><span class="line">flags <span class="type">uint8</span> <span class="comment">// 标志当前map的状态，正在删除元素、添加元素、、、、</span></span><br><span class="line">B <span class="type">uint8</span> <span class="comment">//单元(buckets)的对数 B=5表示能容纳32个元素  B随着map容量增大而变大</span></span><br><span class="line"></span><br><span class="line">noverflow <span class="type">uint16</span>  <span class="comment">//单元(buckets)溢出数量，如果一个单元能存8个key，此时存储了9个，溢出了，就需要再增加一个单元</span></span><br><span class="line">hash0 <span class="type">uint32</span> <span class="comment">//哈希种子</span></span><br><span class="line">buckets unsafe.Pointer <span class="comment">//指向单元(buckets)数组,大小为2^B，可以为nil</span></span><br><span class="line">oldbuckets unsafe.Pointer <span class="comment">//扩容的时候，buckets长度会是oldbuckets的两倍</span></span><br><span class="line">nevacute <span class="type">uintptr</span>  <span class="comment">//指示扩容进度，小于此buckets迁移完成 </span></span><br><span class="line">extra *mapextra <span class="comment">//与gc相关 可选字段 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span>&#123;</span><br><span class="line">tophash [bucketCnt]<span class="type">uint8</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实际上编译期间会生成一个新的数据结构  </span></span><br><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123; </span><br><span class="line">    topbits [<span class="number">8</span>]<span class="type">uint8</span>     <span class="comment">//key hash值前8位 用于快速定位keys的位置</span></span><br><span class="line">    keys [<span class="number">8</span>]keytype     <span class="comment">//键</span></span><br><span class="line">    values [<span class="number">8</span>]valuetype <span class="comment">//值</span></span><br><span class="line">    pad <span class="type">uintptr</span> </span><br><span class="line">    overflow <span class="type">uintptr</span>     <span class="comment">//指向溢出桶 无符号整形 优化GC</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="map的扩容机制"><a href="#map的扩容机制" class="headerlink" title="map的扩容机制"></a>map的扩容机制</h3><p>扩容时机：向map里面插入新的key的时候，会进行条件检测，符合以下两个条件就会触发扩容操作：</p><p>扩容条件：</p><ol><li>超过负载 map元素个数 &gt; 负载因子 * 桶个数</li><li>溢出桶太多</li></ol><p>负载因子是元素个数与桶的数量的比值</p><p>当桶总数&lt;2^15^时，如果溢出桶总数&gt;=桶总数，则认为溢出桶过多</p><p>当桶总数&gt;2^15^时，如果溢出桶总数&gt;=2^15^，则认为溢出桶过多</p><p>扩容机制：</p><ul><li><p>双倍扩容：针对条件1，新建一个buckets数组，新的buckets大小是原来的2倍，然后旧buckets数据搬迁到新的buckets。</p></li><li><p>等量扩容：针对条件2，并不扩大容量，buckets数量维持不变，重新做一遍类似双倍扩容的搬迁动作，把松散的键值对重新排列一次，使得同一个 bucket 中的 key 排列地更紧密，节省空间，提高 bucket 利用率，进而保证更快的存取。</p></li><li><p>渐进式扩容： 插入修改删除key的时候，都会尝试进行搬迁桶的工作，每次都会检查oldbucket是否<strong>nil</strong>，如果不是<strong>nil</strong>则每次搬迁<strong>2</strong>个桶，蚂蚁搬家一样渐进式扩容</p></li></ul><h3 id="map的遍历为什么无序"><a href="#map的遍历为什么无序" class="headerlink" title="map的遍历为什么无序"></a>map的遍历为什么无序</h3><p>map  每次遍历，都会从一个随机值序号的桶开始，再从其中随机的cell 开始遍历，并且扩容后，原来桶中的key会落到其他的桶中，本身就会造成失序。</p><p>如果想要遍历map，先把key放到切片中排序，再按照key的顺序遍历map</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请写一段代码验证</span></span><br><span class="line">m := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span> &#123;</span><br><span class="line"><span class="number">1</span>: <span class="string">&quot;one&quot;</span>,</span><br><span class="line"><span class="number">2</span>: <span class="string">&quot;two&quot;</span>,</span><br><span class="line"><span class="number">3</span>: <span class="string">&quot;three&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key,value := <span class="keyword">range</span> m&#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;data is : %d ---&gt; %S \n&quot;</span>, key,value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="map的底层存储不是连续的"><a href="#map的底层存储不是连续的" class="headerlink" title="map的底层存储不是连续的"></a>map的底层存储不是连续的</h3><p>具体来说map 内部存储的是一个桶（bucket）数组，桶数组中的每个元素有事一个指向链表头的指针，他存储的数据并不连续</p><h3 id="map-为什么不是线程安全的"><a href="#map-为什么不是线程安全的" class="headerlink" title="map 为什么不是线程安全的"></a>map 为什么不是线程安全的</h3><p>多个协程同时对<strong>map</strong>进行并发读写**,<strong>程序会</strong>panic**</p><p>想要线程安全，可以使用sync.RWLock锁</p><p>在sync.map 这个包当中实现了锁，是线程安全的</p><h3 id="Map如何查找"><a href="#Map如何查找" class="headerlink" title="Map如何查找"></a>Map如何查找</h3><ol><li>计算hash值<br> key经过哈希函数计算后,得到64bit(64位CPU)<br> 10010111 | 101011101010110101010101101010101010 | 10010</li><li>找到hash对应的桶<br> 上面64位后5(hmap的B值)位定位所存放的桶<br> 如果当前正在扩容中,并且定位到旧桶数据还未完成迁移,则使用旧的桶</li><li>遍历桶查找<br> 上面64位前8位用来在tophash数组查找快速判断key是否在当前的桶中,如果不在需要去溢出桶查找</li><li>返回key对应的指针</li></ol><h3 id="map-冲突解决的方式"><a href="#map-冲突解决的方式" class="headerlink" title="map 冲突解决的方式"></a>map 冲突解决的方式</h3><p>Go采用链式地址解决冲突，具体实现就是插入key到map中时，当key定位的桶填满8个元素，将会创建一个溢出桶并且将溢出桶插入到当前桶所在的链表尾部</p><p>Golang当中采用链式哈希表（Cahined Hash Table）</p><p>在Golang的哈希表实现当中，每一个桶就是一个链表的头指针，桶内每个元素都是哈希链表节点，节点包含了该元素的哈希值、键以及指向下一个节点的指针。</p><p>在查找时候，先根据键的哈希值找到对应的桶，然后在该桶对应的链表中顺序查找，指导找到目标元素或者是链表遍历完毕。</p><h3 id="map-的负载因子为什么时6-5"><a href="#map-的负载因子为什么时6-5" class="headerlink" title="map 的负载因子为什么时6.5"></a>map 的负载因子为什么时6.5</h3><blockquote><p>负载因子 = 哈希表存储的元素个数 / 桶个数</p></blockquote><p>Go 官方发现：装载因子越大，填入的元素越多，空间利用率就越高，但发生哈希冲突的几率就变大。<br>装载因子越小，填入的元素越少，冲突发生的几率减小，但空间浪费也会变得更多，而且还会提高扩容操作的次数</p><p>Go 官方取了一个相对适中的值，把 Go 中的 map 的负载因子硬编码为 6.5，这就是 6.5 的选择缘由。</p><p>这意味着在 Go 语言中，当 map存储的元素个数大于或等于 6.5 * 桶个数 时，就会触发扩容行为。</p><h3 id="Map和-Sync-Map哪一个性能好"><a href="#Map和-Sync-Map哪一个性能好" class="headerlink" title="Map和 Sync.Map哪一个性能好"></a>Map和 Sync.Map哪一个性能好</h3><p>对比原始map：</p><p>和原始map+RWLock的实现并发的方式相比，减少了加锁对性能的影响。</p><p>它做了一些优化：可以无锁访问read map，而且会优先操作read map，倘若只操作read map就可以满足要求，那就不用去操作write map(dirty)，所以在某些特定场景中它发生锁竞争的频率会远远小于map+RWLock的实现方式</p><ul><li>优点：<br>适合读多写少的场景</li><li>缺点：<br>写多的场景，会导致 read map 缓存失效，需要加锁，冲突变多，性能急剧下降</li></ul><h3 id="channel-底层实现原理"><a href="#channel-底层实现原理" class="headerlink" title="channel 底层实现原理"></a>channel 底层实现原理</h3><p>通过<strong>var****声明或者是</strong>​<strong>make****函数创建的channel变量</strong>是一个存储在函数栈帧上的指针，占用8个字节，指向堆上的hchan结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span>&#123;</span><br><span class="line">closed <span class="type">uint32</span> <span class="comment">// channel 是否关闭的标志</span></span><br><span class="line">elemtype *_type <span class="comment">// channel 中的元素类型</span></span><br><span class="line"></span><br><span class="line">buf unsafe.Pointer <span class="comment">//指向底层循环数组的指针（环形缓存区）</span></span><br><span class="line">qcount <span class="type">uint</span> <span class="comment">// 循环数组中的元素数量</span></span><br><span class="line">dataqsiz <span class="type">uint</span> <span class="comment">//循环数组的长度</span></span><br><span class="line">elemsize <span class="type">uint16</span> <span class="comment">//元素的大小</span></span><br><span class="line">sendx <span class="type">uint</span> <span class="comment">// 下一次写下标的位置</span></span><br><span class="line">recvx <span class="type">uint</span> <span class="comment">// 下一次读下标的位置</span></span><br><span class="line"><span class="comment">// 尝试读取channel 或者向channel 写入数据而被阻塞的goroutine</span></span><br><span class="line">    recvq    waitq  <span class="comment">// 读等待队列</span></span><br><span class="line">    sendq    waitq  <span class="comment">// 写等待队列</span></span><br><span class="line">    lock mutex <span class="comment">//互斥锁，保证读写channel时不存在并发竞争问题</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>channel 分为无缓冲和有缓冲两种</p><ul><li><p>对于有缓冲的channel存储数据，使用了ring buffer(环形缓冲区) 来缓存写入的数据，本质是循环数组。</p><p>为啥是循环数组呢？普通数组不行吗，普通数组容量固定，更适合指定的空间，弹出元素的时候，普通数组需要全部前移。</p><p><code>当下标超过数组容量后会回到第一个位置，所以需要有两个字段记录当前读和写的下标位置</code></p></li><li><p>对于无缓冲的channel 存储数据</p></li></ul><p>等待队列： </p><p>双向链表，包含一个头结点和一个尾结点 每个节点是一个sudog结构体变量，记录哪个协程在等待，等待的是哪个channel，等待发送**/**接收的数据在哪里</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> wait <span class="keyword">struct</span>&#123;</span><br><span class="line">first *sudog</span><br><span class="line">last *sudog</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> sudog <span class="keyword">struct</span>&#123;</span><br><span class="line">g *g</span><br><span class="line">next *sudog</span><br><span class="line">pre  *sudog</span><br><span class="line">elem unsafe.Pointer</span><br><span class="line">c  *hchan</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建 channel 的时候：</p><p>创建时会做一些检查**:** </p><ul><li>元素大小不能超过 <strong>64</strong>K</li><li>元素的对齐大小不能超过 maxAlign 也就是 <strong>8</strong> 字节</li><li>计算出来的内存是否超过限制</li></ul><p>创建时的策略:</p><ul><li><p>如果是无缓冲的channel，会直接给hchan 分配内存</p></li><li><p>如果是有缓冲的channel，并且元素不包含指针，那么会为 hchan  和底层数组分配一段连续的地址</p></li><li><p>如果是有缓冲的channel，元素包含指针，那么就会为了hchan 和底层数组分别分配地址</p></li></ul><p>发送时：</p><ul><li><p>如果 channel 的读队列存在着接收者 goroutine，将唤醒接收的goroutine，将数据<strong>直接发送</strong>给第一个等待的 goroutine</p></li><li><p>如果channel 的读等待队列不存在接收者 goroutine</p><ul><li>如果循环数组buffer未满，那么将会把数据发送到循环数组buffer的队尾</li><li>如果循环数组buffer已满，这个时候就会阻塞发送的流程，将当前goroutine加入写等待队列，<strong>并挂起等待唤醒</strong></li></ul></li></ul><p>接收时：</p><ul><li><p>如果 channel 的写等待队列存在发送者 goroutine</p><ul><li>如果是无缓冲 channel ，<strong>直接</strong>从第一个发送者goroutine 那里 把数据拷贝给接受变量，<strong>唤醒 发送的goroutine</strong></li><li>如果是有缓冲的 channel（已满），将循环数组的buffer的队首元素拷贝给接受变量，将第一个发送者goroutine的数据拷贝到buffer循环数组的队尾，<strong>唤醒发送的goroutine</strong></li></ul></li><li><p>如果channel 的写等待队列不存在发送者goroutine</p><ul><li>如果循环数组buffer非空，将循环数组buffer的队首元素拷贝给接受变量</li><li>如果循环数组buffer为空，这个时候就会阻塞接收的流程，将当前goroutine 加入读等待队列，并<strong>挂起等待唤醒</strong></li></ul></li></ul><h3 id="channel-有什么特点"><a href="#channel-有什么特点" class="headerlink" title="channel 有什么特点"></a>channel 有什么特点</h3><p>channel是线程安全的</p><p>channel 有两种类型： 无缓冲、有缓冲</p><p>channel 有三种模式： 写操作模式（单向通道）、读操作模式（单向通道）、读写操作模式（双向通道）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">写操作模式    <span class="built_in">make</span>(<span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span><br><span class="line">读操作模式    <span class="built_in">make</span>(&lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">读写操作模式    <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br></pre></td></tr></table></figure><p>channel 有 3 种状态：未初始化、正常、关闭</p><table><thead><tr><th>操作 \ 状态</th><th>未初始化</th><th>关闭</th><th>正常</th></tr></thead><tbody><tr><td>关闭</td><td>panic</td><td>panic</td><td>正常</td></tr><tr><td>发送</td><td>永远阻塞导致死锁</td><td>panic</td><td>阻塞或者成功发送</td></tr><tr><td>接收</td><td>永远阻塞导致死锁</td><td>缓冲区为空则为零值，否则可以继续读</td><td>阻塞或者成功接收</td></tr></tbody></table><p>注意点：</p><ul><li><p>一个 channel不能多次关闭，会导致painc</p></li><li><p>如果多个 goroutine 都监听同一个 channel，那么 channel 上的数据都可能随机被某一个 goroutine 取走进行消费</p></li><li><p>如果多个 goroutine 监听同一个 channel，如果这个 channel 被关闭，则所有 goroutine 都能收到退出信号</p></li></ul><h3 id="Channel-的使用场景"><a href="#Channel-的使用场景" class="headerlink" title="Channel 的使用场景"></a>Channel 的使用场景</h3><p>无缓冲 Channel 在并发编程中的具体业务使用场景很多，主要应用于 Go 语言中。以下是一些常见的无缓冲 Channel 的具体业务使用场景及例子：</p><ol><li>并发控制：在并发程序中，通过无缓冲 Channel 可以实现多个 Goroutine 之间的<strong>同步和控制</strong>。例如，一个任务需要多个协程协作完成时，可以使用无缓冲 Channel 来传递任务数据和控制信号。</li><li>事件驱动：在事件驱动的编程中，可以使用无缓冲 Channel 来传递事件和执行结果。例如，当一个 HTTP 请求到达时，可以将请求交给一个协程处理，并使用无缓冲 Channel 返回处理结果。</li><li>分布式计算：在分布式计算中，可以使用无缓冲 Channel 来实现节点之间的通信和数据传递。例如，在 MapReduce 算法中，可以使用无缓冲 Channel 来传递 Map 阶段的输出结果并驱动 Reduce 阶段的计算。</li></ol><p>有缓冲 Channel 在并发编程中的具体业务使用场景也很多，主要应用于 Go 语言中。以下是一些常见的有缓冲 Channel 的具体业务使用场景及例子：</p><ol><li>网络编程：在 TCP 或 UDP 数据处理中，可以使用有缓冲 Channel 缓存数据，<strong>以避免因数据接收太慢而导致发送者被阻塞</strong>。例如，在高并发的 Web 服务器中，可以使用有缓冲 Channel 缓存请求数据以提高吞吐量。</li><li>IO 操作：在使用 IO 操作时，如文件读写、数据库访问等，可以使用有缓冲 Channel 缓存数据，以避免因数据处理速度不匹配而导致发送者或接收者被阻塞。例如，<strong>在从数据库获取大量数据时，可以使用有缓冲 Channel 缓存数据，减少数据库连接次数。</strong></li><li>并发控制：在并发程序中，通过有缓冲 Channel 可以实现多个 Goroutine 之间的同步和控制。例如，一个任务需要多个协程协作完成时，可以使用有缓冲 Channel 来传递任务数据和控制信号，并根据缓冲区的剩余空间来控制协程的执行顺序。</li><li>事件驱动：在事件驱动的编程中，可以使用有缓冲 Channel 来缓存事件和执行结果，并根据缓冲区的剩余空间来控制事件的处理顺序。例如，当一个 HTTP 请求到达时，可以将请求交给一个协程处理，并使用有缓冲 Channel 缓存处理结果，避免处理速度过慢导致请求被阻塞。</li></ol><h3 id="channel-为什么是线程安全的"><a href="#channel-为什么是线程安全的" class="headerlink" title="channel 为什么是线程安全的"></a>channel 为什么是线程安全的</h3><p>不同协程通过channel进行通信，本身的使用场景就是多线程，为了保证数据的一致性，必须实现线程安全</p><p>channel的底层实现中，hchan结构体中采用Mutex锁来保证数据读写安全。在对循环数组buf中的数据进行入队和出队操作时，必须先获取互斥锁，才能操作channel数据</p><h3 id="Channel-发送和接收什么情况下会死锁"><a href="#Channel-发送和接收什么情况下会死锁" class="headerlink" title="Channel 发送和接收什么情况下会死锁"></a>Channel 发送和接收什么情况下会死锁</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deadlock1</span><span class="params">()</span></span> &#123;    <span class="comment">//无缓冲channel只写不读</span></span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>) </span><br><span class="line">    ch &lt;- <span class="number">3</span> <span class="comment">//  这里会发生一直阻塞的情况，执行不到下面一句</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deadlock2</span><span class="params">()</span></span> &#123; <span class="comment">//无缓冲channel读在写后面</span></span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    ch &lt;- <span class="number">3</span>  <span class="comment">//  这里会发生一直阻塞的情况，执行不到下面一句</span></span><br><span class="line">    num := &lt;-ch</span><br><span class="line">    fmt.Println(<span class="string">&quot;num=&quot;</span>, num)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deadlock3</span><span class="params">()</span></span> &#123; <span class="comment">//无缓冲channel读在写后面</span></span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    ch &lt;- <span class="number">100</span> <span class="comment">//  这里会发生一直阻塞的情况，执行不到下面一句</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        num := &lt;-ch</span><br><span class="line">        fmt.Println(<span class="string">&quot;num=&quot;</span>, num)</span><br><span class="line">    &#125;()</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deadlock3</span><span class="params">()</span></span> &#123;    <span class="comment">//有缓冲channel写入超过缓冲区数量</span></span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line">    ch &lt;- <span class="number">3</span></span><br><span class="line">    ch &lt;- <span class="number">4</span></span><br><span class="line">    ch &lt;- <span class="number">5</span></span><br><span class="line">    ch &lt;- <span class="number">6</span>  <span class="comment">//  这里会发生一直阻塞的情况</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deadlock4</span><span class="params">()</span></span> &#123;    <span class="comment">//空读</span></span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="comment">// ch := make(chan int, 1)</span></span><br><span class="line">    fmt.Println(&lt;-ch)  <span class="comment">//  这里会发生一直阻塞的情况</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deadlock5</span><span class="params">()</span></span> &#123;    <span class="comment">//互相等对方造成死锁</span></span><br><span class="line">    ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> num := &lt;-ch1:</span><br><span class="line">            fmt.Println(<span class="string">&quot;num=&quot;</span>, num)</span><br><span class="line">            ch2 &lt;- <span class="number">100</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> num := &lt;-ch2:</span><br><span class="line">            fmt.Println(<span class="string">&quot;num=&quot;</span>, num)</span><br><span class="line">            ch1 &lt;- <span class="number">300</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="互斥锁实现原理"><a href="#互斥锁实现原理" class="headerlink" title="互斥锁实现原理"></a>互斥锁实现原理</h3><p>Go sync包提供了两种锁类型：互斥锁sync.Mutex 和 读写互斥锁sync.RWMutex，都属于((20230402113517-ppcs0gj “悲观锁”))。<br><a href="https://blog.csdn.net/baolingye/article/details/111357407">https://blog.csdn.net/baolingye/article/details/111357407</a></p><p>在正常模式下，<strong>锁的等待者会按照先进先出的顺序获取锁</strong>。但是刚被唤起的 Goroutine 与新创建的 Goroutine 竞争时，大概率会获取不到锁，在这种情况下，这个被唤醒的 Goroutine 会加入到等待队列的前面。 如果一个等待的 Goroutine 超过1ms 没有获取锁，那么它将会把锁转变为<strong>饥饿模式</strong>。<br>Go在1.9中引入优化，目的保证互斥锁的公平性。在饥饿模式中，互斥锁会直接交给等待队列最前面的 Goroutine。新的 Goroutine 在该状态下不能获取锁、也不会进入自旋状态，它们只会在队列的末尾等待。如果一个 Goroutine 获得了互斥锁并且它在队列的末尾或者它等待的时间少于 1ms，那么当前的互斥锁就会切换回正常模式。</p><h3 id="悲观锁与乐观锁"><a href="#悲观锁与乐观锁" class="headerlink" title="悲观锁与乐观锁"></a>悲观锁与乐观锁</h3><p><strong>悲观锁</strong>是基于一种悲观的态度类来防止一切数据冲突，它是以一种预防的姿态在<strong>修改数据之前把数据锁住，然后再对数据进行读写，在它释放锁之前任何人都不能对其数据进行操作，直到前面一个人把锁释放后下一个人数据加锁才可对数据进行加锁，</strong>然后才可以对数据进行操作，一般数据库本身锁的机制都是基于悲观锁的机制实现的;</p><p>特点：可以完全保证数据的独占性和正确性，因为每次请求都会先对数据进行加锁， 然后进行数据操作，最后再解锁，而加锁释放锁的过程会造成消耗，所以性能不高;</p><p><strong>乐观锁</strong>是对于数据冲突保持一种乐观态度，操作数据时不会对操作的数据进行加锁（这使得多个任务可以并行的对数据进行操作），只有到数据提交的时候才通过一种机制来验证数据是否存在冲突(一般实现方式是通过加版本号然后进行版本号的对比方式实现);</p><p>特点：乐观锁是一种并发类型的锁，其本身不对数据进行加锁通而是通过业务实现锁的功能，不对数据进行加锁就意味着允许多个请求同时访问数据，同时也省掉了对数据加锁和解锁的过程，这种方式因为节省了悲观锁加锁的操作，所以可以一定程度的的提高操作的性能，不过在并发非常高的情况下，会导致大量的请求冲突，冲突导致大部分操作无功而返而浪费资源，所以在高并发的场景下，乐观锁的性能却反而不如悲观锁。</p><h3 id="原子操作和锁的区别"><a href="#原子操作和锁的区别" class="headerlink" title="原子操作和锁的区别"></a>原子操作和锁的区别</h3><p>在并发编程里，Go语言<code>sync</code>包里的同步原语<code>Mutex</code>是我们经常用来保证并发安全的，那么他跟<code>atomic</code>包里的这些操作有啥区别呢？在我看来他们在使用目的和底层实现上都不一样：</p><ul><li>使用目的：互斥锁是用来保护一段逻辑，原子操作用于对一个变量的更新保护。</li><li>底层实现：<code>Mutex</code>由<strong>操作系统</strong>的调度器实现，而<code>atomic</code>包中的原子操作则由<strong>底层硬件指令</strong>直接提供支持，这些指令在执行的过程中是不允许中断的，因此原子操作可以在<code>lock-free</code>的情况下保证并发安全，并且它的性能也能做到随<code>CPU</code>个数的增多而线性扩展。</li></ul><h3 id="互斥锁允许自旋的条件"><a href="#互斥锁允许自旋的条件" class="headerlink" title="互斥锁允许自旋的条件"></a>互斥锁允许自旋的条件</h3><p>线程没有获取到锁时常见有2种处理方式：</p><ul><li>一种是没有获取到锁的线程就会循环等待判断该资源是否已经释放锁，这种锁也叫做自旋锁，它不用将线程阻塞起来， 适用于并发低且程序执行时间短的场景，缺点是cpu占用较高</li><li>另外一种处理方式就是把自己阻塞起来，会释放CPU给其他线程，内核会将线程置为「睡眠」状态，等到锁被释放后，内核会在合适的时机唤醒该线程，适用于高并发场景，缺点是有线程上下文切换的开销<br>Go语言中的Mutex实现了自旋与阻塞两种场景，当满足不了自旋条件时，就会进入阻塞<br><strong>允许自旋的条件：</strong></li></ul><ol><li>锁已被占用，并且锁不处于饥饿模式。</li><li>积累的自旋次数小于最大自旋次数（active_spin=4）。</li><li>cpu 核数大于 1。</li><li>有空闲的 P。</li><li>当前 goroutine 所挂载的 P 下，本地待运行队列为空。</li></ol><h3 id="读写锁的实现原理"><a href="#读写锁的实现原理" class="headerlink" title="读写锁的实现原理"></a>读写锁的实现原理</h3><p>读写锁的底层是基于互斥锁实现的。<br>写锁需要阻塞写锁：一个协程拥有写锁时，其他协程写锁定需要阻塞；<br>写锁需要阻塞读锁：一个协程拥有写锁时，其他协程读锁定需要阻塞；<br>读锁需要阻塞写锁：一个协程拥有读锁时，其他协程写锁定需要阻塞；<br><strong>读锁不能阻塞读锁：一个协程拥有读锁时，其他协程也可以拥有读锁。</strong></p><h3 id="“原子操作”有哪些"><a href="#“原子操作”有哪些" class="headerlink" title="“原子操作”有哪些"></a>“原子操作”有哪些</h3><p>Go atomic包是最轻量级的锁（也称无锁结构），可以在不形成临界区和创建互斥量的情况下完成并发安全的值替换操作，不过这个包只支持int32/int64/uint32/uint64/uintptr这几种数据类型的一些基础操作（增减、交换、载入、存储等）<br>当我们想要对<strong>某个变量</strong>并发安全的修改，除了使用官方提供的 <code>mutex</code>，还可以使用 sync/atomic 包的原子操作，它能够保证对变量的读取或修改期间不被其他的协程所影响。<br>atomic 包提供的原子操作能够确保任一时刻只有一个goroutine对变量进行操作，善用 atomic 能够避免程序中出现大量的锁操作。<br><strong>常见操作：</strong></p><ul><li>增减Add     AddInt32 AddInt64 AddUint32 AddUint64 AddUintptr</li><li>载入Load    LoadInt32 LoadInt64    LoadPointer    LoadUint32    LoadUint64    LoadUintptr</li><li>比较并交换   CompareAndSwap    CompareAndSwapInt32…</li><li>交换Swap    SwapInt32…</li><li>存储Store    StoreInt32…</li></ul><h3 id="Goroutine-的底层实现原理"><a href="#Goroutine-的底层实现原理" class="headerlink" title="Goroutine 的底层实现原理"></a>Goroutine 的底层实现原理</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">g本质是一个数据结构,真正让 goroutine 运行起来的是调度器</span><br><span class="line"><span class="keyword">type</span> g <span class="keyword">struct</span> &#123; </span><br><span class="line">    goid <span class="type">int64</span>  <span class="comment">// 唯一的goroutine的ID </span></span><br><span class="line">    sched gobuf <span class="comment">// goroutine切换时，用于保存g的上下文 </span></span><br><span class="line">    stack stack <span class="comment">// 栈 </span></span><br><span class="line">    gopc <span class="comment">// pc of go statement that created this goroutine </span></span><br><span class="line">    startpc <span class="type">uintptr</span>  <span class="comment">// pc of goroutine function ... </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">type</span> gobuf <span class="keyword">struct</span> &#123;     <span class="comment">//运行时寄存器</span></span><br><span class="line">    sp <span class="type">uintptr</span>  <span class="comment">// 栈指针位置 </span></span><br><span class="line">    pc <span class="type">uintptr</span>  <span class="comment">// 运行到的程序位置 </span></span><br><span class="line">    g  guintptr <span class="comment">// 指向 goroutine </span></span><br><span class="line">    ret <span class="type">uintptr</span> <span class="comment">// 保存系统调用的返回值 ... </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">type</span> stack <span class="keyword">struct</span> &#123;     <span class="comment">//运行时栈</span></span><br><span class="line">    lo <span class="type">uintptr</span>  <span class="comment">// 栈的下界内存地址 </span></span><br><span class="line">    hi <span class="type">uintptr</span>  <span class="comment">// 栈的上界内存地址 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="goroutine-和线程的区别"><a href="#goroutine-和线程的区别" class="headerlink" title="goroutine 和线程的区别"></a>goroutine 和线程的区别</h3><p>内存占用:<br>创建一个 goroutine 的栈内存消耗为 2 KB，实际运行过程中，如果栈空间不够用，会自动进行扩容。创建一个 thread 则需要消耗 1 MB 栈内存。<br>创建和销毀:<br>Thread 创建和销毀需要陷入内核,系统调用。而 goroutine 因为是由 Go runtime 负责管理的，创建和销毁的消耗非常小，是用户级。<br>切换:<br>当 threads 切换时，需要保存各种寄存器,而 goroutines 切换只需保存三个寄存器：Program Counter, Stack Pointer and BP。一般而言，线程切换会消耗 1000-1500 ns,Goroutine 的切换约为 200 ns,因此，goroutines 切换成本比 threads 要小得多。</p><h3 id="Go-线程模型（Go底层怎么实现高并发的）"><a href="#Go-线程模型（Go底层怎么实现高并发的）" class="headerlink" title="Go 线程模型（Go底层怎么实现高并发的）"></a>Go 线程模型（Go底层怎么实现高并发的）</h3><blockquote><p>线程协程，进程的区别：</p><p><a href="https://zhuanlan.zhihu.com/p/337978321">https://zhuanlan.zhihu.com/p/337978321</a></p><p><a href="https://www.bilibili.com/read/cv9346691/">https://www.bilibili.com/read/cv9346691/</a></p></blockquote><p>Golang的调度器是一个轻量级的协程调度器，主要负责管理和调度协程。Golang 中的调度器采用 <strong>M:N 模型</strong>，即 M 个用户级线程对应 N 个内核线程。</p><p>调度器会将 Golang 中的协程（goroutine）调度到不同的线程上运行，以实现并发执行的效果。</p><p>M个线程对应N个内核线程的优点：</p><ul><li>能够利用多核</li><li>上下文切换成本低</li><li>如果进程中的一个线程被阻塞，不会阻塞其他线程，是能够切换同一进程内的其他线程继续执行</li></ul><h3 id="Golang-assertion"><a href="#Golang-assertion" class="headerlink" title="Golang assertion"></a>Golang assertion</h3><h2 id="Golang调用方面"><a href="#Golang调用方面" class="headerlink" title="Golang调用方面"></a>Golang调用方面</h2><h3 id="len-统计长度"><a href="#len-统计长度" class="headerlink" title="len 统计长度"></a>len 统计长度</h3><p><font color = 'red'>len()计算的是字节的长度，和编码无关，对于英文和数组对象等，字节长度等效于实际长度</font><br>当需要计算中文字符长度的时候，就需要调用其他的函数方法：<br><code>utf8.RuneCountInString(&quot;中文&quot;)</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Golang-系统知识回答收集&quot;&gt;&lt;a href=&quot;#Golang-系统知识回答收集&quot; class=&quot;headerlink&quot; title=&quot;Golang 系统知识回答收集&quot;&gt;&lt;/a&gt;Golang 系统知识回答收集&lt;/h1&gt;&lt;h2 id=&quot;Golang-语法方面&quot;&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>算法简要汇总</title>
    <link href="http://ideameshdyx.github.io/2023/03/27/Algorithm/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B-%E5%8D%97%E5%BC%80%E8%8B%8F%E6%98%8E%E8%80%81%E5%B8%88/%E7%AE%97%E6%B3%95%E7%AE%80%E8%A6%81%E6%B1%87%E6%80%BB/"/>
    <id>http://ideameshdyx.github.io/2023/03/27/Algorithm/%E7%AE%97%E6%B3%95%E8%AF%BE%E7%A8%8B-%E5%8D%97%E5%BC%80%E8%8B%8F%E6%98%8E%E8%80%81%E5%B8%88/%E7%AE%97%E6%B3%95%E7%AE%80%E8%A6%81%E6%B1%87%E6%80%BB/</id>
    <published>2023-03-27T20:52:12.000Z</published>
    <updated>2023-04-22T13:24:02.204Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><blockquote><p>the art of data</p></blockquote><h1 id="第一节课-课程背景"><a href="#第一节课-课程背景" class="headerlink" title="[第一节课] 课程背景"></a>[第一节课] 课程背景</h1><blockquote><p>The theoretical study of computer-program performance and resource usage</p></blockquote><h2 id="为什么研究算法"><a href="#为什么研究算法" class="headerlink" title="为什么研究算法"></a>为什么研究算法</h2><ol><li><p>对性能的研究 –&gt; 告知哪些是可以做到的，哪些是不可能实现的</p></li><li><p>对算法性能的抽象可以推广到其他计算资源上</p></li><li><p>程序[逻辑推演]通用一套逻辑</p></li></ol><h2 id="算法关注的焦点"><a href="#算法关注的焦点" class="headerlink" title="算法关注的焦点"></a>算法关注的焦点</h2><ol><li><p>忽略在哪里实现： 与平台无关</p></li><li><p>忽略实例的不同：与实例无关</p></li><li><p>注意问题的增长规模</p></li></ol><p>以排序算法为例：<br>算法最为关心其中元素的比较、移动次数</p><ul><li>最坏情况: 插入排序当中，如果序列是倒序，解决需要的时间与问题规模呈现 n^2 级别增长 </li><li>平均情况: 插入排序当中，最快是序列就是顺序的，平均情况是和最坏情况取平均值</li></ul><p>如果要对这个排序算法做优化的话，可以怎么想呢？<br>以一个合并排序作为例子来讲解：</p><p>通过将问题分解之后，使得合并排序比起插入排序有更快的速度，但却消耗了更多的空间。</p><p>学习算法的目标：</p><ul><li>灵活运用合适数据结构来解决实际问题</li><li>碰到具体的问题，能够分析问题的关键点并进行规划，编写代码输出正确结果</li><li>清晰的算法复杂度概念，采用正确的算法是的编写的代码运行更有效率</li><li>全面提高编写代码的逻辑</li></ul><h2 id="第二节课-引言：-某些特定的问题"><a href="#第二节课-引言：-某些特定的问题" class="headerlink" title="[第二节课] 引言： 某些特定的问题"></a>[第二节课] 引言： 某些特定的问题</h2><h3 id="第一个问题：-稳定匹配"><a href="#第一个问题：-稳定匹配" class="headerlink" title="第一个问题： 稳定匹配"></a>第一个问题： 稳定匹配</h3><blockquote><p>College Admission and the Stability of Marriage</p></blockquote><h4 id="双向选择"><a href="#双向选择" class="headerlink" title="双向选择"></a>双向选择</h4><blockquote><p>比如交朋友，南开大学 X 和天津大学 Y 学生相互之间选择，存在一个需求是： X 对于 Y 可能满足或者不满足，Y 对于 X 可能满足或者不满足<br>关键在于找到一个 <strong>稳定</strong> 的方案尽可能不与 X/Y 的特性和意愿产生矛盾</p></blockquote><p><strong><font color ='red'> 问题的形式化: 提出本质的、相对简单的问题模型： n 个 X 类型对象中的每一个对 m 个 Y 类型对象提出申请，而每个 Y 类型对象只要单一个 X 对象</font></strong></p><p>那么<strong>稳定的对象</strong> 就是一个匹配 （X,Y），每一个 X,Y 应该只出现在其中一个组合当中，完美的匹配就是满足所有的 X， Y 对象的需求。</p><p>–&gt; 对每组优先表是否存在一个稳定的匹配呢<br>–&gt; 给定一组优先表，如果存在稳定匹配，能够有效构造出来吗<br>–&gt; 如果存在稳定匹配会有很多吗？</p><p>那么是否对于每一类优先列表都存在一个通用的选择方法嘛？</p><p>邀请拒绝算法–&gt; 找到 <strong>稳定匹配符合直觉</strong> 的算法</p><p><strong>评价算法的正确性</strong></p><ul><li>正确性： 是否满足题目要求</li><li>有穷性： 有while循环，是否能够正确退出</li><li>输出  ： 输出结构是否符合题目要求</li></ul><p>那么如何才能够在代码上实现这个算法呢？<br>要点：</p><ul><li>要用两个数组记录约会的对象</li></ul><blockquote><p>小技巧：在多层循环当中，尽量降低内层循环的计算复杂度</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;算法&quot;&gt;&lt;a href=&quot;#算法&quot; class=&quot;headerlink&quot; title=&quot;算法&quot;&gt;&lt;/a&gt;算法&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;the art of data&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;第一节课-课程背景&quot;&gt;&lt;a h</summary>
      
    
    
    
    <category term="算法[Algrithm]" scheme="http://ideameshdyx.github.io/categories/%E7%AE%97%E6%B3%95-Algrithm/"/>
    
    
    <category term="算法， 南开大学，Golang, working" scheme="http://ideameshdyx.github.io/tags/%E7%AE%97%E6%B3%95%EF%BC%8C-%E5%8D%97%E5%BC%80%E5%A4%A7%E5%AD%A6%EF%BC%8CGolang-working/"/>
    
  </entry>
  
  <entry>
    <title>ACM 模式输入输出总结</title>
    <link href="http://ideameshdyx.github.io/2023/03/25/Algorithm/ACM-%E6%A8%A1%E5%BC%8F%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%80%BB%E7%BB%93/ACM-%E6%A8%A1%E5%BC%8F%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%80%BB%E7%BB%93/"/>
    <id>http://ideameshdyx.github.io/2023/03/25/Algorithm/ACM-%E6%A8%A1%E5%BC%8F%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%80%BB%E7%BB%93/ACM-%E6%A8%A1%E5%BC%8F%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%80%BB%E7%BB%93/</id>
    <published>2023-03-25T19:38:52.000Z</published>
    <updated>2023-04-22T13:24:02.164Z</updated>
    
    <content type="html"><![CDATA[<h1 id="输入格式归纳记录"><a href="#输入格式归纳记录" class="headerlink" title="输入格式归纳记录"></a>输入格式归纳记录</h1><p>由于牛客网采用的是 acm 形式编写代码，所以需要在做题时候需要自行处理输入输出的数据格式，以 Golang 作为主要例子归纳如下：</p><h2 id="读取多行数据，每一行数据是多个空格隔开的元素"><a href="#读取多行数据，每一行数据是多个空格隔开的元素" class="headerlink" title="读取多行数据，每一行数据是多个空格隔开的元素"></a>读取多行数据，每一行数据是多个空格隔开的元素</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line">    <span class="string">&quot;bufio&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    scanner := bufio.NewScanner(os.Stdin)</span><br><span class="line">    scanner.Split(bufio.ScanLines)</span><br><span class="line">    <span class="keyword">var</span> sum <span class="type">int</span></span><br><span class="line">    <span class="keyword">for</span> scanner.Scan()&#123;</span><br><span class="line">        line := scanner.Text()</span><br><span class="line">        fields := strings.Fields(line)</span><br><span class="line">        <span class="keyword">for</span> _, field := <span class="keyword">range</span> fields&#123;</span><br><span class="line">            num, err := strconv.Atoi(field)</span><br><span class="line">            <span class="keyword">if</span> err == <span class="literal">nil</span>&#123;</span><br><span class="line">                sum += num</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(sum)</span><br><span class="line">        sum = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="输入数值的进制转换"><a href="#输入数值的进制转换" class="headerlink" title="输入数值的进制转换"></a>输入数值的进制转换</h1><h2 id="十进制数字转换为其他进制数字"><a href="#十进制数字转换为其他进制数字" class="headerlink" title="十进制数字转换为其他进制数字"></a>十进制数字转换为其他进制数字</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">i := <span class="number">255</span></span><br><span class="line"><span class="comment">// 将int类型的i转化为二进制字符串并输出</span></span><br><span class="line">s := strconv.FormatInt(<span class="type">int64</span>(i), <span class="number">2</span>)</span><br><span class="line">fmt.Println(s) <span class="comment">// &quot;11111111&quot;</span></span><br><span class="line"><span class="comment">// 将int类型的i转化为八进制字符串并输出</span></span><br><span class="line">s = strconv.FormatInt(<span class="type">int64</span>(i), <span class="number">8</span>)</span><br><span class="line">fmt.Println(s) <span class="comment">// &quot;377&quot;</span></span><br><span class="line"><span class="comment">// 将int类型的i转化为十六进制字符串并输出</span></span><br><span class="line">s = strconv.FormatInt(<span class="type">int64</span>(i), <span class="number">16</span>)</span><br><span class="line">fmt.Println(s) <span class="comment">// &quot;ff&quot;</span></span><br></pre></td></tr></table></figure><h2 id="其他进制转换为10进制"><a href="#其他进制转换为10进制" class="headerlink" title="其他进制转换为10进制"></a>其他进制转换为10进制</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">&quot;377&quot;</span></span><br><span class="line">i, err := strconv.ParseInt(s, <span class="number">8</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(i) <span class="comment">// 255</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;输入格式归纳记录&quot;&gt;&lt;a href=&quot;#输入格式归纳记录&quot; class=&quot;headerlink&quot; title=&quot;输入格式归纳记录&quot;&gt;&lt;/a&gt;输入格式归纳记录&lt;/h1&gt;&lt;p&gt;由于牛客网采用的是 acm 形式编写代码，所以需要在做题时候需要自行处理输入输出的数据格式，</summary>
      
    
    
    
    
    <category term="Golang" scheme="http://ideameshdyx.github.io/tags/Golang/"/>
    
  </entry>
  
</feed>
